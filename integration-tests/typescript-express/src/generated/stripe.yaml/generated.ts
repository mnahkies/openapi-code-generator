/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_DeleteAccountsAccountBankAccountsIdParamSchema,
  t_DeleteAccountsAccountBankAccountsIdRequestBodySchema,
  t_DeleteAccountsAccountExternalAccountsIdParamSchema,
  t_DeleteAccountsAccountExternalAccountsIdRequestBodySchema,
  t_DeleteAccountsAccountParamSchema,
  t_DeleteAccountsAccountPeoplePersonParamSchema,
  t_DeleteAccountsAccountPeoplePersonRequestBodySchema,
  t_DeleteAccountsAccountPersonsPersonParamSchema,
  t_DeleteAccountsAccountPersonsPersonRequestBodySchema,
  t_DeleteAccountsAccountRequestBodySchema,
  t_DeleteApplePayDomainsDomainParamSchema,
  t_DeleteApplePayDomainsDomainRequestBodySchema,
  t_DeleteCouponsCouponParamSchema,
  t_DeleteCouponsCouponRequestBodySchema,
  t_DeleteCustomersCustomerBankAccountsIdParamSchema,
  t_DeleteCustomersCustomerBankAccountsIdRequestBodySchema,
  t_DeleteCustomersCustomerCardsIdParamSchema,
  t_DeleteCustomersCustomerCardsIdRequestBodySchema,
  t_DeleteCustomersCustomerDiscountParamSchema,
  t_DeleteCustomersCustomerDiscountRequestBodySchema,
  t_DeleteCustomersCustomerParamSchema,
  t_DeleteCustomersCustomerRequestBodySchema,
  t_DeleteCustomersCustomerSourcesIdParamSchema,
  t_DeleteCustomersCustomerSourcesIdRequestBodySchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema,
  t_DeleteCustomersCustomerTaxIdsIdParamSchema,
  t_DeleteCustomersCustomerTaxIdsIdRequestBodySchema,
  t_DeleteEphemeralKeysKeyParamSchema,
  t_DeleteEphemeralKeysKeyRequestBodySchema,
  t_DeleteInvoiceitemsInvoiceitemParamSchema,
  t_DeleteInvoiceitemsInvoiceitemRequestBodySchema,
  t_DeleteInvoicesInvoiceParamSchema,
  t_DeleteInvoicesInvoiceRequestBodySchema,
  t_DeletePlansPlanParamSchema,
  t_DeletePlansPlanRequestBodySchema,
  t_DeleteProductsIdParamSchema,
  t_DeleteProductsIdRequestBodySchema,
  t_DeleteProductsProductFeaturesIdParamSchema,
  t_DeleteProductsProductFeaturesIdRequestBodySchema,
  t_DeleteRadarValueListItemsItemParamSchema,
  t_DeleteRadarValueListItemsItemRequestBodySchema,
  t_DeleteRadarValueListsValueListParamSchema,
  t_DeleteRadarValueListsValueListRequestBodySchema,
  t_DeleteSubscriptionItemsItemParamSchema,
  t_DeleteSubscriptionItemsItemRequestBodySchema,
  t_DeleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_DeleteSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema,
  t_DeleteSubscriptionsSubscriptionExposedIdParamSchema,
  t_DeleteSubscriptionsSubscriptionExposedIdRequestBodySchema,
  t_DeleteTaxIdsIdParamSchema,
  t_DeleteTaxIdsIdRequestBodySchema,
  t_DeleteTerminalConfigurationsConfigurationParamSchema,
  t_DeleteTerminalConfigurationsConfigurationRequestBodySchema,
  t_DeleteTerminalLocationsLocationParamSchema,
  t_DeleteTerminalLocationsLocationRequestBodySchema,
  t_DeleteTerminalReadersReaderParamSchema,
  t_DeleteTerminalReadersReaderRequestBodySchema,
  t_DeleteTestHelpersTestClocksTestClockParamSchema,
  t_DeleteTestHelpersTestClocksTestClockRequestBodySchema,
  t_DeleteWebhookEndpointsWebhookEndpointParamSchema,
  t_DeleteWebhookEndpointsWebhookEndpointRequestBodySchema,
  t_GetAccountQuerySchema,
  t_GetAccountRequestBodySchema,
  t_GetAccountsAccountBankAccountsIdParamSchema,
  t_GetAccountsAccountBankAccountsIdQuerySchema,
  t_GetAccountsAccountBankAccountsIdRequestBodySchema,
  t_GetAccountsAccountCapabilitiesCapabilityParamSchema,
  t_GetAccountsAccountCapabilitiesCapabilityQuerySchema,
  t_GetAccountsAccountCapabilitiesCapabilityRequestBodySchema,
  t_GetAccountsAccountCapabilitiesParamSchema,
  t_GetAccountsAccountCapabilitiesQuerySchema,
  t_GetAccountsAccountCapabilitiesRequestBodySchema,
  t_GetAccountsAccountExternalAccountsIdParamSchema,
  t_GetAccountsAccountExternalAccountsIdQuerySchema,
  t_GetAccountsAccountExternalAccountsIdRequestBodySchema,
  t_GetAccountsAccountExternalAccountsParamSchema,
  t_GetAccountsAccountExternalAccountsQuerySchema,
  t_GetAccountsAccountExternalAccountsRequestBodySchema,
  t_GetAccountsAccountParamSchema,
  t_GetAccountsAccountPeopleParamSchema,
  t_GetAccountsAccountPeoplePersonParamSchema,
  t_GetAccountsAccountPeoplePersonQuerySchema,
  t_GetAccountsAccountPeoplePersonRequestBodySchema,
  t_GetAccountsAccountPeopleQuerySchema,
  t_GetAccountsAccountPeopleRequestBodySchema,
  t_GetAccountsAccountPersonsParamSchema,
  t_GetAccountsAccountPersonsPersonParamSchema,
  t_GetAccountsAccountPersonsPersonQuerySchema,
  t_GetAccountsAccountPersonsPersonRequestBodySchema,
  t_GetAccountsAccountPersonsQuerySchema,
  t_GetAccountsAccountPersonsRequestBodySchema,
  t_GetAccountsAccountQuerySchema,
  t_GetAccountsAccountRequestBodySchema,
  t_GetAccountsQuerySchema,
  t_GetAccountsRequestBodySchema,
  t_GetApplePayDomainsDomainParamSchema,
  t_GetApplePayDomainsDomainQuerySchema,
  t_GetApplePayDomainsDomainRequestBodySchema,
  t_GetApplePayDomainsQuerySchema,
  t_GetApplePayDomainsRequestBodySchema,
  t_GetApplicationFeesFeeRefundsIdParamSchema,
  t_GetApplicationFeesFeeRefundsIdQuerySchema,
  t_GetApplicationFeesFeeRefundsIdRequestBodySchema,
  t_GetApplicationFeesIdParamSchema,
  t_GetApplicationFeesIdQuerySchema,
  t_GetApplicationFeesIdRefundsParamSchema,
  t_GetApplicationFeesIdRefundsQuerySchema,
  t_GetApplicationFeesIdRefundsRequestBodySchema,
  t_GetApplicationFeesIdRequestBodySchema,
  t_GetApplicationFeesQuerySchema,
  t_GetApplicationFeesRequestBodySchema,
  t_GetAppsSecretsFindQuerySchema,
  t_GetAppsSecretsFindRequestBodySchema,
  t_GetAppsSecretsQuerySchema,
  t_GetAppsSecretsRequestBodySchema,
  t_GetBalanceHistoryIdParamSchema,
  t_GetBalanceHistoryIdQuerySchema,
  t_GetBalanceHistoryIdRequestBodySchema,
  t_GetBalanceHistoryQuerySchema,
  t_GetBalanceHistoryRequestBodySchema,
  t_GetBalanceQuerySchema,
  t_GetBalanceRequestBodySchema,
  t_GetBalanceTransactionsIdParamSchema,
  t_GetBalanceTransactionsIdQuerySchema,
  t_GetBalanceTransactionsIdRequestBodySchema,
  t_GetBalanceTransactionsQuerySchema,
  t_GetBalanceTransactionsRequestBodySchema,
  t_GetBillingAlertsIdParamSchema,
  t_GetBillingAlertsIdQuerySchema,
  t_GetBillingAlertsIdRequestBodySchema,
  t_GetBillingAlertsQuerySchema,
  t_GetBillingAlertsRequestBodySchema,
  t_GetBillingCreditBalanceSummaryQuerySchema,
  t_GetBillingCreditBalanceSummaryRequestBodySchema,
  t_GetBillingCreditBalanceTransactionsIdParamSchema,
  t_GetBillingCreditBalanceTransactionsIdQuerySchema,
  t_GetBillingCreditBalanceTransactionsIdRequestBodySchema,
  t_GetBillingCreditBalanceTransactionsQuerySchema,
  t_GetBillingCreditBalanceTransactionsRequestBodySchema,
  t_GetBillingCreditGrantsIdParamSchema,
  t_GetBillingCreditGrantsIdQuerySchema,
  t_GetBillingCreditGrantsIdRequestBodySchema,
  t_GetBillingCreditGrantsQuerySchema,
  t_GetBillingCreditGrantsRequestBodySchema,
  t_GetBillingMetersIdEventSummariesParamSchema,
  t_GetBillingMetersIdEventSummariesQuerySchema,
  t_GetBillingMetersIdEventSummariesRequestBodySchema,
  t_GetBillingMetersIdParamSchema,
  t_GetBillingMetersIdQuerySchema,
  t_GetBillingMetersIdRequestBodySchema,
  t_GetBillingMetersQuerySchema,
  t_GetBillingMetersRequestBodySchema,
  t_GetBillingPortalConfigurationsConfigurationParamSchema,
  t_GetBillingPortalConfigurationsConfigurationQuerySchema,
  t_GetBillingPortalConfigurationsConfigurationRequestBodySchema,
  t_GetBillingPortalConfigurationsQuerySchema,
  t_GetBillingPortalConfigurationsRequestBodySchema,
  t_GetChargesChargeDisputeParamSchema,
  t_GetChargesChargeDisputeQuerySchema,
  t_GetChargesChargeDisputeRequestBodySchema,
  t_GetChargesChargeParamSchema,
  t_GetChargesChargeQuerySchema,
  t_GetChargesChargeRefundsParamSchema,
  t_GetChargesChargeRefundsQuerySchema,
  t_GetChargesChargeRefundsRefundParamSchema,
  t_GetChargesChargeRefundsRefundQuerySchema,
  t_GetChargesChargeRefundsRefundRequestBodySchema,
  t_GetChargesChargeRefundsRequestBodySchema,
  t_GetChargesChargeRequestBodySchema,
  t_GetChargesQuerySchema,
  t_GetChargesRequestBodySchema,
  t_GetChargesSearchQuerySchema,
  t_GetChargesSearchRequestBodySchema,
  t_GetCheckoutSessionsQuerySchema,
  t_GetCheckoutSessionsRequestBodySchema,
  t_GetCheckoutSessionsSessionLineItemsParamSchema,
  t_GetCheckoutSessionsSessionLineItemsQuerySchema,
  t_GetCheckoutSessionsSessionLineItemsRequestBodySchema,
  t_GetCheckoutSessionsSessionParamSchema,
  t_GetCheckoutSessionsSessionQuerySchema,
  t_GetCheckoutSessionsSessionRequestBodySchema,
  t_GetClimateOrdersOrderParamSchema,
  t_GetClimateOrdersOrderQuerySchema,
  t_GetClimateOrdersOrderRequestBodySchema,
  t_GetClimateOrdersQuerySchema,
  t_GetClimateOrdersRequestBodySchema,
  t_GetClimateProductsProductParamSchema,
  t_GetClimateProductsProductQuerySchema,
  t_GetClimateProductsProductRequestBodySchema,
  t_GetClimateProductsQuerySchema,
  t_GetClimateProductsRequestBodySchema,
  t_GetClimateSuppliersQuerySchema,
  t_GetClimateSuppliersRequestBodySchema,
  t_GetClimateSuppliersSupplierParamSchema,
  t_GetClimateSuppliersSupplierQuerySchema,
  t_GetClimateSuppliersSupplierRequestBodySchema,
  t_GetConfirmationTokensConfirmationTokenParamSchema,
  t_GetConfirmationTokensConfirmationTokenQuerySchema,
  t_GetConfirmationTokensConfirmationTokenRequestBodySchema,
  t_GetCountrySpecsCountryParamSchema,
  t_GetCountrySpecsCountryQuerySchema,
  t_GetCountrySpecsCountryRequestBodySchema,
  t_GetCountrySpecsQuerySchema,
  t_GetCountrySpecsRequestBodySchema,
  t_GetCouponsCouponParamSchema,
  t_GetCouponsCouponQuerySchema,
  t_GetCouponsCouponRequestBodySchema,
  t_GetCouponsQuerySchema,
  t_GetCouponsRequestBodySchema,
  t_GetCreditNotesCreditNoteLinesParamSchema,
  t_GetCreditNotesCreditNoteLinesQuerySchema,
  t_GetCreditNotesCreditNoteLinesRequestBodySchema,
  t_GetCreditNotesIdParamSchema,
  t_GetCreditNotesIdQuerySchema,
  t_GetCreditNotesIdRequestBodySchema,
  t_GetCreditNotesPreviewLinesQuerySchema,
  t_GetCreditNotesPreviewLinesRequestBodySchema,
  t_GetCreditNotesPreviewQuerySchema,
  t_GetCreditNotesPreviewRequestBodySchema,
  t_GetCreditNotesQuerySchema,
  t_GetCreditNotesRequestBodySchema,
  t_GetCustomersCustomerBalanceTransactionsParamSchema,
  t_GetCustomersCustomerBalanceTransactionsQuerySchema,
  t_GetCustomersCustomerBalanceTransactionsRequestBodySchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionParamSchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionQuerySchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionRequestBodySchema,
  t_GetCustomersCustomerBankAccountsIdParamSchema,
  t_GetCustomersCustomerBankAccountsIdQuerySchema,
  t_GetCustomersCustomerBankAccountsIdRequestBodySchema,
  t_GetCustomersCustomerBankAccountsParamSchema,
  t_GetCustomersCustomerBankAccountsQuerySchema,
  t_GetCustomersCustomerBankAccountsRequestBodySchema,
  t_GetCustomersCustomerCardsIdParamSchema,
  t_GetCustomersCustomerCardsIdQuerySchema,
  t_GetCustomersCustomerCardsIdRequestBodySchema,
  t_GetCustomersCustomerCardsParamSchema,
  t_GetCustomersCustomerCardsQuerySchema,
  t_GetCustomersCustomerCardsRequestBodySchema,
  t_GetCustomersCustomerCashBalanceParamSchema,
  t_GetCustomersCustomerCashBalanceQuerySchema,
  t_GetCustomersCustomerCashBalanceRequestBodySchema,
  t_GetCustomersCustomerCashBalanceTransactionsParamSchema,
  t_GetCustomersCustomerCashBalanceTransactionsQuerySchema,
  t_GetCustomersCustomerCashBalanceTransactionsRequestBodySchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionRequestBodySchema,
  t_GetCustomersCustomerDiscountParamSchema,
  t_GetCustomersCustomerDiscountQuerySchema,
  t_GetCustomersCustomerDiscountRequestBodySchema,
  t_GetCustomersCustomerParamSchema,
  t_GetCustomersCustomerPaymentMethodsParamSchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodRequestBodySchema,
  t_GetCustomersCustomerPaymentMethodsQuerySchema,
  t_GetCustomersCustomerPaymentMethodsRequestBodySchema,
  t_GetCustomersCustomerQuerySchema,
  t_GetCustomersCustomerRequestBodySchema,
  t_GetCustomersCustomerSourcesIdParamSchema,
  t_GetCustomersCustomerSourcesIdQuerySchema,
  t_GetCustomersCustomerSourcesIdRequestBodySchema,
  t_GetCustomersCustomerSourcesParamSchema,
  t_GetCustomersCustomerSourcesQuerySchema,
  t_GetCustomersCustomerSourcesRequestBodySchema,
  t_GetCustomersCustomerSubscriptionsParamSchema,
  t_GetCustomersCustomerSubscriptionsQuerySchema,
  t_GetCustomersCustomerSubscriptionsRequestBodySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema,
  t_GetCustomersCustomerTaxIdsIdParamSchema,
  t_GetCustomersCustomerTaxIdsIdQuerySchema,
  t_GetCustomersCustomerTaxIdsIdRequestBodySchema,
  t_GetCustomersCustomerTaxIdsParamSchema,
  t_GetCustomersCustomerTaxIdsQuerySchema,
  t_GetCustomersCustomerTaxIdsRequestBodySchema,
  t_GetCustomersQuerySchema,
  t_GetCustomersRequestBodySchema,
  t_GetCustomersSearchQuerySchema,
  t_GetCustomersSearchRequestBodySchema,
  t_GetDisputesDisputeParamSchema,
  t_GetDisputesDisputeQuerySchema,
  t_GetDisputesDisputeRequestBodySchema,
  t_GetDisputesQuerySchema,
  t_GetDisputesRequestBodySchema,
  t_GetEntitlementsActiveEntitlementsIdParamSchema,
  t_GetEntitlementsActiveEntitlementsIdQuerySchema,
  t_GetEntitlementsActiveEntitlementsIdRequestBodySchema,
  t_GetEntitlementsActiveEntitlementsQuerySchema,
  t_GetEntitlementsActiveEntitlementsRequestBodySchema,
  t_GetEntitlementsFeaturesIdParamSchema,
  t_GetEntitlementsFeaturesIdQuerySchema,
  t_GetEntitlementsFeaturesIdRequestBodySchema,
  t_GetEntitlementsFeaturesQuerySchema,
  t_GetEntitlementsFeaturesRequestBodySchema,
  t_GetEventsIdParamSchema,
  t_GetEventsIdQuerySchema,
  t_GetEventsIdRequestBodySchema,
  t_GetEventsQuerySchema,
  t_GetEventsRequestBodySchema,
  t_GetExchangeRatesQuerySchema,
  t_GetExchangeRatesRateIdParamSchema,
  t_GetExchangeRatesRateIdQuerySchema,
  t_GetExchangeRatesRateIdRequestBodySchema,
  t_GetExchangeRatesRequestBodySchema,
  t_GetFileLinksLinkParamSchema,
  t_GetFileLinksLinkQuerySchema,
  t_GetFileLinksLinkRequestBodySchema,
  t_GetFileLinksQuerySchema,
  t_GetFileLinksRequestBodySchema,
  t_GetFilesFileParamSchema,
  t_GetFilesFileQuerySchema,
  t_GetFilesFileRequestBodySchema,
  t_GetFilesQuerySchema,
  t_GetFilesRequestBodySchema,
  t_GetFinancialConnectionsAccountsAccountOwnersParamSchema,
  t_GetFinancialConnectionsAccountsAccountOwnersQuerySchema,
  t_GetFinancialConnectionsAccountsAccountOwnersRequestBodySchema,
  t_GetFinancialConnectionsAccountsAccountParamSchema,
  t_GetFinancialConnectionsAccountsAccountQuerySchema,
  t_GetFinancialConnectionsAccountsAccountRequestBodySchema,
  t_GetFinancialConnectionsAccountsQuerySchema,
  t_GetFinancialConnectionsAccountsRequestBodySchema,
  t_GetFinancialConnectionsSessionsSessionParamSchema,
  t_GetFinancialConnectionsSessionsSessionQuerySchema,
  t_GetFinancialConnectionsSessionsSessionRequestBodySchema,
  t_GetFinancialConnectionsTransactionsQuerySchema,
  t_GetFinancialConnectionsTransactionsRequestBodySchema,
  t_GetFinancialConnectionsTransactionsTransactionParamSchema,
  t_GetFinancialConnectionsTransactionsTransactionQuerySchema,
  t_GetFinancialConnectionsTransactionsTransactionRequestBodySchema,
  t_GetForwardingRequestsIdParamSchema,
  t_GetForwardingRequestsIdQuerySchema,
  t_GetForwardingRequestsIdRequestBodySchema,
  t_GetForwardingRequestsQuerySchema,
  t_GetForwardingRequestsRequestBodySchema,
  t_GetIdentityVerificationReportsQuerySchema,
  t_GetIdentityVerificationReportsReportParamSchema,
  t_GetIdentityVerificationReportsReportQuerySchema,
  t_GetIdentityVerificationReportsReportRequestBodySchema,
  t_GetIdentityVerificationReportsRequestBodySchema,
  t_GetIdentityVerificationSessionsQuerySchema,
  t_GetIdentityVerificationSessionsRequestBodySchema,
  t_GetIdentityVerificationSessionsSessionParamSchema,
  t_GetIdentityVerificationSessionsSessionQuerySchema,
  t_GetIdentityVerificationSessionsSessionRequestBodySchema,
  t_GetInvoicePaymentsInvoicePaymentParamSchema,
  t_GetInvoicePaymentsInvoicePaymentQuerySchema,
  t_GetInvoicePaymentsInvoicePaymentRequestBodySchema,
  t_GetInvoicePaymentsQuerySchema,
  t_GetInvoicePaymentsRequestBodySchema,
  t_GetInvoiceRenderingTemplatesQuerySchema,
  t_GetInvoiceRenderingTemplatesRequestBodySchema,
  t_GetInvoiceRenderingTemplatesTemplateParamSchema,
  t_GetInvoiceRenderingTemplatesTemplateQuerySchema,
  t_GetInvoiceRenderingTemplatesTemplateRequestBodySchema,
  t_GetInvoiceitemsInvoiceitemParamSchema,
  t_GetInvoiceitemsInvoiceitemQuerySchema,
  t_GetInvoiceitemsInvoiceitemRequestBodySchema,
  t_GetInvoiceitemsQuerySchema,
  t_GetInvoiceitemsRequestBodySchema,
  t_GetInvoicesInvoiceLinesParamSchema,
  t_GetInvoicesInvoiceLinesQuerySchema,
  t_GetInvoicesInvoiceLinesRequestBodySchema,
  t_GetInvoicesInvoiceParamSchema,
  t_GetInvoicesInvoiceQuerySchema,
  t_GetInvoicesInvoiceRequestBodySchema,
  t_GetInvoicesQuerySchema,
  t_GetInvoicesRequestBodySchema,
  t_GetInvoicesSearchQuerySchema,
  t_GetInvoicesSearchRequestBodySchema,
  t_GetIssuingAuthorizationsAuthorizationParamSchema,
  t_GetIssuingAuthorizationsAuthorizationQuerySchema,
  t_GetIssuingAuthorizationsAuthorizationRequestBodySchema,
  t_GetIssuingAuthorizationsQuerySchema,
  t_GetIssuingAuthorizationsRequestBodySchema,
  t_GetIssuingCardholdersCardholderParamSchema,
  t_GetIssuingCardholdersCardholderQuerySchema,
  t_GetIssuingCardholdersCardholderRequestBodySchema,
  t_GetIssuingCardholdersQuerySchema,
  t_GetIssuingCardholdersRequestBodySchema,
  t_GetIssuingCardsCardParamSchema,
  t_GetIssuingCardsCardQuerySchema,
  t_GetIssuingCardsCardRequestBodySchema,
  t_GetIssuingCardsQuerySchema,
  t_GetIssuingCardsRequestBodySchema,
  t_GetIssuingDisputesDisputeParamSchema,
  t_GetIssuingDisputesDisputeQuerySchema,
  t_GetIssuingDisputesDisputeRequestBodySchema,
  t_GetIssuingDisputesQuerySchema,
  t_GetIssuingDisputesRequestBodySchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema,
  t_GetIssuingPersonalizationDesignsQuerySchema,
  t_GetIssuingPersonalizationDesignsRequestBodySchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleParamSchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleQuerySchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleRequestBodySchema,
  t_GetIssuingPhysicalBundlesQuerySchema,
  t_GetIssuingPhysicalBundlesRequestBodySchema,
  t_GetIssuingSettlementsSettlementParamSchema,
  t_GetIssuingSettlementsSettlementQuerySchema,
  t_GetIssuingSettlementsSettlementRequestBodySchema,
  t_GetIssuingTokensQuerySchema,
  t_GetIssuingTokensRequestBodySchema,
  t_GetIssuingTokensTokenParamSchema,
  t_GetIssuingTokensTokenQuerySchema,
  t_GetIssuingTokensTokenRequestBodySchema,
  t_GetIssuingTransactionsQuerySchema,
  t_GetIssuingTransactionsRequestBodySchema,
  t_GetIssuingTransactionsTransactionParamSchema,
  t_GetIssuingTransactionsTransactionQuerySchema,
  t_GetIssuingTransactionsTransactionRequestBodySchema,
  t_GetLinkAccountSessionsSessionParamSchema,
  t_GetLinkAccountSessionsSessionQuerySchema,
  t_GetLinkAccountSessionsSessionRequestBodySchema,
  t_GetLinkedAccountsAccountOwnersParamSchema,
  t_GetLinkedAccountsAccountOwnersQuerySchema,
  t_GetLinkedAccountsAccountOwnersRequestBodySchema,
  t_GetLinkedAccountsAccountParamSchema,
  t_GetLinkedAccountsAccountQuerySchema,
  t_GetLinkedAccountsAccountRequestBodySchema,
  t_GetLinkedAccountsQuerySchema,
  t_GetLinkedAccountsRequestBodySchema,
  t_GetMandatesMandateParamSchema,
  t_GetMandatesMandateQuerySchema,
  t_GetMandatesMandateRequestBodySchema,
  t_GetPaymentIntentsIntentParamSchema,
  t_GetPaymentIntentsIntentQuerySchema,
  t_GetPaymentIntentsIntentRequestBodySchema,
  t_GetPaymentIntentsQuerySchema,
  t_GetPaymentIntentsRequestBodySchema,
  t_GetPaymentIntentsSearchQuerySchema,
  t_GetPaymentIntentsSearchRequestBodySchema,
  t_GetPaymentLinksPaymentLinkLineItemsParamSchema,
  t_GetPaymentLinksPaymentLinkLineItemsQuerySchema,
  t_GetPaymentLinksPaymentLinkLineItemsRequestBodySchema,
  t_GetPaymentLinksPaymentLinkParamSchema,
  t_GetPaymentLinksPaymentLinkQuerySchema,
  t_GetPaymentLinksPaymentLinkRequestBodySchema,
  t_GetPaymentLinksQuerySchema,
  t_GetPaymentLinksRequestBodySchema,
  t_GetPaymentMethodConfigurationsConfigurationParamSchema,
  t_GetPaymentMethodConfigurationsConfigurationQuerySchema,
  t_GetPaymentMethodConfigurationsConfigurationRequestBodySchema,
  t_GetPaymentMethodConfigurationsQuerySchema,
  t_GetPaymentMethodConfigurationsRequestBodySchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainParamSchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainQuerySchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainRequestBodySchema,
  t_GetPaymentMethodDomainsQuerySchema,
  t_GetPaymentMethodDomainsRequestBodySchema,
  t_GetPaymentMethodsPaymentMethodParamSchema,
  t_GetPaymentMethodsPaymentMethodQuerySchema,
  t_GetPaymentMethodsPaymentMethodRequestBodySchema,
  t_GetPaymentMethodsQuerySchema,
  t_GetPaymentMethodsRequestBodySchema,
  t_GetPayoutsPayoutParamSchema,
  t_GetPayoutsPayoutQuerySchema,
  t_GetPayoutsPayoutRequestBodySchema,
  t_GetPayoutsQuerySchema,
  t_GetPayoutsRequestBodySchema,
  t_GetPlansPlanParamSchema,
  t_GetPlansPlanQuerySchema,
  t_GetPlansPlanRequestBodySchema,
  t_GetPlansQuerySchema,
  t_GetPlansRequestBodySchema,
  t_GetPricesPriceParamSchema,
  t_GetPricesPriceQuerySchema,
  t_GetPricesPriceRequestBodySchema,
  t_GetPricesQuerySchema,
  t_GetPricesRequestBodySchema,
  t_GetPricesSearchQuerySchema,
  t_GetPricesSearchRequestBodySchema,
  t_GetProductsIdParamSchema,
  t_GetProductsIdQuerySchema,
  t_GetProductsIdRequestBodySchema,
  t_GetProductsProductFeaturesIdParamSchema,
  t_GetProductsProductFeaturesIdQuerySchema,
  t_GetProductsProductFeaturesIdRequestBodySchema,
  t_GetProductsProductFeaturesParamSchema,
  t_GetProductsProductFeaturesQuerySchema,
  t_GetProductsProductFeaturesRequestBodySchema,
  t_GetProductsQuerySchema,
  t_GetProductsRequestBodySchema,
  t_GetProductsSearchQuerySchema,
  t_GetProductsSearchRequestBodySchema,
  t_GetPromotionCodesPromotionCodeParamSchema,
  t_GetPromotionCodesPromotionCodeQuerySchema,
  t_GetPromotionCodesPromotionCodeRequestBodySchema,
  t_GetPromotionCodesQuerySchema,
  t_GetPromotionCodesRequestBodySchema,
  t_GetQuotesQuerySchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsParamSchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsQuerySchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsRequestBodySchema,
  t_GetQuotesQuoteLineItemsParamSchema,
  t_GetQuotesQuoteLineItemsQuerySchema,
  t_GetQuotesQuoteLineItemsRequestBodySchema,
  t_GetQuotesQuoteParamSchema,
  t_GetQuotesQuotePdfParamSchema,
  t_GetQuotesQuotePdfQuerySchema,
  t_GetQuotesQuotePdfRequestBodySchema,
  t_GetQuotesQuoteQuerySchema,
  t_GetQuotesQuoteRequestBodySchema,
  t_GetQuotesRequestBodySchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningRequestBodySchema,
  t_GetRadarEarlyFraudWarningsQuerySchema,
  t_GetRadarEarlyFraudWarningsRequestBodySchema,
  t_GetRadarValueListItemsItemParamSchema,
  t_GetRadarValueListItemsItemQuerySchema,
  t_GetRadarValueListItemsItemRequestBodySchema,
  t_GetRadarValueListItemsQuerySchema,
  t_GetRadarValueListItemsRequestBodySchema,
  t_GetRadarValueListsQuerySchema,
  t_GetRadarValueListsRequestBodySchema,
  t_GetRadarValueListsValueListParamSchema,
  t_GetRadarValueListsValueListQuerySchema,
  t_GetRadarValueListsValueListRequestBodySchema,
  t_GetRefundsQuerySchema,
  t_GetRefundsRefundParamSchema,
  t_GetRefundsRefundQuerySchema,
  t_GetRefundsRefundRequestBodySchema,
  t_GetRefundsRequestBodySchema,
  t_GetReportingReportRunsQuerySchema,
  t_GetReportingReportRunsReportRunParamSchema,
  t_GetReportingReportRunsReportRunQuerySchema,
  t_GetReportingReportRunsReportRunRequestBodySchema,
  t_GetReportingReportRunsRequestBodySchema,
  t_GetReportingReportTypesQuerySchema,
  t_GetReportingReportTypesReportTypeParamSchema,
  t_GetReportingReportTypesReportTypeQuerySchema,
  t_GetReportingReportTypesReportTypeRequestBodySchema,
  t_GetReportingReportTypesRequestBodySchema,
  t_GetReviewsQuerySchema,
  t_GetReviewsRequestBodySchema,
  t_GetReviewsReviewParamSchema,
  t_GetReviewsReviewQuerySchema,
  t_GetReviewsReviewRequestBodySchema,
  t_GetSetupAttemptsQuerySchema,
  t_GetSetupAttemptsRequestBodySchema,
  t_GetSetupIntentsIntentParamSchema,
  t_GetSetupIntentsIntentQuerySchema,
  t_GetSetupIntentsIntentRequestBodySchema,
  t_GetSetupIntentsQuerySchema,
  t_GetSetupIntentsRequestBodySchema,
  t_GetShippingRatesQuerySchema,
  t_GetShippingRatesRequestBodySchema,
  t_GetShippingRatesShippingRateTokenParamSchema,
  t_GetShippingRatesShippingRateTokenQuerySchema,
  t_GetShippingRatesShippingRateTokenRequestBodySchema,
  t_GetSigmaScheduledQueryRunsQuerySchema,
  t_GetSigmaScheduledQueryRunsRequestBodySchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunRequestBodySchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationParamSchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationRequestBodySchema,
  t_GetSourcesSourceParamSchema,
  t_GetSourcesSourceQuerySchema,
  t_GetSourcesSourceRequestBodySchema,
  t_GetSourcesSourceSourceTransactionsParamSchema,
  t_GetSourcesSourceSourceTransactionsQuerySchema,
  t_GetSourcesSourceSourceTransactionsRequestBodySchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionParamSchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionRequestBodySchema,
  t_GetSubscriptionItemsItemParamSchema,
  t_GetSubscriptionItemsItemQuerySchema,
  t_GetSubscriptionItemsItemRequestBodySchema,
  t_GetSubscriptionItemsQuerySchema,
  t_GetSubscriptionItemsRequestBodySchema,
  t_GetSubscriptionSchedulesQuerySchema,
  t_GetSubscriptionSchedulesRequestBodySchema,
  t_GetSubscriptionSchedulesScheduleParamSchema,
  t_GetSubscriptionSchedulesScheduleQuerySchema,
  t_GetSubscriptionSchedulesScheduleRequestBodySchema,
  t_GetSubscriptionsQuerySchema,
  t_GetSubscriptionsRequestBodySchema,
  t_GetSubscriptionsSearchQuerySchema,
  t_GetSubscriptionsSearchRequestBodySchema,
  t_GetSubscriptionsSubscriptionExposedIdParamSchema,
  t_GetSubscriptionsSubscriptionExposedIdQuerySchema,
  t_GetSubscriptionsSubscriptionExposedIdRequestBodySchema,
  t_GetTaxCalculationsCalculationLineItemsParamSchema,
  t_GetTaxCalculationsCalculationLineItemsQuerySchema,
  t_GetTaxCalculationsCalculationLineItemsRequestBodySchema,
  t_GetTaxCalculationsCalculationParamSchema,
  t_GetTaxCalculationsCalculationQuerySchema,
  t_GetTaxCalculationsCalculationRequestBodySchema,
  t_GetTaxCodesIdParamSchema,
  t_GetTaxCodesIdQuerySchema,
  t_GetTaxCodesIdRequestBodySchema,
  t_GetTaxCodesQuerySchema,
  t_GetTaxCodesRequestBodySchema,
  t_GetTaxIdsIdParamSchema,
  t_GetTaxIdsIdQuerySchema,
  t_GetTaxIdsIdRequestBodySchema,
  t_GetTaxIdsQuerySchema,
  t_GetTaxIdsRequestBodySchema,
  t_GetTaxRatesQuerySchema,
  t_GetTaxRatesRequestBodySchema,
  t_GetTaxRatesTaxRateParamSchema,
  t_GetTaxRatesTaxRateQuerySchema,
  t_GetTaxRatesTaxRateRequestBodySchema,
  t_GetTaxRegistrationsIdParamSchema,
  t_GetTaxRegistrationsIdQuerySchema,
  t_GetTaxRegistrationsIdRequestBodySchema,
  t_GetTaxRegistrationsQuerySchema,
  t_GetTaxRegistrationsRequestBodySchema,
  t_GetTaxSettingsQuerySchema,
  t_GetTaxSettingsRequestBodySchema,
  t_GetTaxTransactionsTransactionLineItemsParamSchema,
  t_GetTaxTransactionsTransactionLineItemsQuerySchema,
  t_GetTaxTransactionsTransactionLineItemsRequestBodySchema,
  t_GetTaxTransactionsTransactionParamSchema,
  t_GetTaxTransactionsTransactionQuerySchema,
  t_GetTaxTransactionsTransactionRequestBodySchema,
  t_GetTerminalConfigurationsConfigurationParamSchema,
  t_GetTerminalConfigurationsConfigurationQuerySchema,
  t_GetTerminalConfigurationsConfigurationRequestBodySchema,
  t_GetTerminalConfigurationsQuerySchema,
  t_GetTerminalConfigurationsRequestBodySchema,
  t_GetTerminalLocationsLocationParamSchema,
  t_GetTerminalLocationsLocationQuerySchema,
  t_GetTerminalLocationsLocationRequestBodySchema,
  t_GetTerminalLocationsQuerySchema,
  t_GetTerminalLocationsRequestBodySchema,
  t_GetTerminalReadersQuerySchema,
  t_GetTerminalReadersReaderParamSchema,
  t_GetTerminalReadersReaderQuerySchema,
  t_GetTerminalReadersReaderRequestBodySchema,
  t_GetTerminalReadersRequestBodySchema,
  t_GetTestHelpersTestClocksQuerySchema,
  t_GetTestHelpersTestClocksRequestBodySchema,
  t_GetTestHelpersTestClocksTestClockParamSchema,
  t_GetTestHelpersTestClocksTestClockQuerySchema,
  t_GetTestHelpersTestClocksTestClockRequestBodySchema,
  t_GetTokensTokenParamSchema,
  t_GetTokensTokenQuerySchema,
  t_GetTokensTokenRequestBodySchema,
  t_GetTopupsQuerySchema,
  t_GetTopupsRequestBodySchema,
  t_GetTopupsTopupParamSchema,
  t_GetTopupsTopupQuerySchema,
  t_GetTopupsTopupRequestBodySchema,
  t_GetTransfersIdReversalsParamSchema,
  t_GetTransfersIdReversalsQuerySchema,
  t_GetTransfersIdReversalsRequestBodySchema,
  t_GetTransfersQuerySchema,
  t_GetTransfersRequestBodySchema,
  t_GetTransfersTransferParamSchema,
  t_GetTransfersTransferQuerySchema,
  t_GetTransfersTransferRequestBodySchema,
  t_GetTransfersTransferReversalsIdParamSchema,
  t_GetTransfersTransferReversalsIdQuerySchema,
  t_GetTransfersTransferReversalsIdRequestBodySchema,
  t_GetTreasuryCreditReversalsCreditReversalParamSchema,
  t_GetTreasuryCreditReversalsCreditReversalQuerySchema,
  t_GetTreasuryCreditReversalsCreditReversalRequestBodySchema,
  t_GetTreasuryCreditReversalsQuerySchema,
  t_GetTreasuryCreditReversalsRequestBodySchema,
  t_GetTreasuryDebitReversalsDebitReversalParamSchema,
  t_GetTreasuryDebitReversalsDebitReversalQuerySchema,
  t_GetTreasuryDebitReversalsDebitReversalRequestBodySchema,
  t_GetTreasuryDebitReversalsQuerySchema,
  t_GetTreasuryDebitReversalsRequestBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountParamSchema,
  t_GetTreasuryFinancialAccountsFinancialAccountQuerySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountRequestBodySchema,
  t_GetTreasuryFinancialAccountsQuerySchema,
  t_GetTreasuryFinancialAccountsRequestBodySchema,
  t_GetTreasuryInboundTransfersIdParamSchema,
  t_GetTreasuryInboundTransfersIdQuerySchema,
  t_GetTreasuryInboundTransfersIdRequestBodySchema,
  t_GetTreasuryInboundTransfersQuerySchema,
  t_GetTreasuryInboundTransfersRequestBodySchema,
  t_GetTreasuryOutboundPaymentsIdParamSchema,
  t_GetTreasuryOutboundPaymentsIdQuerySchema,
  t_GetTreasuryOutboundPaymentsIdRequestBodySchema,
  t_GetTreasuryOutboundPaymentsQuerySchema,
  t_GetTreasuryOutboundPaymentsRequestBodySchema,
  t_GetTreasuryOutboundTransfersOutboundTransferParamSchema,
  t_GetTreasuryOutboundTransfersOutboundTransferQuerySchema,
  t_GetTreasuryOutboundTransfersOutboundTransferRequestBodySchema,
  t_GetTreasuryOutboundTransfersQuerySchema,
  t_GetTreasuryOutboundTransfersRequestBodySchema,
  t_GetTreasuryReceivedCreditsIdParamSchema,
  t_GetTreasuryReceivedCreditsIdQuerySchema,
  t_GetTreasuryReceivedCreditsIdRequestBodySchema,
  t_GetTreasuryReceivedCreditsQuerySchema,
  t_GetTreasuryReceivedCreditsRequestBodySchema,
  t_GetTreasuryReceivedDebitsIdParamSchema,
  t_GetTreasuryReceivedDebitsIdQuerySchema,
  t_GetTreasuryReceivedDebitsIdRequestBodySchema,
  t_GetTreasuryReceivedDebitsQuerySchema,
  t_GetTreasuryReceivedDebitsRequestBodySchema,
  t_GetTreasuryTransactionEntriesIdParamSchema,
  t_GetTreasuryTransactionEntriesIdQuerySchema,
  t_GetTreasuryTransactionEntriesIdRequestBodySchema,
  t_GetTreasuryTransactionEntriesQuerySchema,
  t_GetTreasuryTransactionEntriesRequestBodySchema,
  t_GetTreasuryTransactionsIdParamSchema,
  t_GetTreasuryTransactionsIdQuerySchema,
  t_GetTreasuryTransactionsIdRequestBodySchema,
  t_GetTreasuryTransactionsQuerySchema,
  t_GetTreasuryTransactionsRequestBodySchema,
  t_GetWebhookEndpointsQuerySchema,
  t_GetWebhookEndpointsRequestBodySchema,
  t_GetWebhookEndpointsWebhookEndpointParamSchema,
  t_GetWebhookEndpointsWebhookEndpointQuerySchema,
  t_GetWebhookEndpointsWebhookEndpointRequestBodySchema,
  t_PostAccountLinksRequestBodySchema,
  t_PostAccountSessionsRequestBodySchema,
  t_PostAccountsAccountBankAccountsIdParamSchema,
  t_PostAccountsAccountBankAccountsIdRequestBodySchema,
  t_PostAccountsAccountBankAccountsParamSchema,
  t_PostAccountsAccountBankAccountsRequestBodySchema,
  t_PostAccountsAccountCapabilitiesCapabilityParamSchema,
  t_PostAccountsAccountCapabilitiesCapabilityRequestBodySchema,
  t_PostAccountsAccountExternalAccountsIdParamSchema,
  t_PostAccountsAccountExternalAccountsIdRequestBodySchema,
  t_PostAccountsAccountExternalAccountsParamSchema,
  t_PostAccountsAccountExternalAccountsRequestBodySchema,
  t_PostAccountsAccountLoginLinksParamSchema,
  t_PostAccountsAccountLoginLinksRequestBodySchema,
  t_PostAccountsAccountParamSchema,
  t_PostAccountsAccountPeopleParamSchema,
  t_PostAccountsAccountPeoplePersonParamSchema,
  t_PostAccountsAccountPeoplePersonRequestBodySchema,
  t_PostAccountsAccountPeopleRequestBodySchema,
  t_PostAccountsAccountPersonsParamSchema,
  t_PostAccountsAccountPersonsPersonParamSchema,
  t_PostAccountsAccountPersonsPersonRequestBodySchema,
  t_PostAccountsAccountPersonsRequestBodySchema,
  t_PostAccountsAccountRejectParamSchema,
  t_PostAccountsAccountRejectRequestBodySchema,
  t_PostAccountsAccountRequestBodySchema,
  t_PostAccountsRequestBodySchema,
  t_PostApplePayDomainsRequestBodySchema,
  t_PostApplicationFeesFeeRefundsIdParamSchema,
  t_PostApplicationFeesFeeRefundsIdRequestBodySchema,
  t_PostApplicationFeesIdRefundParamSchema,
  t_PostApplicationFeesIdRefundRequestBodySchema,
  t_PostApplicationFeesIdRefundsParamSchema,
  t_PostApplicationFeesIdRefundsRequestBodySchema,
  t_PostAppsSecretsDeleteRequestBodySchema,
  t_PostAppsSecretsRequestBodySchema,
  t_PostBillingAlertsIdActivateParamSchema,
  t_PostBillingAlertsIdActivateRequestBodySchema,
  t_PostBillingAlertsIdArchiveParamSchema,
  t_PostBillingAlertsIdArchiveRequestBodySchema,
  t_PostBillingAlertsIdDeactivateParamSchema,
  t_PostBillingAlertsIdDeactivateRequestBodySchema,
  t_PostBillingAlertsRequestBodySchema,
  t_PostBillingCreditGrantsIdExpireParamSchema,
  t_PostBillingCreditGrantsIdExpireRequestBodySchema,
  t_PostBillingCreditGrantsIdParamSchema,
  t_PostBillingCreditGrantsIdRequestBodySchema,
  t_PostBillingCreditGrantsIdVoidParamSchema,
  t_PostBillingCreditGrantsIdVoidRequestBodySchema,
  t_PostBillingCreditGrantsRequestBodySchema,
  t_PostBillingMeterEventAdjustmentsRequestBodySchema,
  t_PostBillingMeterEventsRequestBodySchema,
  t_PostBillingMetersIdDeactivateParamSchema,
  t_PostBillingMetersIdDeactivateRequestBodySchema,
  t_PostBillingMetersIdParamSchema,
  t_PostBillingMetersIdReactivateParamSchema,
  t_PostBillingMetersIdReactivateRequestBodySchema,
  t_PostBillingMetersIdRequestBodySchema,
  t_PostBillingMetersRequestBodySchema,
  t_PostBillingPortalConfigurationsConfigurationParamSchema,
  t_PostBillingPortalConfigurationsConfigurationRequestBodySchema,
  t_PostBillingPortalConfigurationsRequestBodySchema,
  t_PostBillingPortalSessionsRequestBodySchema,
  t_PostChargesChargeCaptureParamSchema,
  t_PostChargesChargeCaptureRequestBodySchema,
  t_PostChargesChargeDisputeCloseParamSchema,
  t_PostChargesChargeDisputeCloseRequestBodySchema,
  t_PostChargesChargeDisputeParamSchema,
  t_PostChargesChargeDisputeRequestBodySchema,
  t_PostChargesChargeParamSchema,
  t_PostChargesChargeRefundParamSchema,
  t_PostChargesChargeRefundRequestBodySchema,
  t_PostChargesChargeRefundsParamSchema,
  t_PostChargesChargeRefundsRefundParamSchema,
  t_PostChargesChargeRefundsRefundRequestBodySchema,
  t_PostChargesChargeRefundsRequestBodySchema,
  t_PostChargesChargeRequestBodySchema,
  t_PostChargesRequestBodySchema,
  t_PostCheckoutSessionsRequestBodySchema,
  t_PostCheckoutSessionsSessionExpireParamSchema,
  t_PostCheckoutSessionsSessionExpireRequestBodySchema,
  t_PostCheckoutSessionsSessionParamSchema,
  t_PostCheckoutSessionsSessionRequestBodySchema,
  t_PostClimateOrdersOrderCancelParamSchema,
  t_PostClimateOrdersOrderCancelRequestBodySchema,
  t_PostClimateOrdersOrderParamSchema,
  t_PostClimateOrdersOrderRequestBodySchema,
  t_PostClimateOrdersRequestBodySchema,
  t_PostCouponsCouponParamSchema,
  t_PostCouponsCouponRequestBodySchema,
  t_PostCouponsRequestBodySchema,
  t_PostCreditNotesIdParamSchema,
  t_PostCreditNotesIdRequestBodySchema,
  t_PostCreditNotesIdVoidParamSchema,
  t_PostCreditNotesIdVoidRequestBodySchema,
  t_PostCreditNotesRequestBodySchema,
  t_PostCustomerSessionsRequestBodySchema,
  t_PostCustomersCustomerBalanceTransactionsParamSchema,
  t_PostCustomersCustomerBalanceTransactionsRequestBodySchema,
  t_PostCustomersCustomerBalanceTransactionsTransactionParamSchema,
  t_PostCustomersCustomerBalanceTransactionsTransactionRequestBodySchema,
  t_PostCustomersCustomerBankAccountsIdParamSchema,
  t_PostCustomersCustomerBankAccountsIdRequestBodySchema,
  t_PostCustomersCustomerBankAccountsIdVerifyParamSchema,
  t_PostCustomersCustomerBankAccountsIdVerifyRequestBodySchema,
  t_PostCustomersCustomerBankAccountsParamSchema,
  t_PostCustomersCustomerBankAccountsRequestBodySchema,
  t_PostCustomersCustomerCardsIdParamSchema,
  t_PostCustomersCustomerCardsIdRequestBodySchema,
  t_PostCustomersCustomerCardsParamSchema,
  t_PostCustomersCustomerCardsRequestBodySchema,
  t_PostCustomersCustomerCashBalanceParamSchema,
  t_PostCustomersCustomerCashBalanceRequestBodySchema,
  t_PostCustomersCustomerFundingInstructionsParamSchema,
  t_PostCustomersCustomerFundingInstructionsRequestBodySchema,
  t_PostCustomersCustomerParamSchema,
  t_PostCustomersCustomerRequestBodySchema,
  t_PostCustomersCustomerSourcesIdParamSchema,
  t_PostCustomersCustomerSourcesIdRequestBodySchema,
  t_PostCustomersCustomerSourcesIdVerifyParamSchema,
  t_PostCustomersCustomerSourcesIdVerifyRequestBodySchema,
  t_PostCustomersCustomerSourcesParamSchema,
  t_PostCustomersCustomerSourcesRequestBodySchema,
  t_PostCustomersCustomerSubscriptionsParamSchema,
  t_PostCustomersCustomerSubscriptionsRequestBodySchema,
  t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema,
  t_PostCustomersCustomerTaxIdsParamSchema,
  t_PostCustomersCustomerTaxIdsRequestBodySchema,
  t_PostCustomersRequestBodySchema,
  t_PostDisputesDisputeCloseParamSchema,
  t_PostDisputesDisputeCloseRequestBodySchema,
  t_PostDisputesDisputeParamSchema,
  t_PostDisputesDisputeRequestBodySchema,
  t_PostEntitlementsFeaturesIdParamSchema,
  t_PostEntitlementsFeaturesIdRequestBodySchema,
  t_PostEntitlementsFeaturesRequestBodySchema,
  t_PostEphemeralKeysRequestBodySchema,
  t_PostExternalAccountsIdParamSchema,
  t_PostExternalAccountsIdRequestBodySchema,
  t_PostFileLinksLinkParamSchema,
  t_PostFileLinksLinkRequestBodySchema,
  t_PostFileLinksRequestBodySchema,
  t_PostFilesRequestBodySchema,
  t_PostFinancialConnectionsAccountsAccountDisconnectParamSchema,
  t_PostFinancialConnectionsAccountsAccountDisconnectRequestBodySchema,
  t_PostFinancialConnectionsAccountsAccountRefreshParamSchema,
  t_PostFinancialConnectionsAccountsAccountRefreshRequestBodySchema,
  t_PostFinancialConnectionsAccountsAccountSubscribeParamSchema,
  t_PostFinancialConnectionsAccountsAccountSubscribeRequestBodySchema,
  t_PostFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
  t_PostFinancialConnectionsAccountsAccountUnsubscribeRequestBodySchema,
  t_PostFinancialConnectionsSessionsRequestBodySchema,
  t_PostForwardingRequestsRequestBodySchema,
  t_PostIdentityVerificationSessionsRequestBodySchema,
  t_PostIdentityVerificationSessionsSessionCancelParamSchema,
  t_PostIdentityVerificationSessionsSessionCancelRequestBodySchema,
  t_PostIdentityVerificationSessionsSessionParamSchema,
  t_PostIdentityVerificationSessionsSessionRedactParamSchema,
  t_PostIdentityVerificationSessionsSessionRedactRequestBodySchema,
  t_PostIdentityVerificationSessionsSessionRequestBodySchema,
  t_PostInvoiceRenderingTemplatesTemplateArchiveParamSchema,
  t_PostInvoiceRenderingTemplatesTemplateArchiveRequestBodySchema,
  t_PostInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
  t_PostInvoiceRenderingTemplatesTemplateUnarchiveRequestBodySchema,
  t_PostInvoiceitemsInvoiceitemParamSchema,
  t_PostInvoiceitemsInvoiceitemRequestBodySchema,
  t_PostInvoiceitemsRequestBodySchema,
  t_PostInvoicesCreatePreviewRequestBodySchema,
  t_PostInvoicesInvoiceAddLinesParamSchema,
  t_PostInvoicesInvoiceAddLinesRequestBodySchema,
  t_PostInvoicesInvoiceAttachPaymentParamSchema,
  t_PostInvoicesInvoiceAttachPaymentRequestBodySchema,
  t_PostInvoicesInvoiceFinalizeParamSchema,
  t_PostInvoicesInvoiceFinalizeRequestBodySchema,
  t_PostInvoicesInvoiceLinesLineItemIdParamSchema,
  t_PostInvoicesInvoiceLinesLineItemIdRequestBodySchema,
  t_PostInvoicesInvoiceMarkUncollectibleParamSchema,
  t_PostInvoicesInvoiceMarkUncollectibleRequestBodySchema,
  t_PostInvoicesInvoiceParamSchema,
  t_PostInvoicesInvoicePayParamSchema,
  t_PostInvoicesInvoicePayRequestBodySchema,
  t_PostInvoicesInvoiceRemoveLinesParamSchema,
  t_PostInvoicesInvoiceRemoveLinesRequestBodySchema,
  t_PostInvoicesInvoiceRequestBodySchema,
  t_PostInvoicesInvoiceSendParamSchema,
  t_PostInvoicesInvoiceSendRequestBodySchema,
  t_PostInvoicesInvoiceUpdateLinesParamSchema,
  t_PostInvoicesInvoiceUpdateLinesRequestBodySchema,
  t_PostInvoicesInvoiceVoidParamSchema,
  t_PostInvoicesInvoiceVoidRequestBodySchema,
  t_PostInvoicesRequestBodySchema,
  t_PostIssuingAuthorizationsAuthorizationApproveParamSchema,
  t_PostIssuingAuthorizationsAuthorizationApproveRequestBodySchema,
  t_PostIssuingAuthorizationsAuthorizationDeclineParamSchema,
  t_PostIssuingAuthorizationsAuthorizationDeclineRequestBodySchema,
  t_PostIssuingAuthorizationsAuthorizationParamSchema,
  t_PostIssuingAuthorizationsAuthorizationRequestBodySchema,
  t_PostIssuingCardholdersCardholderParamSchema,
  t_PostIssuingCardholdersCardholderRequestBodySchema,
  t_PostIssuingCardholdersRequestBodySchema,
  t_PostIssuingCardsCardParamSchema,
  t_PostIssuingCardsCardRequestBodySchema,
  t_PostIssuingCardsRequestBodySchema,
  t_PostIssuingDisputesDisputeParamSchema,
  t_PostIssuingDisputesDisputeRequestBodySchema,
  t_PostIssuingDisputesDisputeSubmitParamSchema,
  t_PostIssuingDisputesDisputeSubmitRequestBodySchema,
  t_PostIssuingDisputesRequestBodySchema,
  t_PostIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
  t_PostIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema,
  t_PostIssuingPersonalizationDesignsRequestBodySchema,
  t_PostIssuingSettlementsSettlementParamSchema,
  t_PostIssuingSettlementsSettlementRequestBodySchema,
  t_PostIssuingTokensTokenParamSchema,
  t_PostIssuingTokensTokenRequestBodySchema,
  t_PostIssuingTransactionsTransactionParamSchema,
  t_PostIssuingTransactionsTransactionRequestBodySchema,
  t_PostLinkAccountSessionsRequestBodySchema,
  t_PostLinkedAccountsAccountDisconnectParamSchema,
  t_PostLinkedAccountsAccountDisconnectRequestBodySchema,
  t_PostLinkedAccountsAccountRefreshParamSchema,
  t_PostLinkedAccountsAccountRefreshRequestBodySchema,
  t_PostPaymentIntentsIntentApplyCustomerBalanceParamSchema,
  t_PostPaymentIntentsIntentApplyCustomerBalanceRequestBodySchema,
  t_PostPaymentIntentsIntentCancelParamSchema,
  t_PostPaymentIntentsIntentCancelRequestBodySchema,
  t_PostPaymentIntentsIntentCaptureParamSchema,
  t_PostPaymentIntentsIntentCaptureRequestBodySchema,
  t_PostPaymentIntentsIntentConfirmParamSchema,
  t_PostPaymentIntentsIntentConfirmRequestBodySchema,
  t_PostPaymentIntentsIntentIncrementAuthorizationParamSchema,
  t_PostPaymentIntentsIntentIncrementAuthorizationRequestBodySchema,
  t_PostPaymentIntentsIntentParamSchema,
  t_PostPaymentIntentsIntentRequestBodySchema,
  t_PostPaymentIntentsIntentVerifyMicrodepositsParamSchema,
  t_PostPaymentIntentsIntentVerifyMicrodepositsRequestBodySchema,
  t_PostPaymentIntentsRequestBodySchema,
  t_PostPaymentLinksPaymentLinkParamSchema,
  t_PostPaymentLinksPaymentLinkRequestBodySchema,
  t_PostPaymentLinksRequestBodySchema,
  t_PostPaymentMethodConfigurationsConfigurationParamSchema,
  t_PostPaymentMethodConfigurationsConfigurationRequestBodySchema,
  t_PostPaymentMethodConfigurationsRequestBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainParamSchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainRequestBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainValidateRequestBodySchema,
  t_PostPaymentMethodDomainsRequestBodySchema,
  t_PostPaymentMethodsPaymentMethodAttachParamSchema,
  t_PostPaymentMethodsPaymentMethodAttachRequestBodySchema,
  t_PostPaymentMethodsPaymentMethodDetachParamSchema,
  t_PostPaymentMethodsPaymentMethodDetachRequestBodySchema,
  t_PostPaymentMethodsPaymentMethodParamSchema,
  t_PostPaymentMethodsPaymentMethodRequestBodySchema,
  t_PostPaymentMethodsRequestBodySchema,
  t_PostPayoutsPayoutCancelParamSchema,
  t_PostPayoutsPayoutCancelRequestBodySchema,
  t_PostPayoutsPayoutParamSchema,
  t_PostPayoutsPayoutRequestBodySchema,
  t_PostPayoutsPayoutReverseParamSchema,
  t_PostPayoutsPayoutReverseRequestBodySchema,
  t_PostPayoutsRequestBodySchema,
  t_PostPlansPlanParamSchema,
  t_PostPlansPlanRequestBodySchema,
  t_PostPlansRequestBodySchema,
  t_PostPricesPriceParamSchema,
  t_PostPricesPriceRequestBodySchema,
  t_PostPricesRequestBodySchema,
  t_PostProductsIdParamSchema,
  t_PostProductsIdRequestBodySchema,
  t_PostProductsProductFeaturesParamSchema,
  t_PostProductsProductFeaturesRequestBodySchema,
  t_PostProductsRequestBodySchema,
  t_PostPromotionCodesPromotionCodeParamSchema,
  t_PostPromotionCodesPromotionCodeRequestBodySchema,
  t_PostPromotionCodesRequestBodySchema,
  t_PostQuotesQuoteAcceptParamSchema,
  t_PostQuotesQuoteAcceptRequestBodySchema,
  t_PostQuotesQuoteCancelParamSchema,
  t_PostQuotesQuoteCancelRequestBodySchema,
  t_PostQuotesQuoteFinalizeParamSchema,
  t_PostQuotesQuoteFinalizeRequestBodySchema,
  t_PostQuotesQuoteParamSchema,
  t_PostQuotesQuoteRequestBodySchema,
  t_PostQuotesRequestBodySchema,
  t_PostRadarValueListItemsRequestBodySchema,
  t_PostRadarValueListsRequestBodySchema,
  t_PostRadarValueListsValueListParamSchema,
  t_PostRadarValueListsValueListRequestBodySchema,
  t_PostRefundsRefundCancelParamSchema,
  t_PostRefundsRefundCancelRequestBodySchema,
  t_PostRefundsRefundParamSchema,
  t_PostRefundsRefundRequestBodySchema,
  t_PostRefundsRequestBodySchema,
  t_PostReportingReportRunsRequestBodySchema,
  t_PostReviewsReviewApproveParamSchema,
  t_PostReviewsReviewApproveRequestBodySchema,
  t_PostSetupIntentsIntentCancelParamSchema,
  t_PostSetupIntentsIntentCancelRequestBodySchema,
  t_PostSetupIntentsIntentConfirmParamSchema,
  t_PostSetupIntentsIntentConfirmRequestBodySchema,
  t_PostSetupIntentsIntentParamSchema,
  t_PostSetupIntentsIntentRequestBodySchema,
  t_PostSetupIntentsIntentVerifyMicrodepositsParamSchema,
  t_PostSetupIntentsIntentVerifyMicrodepositsRequestBodySchema,
  t_PostSetupIntentsRequestBodySchema,
  t_PostShippingRatesRequestBodySchema,
  t_PostShippingRatesShippingRateTokenParamSchema,
  t_PostShippingRatesShippingRateTokenRequestBodySchema,
  t_PostSigmaSavedQueriesIdParamSchema,
  t_PostSigmaSavedQueriesIdRequestBodySchema,
  t_PostSourcesRequestBodySchema,
  t_PostSourcesSourceParamSchema,
  t_PostSourcesSourceRequestBodySchema,
  t_PostSourcesSourceVerifyParamSchema,
  t_PostSourcesSourceVerifyRequestBodySchema,
  t_PostSubscriptionItemsItemParamSchema,
  t_PostSubscriptionItemsItemRequestBodySchema,
  t_PostSubscriptionItemsRequestBodySchema,
  t_PostSubscriptionSchedulesRequestBodySchema,
  t_PostSubscriptionSchedulesScheduleCancelParamSchema,
  t_PostSubscriptionSchedulesScheduleCancelRequestBodySchema,
  t_PostSubscriptionSchedulesScheduleParamSchema,
  t_PostSubscriptionSchedulesScheduleReleaseParamSchema,
  t_PostSubscriptionSchedulesScheduleReleaseRequestBodySchema,
  t_PostSubscriptionSchedulesScheduleRequestBodySchema,
  t_PostSubscriptionsRequestBodySchema,
  t_PostSubscriptionsSubscriptionExposedIdParamSchema,
  t_PostSubscriptionsSubscriptionExposedIdRequestBodySchema,
  t_PostSubscriptionsSubscriptionMigrateParamSchema,
  t_PostSubscriptionsSubscriptionMigrateRequestBodySchema,
  t_PostSubscriptionsSubscriptionResumeParamSchema,
  t_PostSubscriptionsSubscriptionResumeRequestBodySchema,
  t_PostTaxCalculationsRequestBodySchema,
  t_PostTaxIdsRequestBodySchema,
  t_PostTaxRatesRequestBodySchema,
  t_PostTaxRatesTaxRateParamSchema,
  t_PostTaxRatesTaxRateRequestBodySchema,
  t_PostTaxRegistrationsIdParamSchema,
  t_PostTaxRegistrationsIdRequestBodySchema,
  t_PostTaxRegistrationsRequestBodySchema,
  t_PostTaxSettingsRequestBodySchema,
  t_PostTaxTransactionsCreateFromCalculationRequestBodySchema,
  t_PostTaxTransactionsCreateReversalRequestBodySchema,
  t_PostTerminalConfigurationsConfigurationParamSchema,
  t_PostTerminalConfigurationsConfigurationRequestBodySchema,
  t_PostTerminalConfigurationsRequestBodySchema,
  t_PostTerminalConnectionTokensRequestBodySchema,
  t_PostTerminalLocationsLocationParamSchema,
  t_PostTerminalLocationsLocationRequestBodySchema,
  t_PostTerminalLocationsRequestBodySchema,
  t_PostTerminalReadersReaderCancelActionParamSchema,
  t_PostTerminalReadersReaderCancelActionRequestBodySchema,
  t_PostTerminalReadersReaderCollectInputsParamSchema,
  t_PostTerminalReadersReaderCollectInputsRequestBodySchema,
  t_PostTerminalReadersReaderCollectPaymentMethodParamSchema,
  t_PostTerminalReadersReaderCollectPaymentMethodRequestBodySchema,
  t_PostTerminalReadersReaderConfirmPaymentIntentParamSchema,
  t_PostTerminalReadersReaderConfirmPaymentIntentRequestBodySchema,
  t_PostTerminalReadersReaderParamSchema,
  t_PostTerminalReadersReaderProcessPaymentIntentParamSchema,
  t_PostTerminalReadersReaderProcessPaymentIntentRequestBodySchema,
  t_PostTerminalReadersReaderProcessSetupIntentParamSchema,
  t_PostTerminalReadersReaderProcessSetupIntentRequestBodySchema,
  t_PostTerminalReadersReaderRefundPaymentParamSchema,
  t_PostTerminalReadersReaderRefundPaymentRequestBodySchema,
  t_PostTerminalReadersReaderRequestBodySchema,
  t_PostTerminalReadersReaderSetReaderDisplayParamSchema,
  t_PostTerminalReadersReaderSetReaderDisplayRequestBodySchema,
  t_PostTerminalReadersRequestBodySchema,
  t_PostTestHelpersConfirmationTokensRequestBodySchema,
  t_PostTestHelpersCustomersCustomerFundCashBalanceParamSchema,
  t_PostTestHelpersCustomersCustomerFundCashBalanceRequestBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureRequestBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireRequestBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountRequestBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondRequestBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementRequestBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseRequestBodySchema,
  t_PostTestHelpersIssuingAuthorizationsRequestBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingDeliverParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingDeliverRequestBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingFailParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingFailRequestBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingReturnParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingReturnRequestBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingShipParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingShipRequestBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingSubmitParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingSubmitRequestBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateRequestBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateRequestBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectRequestBodySchema,
  t_PostTestHelpersIssuingSettlementsRequestBodySchema,
  t_PostTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
  t_PostTestHelpersIssuingSettlementsSettlementCompleteRequestBodySchema,
  t_PostTestHelpersIssuingTransactionsCreateForceCaptureRequestBodySchema,
  t_PostTestHelpersIssuingTransactionsCreateUnlinkedRefundRequestBodySchema,
  t_PostTestHelpersIssuingTransactionsTransactionRefundParamSchema,
  t_PostTestHelpersIssuingTransactionsTransactionRefundRequestBodySchema,
  t_PostTestHelpersRefundsRefundExpireParamSchema,
  t_PostTestHelpersRefundsRefundExpireRequestBodySchema,
  t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
  t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodRequestBodySchema,
  t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema,
  t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionRequestBodySchema,
  t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema,
  t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionRequestBodySchema,
  t_PostTestHelpersTestClocksRequestBodySchema,
  t_PostTestHelpersTestClocksTestClockAdvanceParamSchema,
  t_PostTestHelpersTestClocksTestClockAdvanceRequestBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdFailParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdFailRequestBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdReturnRequestBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdSucceedRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdFailRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdPostRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdReturnRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferRequestBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnRequestBodySchema,
  t_PostTestHelpersTreasuryReceivedCreditsRequestBodySchema,
  t_PostTestHelpersTreasuryReceivedDebitsRequestBodySchema,
  t_PostTokensRequestBodySchema,
  t_PostTopupsRequestBodySchema,
  t_PostTopupsTopupCancelParamSchema,
  t_PostTopupsTopupCancelRequestBodySchema,
  t_PostTopupsTopupParamSchema,
  t_PostTopupsTopupRequestBodySchema,
  t_PostTransfersIdReversalsParamSchema,
  t_PostTransfersIdReversalsRequestBodySchema,
  t_PostTransfersRequestBodySchema,
  t_PostTransfersTransferParamSchema,
  t_PostTransfersTransferRequestBodySchema,
  t_PostTransfersTransferReversalsIdParamSchema,
  t_PostTransfersTransferReversalsIdRequestBodySchema,
  t_PostTreasuryCreditReversalsRequestBodySchema,
  t_PostTreasuryDebitReversalsRequestBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
  t_PostTreasuryFinancialAccountsFinancialAccountCloseRequestBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
  t_PostTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountParamSchema,
  t_PostTreasuryFinancialAccountsFinancialAccountRequestBodySchema,
  t_PostTreasuryFinancialAccountsRequestBodySchema,
  t_PostTreasuryInboundTransfersInboundTransferCancelParamSchema,
  t_PostTreasuryInboundTransfersInboundTransferCancelRequestBodySchema,
  t_PostTreasuryInboundTransfersRequestBodySchema,
  t_PostTreasuryOutboundPaymentsIdCancelParamSchema,
  t_PostTreasuryOutboundPaymentsIdCancelRequestBodySchema,
  t_PostTreasuryOutboundPaymentsRequestBodySchema,
  t_PostTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
  t_PostTreasuryOutboundTransfersOutboundTransferCancelRequestBodySchema,
  t_PostTreasuryOutboundTransfersRequestBodySchema,
  t_PostWebhookEndpointsRequestBodySchema,
  t_PostWebhookEndpointsWebhookEndpointParamSchema,
  t_PostWebhookEndpointsWebhookEndpointRequestBodySchema,
  t_account,
  t_account_link,
  t_account_session,
  t_apple_pay_domain,
  t_application_fee,
  t_apps_secret,
  t_balance,
  t_balance_transaction,
  t_bank_account,
  t_billing_alert,
  t_billing_credit_balance_summary,
  t_billing_credit_balance_transaction,
  t_billing_credit_grant,
  t_billing_meter,
  t_billing_meter_event,
  t_billing_meter_event_adjustment,
  t_billing_meter_event_summary,
  t_billing_portal_configuration,
  t_billing_portal_session,
  t_capability,
  t_card,
  t_cash_balance,
  t_charge,
  t_checkout_session,
  t_climate_order,
  t_climate_product,
  t_climate_supplier,
  t_confirmation_token,
  t_country_spec,
  t_coupon,
  t_credit_note,
  t_credit_note_line_item,
  t_customer,
  t_customer_balance_transaction,
  t_customer_cash_balance_transaction,
  t_customer_session,
  t_deleted_account,
  t_deleted_apple_pay_domain,
  t_deleted_coupon,
  t_deleted_customer,
  t_deleted_discount,
  t_deleted_external_account,
  t_deleted_invoice,
  t_deleted_invoiceitem,
  t_deleted_payment_source,
  t_deleted_person,
  t_deleted_plan,
  t_deleted_product,
  t_deleted_product_feature,
  t_deleted_radar_value_list,
  t_deleted_radar_value_list_item,
  t_deleted_subscription_item,
  t_deleted_tax_id,
  t_deleted_terminal_configuration,
  t_deleted_terminal_location,
  t_deleted_terminal_reader,
  t_deleted_test_helpers_test_clock,
  t_deleted_webhook_endpoint,
  t_discount,
  t_dispute,
  t_entitlements_active_entitlement,
  t_entitlements_feature,
  t_ephemeral_key,
  t_error,
  t_event,
  t_exchange_rate,
  t_external_account,
  t_fee_refund,
  t_file,
  t_file_link,
  t_financial_connections_account,
  t_financial_connections_account_owner,
  t_financial_connections_session,
  t_financial_connections_transaction,
  t_forwarding_request,
  t_funding_instructions,
  t_identity_verification_report,
  t_identity_verification_session,
  t_invoice,
  t_invoice_payment,
  t_invoice_rendering_template,
  t_invoiceitem,
  t_issuing_authorization,
  t_issuing_card,
  t_issuing_cardholder,
  t_issuing_dispute,
  t_issuing_personalization_design,
  t_issuing_physical_bundle,
  t_issuing_settlement,
  t_issuing_token,
  t_issuing_transaction,
  t_item,
  t_line_item,
  t_login_link,
  t_mandate,
  t_payment_intent,
  t_payment_link,
  t_payment_method,
  t_payment_method_configuration,
  t_payment_method_domain,
  t_payment_source,
  t_payout,
  t_person,
  t_plan,
  t_price,
  t_product,
  t_product_feature,
  t_promotion_code,
  t_quote,
  t_radar_early_fraud_warning,
  t_radar_value_list,
  t_radar_value_list_item,
  t_refund,
  t_reporting_report_run,
  t_reporting_report_type,
  t_review,
  t_scheduled_query_run,
  t_setup_attempt,
  t_setup_intent,
  t_shipping_rate,
  t_sigma_sigma_api_query,
  t_source,
  t_source_mandate_notification,
  t_source_transaction,
  t_subscription,
  t_subscription_item,
  t_subscription_schedule,
  t_tax_calculation,
  t_tax_calculation_line_item,
  t_tax_code,
  t_tax_id,
  t_tax_rate,
  t_tax_registration,
  t_tax_settings,
  t_tax_transaction,
  t_tax_transaction_line_item,
  t_terminal_configuration,
  t_terminal_connection_token,
  t_terminal_location,
  t_terminal_reader,
  t_test_helpers_test_clock,
  t_token,
  t_topup,
  t_transfer,
  t_transfer_reversal,
  t_treasury_credit_reversal,
  t_treasury_debit_reversal,
  t_treasury_financial_account,
  t_treasury_financial_account_features,
  t_treasury_inbound_transfer,
  t_treasury_outbound_payment,
  t_treasury_outbound_transfer,
  t_treasury_received_credit,
  t_treasury_received_debit,
  t_treasury_transaction,
  t_treasury_transaction_entry,
  t_webhook_endpoint,
} from "./models"
import {
  PermissiveBoolean,
  s_account,
  s_account_link,
  s_account_session,
  s_apple_pay_domain,
  s_application_fee,
  s_apps_secret,
  s_balance,
  s_balance_transaction,
  s_bank_account,
  s_billing_alert,
  s_billing_credit_balance_summary,
  s_billing_credit_balance_transaction,
  s_billing_credit_grant,
  s_billing_meter,
  s_billing_meter_event,
  s_billing_meter_event_adjustment,
  s_billing_meter_event_summary,
  s_billing_portal_configuration,
  s_billing_portal_session,
  s_capability,
  s_card,
  s_cash_balance,
  s_charge,
  s_checkout_session,
  s_climate_order,
  s_climate_product,
  s_climate_supplier,
  s_confirmation_token,
  s_country_spec,
  s_coupon,
  s_credit_note,
  s_credit_note_line_item,
  s_customer,
  s_customer_balance_transaction,
  s_customer_cash_balance_transaction,
  s_customer_session,
  s_deleted_account,
  s_deleted_apple_pay_domain,
  s_deleted_coupon,
  s_deleted_customer,
  s_deleted_discount,
  s_deleted_external_account,
  s_deleted_invoice,
  s_deleted_invoiceitem,
  s_deleted_payment_source,
  s_deleted_person,
  s_deleted_plan,
  s_deleted_product,
  s_deleted_product_feature,
  s_deleted_radar_value_list,
  s_deleted_radar_value_list_item,
  s_deleted_subscription_item,
  s_deleted_tax_id,
  s_deleted_terminal_configuration,
  s_deleted_terminal_location,
  s_deleted_terminal_reader,
  s_deleted_test_helpers_test_clock,
  s_deleted_webhook_endpoint,
  s_discount,
  s_dispute,
  s_entitlements_active_entitlement,
  s_entitlements_feature,
  s_ephemeral_key,
  s_error,
  s_event,
  s_exchange_rate,
  s_external_account,
  s_fee_refund,
  s_file,
  s_file_link,
  s_financial_connections_account,
  s_financial_connections_account_owner,
  s_financial_connections_session,
  s_financial_connections_transaction,
  s_forwarding_request,
  s_funding_instructions,
  s_identity_verification_report,
  s_identity_verification_session,
  s_invoice,
  s_invoice_payment,
  s_invoice_rendering_template,
  s_invoiceitem,
  s_issuing_authorization,
  s_issuing_card,
  s_issuing_cardholder,
  s_issuing_dispute,
  s_issuing_personalization_design,
  s_issuing_physical_bundle,
  s_issuing_settlement,
  s_issuing_token,
  s_issuing_transaction,
  s_item,
  s_line_item,
  s_login_link,
  s_mandate,
  s_payment_intent,
  s_payment_link,
  s_payment_method,
  s_payment_method_configuration,
  s_payment_method_domain,
  s_payment_source,
  s_payout,
  s_person,
  s_plan,
  s_price,
  s_product,
  s_product_feature,
  s_promotion_code,
  s_quote,
  s_radar_early_fraud_warning,
  s_radar_value_list,
  s_radar_value_list_item,
  s_refund,
  s_reporting_report_run,
  s_reporting_report_type,
  s_review,
  s_scheduled_query_run,
  s_setup_attempt,
  s_setup_intent,
  s_shipping_rate,
  s_sigma_sigma_api_query,
  s_source,
  s_source_mandate_notification,
  s_source_transaction,
  s_subscription,
  s_subscription_item,
  s_subscription_schedule,
  s_tax_calculation,
  s_tax_calculation_line_item,
  s_tax_code,
  s_tax_id,
  s_tax_rate,
  s_tax_registration,
  s_tax_settings,
  s_tax_transaction,
  s_tax_transaction_line_item,
  s_terminal_configuration,
  s_terminal_connection_token,
  s_terminal_location,
  s_terminal_reader,
  s_test_helpers_test_clock,
  s_token,
  s_topup,
  s_transfer,
  s_transfer_reversal,
  s_treasury_credit_reversal,
  s_treasury_debit_reversal,
  s_treasury_financial_account,
  s_treasury_financial_account_features,
  s_treasury_inbound_transfer,
  s_treasury_outbound_payment,
  s_treasury_outbound_transfer,
  s_treasury_received_credit,
  s_treasury_received_debit,
  s_treasury_transaction,
  s_treasury_transaction_entry,
  s_webhook_endpoint,
} from "./schemas"
import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  Params,
  ServerConfig,
  SkipResponse,
  StatusCode,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod"
import {NextFunction, Request, Response, Router} from "express"
import {z} from "zod"

export type GetAccountResponder = {
  with200(): ExpressRuntimeResponse<t_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccount = (
  params: Params<
    void,
    t_GetAccountQuerySchema,
    t_GetAccountRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountLinksResponder = {
  with200(): ExpressRuntimeResponse<t_account_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountLinks = (
  params: Params<void, void, t_PostAccountLinksRequestBodySchema, void>,
  respond: PostAccountLinksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountSessionsResponder = {
  with200(): ExpressRuntimeResponse<t_account_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountSessions = (
  params: Params<void, void, t_PostAccountSessionsRequestBodySchema, void>,
  respond: PostAccountSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccounts = (
  params: Params<
    void,
    t_GetAccountsQuerySchema,
    t_GetAccountsRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsResponder = {
  with200(): ExpressRuntimeResponse<t_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccounts = (
  params: Params<void, void, t_PostAccountsRequestBodySchema | undefined, void>,
  respond: PostAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteAccountsAccountResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteAccountsAccount = (
  params: Params<
    t_DeleteAccountsAccountParamSchema,
    void,
    t_DeleteAccountsAccountRequestBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountResponder = {
  with200(): ExpressRuntimeResponse<t_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccount = (
  params: Params<
    t_GetAccountsAccountParamSchema,
    t_GetAccountsAccountQuerySchema,
    t_GetAccountsAccountRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountResponder = {
  with200(): ExpressRuntimeResponse<t_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccount = (
  params: Params<
    t_PostAccountsAccountParamSchema,
    void,
    t_PostAccountsAccountRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountBankAccountsResponder = {
  with200(): ExpressRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountBankAccounts = (
  params: Params<
    t_PostAccountsAccountBankAccountsParamSchema,
    void,
    t_PostAccountsAccountBankAccountsRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountBankAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteAccountsAccountBankAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteAccountsAccountBankAccountsId = (
  params: Params<
    t_DeleteAccountsAccountBankAccountsIdParamSchema,
    void,
    t_DeleteAccountsAccountBankAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountBankAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountBankAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountBankAccountsId = (
  params: Params<
    t_GetAccountsAccountBankAccountsIdParamSchema,
    t_GetAccountsAccountBankAccountsIdQuerySchema,
    t_GetAccountsAccountBankAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountBankAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountBankAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountBankAccountsId = (
  params: Params<
    t_PostAccountsAccountBankAccountsIdParamSchema,
    void,
    t_PostAccountsAccountBankAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountBankAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountCapabilitiesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_capability[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountCapabilities = (
  params: Params<
    t_GetAccountsAccountCapabilitiesParamSchema,
    t_GetAccountsAccountCapabilitiesQuerySchema,
    t_GetAccountsAccountCapabilitiesRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountCapabilitiesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountCapabilitiesCapabilityResponder = {
  with200(): ExpressRuntimeResponse<t_capability>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountCapabilitiesCapability = (
  params: Params<
    t_GetAccountsAccountCapabilitiesCapabilityParamSchema,
    t_GetAccountsAccountCapabilitiesCapabilityQuerySchema,
    t_GetAccountsAccountCapabilitiesCapabilityRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountCapabilitiesCapabilityResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountCapabilitiesCapabilityResponder = {
  with200(): ExpressRuntimeResponse<t_capability>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountCapabilitiesCapability = (
  params: Params<
    t_PostAccountsAccountCapabilitiesCapabilityParamSchema,
    void,
    t_PostAccountsAccountCapabilitiesCapabilityRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountCapabilitiesCapabilityResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountExternalAccountsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: (t_bank_account | t_card)[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountExternalAccounts = (
  params: Params<
    t_GetAccountsAccountExternalAccountsParamSchema,
    t_GetAccountsAccountExternalAccountsQuerySchema,
    t_GetAccountsAccountExternalAccountsRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountExternalAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountExternalAccountsResponder = {
  with200(): ExpressRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountExternalAccounts = (
  params: Params<
    t_PostAccountsAccountExternalAccountsParamSchema,
    void,
    t_PostAccountsAccountExternalAccountsRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountExternalAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteAccountsAccountExternalAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteAccountsAccountExternalAccountsId = (
  params: Params<
    t_DeleteAccountsAccountExternalAccountsIdParamSchema,
    void,
    t_DeleteAccountsAccountExternalAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountExternalAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountExternalAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountExternalAccountsId = (
  params: Params<
    t_GetAccountsAccountExternalAccountsIdParamSchema,
    t_GetAccountsAccountExternalAccountsIdQuerySchema,
    t_GetAccountsAccountExternalAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountExternalAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountExternalAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountExternalAccountsId = (
  params: Params<
    t_PostAccountsAccountExternalAccountsIdParamSchema,
    void,
    t_PostAccountsAccountExternalAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountExternalAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountLoginLinksResponder = {
  with200(): ExpressRuntimeResponse<t_login_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountLoginLinks = (
  params: Params<
    t_PostAccountsAccountLoginLinksParamSchema,
    void,
    t_PostAccountsAccountLoginLinksRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountLoginLinksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountPeopleResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_person[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountPeople = (
  params: Params<
    t_GetAccountsAccountPeopleParamSchema,
    t_GetAccountsAccountPeopleQuerySchema,
    t_GetAccountsAccountPeopleRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPeopleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountPeopleResponder = {
  with200(): ExpressRuntimeResponse<t_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountPeople = (
  params: Params<
    t_PostAccountsAccountPeopleParamSchema,
    void,
    t_PostAccountsAccountPeopleRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPeopleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteAccountsAccountPeoplePersonResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteAccountsAccountPeoplePerson = (
  params: Params<
    t_DeleteAccountsAccountPeoplePersonParamSchema,
    void,
    t_DeleteAccountsAccountPeoplePersonRequestBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountPeoplePersonResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountPeoplePersonResponder = {
  with200(): ExpressRuntimeResponse<t_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountPeoplePerson = (
  params: Params<
    t_GetAccountsAccountPeoplePersonParamSchema,
    t_GetAccountsAccountPeoplePersonQuerySchema,
    t_GetAccountsAccountPeoplePersonRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPeoplePersonResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountPeoplePersonResponder = {
  with200(): ExpressRuntimeResponse<t_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountPeoplePerson = (
  params: Params<
    t_PostAccountsAccountPeoplePersonParamSchema,
    void,
    t_PostAccountsAccountPeoplePersonRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPeoplePersonResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountPersonsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_person[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountPersons = (
  params: Params<
    t_GetAccountsAccountPersonsParamSchema,
    t_GetAccountsAccountPersonsQuerySchema,
    t_GetAccountsAccountPersonsRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPersonsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountPersonsResponder = {
  with200(): ExpressRuntimeResponse<t_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountPersons = (
  params: Params<
    t_PostAccountsAccountPersonsParamSchema,
    void,
    t_PostAccountsAccountPersonsRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPersonsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteAccountsAccountPersonsPersonResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteAccountsAccountPersonsPerson = (
  params: Params<
    t_DeleteAccountsAccountPersonsPersonParamSchema,
    void,
    t_DeleteAccountsAccountPersonsPersonRequestBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountPersonsPersonResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAccountsAccountPersonsPersonResponder = {
  with200(): ExpressRuntimeResponse<t_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAccountsAccountPersonsPerson = (
  params: Params<
    t_GetAccountsAccountPersonsPersonParamSchema,
    t_GetAccountsAccountPersonsPersonQuerySchema,
    t_GetAccountsAccountPersonsPersonRequestBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPersonsPersonResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountPersonsPersonResponder = {
  with200(): ExpressRuntimeResponse<t_person>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountPersonsPerson = (
  params: Params<
    t_PostAccountsAccountPersonsPersonParamSchema,
    void,
    t_PostAccountsAccountPersonsPersonRequestBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPersonsPersonResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAccountsAccountRejectResponder = {
  with200(): ExpressRuntimeResponse<t_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAccountsAccountReject = (
  params: Params<
    t_PostAccountsAccountRejectParamSchema,
    void,
    t_PostAccountsAccountRejectRequestBodySchema,
    void
  >,
  respond: PostAccountsAccountRejectResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetApplePayDomainsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_apple_pay_domain[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetApplePayDomains = (
  params: Params<
    void,
    t_GetApplePayDomainsQuerySchema,
    t_GetApplePayDomainsRequestBodySchema | undefined,
    void
  >,
  respond: GetApplePayDomainsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostApplePayDomainsResponder = {
  with200(): ExpressRuntimeResponse<t_apple_pay_domain>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostApplePayDomains = (
  params: Params<void, void, t_PostApplePayDomainsRequestBodySchema, void>,
  respond: PostApplePayDomainsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteApplePayDomainsDomainResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_apple_pay_domain>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteApplePayDomainsDomain = (
  params: Params<
    t_DeleteApplePayDomainsDomainParamSchema,
    void,
    t_DeleteApplePayDomainsDomainRequestBodySchema | undefined,
    void
  >,
  respond: DeleteApplePayDomainsDomainResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetApplePayDomainsDomainResponder = {
  with200(): ExpressRuntimeResponse<t_apple_pay_domain>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetApplePayDomainsDomain = (
  params: Params<
    t_GetApplePayDomainsDomainParamSchema,
    t_GetApplePayDomainsDomainQuerySchema,
    t_GetApplePayDomainsDomainRequestBodySchema | undefined,
    void
  >,
  respond: GetApplePayDomainsDomainResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetApplicationFeesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_application_fee[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetApplicationFees = (
  params: Params<
    void,
    t_GetApplicationFeesQuerySchema,
    t_GetApplicationFeesRequestBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetApplicationFeesFeeRefundsIdResponder = {
  with200(): ExpressRuntimeResponse<t_fee_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetApplicationFeesFeeRefundsId = (
  params: Params<
    t_GetApplicationFeesFeeRefundsIdParamSchema,
    t_GetApplicationFeesFeeRefundsIdQuerySchema,
    t_GetApplicationFeesFeeRefundsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesFeeRefundsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostApplicationFeesFeeRefundsIdResponder = {
  with200(): ExpressRuntimeResponse<t_fee_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostApplicationFeesFeeRefundsId = (
  params: Params<
    t_PostApplicationFeesFeeRefundsIdParamSchema,
    void,
    t_PostApplicationFeesFeeRefundsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostApplicationFeesFeeRefundsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetApplicationFeesIdResponder = {
  with200(): ExpressRuntimeResponse<t_application_fee>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetApplicationFeesId = (
  params: Params<
    t_GetApplicationFeesIdParamSchema,
    t_GetApplicationFeesIdQuerySchema,
    t_GetApplicationFeesIdRequestBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostApplicationFeesIdRefundResponder = {
  with200(): ExpressRuntimeResponse<t_application_fee>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostApplicationFeesIdRefund = (
  params: Params<
    t_PostApplicationFeesIdRefundParamSchema,
    void,
    t_PostApplicationFeesIdRefundRequestBodySchema | undefined,
    void
  >,
  respond: PostApplicationFeesIdRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetApplicationFeesIdRefundsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_fee_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetApplicationFeesIdRefunds = (
  params: Params<
    t_GetApplicationFeesIdRefundsParamSchema,
    t_GetApplicationFeesIdRefundsQuerySchema,
    t_GetApplicationFeesIdRefundsRequestBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesIdRefundsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostApplicationFeesIdRefundsResponder = {
  with200(): ExpressRuntimeResponse<t_fee_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostApplicationFeesIdRefunds = (
  params: Params<
    t_PostApplicationFeesIdRefundsParamSchema,
    void,
    t_PostApplicationFeesIdRefundsRequestBodySchema | undefined,
    void
  >,
  respond: PostApplicationFeesIdRefundsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAppsSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_apps_secret[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAppsSecrets = (
  params: Params<
    void,
    t_GetAppsSecretsQuerySchema,
    t_GetAppsSecretsRequestBodySchema | undefined,
    void
  >,
  respond: GetAppsSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAppsSecretsResponder = {
  with200(): ExpressRuntimeResponse<t_apps_secret>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAppsSecrets = (
  params: Params<void, void, t_PostAppsSecretsRequestBodySchema, void>,
  respond: PostAppsSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostAppsSecretsDeleteResponder = {
  with200(): ExpressRuntimeResponse<t_apps_secret>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostAppsSecretsDelete = (
  params: Params<void, void, t_PostAppsSecretsDeleteRequestBodySchema, void>,
  respond: PostAppsSecretsDeleteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAppsSecretsFindResponder = {
  with200(): ExpressRuntimeResponse<t_apps_secret>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetAppsSecretsFind = (
  params: Params<
    void,
    t_GetAppsSecretsFindQuerySchema,
    t_GetAppsSecretsFindRequestBodySchema | undefined,
    void
  >,
  respond: GetAppsSecretsFindResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBalanceResponder = {
  with200(): ExpressRuntimeResponse<t_balance>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBalance = (
  params: Params<
    void,
    t_GetBalanceQuerySchema,
    t_GetBalanceRequestBodySchema | undefined,
    void
  >,
  respond: GetBalanceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBalanceHistoryResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBalanceHistory = (
  params: Params<
    void,
    t_GetBalanceHistoryQuerySchema,
    t_GetBalanceHistoryRequestBodySchema | undefined,
    void
  >,
  respond: GetBalanceHistoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBalanceHistoryIdResponder = {
  with200(): ExpressRuntimeResponse<t_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBalanceHistoryId = (
  params: Params<
    t_GetBalanceHistoryIdParamSchema,
    t_GetBalanceHistoryIdQuerySchema,
    t_GetBalanceHistoryIdRequestBodySchema | undefined,
    void
  >,
  respond: GetBalanceHistoryIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBalanceTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBalanceTransactions = (
  params: Params<
    void,
    t_GetBalanceTransactionsQuerySchema,
    t_GetBalanceTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetBalanceTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBalanceTransactionsIdResponder = {
  with200(): ExpressRuntimeResponse<t_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBalanceTransactionsId = (
  params: Params<
    t_GetBalanceTransactionsIdParamSchema,
    t_GetBalanceTransactionsIdQuerySchema,
    t_GetBalanceTransactionsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetBalanceTransactionsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingAlertsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_billing_alert[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingAlerts = (
  params: Params<
    void,
    t_GetBillingAlertsQuerySchema,
    t_GetBillingAlertsRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingAlertsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingAlertsResponder = {
  with200(): ExpressRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingAlerts = (
  params: Params<void, void, t_PostBillingAlertsRequestBodySchema, void>,
  respond: PostBillingAlertsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingAlertsIdResponder = {
  with200(): ExpressRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingAlertsId = (
  params: Params<
    t_GetBillingAlertsIdParamSchema,
    t_GetBillingAlertsIdQuerySchema,
    t_GetBillingAlertsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingAlertsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingAlertsIdActivateResponder = {
  with200(): ExpressRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingAlertsIdActivate = (
  params: Params<
    t_PostBillingAlertsIdActivateParamSchema,
    void,
    t_PostBillingAlertsIdActivateRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingAlertsIdActivateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingAlertsIdArchiveResponder = {
  with200(): ExpressRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingAlertsIdArchive = (
  params: Params<
    t_PostBillingAlertsIdArchiveParamSchema,
    void,
    t_PostBillingAlertsIdArchiveRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingAlertsIdArchiveResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingAlertsIdDeactivateResponder = {
  with200(): ExpressRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingAlertsIdDeactivate = (
  params: Params<
    t_PostBillingAlertsIdDeactivateParamSchema,
    void,
    t_PostBillingAlertsIdDeactivateRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingAlertsIdDeactivateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingCreditBalanceSummaryResponder = {
  with200(): ExpressRuntimeResponse<t_billing_credit_balance_summary>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingCreditBalanceSummary = (
  params: Params<
    void,
    t_GetBillingCreditBalanceSummaryQuerySchema,
    t_GetBillingCreditBalanceSummaryRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditBalanceSummaryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingCreditBalanceTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_billing_credit_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingCreditBalanceTransactions = (
  params: Params<
    void,
    t_GetBillingCreditBalanceTransactionsQuerySchema,
    t_GetBillingCreditBalanceTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditBalanceTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingCreditBalanceTransactionsIdResponder = {
  with200(): ExpressRuntimeResponse<t_billing_credit_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingCreditBalanceTransactionsId = (
  params: Params<
    t_GetBillingCreditBalanceTransactionsIdParamSchema,
    t_GetBillingCreditBalanceTransactionsIdQuerySchema,
    t_GetBillingCreditBalanceTransactionsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditBalanceTransactionsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingCreditGrantsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_billing_credit_grant[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingCreditGrants = (
  params: Params<
    void,
    t_GetBillingCreditGrantsQuerySchema,
    t_GetBillingCreditGrantsRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditGrantsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingCreditGrantsResponder = {
  with200(): ExpressRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingCreditGrants = (
  params: Params<void, void, t_PostBillingCreditGrantsRequestBodySchema, void>,
  respond: PostBillingCreditGrantsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingCreditGrantsIdResponder = {
  with200(): ExpressRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingCreditGrantsId = (
  params: Params<
    t_GetBillingCreditGrantsIdParamSchema,
    t_GetBillingCreditGrantsIdQuerySchema,
    t_GetBillingCreditGrantsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditGrantsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingCreditGrantsIdResponder = {
  with200(): ExpressRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingCreditGrantsId = (
  params: Params<
    t_PostBillingCreditGrantsIdParamSchema,
    void,
    t_PostBillingCreditGrantsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingCreditGrantsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingCreditGrantsIdExpireResponder = {
  with200(): ExpressRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingCreditGrantsIdExpire = (
  params: Params<
    t_PostBillingCreditGrantsIdExpireParamSchema,
    void,
    t_PostBillingCreditGrantsIdExpireRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingCreditGrantsIdExpireResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingCreditGrantsIdVoidResponder = {
  with200(): ExpressRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingCreditGrantsIdVoid = (
  params: Params<
    t_PostBillingCreditGrantsIdVoidParamSchema,
    void,
    t_PostBillingCreditGrantsIdVoidRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingCreditGrantsIdVoidResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingMeterEventAdjustmentsResponder = {
  with200(): ExpressRuntimeResponse<t_billing_meter_event_adjustment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingMeterEventAdjustments = (
  params: Params<
    void,
    void,
    t_PostBillingMeterEventAdjustmentsRequestBodySchema,
    void
  >,
  respond: PostBillingMeterEventAdjustmentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingMeterEventsResponder = {
  with200(): ExpressRuntimeResponse<t_billing_meter_event>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingMeterEvents = (
  params: Params<void, void, t_PostBillingMeterEventsRequestBodySchema, void>,
  respond: PostBillingMeterEventsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingMetersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_billing_meter[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingMeters = (
  params: Params<
    void,
    t_GetBillingMetersQuerySchema,
    t_GetBillingMetersRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingMetersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingMetersResponder = {
  with200(): ExpressRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingMeters = (
  params: Params<void, void, t_PostBillingMetersRequestBodySchema, void>,
  respond: PostBillingMetersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingMetersIdResponder = {
  with200(): ExpressRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingMetersId = (
  params: Params<
    t_GetBillingMetersIdParamSchema,
    t_GetBillingMetersIdQuerySchema,
    t_GetBillingMetersIdRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingMetersIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingMetersIdResponder = {
  with200(): ExpressRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingMetersId = (
  params: Params<
    t_PostBillingMetersIdParamSchema,
    void,
    t_PostBillingMetersIdRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingMetersIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingMetersIdDeactivateResponder = {
  with200(): ExpressRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingMetersIdDeactivate = (
  params: Params<
    t_PostBillingMetersIdDeactivateParamSchema,
    void,
    t_PostBillingMetersIdDeactivateRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingMetersIdDeactivateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingMetersIdEventSummariesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_billing_meter_event_summary[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingMetersIdEventSummaries = (
  params: Params<
    t_GetBillingMetersIdEventSummariesParamSchema,
    t_GetBillingMetersIdEventSummariesQuerySchema,
    t_GetBillingMetersIdEventSummariesRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingMetersIdEventSummariesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingMetersIdReactivateResponder = {
  with200(): ExpressRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingMetersIdReactivate = (
  params: Params<
    t_PostBillingMetersIdReactivateParamSchema,
    void,
    t_PostBillingMetersIdReactivateRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingMetersIdReactivateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingPortalConfigurationsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_billing_portal_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingPortalConfigurations = (
  params: Params<
    void,
    t_GetBillingPortalConfigurationsQuerySchema,
    t_GetBillingPortalConfigurationsRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingPortalConfigurationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingPortalConfigurationsResponder = {
  with200(): ExpressRuntimeResponse<t_billing_portal_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingPortalConfigurations = (
  params: Params<
    void,
    void,
    t_PostBillingPortalConfigurationsRequestBodySchema,
    void
  >,
  respond: PostBillingPortalConfigurationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetBillingPortalConfigurationsConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_billing_portal_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetBillingPortalConfigurationsConfiguration = (
  params: Params<
    t_GetBillingPortalConfigurationsConfigurationParamSchema,
    t_GetBillingPortalConfigurationsConfigurationQuerySchema,
    t_GetBillingPortalConfigurationsConfigurationRequestBodySchema | undefined,
    void
  >,
  respond: GetBillingPortalConfigurationsConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingPortalConfigurationsConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_billing_portal_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingPortalConfigurationsConfiguration = (
  params: Params<
    t_PostBillingPortalConfigurationsConfigurationParamSchema,
    void,
    t_PostBillingPortalConfigurationsConfigurationRequestBodySchema | undefined,
    void
  >,
  respond: PostBillingPortalConfigurationsConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostBillingPortalSessionsResponder = {
  with200(): ExpressRuntimeResponse<t_billing_portal_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostBillingPortalSessions = (
  params: Params<
    void,
    void,
    t_PostBillingPortalSessionsRequestBodySchema,
    void
  >,
  respond: PostBillingPortalSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetChargesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_charge[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCharges = (
  params: Params<
    void,
    t_GetChargesQuerySchema,
    t_GetChargesRequestBodySchema | undefined,
    void
  >,
  respond: GetChargesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesResponder = {
  with200(): ExpressRuntimeResponse<t_charge>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCharges = (
  params: Params<void, void, t_PostChargesRequestBodySchema | undefined, void>,
  respond: PostChargesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetChargesSearchResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_charge[]
    has_more: boolean
    next_page?: (string | null) | undefined
    object: "search_result"
    total_count?: number | undefined
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetChargesSearch = (
  params: Params<
    void,
    t_GetChargesSearchQuerySchema,
    t_GetChargesSearchRequestBodySchema | undefined,
    void
  >,
  respond: GetChargesSearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetChargesChargeResponder = {
  with200(): ExpressRuntimeResponse<t_charge>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetChargesCharge = (
  params: Params<
    t_GetChargesChargeParamSchema,
    t_GetChargesChargeQuerySchema,
    t_GetChargesChargeRequestBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesChargeResponder = {
  with200(): ExpressRuntimeResponse<t_charge>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostChargesCharge = (
  params: Params<
    t_PostChargesChargeParamSchema,
    void,
    t_PostChargesChargeRequestBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesChargeCaptureResponder = {
  with200(): ExpressRuntimeResponse<t_charge>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostChargesChargeCapture = (
  params: Params<
    t_PostChargesChargeCaptureParamSchema,
    void,
    t_PostChargesChargeCaptureRequestBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeCaptureResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetChargesChargeDisputeResponder = {
  with200(): ExpressRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetChargesChargeDispute = (
  params: Params<
    t_GetChargesChargeDisputeParamSchema,
    t_GetChargesChargeDisputeQuerySchema,
    t_GetChargesChargeDisputeRequestBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeDisputeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesChargeDisputeResponder = {
  with200(): ExpressRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostChargesChargeDispute = (
  params: Params<
    t_PostChargesChargeDisputeParamSchema,
    void,
    t_PostChargesChargeDisputeRequestBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeDisputeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesChargeDisputeCloseResponder = {
  with200(): ExpressRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostChargesChargeDisputeClose = (
  params: Params<
    t_PostChargesChargeDisputeCloseParamSchema,
    void,
    t_PostChargesChargeDisputeCloseRequestBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeDisputeCloseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesChargeRefundResponder = {
  with200(): ExpressRuntimeResponse<t_charge>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostChargesChargeRefund = (
  params: Params<
    t_PostChargesChargeRefundParamSchema,
    void,
    t_PostChargesChargeRefundRequestBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetChargesChargeRefundsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetChargesChargeRefunds = (
  params: Params<
    t_GetChargesChargeRefundsParamSchema,
    t_GetChargesChargeRefundsQuerySchema,
    t_GetChargesChargeRefundsRequestBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeRefundsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesChargeRefundsResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostChargesChargeRefunds = (
  params: Params<
    t_PostChargesChargeRefundsParamSchema,
    void,
    t_PostChargesChargeRefundsRequestBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeRefundsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetChargesChargeRefundsRefundResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetChargesChargeRefundsRefund = (
  params: Params<
    t_GetChargesChargeRefundsRefundParamSchema,
    t_GetChargesChargeRefundsRefundQuerySchema,
    t_GetChargesChargeRefundsRefundRequestBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeRefundsRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostChargesChargeRefundsRefundResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostChargesChargeRefundsRefund = (
  params: Params<
    t_PostChargesChargeRefundsRefundParamSchema,
    void,
    t_PostChargesChargeRefundsRefundRequestBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeRefundsRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCheckoutSessionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_checkout_session[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCheckoutSessions = (
  params: Params<
    void,
    t_GetCheckoutSessionsQuerySchema,
    t_GetCheckoutSessionsRequestBodySchema | undefined,
    void
  >,
  respond: GetCheckoutSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCheckoutSessionsResponder = {
  with200(): ExpressRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCheckoutSessions = (
  params: Params<
    void,
    void,
    t_PostCheckoutSessionsRequestBodySchema | undefined,
    void
  >,
  respond: PostCheckoutSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCheckoutSessionsSessionResponder = {
  with200(): ExpressRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCheckoutSessionsSession = (
  params: Params<
    t_GetCheckoutSessionsSessionParamSchema,
    t_GetCheckoutSessionsSessionQuerySchema,
    t_GetCheckoutSessionsSessionRequestBodySchema | undefined,
    void
  >,
  respond: GetCheckoutSessionsSessionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCheckoutSessionsSessionResponder = {
  with200(): ExpressRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCheckoutSessionsSession = (
  params: Params<
    t_PostCheckoutSessionsSessionParamSchema,
    void,
    t_PostCheckoutSessionsSessionRequestBodySchema | undefined,
    void
  >,
  respond: PostCheckoutSessionsSessionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCheckoutSessionsSessionExpireResponder = {
  with200(): ExpressRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCheckoutSessionsSessionExpire = (
  params: Params<
    t_PostCheckoutSessionsSessionExpireParamSchema,
    void,
    t_PostCheckoutSessionsSessionExpireRequestBodySchema | undefined,
    void
  >,
  respond: PostCheckoutSessionsSessionExpireResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCheckoutSessionsSessionLineItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCheckoutSessionsSessionLineItems = (
  params: Params<
    t_GetCheckoutSessionsSessionLineItemsParamSchema,
    t_GetCheckoutSessionsSessionLineItemsQuerySchema,
    t_GetCheckoutSessionsSessionLineItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetCheckoutSessionsSessionLineItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClimateOrdersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_climate_order[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetClimateOrders = (
  params: Params<
    void,
    t_GetClimateOrdersQuerySchema,
    t_GetClimateOrdersRequestBodySchema | undefined,
    void
  >,
  respond: GetClimateOrdersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostClimateOrdersResponder = {
  with200(): ExpressRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostClimateOrders = (
  params: Params<void, void, t_PostClimateOrdersRequestBodySchema, void>,
  respond: PostClimateOrdersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClimateOrdersOrderResponder = {
  with200(): ExpressRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetClimateOrdersOrder = (
  params: Params<
    t_GetClimateOrdersOrderParamSchema,
    t_GetClimateOrdersOrderQuerySchema,
    t_GetClimateOrdersOrderRequestBodySchema | undefined,
    void
  >,
  respond: GetClimateOrdersOrderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostClimateOrdersOrderResponder = {
  with200(): ExpressRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostClimateOrdersOrder = (
  params: Params<
    t_PostClimateOrdersOrderParamSchema,
    void,
    t_PostClimateOrdersOrderRequestBodySchema | undefined,
    void
  >,
  respond: PostClimateOrdersOrderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostClimateOrdersOrderCancelResponder = {
  with200(): ExpressRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostClimateOrdersOrderCancel = (
  params: Params<
    t_PostClimateOrdersOrderCancelParamSchema,
    void,
    t_PostClimateOrdersOrderCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostClimateOrdersOrderCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClimateProductsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_climate_product[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetClimateProducts = (
  params: Params<
    void,
    t_GetClimateProductsQuerySchema,
    t_GetClimateProductsRequestBodySchema | undefined,
    void
  >,
  respond: GetClimateProductsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClimateProductsProductResponder = {
  with200(): ExpressRuntimeResponse<t_climate_product>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetClimateProductsProduct = (
  params: Params<
    t_GetClimateProductsProductParamSchema,
    t_GetClimateProductsProductQuerySchema,
    t_GetClimateProductsProductRequestBodySchema | undefined,
    void
  >,
  respond: GetClimateProductsProductResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClimateSuppliersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_climate_supplier[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetClimateSuppliers = (
  params: Params<
    void,
    t_GetClimateSuppliersQuerySchema,
    t_GetClimateSuppliersRequestBodySchema | undefined,
    void
  >,
  respond: GetClimateSuppliersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClimateSuppliersSupplierResponder = {
  with200(): ExpressRuntimeResponse<t_climate_supplier>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetClimateSuppliersSupplier = (
  params: Params<
    t_GetClimateSuppliersSupplierParamSchema,
    t_GetClimateSuppliersSupplierQuerySchema,
    t_GetClimateSuppliersSupplierRequestBodySchema | undefined,
    void
  >,
  respond: GetClimateSuppliersSupplierResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetConfirmationTokensConfirmationTokenResponder = {
  with200(): ExpressRuntimeResponse<t_confirmation_token>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetConfirmationTokensConfirmationToken = (
  params: Params<
    t_GetConfirmationTokensConfirmationTokenParamSchema,
    t_GetConfirmationTokensConfirmationTokenQuerySchema,
    t_GetConfirmationTokensConfirmationTokenRequestBodySchema | undefined,
    void
  >,
  respond: GetConfirmationTokensConfirmationTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCountrySpecsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_country_spec[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCountrySpecs = (
  params: Params<
    void,
    t_GetCountrySpecsQuerySchema,
    t_GetCountrySpecsRequestBodySchema | undefined,
    void
  >,
  respond: GetCountrySpecsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCountrySpecsCountryResponder = {
  with200(): ExpressRuntimeResponse<t_country_spec>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCountrySpecsCountry = (
  params: Params<
    t_GetCountrySpecsCountryParamSchema,
    t_GetCountrySpecsCountryQuerySchema,
    t_GetCountrySpecsCountryRequestBodySchema | undefined,
    void
  >,
  respond: GetCountrySpecsCountryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCouponsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_coupon[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCoupons = (
  params: Params<
    void,
    t_GetCouponsQuerySchema,
    t_GetCouponsRequestBodySchema | undefined,
    void
  >,
  respond: GetCouponsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCouponsResponder = {
  with200(): ExpressRuntimeResponse<t_coupon>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCoupons = (
  params: Params<void, void, t_PostCouponsRequestBodySchema | undefined, void>,
  respond: PostCouponsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCouponsCouponResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_coupon>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteCouponsCoupon = (
  params: Params<
    t_DeleteCouponsCouponParamSchema,
    void,
    t_DeleteCouponsCouponRequestBodySchema | undefined,
    void
  >,
  respond: DeleteCouponsCouponResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCouponsCouponResponder = {
  with200(): ExpressRuntimeResponse<t_coupon>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCouponsCoupon = (
  params: Params<
    t_GetCouponsCouponParamSchema,
    t_GetCouponsCouponQuerySchema,
    t_GetCouponsCouponRequestBodySchema | undefined,
    void
  >,
  respond: GetCouponsCouponResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCouponsCouponResponder = {
  with200(): ExpressRuntimeResponse<t_coupon>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCouponsCoupon = (
  params: Params<
    t_PostCouponsCouponParamSchema,
    void,
    t_PostCouponsCouponRequestBodySchema | undefined,
    void
  >,
  respond: PostCouponsCouponResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCreditNotesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_credit_note[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCreditNotes = (
  params: Params<
    void,
    t_GetCreditNotesQuerySchema,
    t_GetCreditNotesRequestBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCreditNotesResponder = {
  with200(): ExpressRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCreditNotes = (
  params: Params<void, void, t_PostCreditNotesRequestBodySchema, void>,
  respond: PostCreditNotesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCreditNotesPreviewResponder = {
  with200(): ExpressRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCreditNotesPreview = (
  params: Params<
    void,
    t_GetCreditNotesPreviewQuerySchema,
    t_GetCreditNotesPreviewRequestBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesPreviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCreditNotesPreviewLinesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_credit_note_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCreditNotesPreviewLines = (
  params: Params<
    void,
    t_GetCreditNotesPreviewLinesQuerySchema,
    t_GetCreditNotesPreviewLinesRequestBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesPreviewLinesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCreditNotesCreditNoteLinesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_credit_note_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCreditNotesCreditNoteLines = (
  params: Params<
    t_GetCreditNotesCreditNoteLinesParamSchema,
    t_GetCreditNotesCreditNoteLinesQuerySchema,
    t_GetCreditNotesCreditNoteLinesRequestBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesCreditNoteLinesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCreditNotesIdResponder = {
  with200(): ExpressRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCreditNotesId = (
  params: Params<
    t_GetCreditNotesIdParamSchema,
    t_GetCreditNotesIdQuerySchema,
    t_GetCreditNotesIdRequestBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCreditNotesIdResponder = {
  with200(): ExpressRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCreditNotesId = (
  params: Params<
    t_PostCreditNotesIdParamSchema,
    void,
    t_PostCreditNotesIdRequestBodySchema | undefined,
    void
  >,
  respond: PostCreditNotesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCreditNotesIdVoidResponder = {
  with200(): ExpressRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCreditNotesIdVoid = (
  params: Params<
    t_PostCreditNotesIdVoidParamSchema,
    void,
    t_PostCreditNotesIdVoidRequestBodySchema | undefined,
    void
  >,
  respond: PostCreditNotesIdVoidResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomerSessionsResponder = {
  with200(): ExpressRuntimeResponse<t_customer_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomerSessions = (
  params: Params<void, void, t_PostCustomerSessionsRequestBodySchema, void>,
  respond: PostCustomerSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_customer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomers = (
  params: Params<
    void,
    t_GetCustomersQuerySchema,
    t_GetCustomersRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersResponder = {
  with200(): ExpressRuntimeResponse<t_customer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomers = (
  params: Params<
    void,
    void,
    t_PostCustomersRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersSearchResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_customer[]
    has_more: boolean
    next_page?: (string | null) | undefined
    object: "search_result"
    total_count?: number | undefined
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersSearch = (
  params: Params<
    void,
    t_GetCustomersSearchQuerySchema,
    t_GetCustomersSearchRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersSearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_customer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteCustomersCustomer = (
  params: Params<
    t_DeleteCustomersCustomerParamSchema,
    void,
    t_DeleteCustomersCustomerRequestBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerResponder = {
  with200(): ExpressRuntimeResponse<t_customer | t_deleted_customer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomer = (
  params: Params<
    t_GetCustomersCustomerParamSchema,
    t_GetCustomersCustomerQuerySchema,
    t_GetCustomersCustomerRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerResponder = {
  with200(): ExpressRuntimeResponse<t_customer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomer = (
  params: Params<
    t_PostCustomersCustomerParamSchema,
    void,
    t_PostCustomersCustomerRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerBalanceTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_customer_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerBalanceTransactions = (
  params: Params<
    t_GetCustomersCustomerBalanceTransactionsParamSchema,
    t_GetCustomersCustomerBalanceTransactionsQuerySchema,
    t_GetCustomersCustomerBalanceTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerBalanceTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerBalanceTransactionsResponder = {
  with200(): ExpressRuntimeResponse<t_customer_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerBalanceTransactions = (
  params: Params<
    t_PostCustomersCustomerBalanceTransactionsParamSchema,
    void,
    t_PostCustomersCustomerBalanceTransactionsRequestBodySchema,
    void
  >,
  respond: PostCustomersCustomerBalanceTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerBalanceTransactionsTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_customer_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerBalanceTransactionsTransaction = (
  params: Params<
    t_GetCustomersCustomerBalanceTransactionsTransactionParamSchema,
    t_GetCustomersCustomerBalanceTransactionsTransactionQuerySchema,
    | t_GetCustomersCustomerBalanceTransactionsTransactionRequestBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerBalanceTransactionsTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerBalanceTransactionsTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_customer_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerBalanceTransactionsTransaction = (
  params: Params<
    t_PostCustomersCustomerBalanceTransactionsTransactionParamSchema,
    void,
    | t_PostCustomersCustomerBalanceTransactionsTransactionRequestBodySchema
    | undefined,
    void
  >,
  respond: PostCustomersCustomerBalanceTransactionsTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerBankAccountsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_bank_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerBankAccounts = (
  params: Params<
    t_GetCustomersCustomerBankAccountsParamSchema,
    t_GetCustomersCustomerBankAccountsQuerySchema,
    t_GetCustomersCustomerBankAccountsRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerBankAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerBankAccountsResponder = {
  with200(): ExpressRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerBankAccounts = (
  params: Params<
    t_PostCustomersCustomerBankAccountsParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerBankAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerBankAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_payment_source | t_deleted_payment_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteCustomersCustomerBankAccountsId = (
  params: Params<
    t_DeleteCustomersCustomerBankAccountsIdParamSchema,
    void,
    t_DeleteCustomersCustomerBankAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerBankAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerBankAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_bank_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerBankAccountsId = (
  params: Params<
    t_GetCustomersCustomerBankAccountsIdParamSchema,
    t_GetCustomersCustomerBankAccountsIdQuerySchema,
    t_GetCustomersCustomerBankAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerBankAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerBankAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_card | t_bank_account | t_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerBankAccountsId = (
  params: Params<
    t_PostCustomersCustomerBankAccountsIdParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerBankAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerBankAccountsIdVerifyResponder = {
  with200(): ExpressRuntimeResponse<t_bank_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerBankAccountsIdVerify = (
  params: Params<
    t_PostCustomersCustomerBankAccountsIdVerifyParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsIdVerifyRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerBankAccountsIdVerifyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerCardsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_card[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerCards = (
  params: Params<
    t_GetCustomersCustomerCardsParamSchema,
    t_GetCustomersCustomerCardsQuerySchema,
    t_GetCustomersCustomerCardsRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCardsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerCardsResponder = {
  with200(): ExpressRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerCards = (
  params: Params<
    t_PostCustomersCustomerCardsParamSchema,
    void,
    t_PostCustomersCustomerCardsRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerCardsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerCardsIdResponder = {
  with200(): ExpressRuntimeResponse<t_payment_source | t_deleted_payment_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteCustomersCustomerCardsId = (
  params: Params<
    t_DeleteCustomersCustomerCardsIdParamSchema,
    void,
    t_DeleteCustomersCustomerCardsIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerCardsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerCardsIdResponder = {
  with200(): ExpressRuntimeResponse<t_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerCardsId = (
  params: Params<
    t_GetCustomersCustomerCardsIdParamSchema,
    t_GetCustomersCustomerCardsIdQuerySchema,
    t_GetCustomersCustomerCardsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCardsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerCardsIdResponder = {
  with200(): ExpressRuntimeResponse<t_card | t_bank_account | t_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerCardsId = (
  params: Params<
    t_PostCustomersCustomerCardsIdParamSchema,
    void,
    t_PostCustomersCustomerCardsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerCardsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerCashBalanceResponder = {
  with200(): ExpressRuntimeResponse<t_cash_balance>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerCashBalance = (
  params: Params<
    t_GetCustomersCustomerCashBalanceParamSchema,
    t_GetCustomersCustomerCashBalanceQuerySchema,
    t_GetCustomersCustomerCashBalanceRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCashBalanceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerCashBalanceResponder = {
  with200(): ExpressRuntimeResponse<t_cash_balance>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerCashBalance = (
  params: Params<
    t_PostCustomersCustomerCashBalanceParamSchema,
    void,
    t_PostCustomersCustomerCashBalanceRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerCashBalanceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerCashBalanceTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_customer_cash_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerCashBalanceTransactions = (
  params: Params<
    t_GetCustomersCustomerCashBalanceTransactionsParamSchema,
    t_GetCustomersCustomerCashBalanceTransactionsQuerySchema,
    t_GetCustomersCustomerCashBalanceTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCashBalanceTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerCashBalanceTransactionsTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_customer_cash_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerCashBalanceTransactionsTransaction = (
  params: Params<
    t_GetCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
    t_GetCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
    | t_GetCustomersCustomerCashBalanceTransactionsTransactionRequestBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerCashBalanceTransactionsTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerDiscountResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_discount>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteCustomersCustomerDiscount = (
  params: Params<
    t_DeleteCustomersCustomerDiscountParamSchema,
    void,
    t_DeleteCustomersCustomerDiscountRequestBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerDiscountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerDiscountResponder = {
  with200(): ExpressRuntimeResponse<t_discount>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerDiscount = (
  params: Params<
    t_GetCustomersCustomerDiscountParamSchema,
    t_GetCustomersCustomerDiscountQuerySchema,
    t_GetCustomersCustomerDiscountRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerDiscountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerFundingInstructionsResponder = {
  with200(): ExpressRuntimeResponse<t_funding_instructions>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerFundingInstructions = (
  params: Params<
    t_PostCustomersCustomerFundingInstructionsParamSchema,
    void,
    t_PostCustomersCustomerFundingInstructionsRequestBodySchema,
    void
  >,
  respond: PostCustomersCustomerFundingInstructionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerPaymentMethodsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payment_method[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerPaymentMethods = (
  params: Params<
    t_GetCustomersCustomerPaymentMethodsParamSchema,
    t_GetCustomersCustomerPaymentMethodsQuerySchema,
    t_GetCustomersCustomerPaymentMethodsRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerPaymentMethodsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerPaymentMethodsPaymentMethodResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerPaymentMethodsPaymentMethod = (
  params: Params<
    t_GetCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
    t_GetCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
    | t_GetCustomersCustomerPaymentMethodsPaymentMethodRequestBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerPaymentMethodsPaymentMethodResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerSourcesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: (t_bank_account | t_card | t_source)[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerSources = (
  params: Params<
    t_GetCustomersCustomerSourcesParamSchema,
    t_GetCustomersCustomerSourcesQuerySchema,
    t_GetCustomersCustomerSourcesRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerSourcesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerSourcesResponder = {
  with200(): ExpressRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerSources = (
  params: Params<
    t_PostCustomersCustomerSourcesParamSchema,
    void,
    t_PostCustomersCustomerSourcesRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSourcesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerSourcesIdResponder = {
  with200(): ExpressRuntimeResponse<t_payment_source | t_deleted_payment_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteCustomersCustomerSourcesId = (
  params: Params<
    t_DeleteCustomersCustomerSourcesIdParamSchema,
    void,
    t_DeleteCustomersCustomerSourcesIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerSourcesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerSourcesIdResponder = {
  with200(): ExpressRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerSourcesId = (
  params: Params<
    t_GetCustomersCustomerSourcesIdParamSchema,
    t_GetCustomersCustomerSourcesIdQuerySchema,
    t_GetCustomersCustomerSourcesIdRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerSourcesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerSourcesIdResponder = {
  with200(): ExpressRuntimeResponse<t_card | t_bank_account | t_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerSourcesId = (
  params: Params<
    t_PostCustomersCustomerSourcesIdParamSchema,
    void,
    t_PostCustomersCustomerSourcesIdRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSourcesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerSourcesIdVerifyResponder = {
  with200(): ExpressRuntimeResponse<t_bank_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerSourcesIdVerify = (
  params: Params<
    t_PostCustomersCustomerSourcesIdVerifyParamSchema,
    void,
    t_PostCustomersCustomerSourcesIdVerifyRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSourcesIdVerifyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerSubscriptionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_subscription[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerSubscriptions = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsParamSchema,
    t_GetCustomersCustomerSubscriptionsQuerySchema,
    t_GetCustomersCustomerSubscriptionsRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerSubscriptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerSubscriptionsResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerSubscriptions = (
  params: Params<
    t_PostCustomersCustomerSubscriptionsParamSchema,
    void,
    t_PostCustomersCustomerSubscriptionsRequestBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSubscriptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponder =
  {
    with200(): ExpressRuntimeResponse<t_subscription>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    | t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema
    | undefined,
    void
  >,
  respond: DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerSubscriptionsSubscriptionExposedIdResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
    | t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerSubscriptionsSubscriptionExposedIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerSubscriptionsSubscriptionExposedIdResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    | t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema
    | undefined,
    void
  >,
  respond: PostCustomersCustomerSubscriptionsSubscriptionExposedIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder =
  {
    with200(): ExpressRuntimeResponse<t_deleted_discount>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount =
  (
    params: Params<
      t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
      void,
      | t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema
      | undefined,
      void
    >,
    respond: DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder,
    req: Request,
    res: Response,
    next: NextFunction,
  ) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder =
  {
    with200(): ExpressRuntimeResponse<t_discount>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
    | t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerTaxIdsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_tax_id[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerTaxIds = (
  params: Params<
    t_GetCustomersCustomerTaxIdsParamSchema,
    t_GetCustomersCustomerTaxIdsQuerySchema,
    t_GetCustomersCustomerTaxIdsRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerTaxIdsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostCustomersCustomerTaxIdsResponder = {
  with200(): ExpressRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostCustomersCustomerTaxIds = (
  params: Params<
    t_PostCustomersCustomerTaxIdsParamSchema,
    void,
    t_PostCustomersCustomerTaxIdsRequestBodySchema,
    void
  >,
  respond: PostCustomersCustomerTaxIdsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteCustomersCustomerTaxIdsIdResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_tax_id>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteCustomersCustomerTaxIdsId = (
  params: Params<
    t_DeleteCustomersCustomerTaxIdsIdParamSchema,
    void,
    t_DeleteCustomersCustomerTaxIdsIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerTaxIdsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetCustomersCustomerTaxIdsIdResponder = {
  with200(): ExpressRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetCustomersCustomerTaxIdsId = (
  params: Params<
    t_GetCustomersCustomerTaxIdsIdParamSchema,
    t_GetCustomersCustomerTaxIdsIdQuerySchema,
    t_GetCustomersCustomerTaxIdsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerTaxIdsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetDisputesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_dispute[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetDisputes = (
  params: Params<
    void,
    t_GetDisputesQuerySchema,
    t_GetDisputesRequestBodySchema | undefined,
    void
  >,
  respond: GetDisputesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetDisputesDisputeResponder = {
  with200(): ExpressRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetDisputesDispute = (
  params: Params<
    t_GetDisputesDisputeParamSchema,
    t_GetDisputesDisputeQuerySchema,
    t_GetDisputesDisputeRequestBodySchema | undefined,
    void
  >,
  respond: GetDisputesDisputeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostDisputesDisputeResponder = {
  with200(): ExpressRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostDisputesDispute = (
  params: Params<
    t_PostDisputesDisputeParamSchema,
    void,
    t_PostDisputesDisputeRequestBodySchema | undefined,
    void
  >,
  respond: PostDisputesDisputeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostDisputesDisputeCloseResponder = {
  with200(): ExpressRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostDisputesDisputeClose = (
  params: Params<
    t_PostDisputesDisputeCloseParamSchema,
    void,
    t_PostDisputesDisputeCloseRequestBodySchema | undefined,
    void
  >,
  respond: PostDisputesDisputeCloseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEntitlementsActiveEntitlementsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_entitlements_active_entitlement[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetEntitlementsActiveEntitlements = (
  params: Params<
    void,
    t_GetEntitlementsActiveEntitlementsQuerySchema,
    t_GetEntitlementsActiveEntitlementsRequestBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsActiveEntitlementsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEntitlementsActiveEntitlementsIdResponder = {
  with200(): ExpressRuntimeResponse<t_entitlements_active_entitlement>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetEntitlementsActiveEntitlementsId = (
  params: Params<
    t_GetEntitlementsActiveEntitlementsIdParamSchema,
    t_GetEntitlementsActiveEntitlementsIdQuerySchema,
    t_GetEntitlementsActiveEntitlementsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsActiveEntitlementsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEntitlementsFeaturesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_entitlements_feature[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetEntitlementsFeatures = (
  params: Params<
    void,
    t_GetEntitlementsFeaturesQuerySchema,
    t_GetEntitlementsFeaturesRequestBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsFeaturesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostEntitlementsFeaturesResponder = {
  with200(): ExpressRuntimeResponse<t_entitlements_feature>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostEntitlementsFeatures = (
  params: Params<void, void, t_PostEntitlementsFeaturesRequestBodySchema, void>,
  respond: PostEntitlementsFeaturesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEntitlementsFeaturesIdResponder = {
  with200(): ExpressRuntimeResponse<t_entitlements_feature>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetEntitlementsFeaturesId = (
  params: Params<
    t_GetEntitlementsFeaturesIdParamSchema,
    t_GetEntitlementsFeaturesIdQuerySchema,
    t_GetEntitlementsFeaturesIdRequestBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsFeaturesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostEntitlementsFeaturesIdResponder = {
  with200(): ExpressRuntimeResponse<t_entitlements_feature>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostEntitlementsFeaturesId = (
  params: Params<
    t_PostEntitlementsFeaturesIdParamSchema,
    void,
    t_PostEntitlementsFeaturesIdRequestBodySchema | undefined,
    void
  >,
  respond: PostEntitlementsFeaturesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostEphemeralKeysResponder = {
  with200(): ExpressRuntimeResponse<t_ephemeral_key>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostEphemeralKeys = (
  params: Params<
    void,
    void,
    t_PostEphemeralKeysRequestBodySchema | undefined,
    void
  >,
  respond: PostEphemeralKeysResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteEphemeralKeysKeyResponder = {
  with200(): ExpressRuntimeResponse<t_ephemeral_key>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteEphemeralKeysKey = (
  params: Params<
    t_DeleteEphemeralKeysKeyParamSchema,
    void,
    t_DeleteEphemeralKeysKeyRequestBodySchema | undefined,
    void
  >,
  respond: DeleteEphemeralKeysKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEventsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_event[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetEvents = (
  params: Params<
    void,
    t_GetEventsQuerySchema,
    t_GetEventsRequestBodySchema | undefined,
    void
  >,
  respond: GetEventsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEventsIdResponder = {
  with200(): ExpressRuntimeResponse<t_event>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetEventsId = (
  params: Params<
    t_GetEventsIdParamSchema,
    t_GetEventsIdQuerySchema,
    t_GetEventsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetEventsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetExchangeRatesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_exchange_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetExchangeRates = (
  params: Params<
    void,
    t_GetExchangeRatesQuerySchema,
    t_GetExchangeRatesRequestBodySchema | undefined,
    void
  >,
  respond: GetExchangeRatesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetExchangeRatesRateIdResponder = {
  with200(): ExpressRuntimeResponse<t_exchange_rate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetExchangeRatesRateId = (
  params: Params<
    t_GetExchangeRatesRateIdParamSchema,
    t_GetExchangeRatesRateIdQuerySchema,
    t_GetExchangeRatesRateIdRequestBodySchema | undefined,
    void
  >,
  respond: GetExchangeRatesRateIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostExternalAccountsIdResponder = {
  with200(): ExpressRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostExternalAccountsId = (
  params: Params<
    t_PostExternalAccountsIdParamSchema,
    void,
    t_PostExternalAccountsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostExternalAccountsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFileLinksResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_file_link[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFileLinks = (
  params: Params<
    void,
    t_GetFileLinksQuerySchema,
    t_GetFileLinksRequestBodySchema | undefined,
    void
  >,
  respond: GetFileLinksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFileLinksResponder = {
  with200(): ExpressRuntimeResponse<t_file_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFileLinks = (
  params: Params<void, void, t_PostFileLinksRequestBodySchema, void>,
  respond: PostFileLinksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFileLinksLinkResponder = {
  with200(): ExpressRuntimeResponse<t_file_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFileLinksLink = (
  params: Params<
    t_GetFileLinksLinkParamSchema,
    t_GetFileLinksLinkQuerySchema,
    t_GetFileLinksLinkRequestBodySchema | undefined,
    void
  >,
  respond: GetFileLinksLinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFileLinksLinkResponder = {
  with200(): ExpressRuntimeResponse<t_file_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFileLinksLink = (
  params: Params<
    t_PostFileLinksLinkParamSchema,
    void,
    t_PostFileLinksLinkRequestBodySchema | undefined,
    void
  >,
  respond: PostFileLinksLinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFilesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_file[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFiles = (
  params: Params<
    void,
    t_GetFilesQuerySchema,
    t_GetFilesRequestBodySchema | undefined,
    void
  >,
  respond: GetFilesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFilesResponder = {
  with200(): ExpressRuntimeResponse<t_file>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFiles = (
  params: Params<void, void, t_PostFilesRequestBodySchema, void>,
  respond: PostFilesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFilesFileResponder = {
  with200(): ExpressRuntimeResponse<t_file>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFilesFile = (
  params: Params<
    t_GetFilesFileParamSchema,
    t_GetFilesFileQuerySchema,
    t_GetFilesFileRequestBodySchema | undefined,
    void
  >,
  respond: GetFilesFileResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFinancialConnectionsAccountsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_financial_connections_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFinancialConnectionsAccounts = (
  params: Params<
    void,
    t_GetFinancialConnectionsAccountsQuerySchema,
    t_GetFinancialConnectionsAccountsRequestBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFinancialConnectionsAccountsAccountResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFinancialConnectionsAccountsAccount = (
  params: Params<
    t_GetFinancialConnectionsAccountsAccountParamSchema,
    t_GetFinancialConnectionsAccountsAccountQuerySchema,
    t_GetFinancialConnectionsAccountsAccountRequestBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsAccountsAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFinancialConnectionsAccountsAccountDisconnectResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFinancialConnectionsAccountsAccountDisconnect = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountDisconnectParamSchema,
    void,
    | t_PostFinancialConnectionsAccountsAccountDisconnectRequestBodySchema
    | undefined,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountDisconnectResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFinancialConnectionsAccountsAccountOwnersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_financial_connections_account_owner[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFinancialConnectionsAccountsAccountOwners = (
  params: Params<
    t_GetFinancialConnectionsAccountsAccountOwnersParamSchema,
    t_GetFinancialConnectionsAccountsAccountOwnersQuerySchema,
    t_GetFinancialConnectionsAccountsAccountOwnersRequestBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsAccountsAccountOwnersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFinancialConnectionsAccountsAccountRefreshResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFinancialConnectionsAccountsAccountRefresh = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountRefreshParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountRefreshRequestBodySchema,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountRefreshResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFinancialConnectionsAccountsAccountSubscribeResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFinancialConnectionsAccountsAccountSubscribe = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountSubscribeParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountSubscribeRequestBodySchema,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountSubscribeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFinancialConnectionsAccountsAccountUnsubscribeResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFinancialConnectionsAccountsAccountUnsubscribe = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountUnsubscribeRequestBodySchema,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountUnsubscribeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostFinancialConnectionsSessionsResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostFinancialConnectionsSessions = (
  params: Params<
    void,
    void,
    t_PostFinancialConnectionsSessionsRequestBodySchema,
    void
  >,
  respond: PostFinancialConnectionsSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFinancialConnectionsSessionsSessionResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFinancialConnectionsSessionsSession = (
  params: Params<
    t_GetFinancialConnectionsSessionsSessionParamSchema,
    t_GetFinancialConnectionsSessionsSessionQuerySchema,
    t_GetFinancialConnectionsSessionsSessionRequestBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsSessionsSessionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFinancialConnectionsTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_financial_connections_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFinancialConnectionsTransactions = (
  params: Params<
    void,
    t_GetFinancialConnectionsTransactionsQuerySchema,
    t_GetFinancialConnectionsTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetFinancialConnectionsTransactionsTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetFinancialConnectionsTransactionsTransaction = (
  params: Params<
    t_GetFinancialConnectionsTransactionsTransactionParamSchema,
    t_GetFinancialConnectionsTransactionsTransactionQuerySchema,
    | t_GetFinancialConnectionsTransactionsTransactionRequestBodySchema
    | undefined,
    void
  >,
  respond: GetFinancialConnectionsTransactionsTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetForwardingRequestsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_forwarding_request[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetForwardingRequests = (
  params: Params<
    void,
    t_GetForwardingRequestsQuerySchema,
    t_GetForwardingRequestsRequestBodySchema | undefined,
    void
  >,
  respond: GetForwardingRequestsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostForwardingRequestsResponder = {
  with200(): ExpressRuntimeResponse<t_forwarding_request>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostForwardingRequests = (
  params: Params<void, void, t_PostForwardingRequestsRequestBodySchema, void>,
  respond: PostForwardingRequestsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetForwardingRequestsIdResponder = {
  with200(): ExpressRuntimeResponse<t_forwarding_request>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetForwardingRequestsId = (
  params: Params<
    t_GetForwardingRequestsIdParamSchema,
    t_GetForwardingRequestsIdQuerySchema,
    t_GetForwardingRequestsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetForwardingRequestsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIdentityVerificationReportsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_identity_verification_report[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIdentityVerificationReports = (
  params: Params<
    void,
    t_GetIdentityVerificationReportsQuerySchema,
    t_GetIdentityVerificationReportsRequestBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationReportsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIdentityVerificationReportsReportResponder = {
  with200(): ExpressRuntimeResponse<t_identity_verification_report>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIdentityVerificationReportsReport = (
  params: Params<
    t_GetIdentityVerificationReportsReportParamSchema,
    t_GetIdentityVerificationReportsReportQuerySchema,
    t_GetIdentityVerificationReportsReportRequestBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationReportsReportResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIdentityVerificationSessionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_identity_verification_session[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIdentityVerificationSessions = (
  params: Params<
    void,
    t_GetIdentityVerificationSessionsQuerySchema,
    t_GetIdentityVerificationSessionsRequestBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIdentityVerificationSessionsResponder = {
  with200(): ExpressRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIdentityVerificationSessions = (
  params: Params<
    void,
    void,
    t_PostIdentityVerificationSessionsRequestBodySchema | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIdentityVerificationSessionsSessionResponder = {
  with200(): ExpressRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIdentityVerificationSessionsSession = (
  params: Params<
    t_GetIdentityVerificationSessionsSessionParamSchema,
    t_GetIdentityVerificationSessionsSessionQuerySchema,
    t_GetIdentityVerificationSessionsSessionRequestBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationSessionsSessionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIdentityVerificationSessionsSessionResponder = {
  with200(): ExpressRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIdentityVerificationSessionsSession = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionParamSchema,
    void,
    t_PostIdentityVerificationSessionsSessionRequestBodySchema | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsSessionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIdentityVerificationSessionsSessionCancelResponder = {
  with200(): ExpressRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIdentityVerificationSessionsSessionCancel = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionCancelParamSchema,
    void,
    | t_PostIdentityVerificationSessionsSessionCancelRequestBodySchema
    | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsSessionCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIdentityVerificationSessionsSessionRedactResponder = {
  with200(): ExpressRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIdentityVerificationSessionsSessionRedact = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionRedactParamSchema,
    void,
    | t_PostIdentityVerificationSessionsSessionRedactRequestBodySchema
    | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsSessionRedactResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoicePaymentsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_invoice_payment[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoicePayments = (
  params: Params<
    void,
    t_GetInvoicePaymentsQuerySchema,
    t_GetInvoicePaymentsRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoicePaymentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoicePaymentsInvoicePaymentResponder = {
  with200(): ExpressRuntimeResponse<t_invoice_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoicePaymentsInvoicePayment = (
  params: Params<
    t_GetInvoicePaymentsInvoicePaymentParamSchema,
    t_GetInvoicePaymentsInvoicePaymentQuerySchema,
    t_GetInvoicePaymentsInvoicePaymentRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoicePaymentsInvoicePaymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoiceRenderingTemplatesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_invoice_rendering_template[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoiceRenderingTemplates = (
  params: Params<
    void,
    t_GetInvoiceRenderingTemplatesQuerySchema,
    t_GetInvoiceRenderingTemplatesRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoiceRenderingTemplatesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoiceRenderingTemplatesTemplateResponder = {
  with200(): ExpressRuntimeResponse<t_invoice_rendering_template>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoiceRenderingTemplatesTemplate = (
  params: Params<
    t_GetInvoiceRenderingTemplatesTemplateParamSchema,
    t_GetInvoiceRenderingTemplatesTemplateQuerySchema,
    t_GetInvoiceRenderingTemplatesTemplateRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoiceRenderingTemplatesTemplateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoiceRenderingTemplatesTemplateArchiveResponder = {
  with200(): ExpressRuntimeResponse<t_invoice_rendering_template>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoiceRenderingTemplatesTemplateArchive = (
  params: Params<
    t_PostInvoiceRenderingTemplatesTemplateArchiveParamSchema,
    void,
    t_PostInvoiceRenderingTemplatesTemplateArchiveRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoiceRenderingTemplatesTemplateArchiveResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoiceRenderingTemplatesTemplateUnarchiveResponder = {
  with200(): ExpressRuntimeResponse<t_invoice_rendering_template>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoiceRenderingTemplatesTemplateUnarchive = (
  params: Params<
    t_PostInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
    void,
    | t_PostInvoiceRenderingTemplatesTemplateUnarchiveRequestBodySchema
    | undefined,
    void
  >,
  respond: PostInvoiceRenderingTemplatesTemplateUnarchiveResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoiceitemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_invoiceitem[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoiceitems = (
  params: Params<
    void,
    t_GetInvoiceitemsQuerySchema,
    t_GetInvoiceitemsRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoiceitemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoiceitemsResponder = {
  with200(): ExpressRuntimeResponse<t_invoiceitem>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoiceitems = (
  params: Params<void, void, t_PostInvoiceitemsRequestBodySchema, void>,
  respond: PostInvoiceitemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteInvoiceitemsInvoiceitemResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_invoiceitem>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteInvoiceitemsInvoiceitem = (
  params: Params<
    t_DeleteInvoiceitemsInvoiceitemParamSchema,
    void,
    t_DeleteInvoiceitemsInvoiceitemRequestBodySchema | undefined,
    void
  >,
  respond: DeleteInvoiceitemsInvoiceitemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoiceitemsInvoiceitemResponder = {
  with200(): ExpressRuntimeResponse<t_invoiceitem>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoiceitemsInvoiceitem = (
  params: Params<
    t_GetInvoiceitemsInvoiceitemParamSchema,
    t_GetInvoiceitemsInvoiceitemQuerySchema,
    t_GetInvoiceitemsInvoiceitemRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoiceitemsInvoiceitemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoiceitemsInvoiceitemResponder = {
  with200(): ExpressRuntimeResponse<t_invoiceitem>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoiceitemsInvoiceitem = (
  params: Params<
    t_PostInvoiceitemsInvoiceitemParamSchema,
    void,
    t_PostInvoiceitemsInvoiceitemRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoiceitemsInvoiceitemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoicesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_invoice[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoices = (
  params: Params<
    void,
    t_GetInvoicesQuerySchema,
    t_GetInvoicesRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoicesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoices = (
  params: Params<void, void, t_PostInvoicesRequestBodySchema | undefined, void>,
  respond: PostInvoicesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesCreatePreviewResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesCreatePreview = (
  params: Params<
    void,
    void,
    t_PostInvoicesCreatePreviewRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesCreatePreviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoicesSearchResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_invoice[]
    has_more: boolean
    next_page?: (string | null) | undefined
    object: "search_result"
    total_count?: number | undefined
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoicesSearch = (
  params: Params<
    void,
    t_GetInvoicesSearchQuerySchema,
    t_GetInvoicesSearchRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoicesSearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteInvoicesInvoiceResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteInvoicesInvoice = (
  params: Params<
    t_DeleteInvoicesInvoiceParamSchema,
    void,
    t_DeleteInvoicesInvoiceRequestBodySchema | undefined,
    void
  >,
  respond: DeleteInvoicesInvoiceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoicesInvoiceResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoicesInvoice = (
  params: Params<
    t_GetInvoicesInvoiceParamSchema,
    t_GetInvoicesInvoiceQuerySchema,
    t_GetInvoicesInvoiceRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoicesInvoiceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoice = (
  params: Params<
    t_PostInvoicesInvoiceParamSchema,
    void,
    t_PostInvoicesInvoiceRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceAddLinesResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceAddLines = (
  params: Params<
    t_PostInvoicesInvoiceAddLinesParamSchema,
    void,
    t_PostInvoicesInvoiceAddLinesRequestBodySchema,
    void
  >,
  respond: PostInvoicesInvoiceAddLinesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceAttachPaymentResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceAttachPayment = (
  params: Params<
    t_PostInvoicesInvoiceAttachPaymentParamSchema,
    void,
    t_PostInvoicesInvoiceAttachPaymentRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceAttachPaymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceFinalizeResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceFinalize = (
  params: Params<
    t_PostInvoicesInvoiceFinalizeParamSchema,
    void,
    t_PostInvoicesInvoiceFinalizeRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceFinalizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetInvoicesInvoiceLinesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetInvoicesInvoiceLines = (
  params: Params<
    t_GetInvoicesInvoiceLinesParamSchema,
    t_GetInvoicesInvoiceLinesQuerySchema,
    t_GetInvoicesInvoiceLinesRequestBodySchema | undefined,
    void
  >,
  respond: GetInvoicesInvoiceLinesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceLinesLineItemIdResponder = {
  with200(): ExpressRuntimeResponse<t_line_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceLinesLineItemId = (
  params: Params<
    t_PostInvoicesInvoiceLinesLineItemIdParamSchema,
    void,
    t_PostInvoicesInvoiceLinesLineItemIdRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceLinesLineItemIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceMarkUncollectibleResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceMarkUncollectible = (
  params: Params<
    t_PostInvoicesInvoiceMarkUncollectibleParamSchema,
    void,
    t_PostInvoicesInvoiceMarkUncollectibleRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceMarkUncollectibleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoicePayResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoicePay = (
  params: Params<
    t_PostInvoicesInvoicePayParamSchema,
    void,
    t_PostInvoicesInvoicePayRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoicePayResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceRemoveLinesResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceRemoveLines = (
  params: Params<
    t_PostInvoicesInvoiceRemoveLinesParamSchema,
    void,
    t_PostInvoicesInvoiceRemoveLinesRequestBodySchema,
    void
  >,
  respond: PostInvoicesInvoiceRemoveLinesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceSendResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceSend = (
  params: Params<
    t_PostInvoicesInvoiceSendParamSchema,
    void,
    t_PostInvoicesInvoiceSendRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceSendResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceUpdateLinesResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceUpdateLines = (
  params: Params<
    t_PostInvoicesInvoiceUpdateLinesParamSchema,
    void,
    t_PostInvoicesInvoiceUpdateLinesRequestBodySchema,
    void
  >,
  respond: PostInvoicesInvoiceUpdateLinesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostInvoicesInvoiceVoidResponder = {
  with200(): ExpressRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostInvoicesInvoiceVoid = (
  params: Params<
    t_PostInvoicesInvoiceVoidParamSchema,
    void,
    t_PostInvoicesInvoiceVoidRequestBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceVoidResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingAuthorizationsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_authorization[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingAuthorizations = (
  params: Params<
    void,
    t_GetIssuingAuthorizationsQuerySchema,
    t_GetIssuingAuthorizationsRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingAuthorizationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingAuthorizationsAuthorizationResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingAuthorizationsAuthorization = (
  params: Params<
    t_GetIssuingAuthorizationsAuthorizationParamSchema,
    t_GetIssuingAuthorizationsAuthorizationQuerySchema,
    t_GetIssuingAuthorizationsAuthorizationRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingAuthorizationsAuthorizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingAuthorizationsAuthorizationResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingAuthorizationsAuthorization = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationParamSchema,
    void,
    t_PostIssuingAuthorizationsAuthorizationRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingAuthorizationsAuthorizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingAuthorizationsAuthorizationApproveResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingAuthorizationsAuthorizationApprove = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationApproveParamSchema,
    void,
    | t_PostIssuingAuthorizationsAuthorizationApproveRequestBodySchema
    | undefined,
    void
  >,
  respond: PostIssuingAuthorizationsAuthorizationApproveResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingAuthorizationsAuthorizationDeclineResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingAuthorizationsAuthorizationDecline = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationDeclineParamSchema,
    void,
    | t_PostIssuingAuthorizationsAuthorizationDeclineRequestBodySchema
    | undefined,
    void
  >,
  respond: PostIssuingAuthorizationsAuthorizationDeclineResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingCardholdersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_cardholder[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingCardholders = (
  params: Params<
    void,
    t_GetIssuingCardholdersQuerySchema,
    t_GetIssuingCardholdersRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardholdersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingCardholdersResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_cardholder>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingCardholders = (
  params: Params<void, void, t_PostIssuingCardholdersRequestBodySchema, void>,
  respond: PostIssuingCardholdersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingCardholdersCardholderResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_cardholder>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingCardholdersCardholder = (
  params: Params<
    t_GetIssuingCardholdersCardholderParamSchema,
    t_GetIssuingCardholdersCardholderQuerySchema,
    t_GetIssuingCardholdersCardholderRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardholdersCardholderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingCardholdersCardholderResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_cardholder>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingCardholdersCardholder = (
  params: Params<
    t_PostIssuingCardholdersCardholderParamSchema,
    void,
    t_PostIssuingCardholdersCardholderRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingCardholdersCardholderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingCardsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_card[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingCards = (
  params: Params<
    void,
    t_GetIssuingCardsQuerySchema,
    t_GetIssuingCardsRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingCardsResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingCards = (
  params: Params<void, void, t_PostIssuingCardsRequestBodySchema, void>,
  respond: PostIssuingCardsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingCardsCardResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingCardsCard = (
  params: Params<
    t_GetIssuingCardsCardParamSchema,
    t_GetIssuingCardsCardQuerySchema,
    t_GetIssuingCardsCardRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardsCardResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingCardsCardResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingCardsCard = (
  params: Params<
    t_PostIssuingCardsCardParamSchema,
    void,
    t_PostIssuingCardsCardRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingCardsCardResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingDisputesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_dispute[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingDisputes = (
  params: Params<
    void,
    t_GetIssuingDisputesQuerySchema,
    t_GetIssuingDisputesRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingDisputesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingDisputesResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingDisputes = (
  params: Params<
    void,
    void,
    t_PostIssuingDisputesRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingDisputesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingDisputesDisputeResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingDisputesDispute = (
  params: Params<
    t_GetIssuingDisputesDisputeParamSchema,
    t_GetIssuingDisputesDisputeQuerySchema,
    t_GetIssuingDisputesDisputeRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingDisputesDisputeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingDisputesDisputeResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingDisputesDispute = (
  params: Params<
    t_PostIssuingDisputesDisputeParamSchema,
    void,
    t_PostIssuingDisputesDisputeRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingDisputesDisputeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingDisputesDisputeSubmitResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingDisputesDisputeSubmit = (
  params: Params<
    t_PostIssuingDisputesDisputeSubmitParamSchema,
    void,
    t_PostIssuingDisputesDisputeSubmitRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingDisputesDisputeSubmitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingPersonalizationDesignsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_personalization_design[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingPersonalizationDesigns = (
  params: Params<
    void,
    t_GetIssuingPersonalizationDesignsQuerySchema,
    t_GetIssuingPersonalizationDesignsRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingPersonalizationDesignsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingPersonalizationDesignsResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_personalization_design>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingPersonalizationDesigns = (
  params: Params<
    void,
    void,
    t_PostIssuingPersonalizationDesignsRequestBodySchema,
    void
  >,
  respond: PostIssuingPersonalizationDesignsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingPersonalizationDesignsPersonalizationDesignResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_personalization_design>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingPersonalizationDesignsPersonalizationDesign = (
  params: Params<
    t_GetIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
    t_GetIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
    | t_GetIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema
    | undefined,
    void
  >,
  respond: GetIssuingPersonalizationDesignsPersonalizationDesignResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingPersonalizationDesignsPersonalizationDesignResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_personalization_design>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingPersonalizationDesignsPersonalizationDesign = (
  params: Params<
    t_PostIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
    void,
    | t_PostIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema
    | undefined,
    void
  >,
  respond: PostIssuingPersonalizationDesignsPersonalizationDesignResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingPhysicalBundlesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_physical_bundle[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingPhysicalBundles = (
  params: Params<
    void,
    t_GetIssuingPhysicalBundlesQuerySchema,
    t_GetIssuingPhysicalBundlesRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingPhysicalBundlesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingPhysicalBundlesPhysicalBundleResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_physical_bundle>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingPhysicalBundlesPhysicalBundle = (
  params: Params<
    t_GetIssuingPhysicalBundlesPhysicalBundleParamSchema,
    t_GetIssuingPhysicalBundlesPhysicalBundleQuerySchema,
    t_GetIssuingPhysicalBundlesPhysicalBundleRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingPhysicalBundlesPhysicalBundleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingSettlementsSettlementResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingSettlementsSettlement = (
  params: Params<
    t_GetIssuingSettlementsSettlementParamSchema,
    t_GetIssuingSettlementsSettlementQuerySchema,
    t_GetIssuingSettlementsSettlementRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingSettlementsSettlementResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingSettlementsSettlementResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingSettlementsSettlement = (
  params: Params<
    t_PostIssuingSettlementsSettlementParamSchema,
    void,
    t_PostIssuingSettlementsSettlementRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingSettlementsSettlementResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingTokensResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_token[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingTokens = (
  params: Params<
    void,
    t_GetIssuingTokensQuerySchema,
    t_GetIssuingTokensRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingTokensResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingTokensTokenResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_token>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingTokensToken = (
  params: Params<
    t_GetIssuingTokensTokenParamSchema,
    t_GetIssuingTokensTokenQuerySchema,
    t_GetIssuingTokensTokenRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingTokensTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingTokensTokenResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_token>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingTokensToken = (
  params: Params<
    t_PostIssuingTokensTokenParamSchema,
    void,
    t_PostIssuingTokensTokenRequestBodySchema,
    void
  >,
  respond: PostIssuingTokensTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_issuing_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingTransactions = (
  params: Params<
    void,
    t_GetIssuingTransactionsQuerySchema,
    t_GetIssuingTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetIssuingTransactionsTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetIssuingTransactionsTransaction = (
  params: Params<
    t_GetIssuingTransactionsTransactionParamSchema,
    t_GetIssuingTransactionsTransactionQuerySchema,
    t_GetIssuingTransactionsTransactionRequestBodySchema | undefined,
    void
  >,
  respond: GetIssuingTransactionsTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostIssuingTransactionsTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostIssuingTransactionsTransaction = (
  params: Params<
    t_PostIssuingTransactionsTransactionParamSchema,
    void,
    t_PostIssuingTransactionsTransactionRequestBodySchema | undefined,
    void
  >,
  respond: PostIssuingTransactionsTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostLinkAccountSessionsResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostLinkAccountSessions = (
  params: Params<void, void, t_PostLinkAccountSessionsRequestBodySchema, void>,
  respond: PostLinkAccountSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetLinkAccountSessionsSessionResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetLinkAccountSessionsSession = (
  params: Params<
    t_GetLinkAccountSessionsSessionParamSchema,
    t_GetLinkAccountSessionsSessionQuerySchema,
    t_GetLinkAccountSessionsSessionRequestBodySchema | undefined,
    void
  >,
  respond: GetLinkAccountSessionsSessionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetLinkedAccountsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_financial_connections_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetLinkedAccounts = (
  params: Params<
    void,
    t_GetLinkedAccountsQuerySchema,
    t_GetLinkedAccountsRequestBodySchema | undefined,
    void
  >,
  respond: GetLinkedAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetLinkedAccountsAccountResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetLinkedAccountsAccount = (
  params: Params<
    t_GetLinkedAccountsAccountParamSchema,
    t_GetLinkedAccountsAccountQuerySchema,
    t_GetLinkedAccountsAccountRequestBodySchema | undefined,
    void
  >,
  respond: GetLinkedAccountsAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostLinkedAccountsAccountDisconnectResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostLinkedAccountsAccountDisconnect = (
  params: Params<
    t_PostLinkedAccountsAccountDisconnectParamSchema,
    void,
    t_PostLinkedAccountsAccountDisconnectRequestBodySchema | undefined,
    void
  >,
  respond: PostLinkedAccountsAccountDisconnectResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetLinkedAccountsAccountOwnersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_financial_connections_account_owner[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetLinkedAccountsAccountOwners = (
  params: Params<
    t_GetLinkedAccountsAccountOwnersParamSchema,
    t_GetLinkedAccountsAccountOwnersQuerySchema,
    t_GetLinkedAccountsAccountOwnersRequestBodySchema | undefined,
    void
  >,
  respond: GetLinkedAccountsAccountOwnersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostLinkedAccountsAccountRefreshResponder = {
  with200(): ExpressRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostLinkedAccountsAccountRefresh = (
  params: Params<
    t_PostLinkedAccountsAccountRefreshParamSchema,
    void,
    t_PostLinkedAccountsAccountRefreshRequestBodySchema,
    void
  >,
  respond: PostLinkedAccountsAccountRefreshResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetMandatesMandateResponder = {
  with200(): ExpressRuntimeResponse<t_mandate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetMandatesMandate = (
  params: Params<
    t_GetMandatesMandateParamSchema,
    t_GetMandatesMandateQuerySchema,
    t_GetMandatesMandateRequestBodySchema | undefined,
    void
  >,
  respond: GetMandatesMandateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentIntentsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payment_intent[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentIntents = (
  params: Params<
    void,
    t_GetPaymentIntentsQuerySchema,
    t_GetPaymentIntentsRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentIntentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntents = (
  params: Params<void, void, t_PostPaymentIntentsRequestBodySchema, void>,
  respond: PostPaymentIntentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentIntentsSearchResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payment_intent[]
    has_more: boolean
    next_page?: (string | null) | undefined
    object: "search_result"
    total_count?: number | undefined
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentIntentsSearch = (
  params: Params<
    void,
    t_GetPaymentIntentsSearchQuerySchema,
    t_GetPaymentIntentsSearchRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentIntentsSearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentIntentsIntentResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentIntentsIntent = (
  params: Params<
    t_GetPaymentIntentsIntentParamSchema,
    t_GetPaymentIntentsIntentQuerySchema,
    t_GetPaymentIntentsIntentRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentIntentsIntentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsIntentResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntentsIntent = (
  params: Params<
    t_PostPaymentIntentsIntentParamSchema,
    void,
    t_PostPaymentIntentsIntentRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsIntentApplyCustomerBalanceResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntentsIntentApplyCustomerBalance = (
  params: Params<
    t_PostPaymentIntentsIntentApplyCustomerBalanceParamSchema,
    void,
    t_PostPaymentIntentsIntentApplyCustomerBalanceRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentApplyCustomerBalanceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsIntentCancelResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntentsIntentCancel = (
  params: Params<
    t_PostPaymentIntentsIntentCancelParamSchema,
    void,
    t_PostPaymentIntentsIntentCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsIntentCaptureResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntentsIntentCapture = (
  params: Params<
    t_PostPaymentIntentsIntentCaptureParamSchema,
    void,
    t_PostPaymentIntentsIntentCaptureRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentCaptureResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsIntentConfirmResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntentsIntentConfirm = (
  params: Params<
    t_PostPaymentIntentsIntentConfirmParamSchema,
    void,
    t_PostPaymentIntentsIntentConfirmRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentConfirmResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsIntentIncrementAuthorizationResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntentsIntentIncrementAuthorization = (
  params: Params<
    t_PostPaymentIntentsIntentIncrementAuthorizationParamSchema,
    void,
    t_PostPaymentIntentsIntentIncrementAuthorizationRequestBodySchema,
    void
  >,
  respond: PostPaymentIntentsIntentIncrementAuthorizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentIntentsIntentVerifyMicrodepositsResponder = {
  with200(): ExpressRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentIntentsIntentVerifyMicrodeposits = (
  params: Params<
    t_PostPaymentIntentsIntentVerifyMicrodepositsParamSchema,
    void,
    t_PostPaymentIntentsIntentVerifyMicrodepositsRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentVerifyMicrodepositsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentLinksResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payment_link[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentLinks = (
  params: Params<
    void,
    t_GetPaymentLinksQuerySchema,
    t_GetPaymentLinksRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentLinksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentLinksResponder = {
  with200(): ExpressRuntimeResponse<t_payment_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentLinks = (
  params: Params<void, void, t_PostPaymentLinksRequestBodySchema, void>,
  respond: PostPaymentLinksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentLinksPaymentLinkResponder = {
  with200(): ExpressRuntimeResponse<t_payment_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentLinksPaymentLink = (
  params: Params<
    t_GetPaymentLinksPaymentLinkParamSchema,
    t_GetPaymentLinksPaymentLinkQuerySchema,
    t_GetPaymentLinksPaymentLinkRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentLinksPaymentLinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentLinksPaymentLinkResponder = {
  with200(): ExpressRuntimeResponse<t_payment_link>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentLinksPaymentLink = (
  params: Params<
    t_PostPaymentLinksPaymentLinkParamSchema,
    void,
    t_PostPaymentLinksPaymentLinkRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentLinksPaymentLinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentLinksPaymentLinkLineItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentLinksPaymentLinkLineItems = (
  params: Params<
    t_GetPaymentLinksPaymentLinkLineItemsParamSchema,
    t_GetPaymentLinksPaymentLinkLineItemsQuerySchema,
    t_GetPaymentLinksPaymentLinkLineItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentLinksPaymentLinkLineItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentMethodConfigurationsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payment_method_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentMethodConfigurations = (
  params: Params<
    void,
    t_GetPaymentMethodConfigurationsQuerySchema,
    t_GetPaymentMethodConfigurationsRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodConfigurationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodConfigurationsResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodConfigurations = (
  params: Params<
    void,
    void,
    t_PostPaymentMethodConfigurationsRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodConfigurationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentMethodConfigurationsConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentMethodConfigurationsConfiguration = (
  params: Params<
    t_GetPaymentMethodConfigurationsConfigurationParamSchema,
    t_GetPaymentMethodConfigurationsConfigurationQuerySchema,
    t_GetPaymentMethodConfigurationsConfigurationRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodConfigurationsConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodConfigurationsConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodConfigurationsConfiguration = (
  params: Params<
    t_PostPaymentMethodConfigurationsConfigurationParamSchema,
    void,
    t_PostPaymentMethodConfigurationsConfigurationRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodConfigurationsConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentMethodDomainsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payment_method_domain[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentMethodDomains = (
  params: Params<
    void,
    t_GetPaymentMethodDomainsQuerySchema,
    t_GetPaymentMethodDomainsRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodDomainsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodDomainsResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodDomains = (
  params: Params<void, void, t_PostPaymentMethodDomainsRequestBodySchema, void>,
  respond: PostPaymentMethodDomainsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentMethodDomainsPaymentMethodDomainResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentMethodDomainsPaymentMethodDomain = (
  params: Params<
    t_GetPaymentMethodDomainsPaymentMethodDomainParamSchema,
    t_GetPaymentMethodDomainsPaymentMethodDomainQuerySchema,
    t_GetPaymentMethodDomainsPaymentMethodDomainRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodDomainsPaymentMethodDomainResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodDomainsPaymentMethodDomainResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodDomainsPaymentMethodDomain = (
  params: Params<
    t_PostPaymentMethodDomainsPaymentMethodDomainParamSchema,
    void,
    t_PostPaymentMethodDomainsPaymentMethodDomainRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodDomainsPaymentMethodDomainResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodDomainsPaymentMethodDomainValidateResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodDomainsPaymentMethodDomainValidate = (
  params: Params<
    t_PostPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
    void,
    | t_PostPaymentMethodDomainsPaymentMethodDomainValidateRequestBodySchema
    | undefined,
    void
  >,
  respond: PostPaymentMethodDomainsPaymentMethodDomainValidateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentMethodsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payment_method[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentMethods = (
  params: Params<
    void,
    t_GetPaymentMethodsQuerySchema,
    t_GetPaymentMethodsRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodsResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethods = (
  params: Params<
    void,
    void,
    t_PostPaymentMethodsRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPaymentMethodsPaymentMethodResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPaymentMethodsPaymentMethod = (
  params: Params<
    t_GetPaymentMethodsPaymentMethodParamSchema,
    t_GetPaymentMethodsPaymentMethodQuerySchema,
    t_GetPaymentMethodsPaymentMethodRequestBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodsPaymentMethodResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodsPaymentMethodResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodsPaymentMethod = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodsPaymentMethodResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodsPaymentMethodAttachResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodsPaymentMethodAttach = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodAttachParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodAttachRequestBodySchema,
    void
  >,
  respond: PostPaymentMethodsPaymentMethodAttachResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPaymentMethodsPaymentMethodDetachResponder = {
  with200(): ExpressRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPaymentMethodsPaymentMethodDetach = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodDetachParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodDetachRequestBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodsPaymentMethodDetachResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPayoutsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_payout[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPayouts = (
  params: Params<
    void,
    t_GetPayoutsQuerySchema,
    t_GetPayoutsRequestBodySchema | undefined,
    void
  >,
  respond: GetPayoutsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPayoutsResponder = {
  with200(): ExpressRuntimeResponse<t_payout>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPayouts = (
  params: Params<void, void, t_PostPayoutsRequestBodySchema, void>,
  respond: PostPayoutsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPayoutsPayoutResponder = {
  with200(): ExpressRuntimeResponse<t_payout>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPayoutsPayout = (
  params: Params<
    t_GetPayoutsPayoutParamSchema,
    t_GetPayoutsPayoutQuerySchema,
    t_GetPayoutsPayoutRequestBodySchema | undefined,
    void
  >,
  respond: GetPayoutsPayoutResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPayoutsPayoutResponder = {
  with200(): ExpressRuntimeResponse<t_payout>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPayoutsPayout = (
  params: Params<
    t_PostPayoutsPayoutParamSchema,
    void,
    t_PostPayoutsPayoutRequestBodySchema | undefined,
    void
  >,
  respond: PostPayoutsPayoutResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPayoutsPayoutCancelResponder = {
  with200(): ExpressRuntimeResponse<t_payout>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPayoutsPayoutCancel = (
  params: Params<
    t_PostPayoutsPayoutCancelParamSchema,
    void,
    t_PostPayoutsPayoutCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostPayoutsPayoutCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPayoutsPayoutReverseResponder = {
  with200(): ExpressRuntimeResponse<t_payout>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPayoutsPayoutReverse = (
  params: Params<
    t_PostPayoutsPayoutReverseParamSchema,
    void,
    t_PostPayoutsPayoutReverseRequestBodySchema | undefined,
    void
  >,
  respond: PostPayoutsPayoutReverseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPlansResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_plan[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPlans = (
  params: Params<
    void,
    t_GetPlansQuerySchema,
    t_GetPlansRequestBodySchema | undefined,
    void
  >,
  respond: GetPlansResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPlansResponder = {
  with200(): ExpressRuntimeResponse<t_plan>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPlans = (
  params: Params<void, void, t_PostPlansRequestBodySchema, void>,
  respond: PostPlansResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeletePlansPlanResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_plan>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeletePlansPlan = (
  params: Params<
    t_DeletePlansPlanParamSchema,
    void,
    t_DeletePlansPlanRequestBodySchema | undefined,
    void
  >,
  respond: DeletePlansPlanResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPlansPlanResponder = {
  with200(): ExpressRuntimeResponse<t_plan>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPlansPlan = (
  params: Params<
    t_GetPlansPlanParamSchema,
    t_GetPlansPlanQuerySchema,
    t_GetPlansPlanRequestBodySchema | undefined,
    void
  >,
  respond: GetPlansPlanResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPlansPlanResponder = {
  with200(): ExpressRuntimeResponse<t_plan>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPlansPlan = (
  params: Params<
    t_PostPlansPlanParamSchema,
    void,
    t_PostPlansPlanRequestBodySchema | undefined,
    void
  >,
  respond: PostPlansPlanResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPricesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_price[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPrices = (
  params: Params<
    void,
    t_GetPricesQuerySchema,
    t_GetPricesRequestBodySchema | undefined,
    void
  >,
  respond: GetPricesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPricesResponder = {
  with200(): ExpressRuntimeResponse<t_price>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPrices = (
  params: Params<void, void, t_PostPricesRequestBodySchema, void>,
  respond: PostPricesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPricesSearchResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_price[]
    has_more: boolean
    next_page?: (string | null) | undefined
    object: "search_result"
    total_count?: number | undefined
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPricesSearch = (
  params: Params<
    void,
    t_GetPricesSearchQuerySchema,
    t_GetPricesSearchRequestBodySchema | undefined,
    void
  >,
  respond: GetPricesSearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPricesPriceResponder = {
  with200(): ExpressRuntimeResponse<t_price>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPricesPrice = (
  params: Params<
    t_GetPricesPriceParamSchema,
    t_GetPricesPriceQuerySchema,
    t_GetPricesPriceRequestBodySchema | undefined,
    void
  >,
  respond: GetPricesPriceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPricesPriceResponder = {
  with200(): ExpressRuntimeResponse<t_price>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPricesPrice = (
  params: Params<
    t_PostPricesPriceParamSchema,
    void,
    t_PostPricesPriceRequestBodySchema | undefined,
    void
  >,
  respond: PostPricesPriceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetProductsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_product[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetProducts = (
  params: Params<
    void,
    t_GetProductsQuerySchema,
    t_GetProductsRequestBodySchema | undefined,
    void
  >,
  respond: GetProductsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostProductsResponder = {
  with200(): ExpressRuntimeResponse<t_product>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostProducts = (
  params: Params<void, void, t_PostProductsRequestBodySchema, void>,
  respond: PostProductsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetProductsSearchResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_product[]
    has_more: boolean
    next_page?: (string | null) | undefined
    object: "search_result"
    total_count?: number | undefined
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetProductsSearch = (
  params: Params<
    void,
    t_GetProductsSearchQuerySchema,
    t_GetProductsSearchRequestBodySchema | undefined,
    void
  >,
  respond: GetProductsSearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteProductsIdResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_product>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteProductsId = (
  params: Params<
    t_DeleteProductsIdParamSchema,
    void,
    t_DeleteProductsIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteProductsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetProductsIdResponder = {
  with200(): ExpressRuntimeResponse<t_product>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetProductsId = (
  params: Params<
    t_GetProductsIdParamSchema,
    t_GetProductsIdQuerySchema,
    t_GetProductsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetProductsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostProductsIdResponder = {
  with200(): ExpressRuntimeResponse<t_product>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostProductsId = (
  params: Params<
    t_PostProductsIdParamSchema,
    void,
    t_PostProductsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostProductsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetProductsProductFeaturesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_product_feature[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetProductsProductFeatures = (
  params: Params<
    t_GetProductsProductFeaturesParamSchema,
    t_GetProductsProductFeaturesQuerySchema,
    t_GetProductsProductFeaturesRequestBodySchema | undefined,
    void
  >,
  respond: GetProductsProductFeaturesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostProductsProductFeaturesResponder = {
  with200(): ExpressRuntimeResponse<t_product_feature>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostProductsProductFeatures = (
  params: Params<
    t_PostProductsProductFeaturesParamSchema,
    void,
    t_PostProductsProductFeaturesRequestBodySchema,
    void
  >,
  respond: PostProductsProductFeaturesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteProductsProductFeaturesIdResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_product_feature>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteProductsProductFeaturesId = (
  params: Params<
    t_DeleteProductsProductFeaturesIdParamSchema,
    void,
    t_DeleteProductsProductFeaturesIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteProductsProductFeaturesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetProductsProductFeaturesIdResponder = {
  with200(): ExpressRuntimeResponse<t_product_feature>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetProductsProductFeaturesId = (
  params: Params<
    t_GetProductsProductFeaturesIdParamSchema,
    t_GetProductsProductFeaturesIdQuerySchema,
    t_GetProductsProductFeaturesIdRequestBodySchema | undefined,
    void
  >,
  respond: GetProductsProductFeaturesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPromotionCodesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_promotion_code[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPromotionCodes = (
  params: Params<
    void,
    t_GetPromotionCodesQuerySchema,
    t_GetPromotionCodesRequestBodySchema | undefined,
    void
  >,
  respond: GetPromotionCodesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPromotionCodesResponder = {
  with200(): ExpressRuntimeResponse<t_promotion_code>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPromotionCodes = (
  params: Params<void, void, t_PostPromotionCodesRequestBodySchema, void>,
  respond: PostPromotionCodesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPromotionCodesPromotionCodeResponder = {
  with200(): ExpressRuntimeResponse<t_promotion_code>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetPromotionCodesPromotionCode = (
  params: Params<
    t_GetPromotionCodesPromotionCodeParamSchema,
    t_GetPromotionCodesPromotionCodeQuerySchema,
    t_GetPromotionCodesPromotionCodeRequestBodySchema | undefined,
    void
  >,
  respond: GetPromotionCodesPromotionCodeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostPromotionCodesPromotionCodeResponder = {
  with200(): ExpressRuntimeResponse<t_promotion_code>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostPromotionCodesPromotionCode = (
  params: Params<
    t_PostPromotionCodesPromotionCodeParamSchema,
    void,
    t_PostPromotionCodesPromotionCodeRequestBodySchema | undefined,
    void
  >,
  respond: PostPromotionCodesPromotionCodeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetQuotesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_quote[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetQuotes = (
  params: Params<
    void,
    t_GetQuotesQuerySchema,
    t_GetQuotesRequestBodySchema | undefined,
    void
  >,
  respond: GetQuotesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostQuotesResponder = {
  with200(): ExpressRuntimeResponse<t_quote>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostQuotes = (
  params: Params<void, void, t_PostQuotesRequestBodySchema | undefined, void>,
  respond: PostQuotesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetQuotesQuoteResponder = {
  with200(): ExpressRuntimeResponse<t_quote>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetQuotesQuote = (
  params: Params<
    t_GetQuotesQuoteParamSchema,
    t_GetQuotesQuoteQuerySchema,
    t_GetQuotesQuoteRequestBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuoteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostQuotesQuoteResponder = {
  with200(): ExpressRuntimeResponse<t_quote>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostQuotesQuote = (
  params: Params<
    t_PostQuotesQuoteParamSchema,
    void,
    t_PostQuotesQuoteRequestBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostQuotesQuoteAcceptResponder = {
  with200(): ExpressRuntimeResponse<t_quote>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostQuotesQuoteAccept = (
  params: Params<
    t_PostQuotesQuoteAcceptParamSchema,
    void,
    t_PostQuotesQuoteAcceptRequestBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteAcceptResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostQuotesQuoteCancelResponder = {
  with200(): ExpressRuntimeResponse<t_quote>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostQuotesQuoteCancel = (
  params: Params<
    t_PostQuotesQuoteCancelParamSchema,
    void,
    t_PostQuotesQuoteCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetQuotesQuoteComputedUpfrontLineItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetQuotesQuoteComputedUpfrontLineItems = (
  params: Params<
    t_GetQuotesQuoteComputedUpfrontLineItemsParamSchema,
    t_GetQuotesQuoteComputedUpfrontLineItemsQuerySchema,
    t_GetQuotesQuoteComputedUpfrontLineItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuoteComputedUpfrontLineItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostQuotesQuoteFinalizeResponder = {
  with200(): ExpressRuntimeResponse<t_quote>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostQuotesQuoteFinalize = (
  params: Params<
    t_PostQuotesQuoteFinalizeParamSchema,
    void,
    t_PostQuotesQuoteFinalizeRequestBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteFinalizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetQuotesQuoteLineItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetQuotesQuoteLineItems = (
  params: Params<
    t_GetQuotesQuoteLineItemsParamSchema,
    t_GetQuotesQuoteLineItemsQuerySchema,
    t_GetQuotesQuoteLineItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuoteLineItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetQuotesQuotePdfResponder = {
  with200(): ExpressRuntimeResponse<string>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetQuotesQuotePdf = (
  params: Params<
    t_GetQuotesQuotePdfParamSchema,
    t_GetQuotesQuotePdfQuerySchema,
    t_GetQuotesQuotePdfRequestBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuotePdfResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRadarEarlyFraudWarningsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_radar_early_fraud_warning[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRadarEarlyFraudWarnings = (
  params: Params<
    void,
    t_GetRadarEarlyFraudWarningsQuerySchema,
    t_GetRadarEarlyFraudWarningsRequestBodySchema | undefined,
    void
  >,
  respond: GetRadarEarlyFraudWarningsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRadarEarlyFraudWarningsEarlyFraudWarningResponder = {
  with200(): ExpressRuntimeResponse<t_radar_early_fraud_warning>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRadarEarlyFraudWarningsEarlyFraudWarning = (
  params: Params<
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningRequestBodySchema | undefined,
    void
  >,
  respond: GetRadarEarlyFraudWarningsEarlyFraudWarningResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRadarValueListItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_radar_value_list_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRadarValueListItems = (
  params: Params<
    void,
    t_GetRadarValueListItemsQuerySchema,
    t_GetRadarValueListItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostRadarValueListItemsResponder = {
  with200(): ExpressRuntimeResponse<t_radar_value_list_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostRadarValueListItems = (
  params: Params<void, void, t_PostRadarValueListItemsRequestBodySchema, void>,
  respond: PostRadarValueListItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteRadarValueListItemsItemResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_radar_value_list_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteRadarValueListItemsItem = (
  params: Params<
    t_DeleteRadarValueListItemsItemParamSchema,
    void,
    t_DeleteRadarValueListItemsItemRequestBodySchema | undefined,
    void
  >,
  respond: DeleteRadarValueListItemsItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRadarValueListItemsItemResponder = {
  with200(): ExpressRuntimeResponse<t_radar_value_list_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRadarValueListItemsItem = (
  params: Params<
    t_GetRadarValueListItemsItemParamSchema,
    t_GetRadarValueListItemsItemQuerySchema,
    t_GetRadarValueListItemsItemRequestBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListItemsItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRadarValueListsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_radar_value_list[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRadarValueLists = (
  params: Params<
    void,
    t_GetRadarValueListsQuerySchema,
    t_GetRadarValueListsRequestBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostRadarValueListsResponder = {
  with200(): ExpressRuntimeResponse<t_radar_value_list>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostRadarValueLists = (
  params: Params<void, void, t_PostRadarValueListsRequestBodySchema, void>,
  respond: PostRadarValueListsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteRadarValueListsValueListResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_radar_value_list>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteRadarValueListsValueList = (
  params: Params<
    t_DeleteRadarValueListsValueListParamSchema,
    void,
    t_DeleteRadarValueListsValueListRequestBodySchema | undefined,
    void
  >,
  respond: DeleteRadarValueListsValueListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRadarValueListsValueListResponder = {
  with200(): ExpressRuntimeResponse<t_radar_value_list>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRadarValueListsValueList = (
  params: Params<
    t_GetRadarValueListsValueListParamSchema,
    t_GetRadarValueListsValueListQuerySchema,
    t_GetRadarValueListsValueListRequestBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListsValueListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostRadarValueListsValueListResponder = {
  with200(): ExpressRuntimeResponse<t_radar_value_list>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostRadarValueListsValueList = (
  params: Params<
    t_PostRadarValueListsValueListParamSchema,
    void,
    t_PostRadarValueListsValueListRequestBodySchema | undefined,
    void
  >,
  respond: PostRadarValueListsValueListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRefundsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRefunds = (
  params: Params<
    void,
    t_GetRefundsQuerySchema,
    t_GetRefundsRequestBodySchema | undefined,
    void
  >,
  respond: GetRefundsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostRefundsResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostRefunds = (
  params: Params<void, void, t_PostRefundsRequestBodySchema | undefined, void>,
  respond: PostRefundsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRefundsRefundResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetRefundsRefund = (
  params: Params<
    t_GetRefundsRefundParamSchema,
    t_GetRefundsRefundQuerySchema,
    t_GetRefundsRefundRequestBodySchema | undefined,
    void
  >,
  respond: GetRefundsRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostRefundsRefundResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostRefundsRefund = (
  params: Params<
    t_PostRefundsRefundParamSchema,
    void,
    t_PostRefundsRefundRequestBodySchema | undefined,
    void
  >,
  respond: PostRefundsRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostRefundsRefundCancelResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostRefundsRefundCancel = (
  params: Params<
    t_PostRefundsRefundCancelParamSchema,
    void,
    t_PostRefundsRefundCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostRefundsRefundCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetReportingReportRunsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_reporting_report_run[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetReportingReportRuns = (
  params: Params<
    void,
    t_GetReportingReportRunsQuerySchema,
    t_GetReportingReportRunsRequestBodySchema | undefined,
    void
  >,
  respond: GetReportingReportRunsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostReportingReportRunsResponder = {
  with200(): ExpressRuntimeResponse<t_reporting_report_run>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostReportingReportRuns = (
  params: Params<void, void, t_PostReportingReportRunsRequestBodySchema, void>,
  respond: PostReportingReportRunsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetReportingReportRunsReportRunResponder = {
  with200(): ExpressRuntimeResponse<t_reporting_report_run>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetReportingReportRunsReportRun = (
  params: Params<
    t_GetReportingReportRunsReportRunParamSchema,
    t_GetReportingReportRunsReportRunQuerySchema,
    t_GetReportingReportRunsReportRunRequestBodySchema | undefined,
    void
  >,
  respond: GetReportingReportRunsReportRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetReportingReportTypesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_reporting_report_type[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetReportingReportTypes = (
  params: Params<
    void,
    t_GetReportingReportTypesQuerySchema,
    t_GetReportingReportTypesRequestBodySchema | undefined,
    void
  >,
  respond: GetReportingReportTypesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetReportingReportTypesReportTypeResponder = {
  with200(): ExpressRuntimeResponse<t_reporting_report_type>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetReportingReportTypesReportType = (
  params: Params<
    t_GetReportingReportTypesReportTypeParamSchema,
    t_GetReportingReportTypesReportTypeQuerySchema,
    t_GetReportingReportTypesReportTypeRequestBodySchema | undefined,
    void
  >,
  respond: GetReportingReportTypesReportTypeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetReviewsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_review[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetReviews = (
  params: Params<
    void,
    t_GetReviewsQuerySchema,
    t_GetReviewsRequestBodySchema | undefined,
    void
  >,
  respond: GetReviewsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetReviewsReviewResponder = {
  with200(): ExpressRuntimeResponse<t_review>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetReviewsReview = (
  params: Params<
    t_GetReviewsReviewParamSchema,
    t_GetReviewsReviewQuerySchema,
    t_GetReviewsReviewRequestBodySchema | undefined,
    void
  >,
  respond: GetReviewsReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostReviewsReviewApproveResponder = {
  with200(): ExpressRuntimeResponse<t_review>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostReviewsReviewApprove = (
  params: Params<
    t_PostReviewsReviewApproveParamSchema,
    void,
    t_PostReviewsReviewApproveRequestBodySchema | undefined,
    void
  >,
  respond: PostReviewsReviewApproveResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSetupAttemptsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_setup_attempt[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSetupAttempts = (
  params: Params<
    void,
    t_GetSetupAttemptsQuerySchema,
    t_GetSetupAttemptsRequestBodySchema | undefined,
    void
  >,
  respond: GetSetupAttemptsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSetupIntentsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_setup_intent[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSetupIntents = (
  params: Params<
    void,
    t_GetSetupIntentsQuerySchema,
    t_GetSetupIntentsRequestBodySchema | undefined,
    void
  >,
  respond: GetSetupIntentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSetupIntentsResponder = {
  with200(): ExpressRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSetupIntents = (
  params: Params<
    void,
    void,
    t_PostSetupIntentsRequestBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSetupIntentsIntentResponder = {
  with200(): ExpressRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSetupIntentsIntent = (
  params: Params<
    t_GetSetupIntentsIntentParamSchema,
    t_GetSetupIntentsIntentQuerySchema,
    t_GetSetupIntentsIntentRequestBodySchema | undefined,
    void
  >,
  respond: GetSetupIntentsIntentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSetupIntentsIntentResponder = {
  with200(): ExpressRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSetupIntentsIntent = (
  params: Params<
    t_PostSetupIntentsIntentParamSchema,
    void,
    t_PostSetupIntentsIntentRequestBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSetupIntentsIntentCancelResponder = {
  with200(): ExpressRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSetupIntentsIntentCancel = (
  params: Params<
    t_PostSetupIntentsIntentCancelParamSchema,
    void,
    t_PostSetupIntentsIntentCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSetupIntentsIntentConfirmResponder = {
  with200(): ExpressRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSetupIntentsIntentConfirm = (
  params: Params<
    t_PostSetupIntentsIntentConfirmParamSchema,
    void,
    t_PostSetupIntentsIntentConfirmRequestBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentConfirmResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSetupIntentsIntentVerifyMicrodepositsResponder = {
  with200(): ExpressRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSetupIntentsIntentVerifyMicrodeposits = (
  params: Params<
    t_PostSetupIntentsIntentVerifyMicrodepositsParamSchema,
    void,
    t_PostSetupIntentsIntentVerifyMicrodepositsRequestBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentVerifyMicrodepositsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetShippingRatesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_shipping_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetShippingRates = (
  params: Params<
    void,
    t_GetShippingRatesQuerySchema,
    t_GetShippingRatesRequestBodySchema | undefined,
    void
  >,
  respond: GetShippingRatesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostShippingRatesResponder = {
  with200(): ExpressRuntimeResponse<t_shipping_rate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostShippingRates = (
  params: Params<void, void, t_PostShippingRatesRequestBodySchema, void>,
  respond: PostShippingRatesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetShippingRatesShippingRateTokenResponder = {
  with200(): ExpressRuntimeResponse<t_shipping_rate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetShippingRatesShippingRateToken = (
  params: Params<
    t_GetShippingRatesShippingRateTokenParamSchema,
    t_GetShippingRatesShippingRateTokenQuerySchema,
    t_GetShippingRatesShippingRateTokenRequestBodySchema | undefined,
    void
  >,
  respond: GetShippingRatesShippingRateTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostShippingRatesShippingRateTokenResponder = {
  with200(): ExpressRuntimeResponse<t_shipping_rate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostShippingRatesShippingRateToken = (
  params: Params<
    t_PostShippingRatesShippingRateTokenParamSchema,
    void,
    t_PostShippingRatesShippingRateTokenRequestBodySchema | undefined,
    void
  >,
  respond: PostShippingRatesShippingRateTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSigmaSavedQueriesIdResponder = {
  with200(): ExpressRuntimeResponse<t_sigma_sigma_api_query>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSigmaSavedQueriesId = (
  params: Params<
    t_PostSigmaSavedQueriesIdParamSchema,
    void,
    t_PostSigmaSavedQueriesIdRequestBodySchema | undefined,
    void
  >,
  respond: PostSigmaSavedQueriesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSigmaScheduledQueryRunsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_scheduled_query_run[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSigmaScheduledQueryRuns = (
  params: Params<
    void,
    t_GetSigmaScheduledQueryRunsQuerySchema,
    t_GetSigmaScheduledQueryRunsRequestBodySchema | undefined,
    void
  >,
  respond: GetSigmaScheduledQueryRunsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSigmaScheduledQueryRunsScheduledQueryRunResponder = {
  with200(): ExpressRuntimeResponse<t_scheduled_query_run>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSigmaScheduledQueryRunsScheduledQueryRun = (
  params: Params<
    t_GetSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
    t_GetSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
    t_GetSigmaScheduledQueryRunsScheduledQueryRunRequestBodySchema | undefined,
    void
  >,
  respond: GetSigmaScheduledQueryRunsScheduledQueryRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSourcesResponder = {
  with200(): ExpressRuntimeResponse<t_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSources = (
  params: Params<void, void, t_PostSourcesRequestBodySchema | undefined, void>,
  respond: PostSourcesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSourcesSourceResponder = {
  with200(): ExpressRuntimeResponse<t_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSourcesSource = (
  params: Params<
    t_GetSourcesSourceParamSchema,
    t_GetSourcesSourceQuerySchema,
    t_GetSourcesSourceRequestBodySchema | undefined,
    void
  >,
  respond: GetSourcesSourceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSourcesSourceResponder = {
  with200(): ExpressRuntimeResponse<t_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSourcesSource = (
  params: Params<
    t_PostSourcesSourceParamSchema,
    void,
    t_PostSourcesSourceRequestBodySchema | undefined,
    void
  >,
  respond: PostSourcesSourceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSourcesSourceMandateNotificationsMandateNotificationResponder = {
  with200(): ExpressRuntimeResponse<t_source_mandate_notification>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSourcesSourceMandateNotificationsMandateNotification = (
  params: Params<
    t_GetSourcesSourceMandateNotificationsMandateNotificationParamSchema,
    t_GetSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
    | t_GetSourcesSourceMandateNotificationsMandateNotificationRequestBodySchema
    | undefined,
    void
  >,
  respond: GetSourcesSourceMandateNotificationsMandateNotificationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSourcesSourceSourceTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_source_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSourcesSourceSourceTransactions = (
  params: Params<
    t_GetSourcesSourceSourceTransactionsParamSchema,
    t_GetSourcesSourceSourceTransactionsQuerySchema,
    t_GetSourcesSourceSourceTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetSourcesSourceSourceTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSourcesSourceSourceTransactionsSourceTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_source_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSourcesSourceSourceTransactionsSourceTransaction = (
  params: Params<
    t_GetSourcesSourceSourceTransactionsSourceTransactionParamSchema,
    t_GetSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
    | t_GetSourcesSourceSourceTransactionsSourceTransactionRequestBodySchema
    | undefined,
    void
  >,
  respond: GetSourcesSourceSourceTransactionsSourceTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSourcesSourceVerifyResponder = {
  with200(): ExpressRuntimeResponse<t_source>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSourcesSourceVerify = (
  params: Params<
    t_PostSourcesSourceVerifyParamSchema,
    void,
    t_PostSourcesSourceVerifyRequestBodySchema,
    void
  >,
  respond: PostSourcesSourceVerifyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSubscriptionItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_subscription_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSubscriptionItems = (
  params: Params<
    void,
    t_GetSubscriptionItemsQuerySchema,
    t_GetSubscriptionItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionItemsResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionItems = (
  params: Params<void, void, t_PostSubscriptionItemsRequestBodySchema, void>,
  respond: PostSubscriptionItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteSubscriptionItemsItemResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_subscription_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteSubscriptionItemsItem = (
  params: Params<
    t_DeleteSubscriptionItemsItemParamSchema,
    void,
    t_DeleteSubscriptionItemsItemRequestBodySchema | undefined,
    void
  >,
  respond: DeleteSubscriptionItemsItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSubscriptionItemsItemResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSubscriptionItemsItem = (
  params: Params<
    t_GetSubscriptionItemsItemParamSchema,
    t_GetSubscriptionItemsItemQuerySchema,
    t_GetSubscriptionItemsItemRequestBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionItemsItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionItemsItemResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_item>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionItemsItem = (
  params: Params<
    t_PostSubscriptionItemsItemParamSchema,
    void,
    t_PostSubscriptionItemsItemRequestBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionItemsItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSubscriptionSchedulesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_subscription_schedule[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSubscriptionSchedules = (
  params: Params<
    void,
    t_GetSubscriptionSchedulesQuerySchema,
    t_GetSubscriptionSchedulesRequestBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionSchedulesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionSchedulesResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionSchedules = (
  params: Params<
    void,
    void,
    t_PostSubscriptionSchedulesRequestBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSubscriptionSchedulesScheduleResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSubscriptionSchedulesSchedule = (
  params: Params<
    t_GetSubscriptionSchedulesScheduleParamSchema,
    t_GetSubscriptionSchedulesScheduleQuerySchema,
    t_GetSubscriptionSchedulesScheduleRequestBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionSchedulesScheduleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionSchedulesScheduleResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionSchedulesSchedule = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleRequestBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesScheduleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionSchedulesScheduleCancelResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionSchedulesScheduleCancel = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleCancelParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesScheduleCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionSchedulesScheduleReleaseResponder = {
  with200(): ExpressRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionSchedulesScheduleRelease = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleReleaseParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleReleaseRequestBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesScheduleReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSubscriptionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_subscription[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSubscriptions = (
  params: Params<
    void,
    t_GetSubscriptionsQuerySchema,
    t_GetSubscriptionsRequestBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionsResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptions = (
  params: Params<void, void, t_PostSubscriptionsRequestBodySchema, void>,
  respond: PostSubscriptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSubscriptionsSearchResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_subscription[]
    has_more: boolean
    next_page?: (string | null) | undefined
    object: "search_result"
    total_count?: number | undefined
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSubscriptionsSearch = (
  params: Params<
    void,
    t_GetSubscriptionsSearchQuerySchema,
    t_GetSubscriptionsSearchRequestBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionsSearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteSubscriptionsSubscriptionExposedIdResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_DeleteSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    t_DeleteSubscriptionsSubscriptionExposedIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteSubscriptionsSubscriptionExposedIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetSubscriptionsSubscriptionExposedIdResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_GetSubscriptionsSubscriptionExposedIdParamSchema,
    t_GetSubscriptionsSubscriptionExposedIdQuerySchema,
    t_GetSubscriptionsSubscriptionExposedIdRequestBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionsSubscriptionExposedIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionsSubscriptionExposedIdResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_PostSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    t_PostSubscriptionsSubscriptionExposedIdRequestBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionsSubscriptionExposedIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteSubscriptionsSubscriptionExposedIdDiscountResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_discount>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteSubscriptionsSubscriptionExposedIdDiscount = (
  params: Params<
    t_DeleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
    void,
    | t_DeleteSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema
    | undefined,
    void
  >,
  respond: DeleteSubscriptionsSubscriptionExposedIdDiscountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionsSubscriptionMigrateResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionsSubscriptionMigrate = (
  params: Params<
    t_PostSubscriptionsSubscriptionMigrateParamSchema,
    void,
    t_PostSubscriptionsSubscriptionMigrateRequestBodySchema,
    void
  >,
  respond: PostSubscriptionsSubscriptionMigrateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostSubscriptionsSubscriptionResumeResponder = {
  with200(): ExpressRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostSubscriptionsSubscriptionResume = (
  params: Params<
    t_PostSubscriptionsSubscriptionResumeParamSchema,
    void,
    t_PostSubscriptionsSubscriptionResumeRequestBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionsSubscriptionResumeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxCalculationsResponder = {
  with200(): ExpressRuntimeResponse<t_tax_calculation>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxCalculations = (
  params: Params<void, void, t_PostTaxCalculationsRequestBodySchema, void>,
  respond: PostTaxCalculationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxCalculationsCalculationResponder = {
  with200(): ExpressRuntimeResponse<t_tax_calculation>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxCalculationsCalculation = (
  params: Params<
    t_GetTaxCalculationsCalculationParamSchema,
    t_GetTaxCalculationsCalculationQuerySchema,
    t_GetTaxCalculationsCalculationRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxCalculationsCalculationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxCalculationsCalculationLineItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_tax_calculation_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxCalculationsCalculationLineItems = (
  params: Params<
    t_GetTaxCalculationsCalculationLineItemsParamSchema,
    t_GetTaxCalculationsCalculationLineItemsQuerySchema,
    t_GetTaxCalculationsCalculationLineItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxCalculationsCalculationLineItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxRegistrationsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_tax_registration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxRegistrations = (
  params: Params<
    void,
    t_GetTaxRegistrationsQuerySchema,
    t_GetTaxRegistrationsRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxRegistrationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxRegistrationsResponder = {
  with200(): ExpressRuntimeResponse<t_tax_registration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxRegistrations = (
  params: Params<void, void, t_PostTaxRegistrationsRequestBodySchema, void>,
  respond: PostTaxRegistrationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxRegistrationsIdResponder = {
  with200(): ExpressRuntimeResponse<t_tax_registration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxRegistrationsId = (
  params: Params<
    t_GetTaxRegistrationsIdParamSchema,
    t_GetTaxRegistrationsIdQuerySchema,
    t_GetTaxRegistrationsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxRegistrationsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxRegistrationsIdResponder = {
  with200(): ExpressRuntimeResponse<t_tax_registration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxRegistrationsId = (
  params: Params<
    t_PostTaxRegistrationsIdParamSchema,
    void,
    t_PostTaxRegistrationsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostTaxRegistrationsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxSettingsResponder = {
  with200(): ExpressRuntimeResponse<t_tax_settings>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxSettings = (
  params: Params<
    void,
    t_GetTaxSettingsQuerySchema,
    t_GetTaxSettingsRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxSettingsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxSettingsResponder = {
  with200(): ExpressRuntimeResponse<t_tax_settings>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxSettings = (
  params: Params<
    void,
    void,
    t_PostTaxSettingsRequestBodySchema | undefined,
    void
  >,
  respond: PostTaxSettingsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxTransactionsCreateFromCalculationResponder = {
  with200(): ExpressRuntimeResponse<t_tax_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxTransactionsCreateFromCalculation = (
  params: Params<
    void,
    void,
    t_PostTaxTransactionsCreateFromCalculationRequestBodySchema,
    void
  >,
  respond: PostTaxTransactionsCreateFromCalculationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxTransactionsCreateReversalResponder = {
  with200(): ExpressRuntimeResponse<t_tax_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxTransactionsCreateReversal = (
  params: Params<
    void,
    void,
    t_PostTaxTransactionsCreateReversalRequestBodySchema,
    void
  >,
  respond: PostTaxTransactionsCreateReversalResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxTransactionsTransactionResponder = {
  with200(): ExpressRuntimeResponse<t_tax_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxTransactionsTransaction = (
  params: Params<
    t_GetTaxTransactionsTransactionParamSchema,
    t_GetTaxTransactionsTransactionQuerySchema,
    t_GetTaxTransactionsTransactionRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxTransactionsTransactionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxTransactionsTransactionLineItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_tax_transaction_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxTransactionsTransactionLineItems = (
  params: Params<
    t_GetTaxTransactionsTransactionLineItemsParamSchema,
    t_GetTaxTransactionsTransactionLineItemsQuerySchema,
    t_GetTaxTransactionsTransactionLineItemsRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxTransactionsTransactionLineItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxCodesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_tax_code[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxCodes = (
  params: Params<
    void,
    t_GetTaxCodesQuerySchema,
    t_GetTaxCodesRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxCodesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxCodesIdResponder = {
  with200(): ExpressRuntimeResponse<t_tax_code>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxCodesId = (
  params: Params<
    t_GetTaxCodesIdParamSchema,
    t_GetTaxCodesIdQuerySchema,
    t_GetTaxCodesIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxCodesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxIdsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_tax_id[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxIds = (
  params: Params<
    void,
    t_GetTaxIdsQuerySchema,
    t_GetTaxIdsRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxIdsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxIdsResponder = {
  with200(): ExpressRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxIds = (
  params: Params<void, void, t_PostTaxIdsRequestBodySchema, void>,
  respond: PostTaxIdsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteTaxIdsIdResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_tax_id>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteTaxIdsId = (
  params: Params<
    t_DeleteTaxIdsIdParamSchema,
    void,
    t_DeleteTaxIdsIdRequestBodySchema | undefined,
    void
  >,
  respond: DeleteTaxIdsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxIdsIdResponder = {
  with200(): ExpressRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxIdsId = (
  params: Params<
    t_GetTaxIdsIdParamSchema,
    t_GetTaxIdsIdQuerySchema,
    t_GetTaxIdsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxIdsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxRatesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_tax_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxRates = (
  params: Params<
    void,
    t_GetTaxRatesQuerySchema,
    t_GetTaxRatesRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxRatesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxRatesResponder = {
  with200(): ExpressRuntimeResponse<t_tax_rate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxRates = (
  params: Params<void, void, t_PostTaxRatesRequestBodySchema, void>,
  respond: PostTaxRatesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTaxRatesTaxRateResponder = {
  with200(): ExpressRuntimeResponse<t_tax_rate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTaxRatesTaxRate = (
  params: Params<
    t_GetTaxRatesTaxRateParamSchema,
    t_GetTaxRatesTaxRateQuerySchema,
    t_GetTaxRatesTaxRateRequestBodySchema | undefined,
    void
  >,
  respond: GetTaxRatesTaxRateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTaxRatesTaxRateResponder = {
  with200(): ExpressRuntimeResponse<t_tax_rate>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTaxRatesTaxRate = (
  params: Params<
    t_PostTaxRatesTaxRateParamSchema,
    void,
    t_PostTaxRatesTaxRateRequestBodySchema | undefined,
    void
  >,
  respond: PostTaxRatesTaxRateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTerminalConfigurationsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_terminal_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTerminalConfigurations = (
  params: Params<
    void,
    t_GetTerminalConfigurationsQuerySchema,
    t_GetTerminalConfigurationsRequestBodySchema | undefined,
    void
  >,
  respond: GetTerminalConfigurationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalConfigurationsResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalConfigurations = (
  params: Params<
    void,
    void,
    t_PostTerminalConfigurationsRequestBodySchema | undefined,
    void
  >,
  respond: PostTerminalConfigurationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteTerminalConfigurationsConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_terminal_configuration>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteTerminalConfigurationsConfiguration = (
  params: Params<
    t_DeleteTerminalConfigurationsConfigurationParamSchema,
    void,
    t_DeleteTerminalConfigurationsConfigurationRequestBodySchema | undefined,
    void
  >,
  respond: DeleteTerminalConfigurationsConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTerminalConfigurationsConfigurationResponder = {
  with200(): ExpressRuntimeResponse<
    t_terminal_configuration | t_deleted_terminal_configuration
  >
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTerminalConfigurationsConfiguration = (
  params: Params<
    t_GetTerminalConfigurationsConfigurationParamSchema,
    t_GetTerminalConfigurationsConfigurationQuerySchema,
    t_GetTerminalConfigurationsConfigurationRequestBodySchema | undefined,
    void
  >,
  respond: GetTerminalConfigurationsConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalConfigurationsConfigurationResponder = {
  with200(): ExpressRuntimeResponse<
    t_terminal_configuration | t_deleted_terminal_configuration
  >
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalConfigurationsConfiguration = (
  params: Params<
    t_PostTerminalConfigurationsConfigurationParamSchema,
    void,
    t_PostTerminalConfigurationsConfigurationRequestBodySchema | undefined,
    void
  >,
  respond: PostTerminalConfigurationsConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalConnectionTokensResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_connection_token>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalConnectionTokens = (
  params: Params<
    void,
    void,
    t_PostTerminalConnectionTokensRequestBodySchema | undefined,
    void
  >,
  respond: PostTerminalConnectionTokensResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTerminalLocationsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_terminal_location[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTerminalLocations = (
  params: Params<
    void,
    t_GetTerminalLocationsQuerySchema,
    t_GetTerminalLocationsRequestBodySchema | undefined,
    void
  >,
  respond: GetTerminalLocationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalLocationsResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_location>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalLocations = (
  params: Params<void, void, t_PostTerminalLocationsRequestBodySchema, void>,
  respond: PostTerminalLocationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteTerminalLocationsLocationResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_terminal_location>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteTerminalLocationsLocation = (
  params: Params<
    t_DeleteTerminalLocationsLocationParamSchema,
    void,
    t_DeleteTerminalLocationsLocationRequestBodySchema | undefined,
    void
  >,
  respond: DeleteTerminalLocationsLocationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTerminalLocationsLocationResponder = {
  with200(): ExpressRuntimeResponse<
    t_terminal_location | t_deleted_terminal_location
  >
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTerminalLocationsLocation = (
  params: Params<
    t_GetTerminalLocationsLocationParamSchema,
    t_GetTerminalLocationsLocationQuerySchema,
    t_GetTerminalLocationsLocationRequestBodySchema | undefined,
    void
  >,
  respond: GetTerminalLocationsLocationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalLocationsLocationResponder = {
  with200(): ExpressRuntimeResponse<
    t_terminal_location | t_deleted_terminal_location
  >
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalLocationsLocation = (
  params: Params<
    t_PostTerminalLocationsLocationParamSchema,
    void,
    t_PostTerminalLocationsLocationRequestBodySchema | undefined,
    void
  >,
  respond: PostTerminalLocationsLocationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTerminalReadersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_terminal_reader[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTerminalReaders = (
  params: Params<
    void,
    t_GetTerminalReadersQuerySchema,
    t_GetTerminalReadersRequestBodySchema | undefined,
    void
  >,
  respond: GetTerminalReadersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReaders = (
  params: Params<void, void, t_PostTerminalReadersRequestBodySchema, void>,
  respond: PostTerminalReadersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteTerminalReadersReaderResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteTerminalReadersReader = (
  params: Params<
    t_DeleteTerminalReadersReaderParamSchema,
    void,
    t_DeleteTerminalReadersReaderRequestBodySchema | undefined,
    void
  >,
  respond: DeleteTerminalReadersReaderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTerminalReadersReaderResponder = {
  with200(): ExpressRuntimeResponse<
    t_terminal_reader | t_deleted_terminal_reader
  >
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTerminalReadersReader = (
  params: Params<
    t_GetTerminalReadersReaderParamSchema,
    t_GetTerminalReadersReaderQuerySchema,
    t_GetTerminalReadersReaderRequestBodySchema | undefined,
    void
  >,
  respond: GetTerminalReadersReaderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderResponder = {
  with200(): ExpressRuntimeResponse<
    t_terminal_reader | t_deleted_terminal_reader
  >
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReader = (
  params: Params<
    t_PostTerminalReadersReaderParamSchema,
    void,
    t_PostTerminalReadersReaderRequestBodySchema | undefined,
    void
  >,
  respond: PostTerminalReadersReaderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderCancelActionResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderCancelAction = (
  params: Params<
    t_PostTerminalReadersReaderCancelActionParamSchema,
    void,
    t_PostTerminalReadersReaderCancelActionRequestBodySchema | undefined,
    void
  >,
  respond: PostTerminalReadersReaderCancelActionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderCollectInputsResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderCollectInputs = (
  params: Params<
    t_PostTerminalReadersReaderCollectInputsParamSchema,
    void,
    t_PostTerminalReadersReaderCollectInputsRequestBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderCollectInputsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderCollectPaymentMethodResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderCollectPaymentMethod = (
  params: Params<
    t_PostTerminalReadersReaderCollectPaymentMethodParamSchema,
    void,
    t_PostTerminalReadersReaderCollectPaymentMethodRequestBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderCollectPaymentMethodResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderConfirmPaymentIntentResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderConfirmPaymentIntent = (
  params: Params<
    t_PostTerminalReadersReaderConfirmPaymentIntentParamSchema,
    void,
    t_PostTerminalReadersReaderConfirmPaymentIntentRequestBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderConfirmPaymentIntentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderProcessPaymentIntentResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderProcessPaymentIntent = (
  params: Params<
    t_PostTerminalReadersReaderProcessPaymentIntentParamSchema,
    void,
    t_PostTerminalReadersReaderProcessPaymentIntentRequestBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderProcessPaymentIntentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderProcessSetupIntentResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderProcessSetupIntent = (
  params: Params<
    t_PostTerminalReadersReaderProcessSetupIntentParamSchema,
    void,
    t_PostTerminalReadersReaderProcessSetupIntentRequestBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderProcessSetupIntentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderRefundPaymentResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderRefundPayment = (
  params: Params<
    t_PostTerminalReadersReaderRefundPaymentParamSchema,
    void,
    t_PostTerminalReadersReaderRefundPaymentRequestBodySchema | undefined,
    void
  >,
  respond: PostTerminalReadersReaderRefundPaymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTerminalReadersReaderSetReaderDisplayResponder = {
  with200(): ExpressRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTerminalReadersReaderSetReaderDisplay = (
  params: Params<
    t_PostTerminalReadersReaderSetReaderDisplayParamSchema,
    void,
    t_PostTerminalReadersReaderSetReaderDisplayRequestBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderSetReaderDisplayResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersConfirmationTokensResponder = {
  with200(): ExpressRuntimeResponse<t_confirmation_token>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersConfirmationTokens = (
  params: Params<
    void,
    void,
    t_PostTestHelpersConfirmationTokensRequestBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersConfirmationTokensResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersCustomersCustomerFundCashBalanceResponder = {
  with200(): ExpressRuntimeResponse<t_customer_cash_balance_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersCustomersCustomerFundCashBalance = (
  params: Params<
    t_PostTestHelpersCustomersCustomerFundCashBalanceParamSchema,
    void,
    t_PostTestHelpersCustomersCustomerFundCashBalanceRequestBodySchema,
    void
  >,
  respond: PostTestHelpersCustomersCustomerFundCashBalanceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingAuthorizationsResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingAuthorizations = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingAuthorizationsRequestBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingAuthorizationsAuthorizationCaptureResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationCapture = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationCaptureResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingAuthorizationsAuthorizationExpireResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationExpire = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationExpireResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
    void,
    t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountRequestBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond =
  (
    params: Params<
      t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
      void,
      t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondRequestBodySchema,
      void
    >,
    respond: PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponder,
    req: Request,
    res: Response,
    next: NextFunction,
  ) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingAuthorizationsAuthorizationIncrementResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationIncrement = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
    void,
    t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementRequestBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationIncrementResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingAuthorizationsAuthorizationReverseResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationReverse = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationReverseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingCardsCardShippingDeliverResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingDeliver = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingDeliverParamSchema,
    void,
    | t_PostTestHelpersIssuingCardsCardShippingDeliverRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingDeliverResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingCardsCardShippingFailResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingFail = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingFailParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingFailRequestBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingFailResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingCardsCardShippingReturnResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingReturn = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingReturnParamSchema,
    void,
    | t_PostTestHelpersIssuingCardsCardShippingReturnRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingReturnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingCardsCardShippingShipResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingShip = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingShipParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingShipRequestBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingShipResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingCardsCardShippingSubmitResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingSubmit = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingSubmitParamSchema,
    void,
    | t_PostTestHelpersIssuingCardsCardShippingSubmitRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingSubmitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_personalization_design>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
      void,
      | t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateRequestBodySchema
      | undefined,
      void
    >,
    respond: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponder,
    req: Request,
    res: Response,
    next: NextFunction,
  ) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_personalization_design>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
      void,
      | t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateRequestBodySchema
      | undefined,
      void
    >,
    respond: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponder,
    req: Request,
    res: Response,
    next: NextFunction,
  ) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponder =
  {
    with200(): ExpressRuntimeResponse<t_issuing_personalization_design>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
      void,
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectRequestBodySchema,
      void
    >,
    respond: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponder,
    req: Request,
    res: Response,
    next: NextFunction,
  ) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingSettlementsResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingSettlements = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingSettlementsRequestBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingSettlementsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingSettlementsSettlementCompleteResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingSettlementsSettlementComplete = (
  params: Params<
    t_PostTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
    void,
    | t_PostTestHelpersIssuingSettlementsSettlementCompleteRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingSettlementsSettlementCompleteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingTransactionsCreateForceCaptureResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingTransactionsCreateForceCapture = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingTransactionsCreateForceCaptureRequestBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingTransactionsCreateForceCaptureResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingTransactionsCreateUnlinkedRefundResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingTransactionsCreateUnlinkedRefund = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingTransactionsCreateUnlinkedRefundRequestBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingTransactionsCreateUnlinkedRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersIssuingTransactionsTransactionRefundResponder = {
  with200(): ExpressRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersIssuingTransactionsTransactionRefund = (
  params: Params<
    t_PostTestHelpersIssuingTransactionsTransactionRefundParamSchema,
    void,
    | t_PostTestHelpersIssuingTransactionsTransactionRefundRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingTransactionsTransactionRefundResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersRefundsRefundExpireResponder = {
  with200(): ExpressRuntimeResponse<t_refund>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersRefundsRefundExpire = (
  params: Params<
    t_PostTestHelpersRefundsRefundExpireParamSchema,
    void,
    t_PostTestHelpersRefundsRefundExpireRequestBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersRefundsRefundExpireResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTerminalReadersReaderPresentPaymentMethodResponder =
  {
    with200(): ExpressRuntimeResponse<t_terminal_reader>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersTerminalReadersReaderPresentPaymentMethod = (
  params: Params<
    t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
    void,
    | t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTerminalReadersReaderPresentPaymentMethodResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTerminalReadersReaderSucceedInputCollectionResponder =
  {
    with200(): ExpressRuntimeResponse<t_terminal_reader>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersTerminalReadersReaderSucceedInputCollection = (
  params: Params<
    t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema,
    void,
    | t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTerminalReadersReaderSucceedInputCollectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTerminalReadersReaderTimeoutInputCollectionResponder =
  {
    with200(): ExpressRuntimeResponse<t_terminal_reader>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersTerminalReadersReaderTimeoutInputCollection = (
  params: Params<
    t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema,
    void,
    | t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTerminalReadersReaderTimeoutInputCollectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTestHelpersTestClocksResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_test_helpers_test_clock[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTestHelpersTestClocks = (
  params: Params<
    void,
    t_GetTestHelpersTestClocksQuerySchema,
    t_GetTestHelpersTestClocksRequestBodySchema | undefined,
    void
  >,
  respond: GetTestHelpersTestClocksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTestClocksResponder = {
  with200(): ExpressRuntimeResponse<t_test_helpers_test_clock>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTestClocks = (
  params: Params<
    void,
    void,
    t_PostTestHelpersTestClocksRequestBodySchema,
    void
  >,
  respond: PostTestHelpersTestClocksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteTestHelpersTestClocksTestClockResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_test_helpers_test_clock>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteTestHelpersTestClocksTestClock = (
  params: Params<
    t_DeleteTestHelpersTestClocksTestClockParamSchema,
    void,
    t_DeleteTestHelpersTestClocksTestClockRequestBodySchema | undefined,
    void
  >,
  respond: DeleteTestHelpersTestClocksTestClockResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTestHelpersTestClocksTestClockResponder = {
  with200(): ExpressRuntimeResponse<t_test_helpers_test_clock>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTestHelpersTestClocksTestClock = (
  params: Params<
    t_GetTestHelpersTestClocksTestClockParamSchema,
    t_GetTestHelpersTestClocksTestClockQuerySchema,
    t_GetTestHelpersTestClocksTestClockRequestBodySchema | undefined,
    void
  >,
  respond: GetTestHelpersTestClocksTestClockResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTestClocksTestClockAdvanceResponder = {
  with200(): ExpressRuntimeResponse<t_test_helpers_test_clock>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTestClocksTestClockAdvance = (
  params: Params<
    t_PostTestHelpersTestClocksTestClockAdvanceParamSchema,
    void,
    t_PostTestHelpersTestClocksTestClockAdvanceRequestBodySchema,
    void
  >,
  respond: PostTestHelpersTestClocksTestClockAdvanceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryInboundTransfersIdFailResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryInboundTransfersIdFail = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdFailParamSchema,
    void,
    | t_PostTestHelpersTreasuryInboundTransfersIdFailRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryInboundTransfersIdFailResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryInboundTransfersIdReturnResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryInboundTransfersIdReturn = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
    void,
    | t_PostTestHelpersTreasuryInboundTransfersIdReturnRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryInboundTransfersIdReturnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryInboundTransfersIdSucceedResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryInboundTransfersIdSucceed = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
    void,
    | t_PostTestHelpersTreasuryInboundTransfersIdSucceedRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryInboundTransfersIdSucceedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundPaymentsIdResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsId = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdRequestBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundPaymentsIdFailResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsIdFail = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundPaymentsIdFailRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdFailResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundPaymentsIdPostResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsIdPost = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundPaymentsIdPostRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundPaymentsIdReturnResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsIdReturn = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundPaymentsIdReturnRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdReturnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferResponder =
  {
    with200(): ExpressRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransfer = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferRequestBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponder =
  {
    with200(): ExpressRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferFail = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponder =
  {
    with200(): ExpressRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferPost = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponder =
  {
    with200(): ExpressRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
  } & ExpressRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturn = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryReceivedCreditsResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_received_credit>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryReceivedCredits = (
  params: Params<
    void,
    void,
    t_PostTestHelpersTreasuryReceivedCreditsRequestBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryReceivedCreditsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTestHelpersTreasuryReceivedDebitsResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_received_debit>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTestHelpersTreasuryReceivedDebits = (
  params: Params<
    void,
    void,
    t_PostTestHelpersTreasuryReceivedDebitsRequestBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryReceivedDebitsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTokensResponder = {
  with200(): ExpressRuntimeResponse<t_token>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTokens = (
  params: Params<void, void, t_PostTokensRequestBodySchema | undefined, void>,
  respond: PostTokensResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTokensTokenResponder = {
  with200(): ExpressRuntimeResponse<t_token>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTokensToken = (
  params: Params<
    t_GetTokensTokenParamSchema,
    t_GetTokensTokenQuerySchema,
    t_GetTokensTokenRequestBodySchema | undefined,
    void
  >,
  respond: GetTokensTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTopupsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_topup[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTopups = (
  params: Params<
    void,
    t_GetTopupsQuerySchema,
    t_GetTopupsRequestBodySchema | undefined,
    void
  >,
  respond: GetTopupsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTopupsResponder = {
  with200(): ExpressRuntimeResponse<t_topup>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTopups = (
  params: Params<void, void, t_PostTopupsRequestBodySchema, void>,
  respond: PostTopupsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTopupsTopupResponder = {
  with200(): ExpressRuntimeResponse<t_topup>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTopupsTopup = (
  params: Params<
    t_GetTopupsTopupParamSchema,
    t_GetTopupsTopupQuerySchema,
    t_GetTopupsTopupRequestBodySchema | undefined,
    void
  >,
  respond: GetTopupsTopupResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTopupsTopupResponder = {
  with200(): ExpressRuntimeResponse<t_topup>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTopupsTopup = (
  params: Params<
    t_PostTopupsTopupParamSchema,
    void,
    t_PostTopupsTopupRequestBodySchema | undefined,
    void
  >,
  respond: PostTopupsTopupResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTopupsTopupCancelResponder = {
  with200(): ExpressRuntimeResponse<t_topup>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTopupsTopupCancel = (
  params: Params<
    t_PostTopupsTopupCancelParamSchema,
    void,
    t_PostTopupsTopupCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostTopupsTopupCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTransfersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTransfers = (
  params: Params<
    void,
    t_GetTransfersQuerySchema,
    t_GetTransfersRequestBodySchema | undefined,
    void
  >,
  respond: GetTransfersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTransfersResponder = {
  with200(): ExpressRuntimeResponse<t_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTransfers = (
  params: Params<void, void, t_PostTransfersRequestBodySchema, void>,
  respond: PostTransfersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTransfersIdReversalsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_transfer_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTransfersIdReversals = (
  params: Params<
    t_GetTransfersIdReversalsParamSchema,
    t_GetTransfersIdReversalsQuerySchema,
    t_GetTransfersIdReversalsRequestBodySchema | undefined,
    void
  >,
  respond: GetTransfersIdReversalsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTransfersIdReversalsResponder = {
  with200(): ExpressRuntimeResponse<t_transfer_reversal>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTransfersIdReversals = (
  params: Params<
    t_PostTransfersIdReversalsParamSchema,
    void,
    t_PostTransfersIdReversalsRequestBodySchema | undefined,
    void
  >,
  respond: PostTransfersIdReversalsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTransfersTransferResponder = {
  with200(): ExpressRuntimeResponse<t_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTransfersTransfer = (
  params: Params<
    t_GetTransfersTransferParamSchema,
    t_GetTransfersTransferQuerySchema,
    t_GetTransfersTransferRequestBodySchema | undefined,
    void
  >,
  respond: GetTransfersTransferResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTransfersTransferResponder = {
  with200(): ExpressRuntimeResponse<t_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTransfersTransfer = (
  params: Params<
    t_PostTransfersTransferParamSchema,
    void,
    t_PostTransfersTransferRequestBodySchema | undefined,
    void
  >,
  respond: PostTransfersTransferResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTransfersTransferReversalsIdResponder = {
  with200(): ExpressRuntimeResponse<t_transfer_reversal>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTransfersTransferReversalsId = (
  params: Params<
    t_GetTransfersTransferReversalsIdParamSchema,
    t_GetTransfersTransferReversalsIdQuerySchema,
    t_GetTransfersTransferReversalsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTransfersTransferReversalsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTransfersTransferReversalsIdResponder = {
  with200(): ExpressRuntimeResponse<t_transfer_reversal>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTransfersTransferReversalsId = (
  params: Params<
    t_PostTransfersTransferReversalsIdParamSchema,
    void,
    t_PostTransfersTransferReversalsIdRequestBodySchema | undefined,
    void
  >,
  respond: PostTransfersTransferReversalsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryCreditReversalsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_credit_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryCreditReversals = (
  params: Params<
    void,
    t_GetTreasuryCreditReversalsQuerySchema,
    t_GetTreasuryCreditReversalsRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryCreditReversalsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryCreditReversalsResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_credit_reversal>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryCreditReversals = (
  params: Params<
    void,
    void,
    t_PostTreasuryCreditReversalsRequestBodySchema,
    void
  >,
  respond: PostTreasuryCreditReversalsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryCreditReversalsCreditReversalResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_credit_reversal>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryCreditReversalsCreditReversal = (
  params: Params<
    t_GetTreasuryCreditReversalsCreditReversalParamSchema,
    t_GetTreasuryCreditReversalsCreditReversalQuerySchema,
    t_GetTreasuryCreditReversalsCreditReversalRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryCreditReversalsCreditReversalResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryDebitReversalsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_debit_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryDebitReversals = (
  params: Params<
    void,
    t_GetTreasuryDebitReversalsQuerySchema,
    t_GetTreasuryDebitReversalsRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryDebitReversalsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryDebitReversalsResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_debit_reversal>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryDebitReversals = (
  params: Params<
    void,
    void,
    t_PostTreasuryDebitReversalsRequestBodySchema,
    void
  >,
  respond: PostTreasuryDebitReversalsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryDebitReversalsDebitReversalResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_debit_reversal>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryDebitReversalsDebitReversal = (
  params: Params<
    t_GetTreasuryDebitReversalsDebitReversalParamSchema,
    t_GetTreasuryDebitReversalsDebitReversalQuerySchema,
    t_GetTreasuryDebitReversalsDebitReversalRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryDebitReversalsDebitReversalResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryFinancialAccountsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_financial_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryFinancialAccounts = (
  params: Params<
    void,
    t_GetTreasuryFinancialAccountsQuerySchema,
    t_GetTreasuryFinancialAccountsRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryFinancialAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryFinancialAccountsResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryFinancialAccounts = (
  params: Params<
    void,
    void,
    t_PostTreasuryFinancialAccountsRequestBodySchema,
    void
  >,
  respond: PostTreasuryFinancialAccountsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryFinancialAccountsFinancialAccountResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryFinancialAccountsFinancialAccount = (
  params: Params<
    t_GetTreasuryFinancialAccountsFinancialAccountParamSchema,
    t_GetTreasuryFinancialAccountsFinancialAccountQuerySchema,
    t_GetTreasuryFinancialAccountsFinancialAccountRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryFinancialAccountsFinancialAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryFinancialAccountsFinancialAccountResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryFinancialAccountsFinancialAccount = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountParamSchema,
    void,
    | t_PostTreasuryFinancialAccountsFinancialAccountRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTreasuryFinancialAccountsFinancialAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryFinancialAccountsFinancialAccountCloseResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryFinancialAccountsFinancialAccountClose = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
    void,
    | t_PostTreasuryFinancialAccountsFinancialAccountCloseRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTreasuryFinancialAccountsFinancialAccountCloseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryFinancialAccountsFinancialAccountFeaturesResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_financial_account_features>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryFinancialAccountsFinancialAccountFeatures = (
  params: Params<
    t_GetTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
    t_GetTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
    | t_GetTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema
    | undefined,
    void
  >,
  respond: GetTreasuryFinancialAccountsFinancialAccountFeaturesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryFinancialAccountsFinancialAccountFeaturesResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_financial_account_features>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryFinancialAccountsFinancialAccountFeatures = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
    void,
    | t_PostTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTreasuryFinancialAccountsFinancialAccountFeaturesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryInboundTransfersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_inbound_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryInboundTransfers = (
  params: Params<
    void,
    t_GetTreasuryInboundTransfersQuerySchema,
    t_GetTreasuryInboundTransfersRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryInboundTransfersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryInboundTransfersResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryInboundTransfers = (
  params: Params<
    void,
    void,
    t_PostTreasuryInboundTransfersRequestBodySchema,
    void
  >,
  respond: PostTreasuryInboundTransfersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryInboundTransfersIdResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryInboundTransfersId = (
  params: Params<
    t_GetTreasuryInboundTransfersIdParamSchema,
    t_GetTreasuryInboundTransfersIdQuerySchema,
    t_GetTreasuryInboundTransfersIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryInboundTransfersIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryInboundTransfersInboundTransferCancelResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryInboundTransfersInboundTransferCancel = (
  params: Params<
    t_PostTreasuryInboundTransfersInboundTransferCancelParamSchema,
    void,
    | t_PostTreasuryInboundTransfersInboundTransferCancelRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTreasuryInboundTransfersInboundTransferCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryOutboundPaymentsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_outbound_payment[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryOutboundPayments = (
  params: Params<
    void,
    t_GetTreasuryOutboundPaymentsQuerySchema,
    t_GetTreasuryOutboundPaymentsRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundPaymentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryOutboundPaymentsResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryOutboundPayments = (
  params: Params<
    void,
    void,
    t_PostTreasuryOutboundPaymentsRequestBodySchema,
    void
  >,
  respond: PostTreasuryOutboundPaymentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryOutboundPaymentsIdResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryOutboundPaymentsId = (
  params: Params<
    t_GetTreasuryOutboundPaymentsIdParamSchema,
    t_GetTreasuryOutboundPaymentsIdQuerySchema,
    t_GetTreasuryOutboundPaymentsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundPaymentsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryOutboundPaymentsIdCancelResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryOutboundPaymentsIdCancel = (
  params: Params<
    t_PostTreasuryOutboundPaymentsIdCancelParamSchema,
    void,
    t_PostTreasuryOutboundPaymentsIdCancelRequestBodySchema | undefined,
    void
  >,
  respond: PostTreasuryOutboundPaymentsIdCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryOutboundTransfersResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_outbound_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryOutboundTransfers = (
  params: Params<
    void,
    t_GetTreasuryOutboundTransfersQuerySchema,
    t_GetTreasuryOutboundTransfersRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundTransfersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryOutboundTransfersResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryOutboundTransfers = (
  params: Params<
    void,
    void,
    t_PostTreasuryOutboundTransfersRequestBodySchema,
    void
  >,
  respond: PostTreasuryOutboundTransfersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryOutboundTransfersOutboundTransferResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryOutboundTransfersOutboundTransfer = (
  params: Params<
    t_GetTreasuryOutboundTransfersOutboundTransferParamSchema,
    t_GetTreasuryOutboundTransfersOutboundTransferQuerySchema,
    t_GetTreasuryOutboundTransfersOutboundTransferRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundTransfersOutboundTransferResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostTreasuryOutboundTransfersOutboundTransferCancelResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_outbound_transfer>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostTreasuryOutboundTransfersOutboundTransferCancel = (
  params: Params<
    t_PostTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
    void,
    | t_PostTreasuryOutboundTransfersOutboundTransferCancelRequestBodySchema
    | undefined,
    void
  >,
  respond: PostTreasuryOutboundTransfersOutboundTransferCancelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryReceivedCreditsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_received_credit[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryReceivedCredits = (
  params: Params<
    void,
    t_GetTreasuryReceivedCreditsQuerySchema,
    t_GetTreasuryReceivedCreditsRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedCreditsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryReceivedCreditsIdResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_received_credit>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryReceivedCreditsId = (
  params: Params<
    t_GetTreasuryReceivedCreditsIdParamSchema,
    t_GetTreasuryReceivedCreditsIdQuerySchema,
    t_GetTreasuryReceivedCreditsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedCreditsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryReceivedDebitsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_received_debit[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryReceivedDebits = (
  params: Params<
    void,
    t_GetTreasuryReceivedDebitsQuerySchema,
    t_GetTreasuryReceivedDebitsRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedDebitsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryReceivedDebitsIdResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_received_debit>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryReceivedDebitsId = (
  params: Params<
    t_GetTreasuryReceivedDebitsIdParamSchema,
    t_GetTreasuryReceivedDebitsIdQuerySchema,
    t_GetTreasuryReceivedDebitsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedDebitsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryTransactionEntriesResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_transaction_entry[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryTransactionEntries = (
  params: Params<
    void,
    t_GetTreasuryTransactionEntriesQuerySchema,
    t_GetTreasuryTransactionEntriesRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionEntriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryTransactionEntriesIdResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_transaction_entry>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryTransactionEntriesId = (
  params: Params<
    t_GetTreasuryTransactionEntriesIdParamSchema,
    t_GetTreasuryTransactionEntriesIdQuerySchema,
    t_GetTreasuryTransactionEntriesIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionEntriesIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryTransactionsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_treasury_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryTransactions = (
  params: Params<
    void,
    t_GetTreasuryTransactionsQuerySchema,
    t_GetTreasuryTransactionsRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTreasuryTransactionsIdResponder = {
  with200(): ExpressRuntimeResponse<t_treasury_transaction>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetTreasuryTransactionsId = (
  params: Params<
    t_GetTreasuryTransactionsIdParamSchema,
    t_GetTreasuryTransactionsIdQuerySchema,
    t_GetTreasuryTransactionsIdRequestBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionsIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetWebhookEndpointsResponder = {
  with200(): ExpressRuntimeResponse<{
    data: t_webhook_endpoint[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetWebhookEndpoints = (
  params: Params<
    void,
    t_GetWebhookEndpointsQuerySchema,
    t_GetWebhookEndpointsRequestBodySchema | undefined,
    void
  >,
  respond: GetWebhookEndpointsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostWebhookEndpointsResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_endpoint>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostWebhookEndpoints = (
  params: Params<void, void, t_PostWebhookEndpointsRequestBodySchema, void>,
  respond: PostWebhookEndpointsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteWebhookEndpointsWebhookEndpointResponder = {
  with200(): ExpressRuntimeResponse<t_deleted_webhook_endpoint>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type DeleteWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_DeleteWebhookEndpointsWebhookEndpointParamSchema,
    void,
    t_DeleteWebhookEndpointsWebhookEndpointRequestBodySchema | undefined,
    void
  >,
  respond: DeleteWebhookEndpointsWebhookEndpointResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetWebhookEndpointsWebhookEndpointResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_endpoint>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type GetWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_GetWebhookEndpointsWebhookEndpointParamSchema,
    t_GetWebhookEndpointsWebhookEndpointQuerySchema,
    t_GetWebhookEndpointsWebhookEndpointRequestBodySchema | undefined,
    void
  >,
  respond: GetWebhookEndpointsWebhookEndpointResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PostWebhookEndpointsWebhookEndpointResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_endpoint>
  withDefault(status: StatusCode): ExpressRuntimeResponse<t_error>
} & ExpressRuntimeResponder

export type PostWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_PostWebhookEndpointsWebhookEndpointParamSchema,
    void,
    t_PostWebhookEndpointsWebhookEndpointRequestBodySchema | undefined,
    void
  >,
  respond: PostWebhookEndpointsWebhookEndpointResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  getAccount: GetAccount
  postAccountLinks: PostAccountLinks
  postAccountSessions: PostAccountSessions
  getAccounts: GetAccounts
  postAccounts: PostAccounts
  deleteAccountsAccount: DeleteAccountsAccount
  getAccountsAccount: GetAccountsAccount
  postAccountsAccount: PostAccountsAccount
  postAccountsAccountBankAccounts: PostAccountsAccountBankAccounts
  deleteAccountsAccountBankAccountsId: DeleteAccountsAccountBankAccountsId
  getAccountsAccountBankAccountsId: GetAccountsAccountBankAccountsId
  postAccountsAccountBankAccountsId: PostAccountsAccountBankAccountsId
  getAccountsAccountCapabilities: GetAccountsAccountCapabilities
  getAccountsAccountCapabilitiesCapability: GetAccountsAccountCapabilitiesCapability
  postAccountsAccountCapabilitiesCapability: PostAccountsAccountCapabilitiesCapability
  getAccountsAccountExternalAccounts: GetAccountsAccountExternalAccounts
  postAccountsAccountExternalAccounts: PostAccountsAccountExternalAccounts
  deleteAccountsAccountExternalAccountsId: DeleteAccountsAccountExternalAccountsId
  getAccountsAccountExternalAccountsId: GetAccountsAccountExternalAccountsId
  postAccountsAccountExternalAccountsId: PostAccountsAccountExternalAccountsId
  postAccountsAccountLoginLinks: PostAccountsAccountLoginLinks
  getAccountsAccountPeople: GetAccountsAccountPeople
  postAccountsAccountPeople: PostAccountsAccountPeople
  deleteAccountsAccountPeoplePerson: DeleteAccountsAccountPeoplePerson
  getAccountsAccountPeoplePerson: GetAccountsAccountPeoplePerson
  postAccountsAccountPeoplePerson: PostAccountsAccountPeoplePerson
  getAccountsAccountPersons: GetAccountsAccountPersons
  postAccountsAccountPersons: PostAccountsAccountPersons
  deleteAccountsAccountPersonsPerson: DeleteAccountsAccountPersonsPerson
  getAccountsAccountPersonsPerson: GetAccountsAccountPersonsPerson
  postAccountsAccountPersonsPerson: PostAccountsAccountPersonsPerson
  postAccountsAccountReject: PostAccountsAccountReject
  getApplePayDomains: GetApplePayDomains
  postApplePayDomains: PostApplePayDomains
  deleteApplePayDomainsDomain: DeleteApplePayDomainsDomain
  getApplePayDomainsDomain: GetApplePayDomainsDomain
  getApplicationFees: GetApplicationFees
  getApplicationFeesFeeRefundsId: GetApplicationFeesFeeRefundsId
  postApplicationFeesFeeRefundsId: PostApplicationFeesFeeRefundsId
  getApplicationFeesId: GetApplicationFeesId
  postApplicationFeesIdRefund: PostApplicationFeesIdRefund
  getApplicationFeesIdRefunds: GetApplicationFeesIdRefunds
  postApplicationFeesIdRefunds: PostApplicationFeesIdRefunds
  getAppsSecrets: GetAppsSecrets
  postAppsSecrets: PostAppsSecrets
  postAppsSecretsDelete: PostAppsSecretsDelete
  getAppsSecretsFind: GetAppsSecretsFind
  getBalance: GetBalance
  getBalanceHistory: GetBalanceHistory
  getBalanceHistoryId: GetBalanceHistoryId
  getBalanceTransactions: GetBalanceTransactions
  getBalanceTransactionsId: GetBalanceTransactionsId
  getBillingAlerts: GetBillingAlerts
  postBillingAlerts: PostBillingAlerts
  getBillingAlertsId: GetBillingAlertsId
  postBillingAlertsIdActivate: PostBillingAlertsIdActivate
  postBillingAlertsIdArchive: PostBillingAlertsIdArchive
  postBillingAlertsIdDeactivate: PostBillingAlertsIdDeactivate
  getBillingCreditBalanceSummary: GetBillingCreditBalanceSummary
  getBillingCreditBalanceTransactions: GetBillingCreditBalanceTransactions
  getBillingCreditBalanceTransactionsId: GetBillingCreditBalanceTransactionsId
  getBillingCreditGrants: GetBillingCreditGrants
  postBillingCreditGrants: PostBillingCreditGrants
  getBillingCreditGrantsId: GetBillingCreditGrantsId
  postBillingCreditGrantsId: PostBillingCreditGrantsId
  postBillingCreditGrantsIdExpire: PostBillingCreditGrantsIdExpire
  postBillingCreditGrantsIdVoid: PostBillingCreditGrantsIdVoid
  postBillingMeterEventAdjustments: PostBillingMeterEventAdjustments
  postBillingMeterEvents: PostBillingMeterEvents
  getBillingMeters: GetBillingMeters
  postBillingMeters: PostBillingMeters
  getBillingMetersId: GetBillingMetersId
  postBillingMetersId: PostBillingMetersId
  postBillingMetersIdDeactivate: PostBillingMetersIdDeactivate
  getBillingMetersIdEventSummaries: GetBillingMetersIdEventSummaries
  postBillingMetersIdReactivate: PostBillingMetersIdReactivate
  getBillingPortalConfigurations: GetBillingPortalConfigurations
  postBillingPortalConfigurations: PostBillingPortalConfigurations
  getBillingPortalConfigurationsConfiguration: GetBillingPortalConfigurationsConfiguration
  postBillingPortalConfigurationsConfiguration: PostBillingPortalConfigurationsConfiguration
  postBillingPortalSessions: PostBillingPortalSessions
  getCharges: GetCharges
  postCharges: PostCharges
  getChargesSearch: GetChargesSearch
  getChargesCharge: GetChargesCharge
  postChargesCharge: PostChargesCharge
  postChargesChargeCapture: PostChargesChargeCapture
  getChargesChargeDispute: GetChargesChargeDispute
  postChargesChargeDispute: PostChargesChargeDispute
  postChargesChargeDisputeClose: PostChargesChargeDisputeClose
  postChargesChargeRefund: PostChargesChargeRefund
  getChargesChargeRefunds: GetChargesChargeRefunds
  postChargesChargeRefunds: PostChargesChargeRefunds
  getChargesChargeRefundsRefund: GetChargesChargeRefundsRefund
  postChargesChargeRefundsRefund: PostChargesChargeRefundsRefund
  getCheckoutSessions: GetCheckoutSessions
  postCheckoutSessions: PostCheckoutSessions
  getCheckoutSessionsSession: GetCheckoutSessionsSession
  postCheckoutSessionsSession: PostCheckoutSessionsSession
  postCheckoutSessionsSessionExpire: PostCheckoutSessionsSessionExpire
  getCheckoutSessionsSessionLineItems: GetCheckoutSessionsSessionLineItems
  getClimateOrders: GetClimateOrders
  postClimateOrders: PostClimateOrders
  getClimateOrdersOrder: GetClimateOrdersOrder
  postClimateOrdersOrder: PostClimateOrdersOrder
  postClimateOrdersOrderCancel: PostClimateOrdersOrderCancel
  getClimateProducts: GetClimateProducts
  getClimateProductsProduct: GetClimateProductsProduct
  getClimateSuppliers: GetClimateSuppliers
  getClimateSuppliersSupplier: GetClimateSuppliersSupplier
  getConfirmationTokensConfirmationToken: GetConfirmationTokensConfirmationToken
  getCountrySpecs: GetCountrySpecs
  getCountrySpecsCountry: GetCountrySpecsCountry
  getCoupons: GetCoupons
  postCoupons: PostCoupons
  deleteCouponsCoupon: DeleteCouponsCoupon
  getCouponsCoupon: GetCouponsCoupon
  postCouponsCoupon: PostCouponsCoupon
  getCreditNotes: GetCreditNotes
  postCreditNotes: PostCreditNotes
  getCreditNotesPreview: GetCreditNotesPreview
  getCreditNotesPreviewLines: GetCreditNotesPreviewLines
  getCreditNotesCreditNoteLines: GetCreditNotesCreditNoteLines
  getCreditNotesId: GetCreditNotesId
  postCreditNotesId: PostCreditNotesId
  postCreditNotesIdVoid: PostCreditNotesIdVoid
  postCustomerSessions: PostCustomerSessions
  getCustomers: GetCustomers
  postCustomers: PostCustomers
  getCustomersSearch: GetCustomersSearch
  deleteCustomersCustomer: DeleteCustomersCustomer
  getCustomersCustomer: GetCustomersCustomer
  postCustomersCustomer: PostCustomersCustomer
  getCustomersCustomerBalanceTransactions: GetCustomersCustomerBalanceTransactions
  postCustomersCustomerBalanceTransactions: PostCustomersCustomerBalanceTransactions
  getCustomersCustomerBalanceTransactionsTransaction: GetCustomersCustomerBalanceTransactionsTransaction
  postCustomersCustomerBalanceTransactionsTransaction: PostCustomersCustomerBalanceTransactionsTransaction
  getCustomersCustomerBankAccounts: GetCustomersCustomerBankAccounts
  postCustomersCustomerBankAccounts: PostCustomersCustomerBankAccounts
  deleteCustomersCustomerBankAccountsId: DeleteCustomersCustomerBankAccountsId
  getCustomersCustomerBankAccountsId: GetCustomersCustomerBankAccountsId
  postCustomersCustomerBankAccountsId: PostCustomersCustomerBankAccountsId
  postCustomersCustomerBankAccountsIdVerify: PostCustomersCustomerBankAccountsIdVerify
  getCustomersCustomerCards: GetCustomersCustomerCards
  postCustomersCustomerCards: PostCustomersCustomerCards
  deleteCustomersCustomerCardsId: DeleteCustomersCustomerCardsId
  getCustomersCustomerCardsId: GetCustomersCustomerCardsId
  postCustomersCustomerCardsId: PostCustomersCustomerCardsId
  getCustomersCustomerCashBalance: GetCustomersCustomerCashBalance
  postCustomersCustomerCashBalance: PostCustomersCustomerCashBalance
  getCustomersCustomerCashBalanceTransactions: GetCustomersCustomerCashBalanceTransactions
  getCustomersCustomerCashBalanceTransactionsTransaction: GetCustomersCustomerCashBalanceTransactionsTransaction
  deleteCustomersCustomerDiscount: DeleteCustomersCustomerDiscount
  getCustomersCustomerDiscount: GetCustomersCustomerDiscount
  postCustomersCustomerFundingInstructions: PostCustomersCustomerFundingInstructions
  getCustomersCustomerPaymentMethods: GetCustomersCustomerPaymentMethods
  getCustomersCustomerPaymentMethodsPaymentMethod: GetCustomersCustomerPaymentMethodsPaymentMethod
  getCustomersCustomerSources: GetCustomersCustomerSources
  postCustomersCustomerSources: PostCustomersCustomerSources
  deleteCustomersCustomerSourcesId: DeleteCustomersCustomerSourcesId
  getCustomersCustomerSourcesId: GetCustomersCustomerSourcesId
  postCustomersCustomerSourcesId: PostCustomersCustomerSourcesId
  postCustomersCustomerSourcesIdVerify: PostCustomersCustomerSourcesIdVerify
  getCustomersCustomerSubscriptions: GetCustomersCustomerSubscriptions
  postCustomersCustomerSubscriptions: PostCustomersCustomerSubscriptions
  deleteCustomersCustomerSubscriptionsSubscriptionExposedId: DeleteCustomersCustomerSubscriptionsSubscriptionExposedId
  getCustomersCustomerSubscriptionsSubscriptionExposedId: GetCustomersCustomerSubscriptionsSubscriptionExposedId
  postCustomersCustomerSubscriptionsSubscriptionExposedId: PostCustomersCustomerSubscriptionsSubscriptionExposedId
  deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount: DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount: GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  getCustomersCustomerTaxIds: GetCustomersCustomerTaxIds
  postCustomersCustomerTaxIds: PostCustomersCustomerTaxIds
  deleteCustomersCustomerTaxIdsId: DeleteCustomersCustomerTaxIdsId
  getCustomersCustomerTaxIdsId: GetCustomersCustomerTaxIdsId
  getDisputes: GetDisputes
  getDisputesDispute: GetDisputesDispute
  postDisputesDispute: PostDisputesDispute
  postDisputesDisputeClose: PostDisputesDisputeClose
  getEntitlementsActiveEntitlements: GetEntitlementsActiveEntitlements
  getEntitlementsActiveEntitlementsId: GetEntitlementsActiveEntitlementsId
  getEntitlementsFeatures: GetEntitlementsFeatures
  postEntitlementsFeatures: PostEntitlementsFeatures
  getEntitlementsFeaturesId: GetEntitlementsFeaturesId
  postEntitlementsFeaturesId: PostEntitlementsFeaturesId
  postEphemeralKeys: PostEphemeralKeys
  deleteEphemeralKeysKey: DeleteEphemeralKeysKey
  getEvents: GetEvents
  getEventsId: GetEventsId
  getExchangeRates: GetExchangeRates
  getExchangeRatesRateId: GetExchangeRatesRateId
  postExternalAccountsId: PostExternalAccountsId
  getFileLinks: GetFileLinks
  postFileLinks: PostFileLinks
  getFileLinksLink: GetFileLinksLink
  postFileLinksLink: PostFileLinksLink
  getFiles: GetFiles
  postFiles: PostFiles
  getFilesFile: GetFilesFile
  getFinancialConnectionsAccounts: GetFinancialConnectionsAccounts
  getFinancialConnectionsAccountsAccount: GetFinancialConnectionsAccountsAccount
  postFinancialConnectionsAccountsAccountDisconnect: PostFinancialConnectionsAccountsAccountDisconnect
  getFinancialConnectionsAccountsAccountOwners: GetFinancialConnectionsAccountsAccountOwners
  postFinancialConnectionsAccountsAccountRefresh: PostFinancialConnectionsAccountsAccountRefresh
  postFinancialConnectionsAccountsAccountSubscribe: PostFinancialConnectionsAccountsAccountSubscribe
  postFinancialConnectionsAccountsAccountUnsubscribe: PostFinancialConnectionsAccountsAccountUnsubscribe
  postFinancialConnectionsSessions: PostFinancialConnectionsSessions
  getFinancialConnectionsSessionsSession: GetFinancialConnectionsSessionsSession
  getFinancialConnectionsTransactions: GetFinancialConnectionsTransactions
  getFinancialConnectionsTransactionsTransaction: GetFinancialConnectionsTransactionsTransaction
  getForwardingRequests: GetForwardingRequests
  postForwardingRequests: PostForwardingRequests
  getForwardingRequestsId: GetForwardingRequestsId
  getIdentityVerificationReports: GetIdentityVerificationReports
  getIdentityVerificationReportsReport: GetIdentityVerificationReportsReport
  getIdentityVerificationSessions: GetIdentityVerificationSessions
  postIdentityVerificationSessions: PostIdentityVerificationSessions
  getIdentityVerificationSessionsSession: GetIdentityVerificationSessionsSession
  postIdentityVerificationSessionsSession: PostIdentityVerificationSessionsSession
  postIdentityVerificationSessionsSessionCancel: PostIdentityVerificationSessionsSessionCancel
  postIdentityVerificationSessionsSessionRedact: PostIdentityVerificationSessionsSessionRedact
  getInvoicePayments: GetInvoicePayments
  getInvoicePaymentsInvoicePayment: GetInvoicePaymentsInvoicePayment
  getInvoiceRenderingTemplates: GetInvoiceRenderingTemplates
  getInvoiceRenderingTemplatesTemplate: GetInvoiceRenderingTemplatesTemplate
  postInvoiceRenderingTemplatesTemplateArchive: PostInvoiceRenderingTemplatesTemplateArchive
  postInvoiceRenderingTemplatesTemplateUnarchive: PostInvoiceRenderingTemplatesTemplateUnarchive
  getInvoiceitems: GetInvoiceitems
  postInvoiceitems: PostInvoiceitems
  deleteInvoiceitemsInvoiceitem: DeleteInvoiceitemsInvoiceitem
  getInvoiceitemsInvoiceitem: GetInvoiceitemsInvoiceitem
  postInvoiceitemsInvoiceitem: PostInvoiceitemsInvoiceitem
  getInvoices: GetInvoices
  postInvoices: PostInvoices
  postInvoicesCreatePreview: PostInvoicesCreatePreview
  getInvoicesSearch: GetInvoicesSearch
  deleteInvoicesInvoice: DeleteInvoicesInvoice
  getInvoicesInvoice: GetInvoicesInvoice
  postInvoicesInvoice: PostInvoicesInvoice
  postInvoicesInvoiceAddLines: PostInvoicesInvoiceAddLines
  postInvoicesInvoiceAttachPayment: PostInvoicesInvoiceAttachPayment
  postInvoicesInvoiceFinalize: PostInvoicesInvoiceFinalize
  getInvoicesInvoiceLines: GetInvoicesInvoiceLines
  postInvoicesInvoiceLinesLineItemId: PostInvoicesInvoiceLinesLineItemId
  postInvoicesInvoiceMarkUncollectible: PostInvoicesInvoiceMarkUncollectible
  postInvoicesInvoicePay: PostInvoicesInvoicePay
  postInvoicesInvoiceRemoveLines: PostInvoicesInvoiceRemoveLines
  postInvoicesInvoiceSend: PostInvoicesInvoiceSend
  postInvoicesInvoiceUpdateLines: PostInvoicesInvoiceUpdateLines
  postInvoicesInvoiceVoid: PostInvoicesInvoiceVoid
  getIssuingAuthorizations: GetIssuingAuthorizations
  getIssuingAuthorizationsAuthorization: GetIssuingAuthorizationsAuthorization
  postIssuingAuthorizationsAuthorization: PostIssuingAuthorizationsAuthorization
  postIssuingAuthorizationsAuthorizationApprove: PostIssuingAuthorizationsAuthorizationApprove
  postIssuingAuthorizationsAuthorizationDecline: PostIssuingAuthorizationsAuthorizationDecline
  getIssuingCardholders: GetIssuingCardholders
  postIssuingCardholders: PostIssuingCardholders
  getIssuingCardholdersCardholder: GetIssuingCardholdersCardholder
  postIssuingCardholdersCardholder: PostIssuingCardholdersCardholder
  getIssuingCards: GetIssuingCards
  postIssuingCards: PostIssuingCards
  getIssuingCardsCard: GetIssuingCardsCard
  postIssuingCardsCard: PostIssuingCardsCard
  getIssuingDisputes: GetIssuingDisputes
  postIssuingDisputes: PostIssuingDisputes
  getIssuingDisputesDispute: GetIssuingDisputesDispute
  postIssuingDisputesDispute: PostIssuingDisputesDispute
  postIssuingDisputesDisputeSubmit: PostIssuingDisputesDisputeSubmit
  getIssuingPersonalizationDesigns: GetIssuingPersonalizationDesigns
  postIssuingPersonalizationDesigns: PostIssuingPersonalizationDesigns
  getIssuingPersonalizationDesignsPersonalizationDesign: GetIssuingPersonalizationDesignsPersonalizationDesign
  postIssuingPersonalizationDesignsPersonalizationDesign: PostIssuingPersonalizationDesignsPersonalizationDesign
  getIssuingPhysicalBundles: GetIssuingPhysicalBundles
  getIssuingPhysicalBundlesPhysicalBundle: GetIssuingPhysicalBundlesPhysicalBundle
  getIssuingSettlementsSettlement: GetIssuingSettlementsSettlement
  postIssuingSettlementsSettlement: PostIssuingSettlementsSettlement
  getIssuingTokens: GetIssuingTokens
  getIssuingTokensToken: GetIssuingTokensToken
  postIssuingTokensToken: PostIssuingTokensToken
  getIssuingTransactions: GetIssuingTransactions
  getIssuingTransactionsTransaction: GetIssuingTransactionsTransaction
  postIssuingTransactionsTransaction: PostIssuingTransactionsTransaction
  postLinkAccountSessions: PostLinkAccountSessions
  getLinkAccountSessionsSession: GetLinkAccountSessionsSession
  getLinkedAccounts: GetLinkedAccounts
  getLinkedAccountsAccount: GetLinkedAccountsAccount
  postLinkedAccountsAccountDisconnect: PostLinkedAccountsAccountDisconnect
  getLinkedAccountsAccountOwners: GetLinkedAccountsAccountOwners
  postLinkedAccountsAccountRefresh: PostLinkedAccountsAccountRefresh
  getMandatesMandate: GetMandatesMandate
  getPaymentIntents: GetPaymentIntents
  postPaymentIntents: PostPaymentIntents
  getPaymentIntentsSearch: GetPaymentIntentsSearch
  getPaymentIntentsIntent: GetPaymentIntentsIntent
  postPaymentIntentsIntent: PostPaymentIntentsIntent
  postPaymentIntentsIntentApplyCustomerBalance: PostPaymentIntentsIntentApplyCustomerBalance
  postPaymentIntentsIntentCancel: PostPaymentIntentsIntentCancel
  postPaymentIntentsIntentCapture: PostPaymentIntentsIntentCapture
  postPaymentIntentsIntentConfirm: PostPaymentIntentsIntentConfirm
  postPaymentIntentsIntentIncrementAuthorization: PostPaymentIntentsIntentIncrementAuthorization
  postPaymentIntentsIntentVerifyMicrodeposits: PostPaymentIntentsIntentVerifyMicrodeposits
  getPaymentLinks: GetPaymentLinks
  postPaymentLinks: PostPaymentLinks
  getPaymentLinksPaymentLink: GetPaymentLinksPaymentLink
  postPaymentLinksPaymentLink: PostPaymentLinksPaymentLink
  getPaymentLinksPaymentLinkLineItems: GetPaymentLinksPaymentLinkLineItems
  getPaymentMethodConfigurations: GetPaymentMethodConfigurations
  postPaymentMethodConfigurations: PostPaymentMethodConfigurations
  getPaymentMethodConfigurationsConfiguration: GetPaymentMethodConfigurationsConfiguration
  postPaymentMethodConfigurationsConfiguration: PostPaymentMethodConfigurationsConfiguration
  getPaymentMethodDomains: GetPaymentMethodDomains
  postPaymentMethodDomains: PostPaymentMethodDomains
  getPaymentMethodDomainsPaymentMethodDomain: GetPaymentMethodDomainsPaymentMethodDomain
  postPaymentMethodDomainsPaymentMethodDomain: PostPaymentMethodDomainsPaymentMethodDomain
  postPaymentMethodDomainsPaymentMethodDomainValidate: PostPaymentMethodDomainsPaymentMethodDomainValidate
  getPaymentMethods: GetPaymentMethods
  postPaymentMethods: PostPaymentMethods
  getPaymentMethodsPaymentMethod: GetPaymentMethodsPaymentMethod
  postPaymentMethodsPaymentMethod: PostPaymentMethodsPaymentMethod
  postPaymentMethodsPaymentMethodAttach: PostPaymentMethodsPaymentMethodAttach
  postPaymentMethodsPaymentMethodDetach: PostPaymentMethodsPaymentMethodDetach
  getPayouts: GetPayouts
  postPayouts: PostPayouts
  getPayoutsPayout: GetPayoutsPayout
  postPayoutsPayout: PostPayoutsPayout
  postPayoutsPayoutCancel: PostPayoutsPayoutCancel
  postPayoutsPayoutReverse: PostPayoutsPayoutReverse
  getPlans: GetPlans
  postPlans: PostPlans
  deletePlansPlan: DeletePlansPlan
  getPlansPlan: GetPlansPlan
  postPlansPlan: PostPlansPlan
  getPrices: GetPrices
  postPrices: PostPrices
  getPricesSearch: GetPricesSearch
  getPricesPrice: GetPricesPrice
  postPricesPrice: PostPricesPrice
  getProducts: GetProducts
  postProducts: PostProducts
  getProductsSearch: GetProductsSearch
  deleteProductsId: DeleteProductsId
  getProductsId: GetProductsId
  postProductsId: PostProductsId
  getProductsProductFeatures: GetProductsProductFeatures
  postProductsProductFeatures: PostProductsProductFeatures
  deleteProductsProductFeaturesId: DeleteProductsProductFeaturesId
  getProductsProductFeaturesId: GetProductsProductFeaturesId
  getPromotionCodes: GetPromotionCodes
  postPromotionCodes: PostPromotionCodes
  getPromotionCodesPromotionCode: GetPromotionCodesPromotionCode
  postPromotionCodesPromotionCode: PostPromotionCodesPromotionCode
  getQuotes: GetQuotes
  postQuotes: PostQuotes
  getQuotesQuote: GetQuotesQuote
  postQuotesQuote: PostQuotesQuote
  postQuotesQuoteAccept: PostQuotesQuoteAccept
  postQuotesQuoteCancel: PostQuotesQuoteCancel
  getQuotesQuoteComputedUpfrontLineItems: GetQuotesQuoteComputedUpfrontLineItems
  postQuotesQuoteFinalize: PostQuotesQuoteFinalize
  getQuotesQuoteLineItems: GetQuotesQuoteLineItems
  getQuotesQuotePdf: GetQuotesQuotePdf
  getRadarEarlyFraudWarnings: GetRadarEarlyFraudWarnings
  getRadarEarlyFraudWarningsEarlyFraudWarning: GetRadarEarlyFraudWarningsEarlyFraudWarning
  getRadarValueListItems: GetRadarValueListItems
  postRadarValueListItems: PostRadarValueListItems
  deleteRadarValueListItemsItem: DeleteRadarValueListItemsItem
  getRadarValueListItemsItem: GetRadarValueListItemsItem
  getRadarValueLists: GetRadarValueLists
  postRadarValueLists: PostRadarValueLists
  deleteRadarValueListsValueList: DeleteRadarValueListsValueList
  getRadarValueListsValueList: GetRadarValueListsValueList
  postRadarValueListsValueList: PostRadarValueListsValueList
  getRefunds: GetRefunds
  postRefunds: PostRefunds
  getRefundsRefund: GetRefundsRefund
  postRefundsRefund: PostRefundsRefund
  postRefundsRefundCancel: PostRefundsRefundCancel
  getReportingReportRuns: GetReportingReportRuns
  postReportingReportRuns: PostReportingReportRuns
  getReportingReportRunsReportRun: GetReportingReportRunsReportRun
  getReportingReportTypes: GetReportingReportTypes
  getReportingReportTypesReportType: GetReportingReportTypesReportType
  getReviews: GetReviews
  getReviewsReview: GetReviewsReview
  postReviewsReviewApprove: PostReviewsReviewApprove
  getSetupAttempts: GetSetupAttempts
  getSetupIntents: GetSetupIntents
  postSetupIntents: PostSetupIntents
  getSetupIntentsIntent: GetSetupIntentsIntent
  postSetupIntentsIntent: PostSetupIntentsIntent
  postSetupIntentsIntentCancel: PostSetupIntentsIntentCancel
  postSetupIntentsIntentConfirm: PostSetupIntentsIntentConfirm
  postSetupIntentsIntentVerifyMicrodeposits: PostSetupIntentsIntentVerifyMicrodeposits
  getShippingRates: GetShippingRates
  postShippingRates: PostShippingRates
  getShippingRatesShippingRateToken: GetShippingRatesShippingRateToken
  postShippingRatesShippingRateToken: PostShippingRatesShippingRateToken
  postSigmaSavedQueriesId: PostSigmaSavedQueriesId
  getSigmaScheduledQueryRuns: GetSigmaScheduledQueryRuns
  getSigmaScheduledQueryRunsScheduledQueryRun: GetSigmaScheduledQueryRunsScheduledQueryRun
  postSources: PostSources
  getSourcesSource: GetSourcesSource
  postSourcesSource: PostSourcesSource
  getSourcesSourceMandateNotificationsMandateNotification: GetSourcesSourceMandateNotificationsMandateNotification
  getSourcesSourceSourceTransactions: GetSourcesSourceSourceTransactions
  getSourcesSourceSourceTransactionsSourceTransaction: GetSourcesSourceSourceTransactionsSourceTransaction
  postSourcesSourceVerify: PostSourcesSourceVerify
  getSubscriptionItems: GetSubscriptionItems
  postSubscriptionItems: PostSubscriptionItems
  deleteSubscriptionItemsItem: DeleteSubscriptionItemsItem
  getSubscriptionItemsItem: GetSubscriptionItemsItem
  postSubscriptionItemsItem: PostSubscriptionItemsItem
  getSubscriptionSchedules: GetSubscriptionSchedules
  postSubscriptionSchedules: PostSubscriptionSchedules
  getSubscriptionSchedulesSchedule: GetSubscriptionSchedulesSchedule
  postSubscriptionSchedulesSchedule: PostSubscriptionSchedulesSchedule
  postSubscriptionSchedulesScheduleCancel: PostSubscriptionSchedulesScheduleCancel
  postSubscriptionSchedulesScheduleRelease: PostSubscriptionSchedulesScheduleRelease
  getSubscriptions: GetSubscriptions
  postSubscriptions: PostSubscriptions
  getSubscriptionsSearch: GetSubscriptionsSearch
  deleteSubscriptionsSubscriptionExposedId: DeleteSubscriptionsSubscriptionExposedId
  getSubscriptionsSubscriptionExposedId: GetSubscriptionsSubscriptionExposedId
  postSubscriptionsSubscriptionExposedId: PostSubscriptionsSubscriptionExposedId
  deleteSubscriptionsSubscriptionExposedIdDiscount: DeleteSubscriptionsSubscriptionExposedIdDiscount
  postSubscriptionsSubscriptionMigrate: PostSubscriptionsSubscriptionMigrate
  postSubscriptionsSubscriptionResume: PostSubscriptionsSubscriptionResume
  postTaxCalculations: PostTaxCalculations
  getTaxCalculationsCalculation: GetTaxCalculationsCalculation
  getTaxCalculationsCalculationLineItems: GetTaxCalculationsCalculationLineItems
  getTaxRegistrations: GetTaxRegistrations
  postTaxRegistrations: PostTaxRegistrations
  getTaxRegistrationsId: GetTaxRegistrationsId
  postTaxRegistrationsId: PostTaxRegistrationsId
  getTaxSettings: GetTaxSettings
  postTaxSettings: PostTaxSettings
  postTaxTransactionsCreateFromCalculation: PostTaxTransactionsCreateFromCalculation
  postTaxTransactionsCreateReversal: PostTaxTransactionsCreateReversal
  getTaxTransactionsTransaction: GetTaxTransactionsTransaction
  getTaxTransactionsTransactionLineItems: GetTaxTransactionsTransactionLineItems
  getTaxCodes: GetTaxCodes
  getTaxCodesId: GetTaxCodesId
  getTaxIds: GetTaxIds
  postTaxIds: PostTaxIds
  deleteTaxIdsId: DeleteTaxIdsId
  getTaxIdsId: GetTaxIdsId
  getTaxRates: GetTaxRates
  postTaxRates: PostTaxRates
  getTaxRatesTaxRate: GetTaxRatesTaxRate
  postTaxRatesTaxRate: PostTaxRatesTaxRate
  getTerminalConfigurations: GetTerminalConfigurations
  postTerminalConfigurations: PostTerminalConfigurations
  deleteTerminalConfigurationsConfiguration: DeleteTerminalConfigurationsConfiguration
  getTerminalConfigurationsConfiguration: GetTerminalConfigurationsConfiguration
  postTerminalConfigurationsConfiguration: PostTerminalConfigurationsConfiguration
  postTerminalConnectionTokens: PostTerminalConnectionTokens
  getTerminalLocations: GetTerminalLocations
  postTerminalLocations: PostTerminalLocations
  deleteTerminalLocationsLocation: DeleteTerminalLocationsLocation
  getTerminalLocationsLocation: GetTerminalLocationsLocation
  postTerminalLocationsLocation: PostTerminalLocationsLocation
  getTerminalReaders: GetTerminalReaders
  postTerminalReaders: PostTerminalReaders
  deleteTerminalReadersReader: DeleteTerminalReadersReader
  getTerminalReadersReader: GetTerminalReadersReader
  postTerminalReadersReader: PostTerminalReadersReader
  postTerminalReadersReaderCancelAction: PostTerminalReadersReaderCancelAction
  postTerminalReadersReaderCollectInputs: PostTerminalReadersReaderCollectInputs
  postTerminalReadersReaderCollectPaymentMethod: PostTerminalReadersReaderCollectPaymentMethod
  postTerminalReadersReaderConfirmPaymentIntent: PostTerminalReadersReaderConfirmPaymentIntent
  postTerminalReadersReaderProcessPaymentIntent: PostTerminalReadersReaderProcessPaymentIntent
  postTerminalReadersReaderProcessSetupIntent: PostTerminalReadersReaderProcessSetupIntent
  postTerminalReadersReaderRefundPayment: PostTerminalReadersReaderRefundPayment
  postTerminalReadersReaderSetReaderDisplay: PostTerminalReadersReaderSetReaderDisplay
  postTestHelpersConfirmationTokens: PostTestHelpersConfirmationTokens
  postTestHelpersCustomersCustomerFundCashBalance: PostTestHelpersCustomersCustomerFundCashBalance
  postTestHelpersIssuingAuthorizations: PostTestHelpersIssuingAuthorizations
  postTestHelpersIssuingAuthorizationsAuthorizationCapture: PostTestHelpersIssuingAuthorizationsAuthorizationCapture
  postTestHelpersIssuingAuthorizationsAuthorizationExpire: PostTestHelpersIssuingAuthorizationsAuthorizationExpire
  postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount: PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount
  postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond: PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond
  postTestHelpersIssuingAuthorizationsAuthorizationIncrement: PostTestHelpersIssuingAuthorizationsAuthorizationIncrement
  postTestHelpersIssuingAuthorizationsAuthorizationReverse: PostTestHelpersIssuingAuthorizationsAuthorizationReverse
  postTestHelpersIssuingCardsCardShippingDeliver: PostTestHelpersIssuingCardsCardShippingDeliver
  postTestHelpersIssuingCardsCardShippingFail: PostTestHelpersIssuingCardsCardShippingFail
  postTestHelpersIssuingCardsCardShippingReturn: PostTestHelpersIssuingCardsCardShippingReturn
  postTestHelpersIssuingCardsCardShippingShip: PostTestHelpersIssuingCardsCardShippingShip
  postTestHelpersIssuingCardsCardShippingSubmit: PostTestHelpersIssuingCardsCardShippingSubmit
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject
  postTestHelpersIssuingSettlements: PostTestHelpersIssuingSettlements
  postTestHelpersIssuingSettlementsSettlementComplete: PostTestHelpersIssuingSettlementsSettlementComplete
  postTestHelpersIssuingTransactionsCreateForceCapture: PostTestHelpersIssuingTransactionsCreateForceCapture
  postTestHelpersIssuingTransactionsCreateUnlinkedRefund: PostTestHelpersIssuingTransactionsCreateUnlinkedRefund
  postTestHelpersIssuingTransactionsTransactionRefund: PostTestHelpersIssuingTransactionsTransactionRefund
  postTestHelpersRefundsRefundExpire: PostTestHelpersRefundsRefundExpire
  postTestHelpersTerminalReadersReaderPresentPaymentMethod: PostTestHelpersTerminalReadersReaderPresentPaymentMethod
  postTestHelpersTerminalReadersReaderSucceedInputCollection: PostTestHelpersTerminalReadersReaderSucceedInputCollection
  postTestHelpersTerminalReadersReaderTimeoutInputCollection: PostTestHelpersTerminalReadersReaderTimeoutInputCollection
  getTestHelpersTestClocks: GetTestHelpersTestClocks
  postTestHelpersTestClocks: PostTestHelpersTestClocks
  deleteTestHelpersTestClocksTestClock: DeleteTestHelpersTestClocksTestClock
  getTestHelpersTestClocksTestClock: GetTestHelpersTestClocksTestClock
  postTestHelpersTestClocksTestClockAdvance: PostTestHelpersTestClocksTestClockAdvance
  postTestHelpersTreasuryInboundTransfersIdFail: PostTestHelpersTreasuryInboundTransfersIdFail
  postTestHelpersTreasuryInboundTransfersIdReturn: PostTestHelpersTreasuryInboundTransfersIdReturn
  postTestHelpersTreasuryInboundTransfersIdSucceed: PostTestHelpersTreasuryInboundTransfersIdSucceed
  postTestHelpersTreasuryOutboundPaymentsId: PostTestHelpersTreasuryOutboundPaymentsId
  postTestHelpersTreasuryOutboundPaymentsIdFail: PostTestHelpersTreasuryOutboundPaymentsIdFail
  postTestHelpersTreasuryOutboundPaymentsIdPost: PostTestHelpersTreasuryOutboundPaymentsIdPost
  postTestHelpersTreasuryOutboundPaymentsIdReturn: PostTestHelpersTreasuryOutboundPaymentsIdReturn
  postTestHelpersTreasuryOutboundTransfersOutboundTransfer: PostTestHelpersTreasuryOutboundTransfersOutboundTransfer
  postTestHelpersTreasuryOutboundTransfersOutboundTransferFail: PostTestHelpersTreasuryOutboundTransfersOutboundTransferFail
  postTestHelpersTreasuryOutboundTransfersOutboundTransferPost: PostTestHelpersTreasuryOutboundTransfersOutboundTransferPost
  postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn: PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturn
  postTestHelpersTreasuryReceivedCredits: PostTestHelpersTreasuryReceivedCredits
  postTestHelpersTreasuryReceivedDebits: PostTestHelpersTreasuryReceivedDebits
  postTokens: PostTokens
  getTokensToken: GetTokensToken
  getTopups: GetTopups
  postTopups: PostTopups
  getTopupsTopup: GetTopupsTopup
  postTopupsTopup: PostTopupsTopup
  postTopupsTopupCancel: PostTopupsTopupCancel
  getTransfers: GetTransfers
  postTransfers: PostTransfers
  getTransfersIdReversals: GetTransfersIdReversals
  postTransfersIdReversals: PostTransfersIdReversals
  getTransfersTransfer: GetTransfersTransfer
  postTransfersTransfer: PostTransfersTransfer
  getTransfersTransferReversalsId: GetTransfersTransferReversalsId
  postTransfersTransferReversalsId: PostTransfersTransferReversalsId
  getTreasuryCreditReversals: GetTreasuryCreditReversals
  postTreasuryCreditReversals: PostTreasuryCreditReversals
  getTreasuryCreditReversalsCreditReversal: GetTreasuryCreditReversalsCreditReversal
  getTreasuryDebitReversals: GetTreasuryDebitReversals
  postTreasuryDebitReversals: PostTreasuryDebitReversals
  getTreasuryDebitReversalsDebitReversal: GetTreasuryDebitReversalsDebitReversal
  getTreasuryFinancialAccounts: GetTreasuryFinancialAccounts
  postTreasuryFinancialAccounts: PostTreasuryFinancialAccounts
  getTreasuryFinancialAccountsFinancialAccount: GetTreasuryFinancialAccountsFinancialAccount
  postTreasuryFinancialAccountsFinancialAccount: PostTreasuryFinancialAccountsFinancialAccount
  postTreasuryFinancialAccountsFinancialAccountClose: PostTreasuryFinancialAccountsFinancialAccountClose
  getTreasuryFinancialAccountsFinancialAccountFeatures: GetTreasuryFinancialAccountsFinancialAccountFeatures
  postTreasuryFinancialAccountsFinancialAccountFeatures: PostTreasuryFinancialAccountsFinancialAccountFeatures
  getTreasuryInboundTransfers: GetTreasuryInboundTransfers
  postTreasuryInboundTransfers: PostTreasuryInboundTransfers
  getTreasuryInboundTransfersId: GetTreasuryInboundTransfersId
  postTreasuryInboundTransfersInboundTransferCancel: PostTreasuryInboundTransfersInboundTransferCancel
  getTreasuryOutboundPayments: GetTreasuryOutboundPayments
  postTreasuryOutboundPayments: PostTreasuryOutboundPayments
  getTreasuryOutboundPaymentsId: GetTreasuryOutboundPaymentsId
  postTreasuryOutboundPaymentsIdCancel: PostTreasuryOutboundPaymentsIdCancel
  getTreasuryOutboundTransfers: GetTreasuryOutboundTransfers
  postTreasuryOutboundTransfers: PostTreasuryOutboundTransfers
  getTreasuryOutboundTransfersOutboundTransfer: GetTreasuryOutboundTransfersOutboundTransfer
  postTreasuryOutboundTransfersOutboundTransferCancel: PostTreasuryOutboundTransfersOutboundTransferCancel
  getTreasuryReceivedCredits: GetTreasuryReceivedCredits
  getTreasuryReceivedCreditsId: GetTreasuryReceivedCreditsId
  getTreasuryReceivedDebits: GetTreasuryReceivedDebits
  getTreasuryReceivedDebitsId: GetTreasuryReceivedDebitsId
  getTreasuryTransactionEntries: GetTreasuryTransactionEntries
  getTreasuryTransactionEntriesId: GetTreasuryTransactionEntriesId
  getTreasuryTransactions: GetTreasuryTransactions
  getTreasuryTransactionsId: GetTreasuryTransactionsId
  getWebhookEndpoints: GetWebhookEndpoints
  postWebhookEndpoints: PostWebhookEndpoints
  deleteWebhookEndpointsWebhookEndpoint: DeleteWebhookEndpointsWebhookEndpoint
  getWebhookEndpointsWebhookEndpoint: GetWebhookEndpointsWebhookEndpoint
  postWebhookEndpointsWebhookEndpoint: PostWebhookEndpointsWebhookEndpoint
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const getAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountRequestBodySchema = z.never().optional()

  const getAccountResponseBodyValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  // getAccount
  router.get(
    `/v1/account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getAccountQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccount(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getAccountResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountLinksRequestBodySchema = z.never()

  const postAccountLinksResponseBodyValidator = responseValidationFactory(
    [["200", s_account_link]],
    s_error,
  )

  // postAccountLinks
  router.post(
    `/v1/account_links`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postAccountLinksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_account_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountLinks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAccountLinksResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountSessionsRequestBodySchema = z.never()

  const postAccountSessionsResponseBodyValidator = responseValidationFactory(
    [["200", s_account_session]],
    s_error,
  )

  // postAccountSessions
  router.post(
    `/v1/account_sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postAccountSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_account_session>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAccountSessionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsRequestBodySchema = z.never().optional()

  const getAccountsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_account)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/accounts")),
        }),
      ],
    ],
    s_error,
  )

  // getAccounts
  router.get(
    `/v1/accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getAccountsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_account[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getAccountsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsRequestBodySchema = z.never().optional()

  const postAccountsResponseBodyValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  // postAccounts
  router.post(
    `/v1/accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAccountsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountRequestBodySchema = z.never().optional()

  const deleteAccountsAccountResponseBodyValidator = responseValidationFactory(
    [["200", s_deleted_account]],
    s_error,
  )

  // deleteAccountsAccount
  router.delete(
    `/v1/accounts/:account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteAccountsAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteAccountsAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteAccountsAccount(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteAccountsAccountResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountRequestBodySchema = z.never().optional()

  const getAccountsAccountResponseBodyValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  // getAccountsAccount
  router.get(
    `/v1/accounts/:account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccount(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getAccountsAccountResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountRequestBodySchema = z.never().optional()

  const postAccountsAccountResponseBodyValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  // postAccountsAccount
  router.post(
    `/v1/accounts/:account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccount(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAccountsAccountResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountBankAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountBankAccountsRequestBodySchema = z.never().optional()

  const postAccountsAccountBankAccountsResponseBodyValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  // postAccountsAccountBankAccounts
  router.post(
    `/v1/accounts/:account/bank_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountBankAccountsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountBankAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountBankAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountBankAccountsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountBankAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const deleteAccountsAccountBankAccountsIdResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_external_account]], s_error)

  // deleteAccountsAccountBankAccountsId
  router.delete(
    `/v1/accounts/:account/bank_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteAccountsAccountBankAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteAccountsAccountBankAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteAccountsAccountBankAccountsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteAccountsAccountBankAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const getAccountsAccountBankAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountBankAccountsIdRequestBodySchema = z.never().optional()

  const getAccountsAccountBankAccountsIdResponseBodyValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  // getAccountsAccountBankAccountsId
  router.get(
    `/v1/accounts/:account/bank_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountBankAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountBankAccountsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountBankAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountBankAccountsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getAccountsAccountBankAccountsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountBankAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const postAccountsAccountBankAccountsIdResponseBodyValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  // postAccountsAccountBankAccountsId
  router.post(
    `/v1/accounts/:account/bank_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountBankAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountBankAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountBankAccountsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountBankAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountCapabilitiesParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountCapabilitiesQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountCapabilitiesRequestBodySchema = z.never().optional()

  const getAccountsAccountCapabilitiesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_capability)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getAccountsAccountCapabilities
  router.get(
    `/v1/accounts/:account/capabilities`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountCapabilitiesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountCapabilitiesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountCapabilitiesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_capability[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountCapabilities(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getAccountsAccountCapabilitiesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountCapabilitiesCapabilityParamSchema = z.object({
    account: z.string().max(5000),
    capability: z.string(),
  })

  const getAccountsAccountCapabilitiesCapabilityQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountCapabilitiesCapabilityRequestBodySchema = z
    .never()
    .optional()

  const getAccountsAccountCapabilitiesCapabilityResponseBodyValidator =
    responseValidationFactory([["200", s_capability]], s_error)

  // getAccountsAccountCapabilitiesCapability
  router.get(
    `/v1/accounts/:account/capabilities/:capability`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountCapabilitiesCapabilityParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountCapabilitiesCapabilityQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountCapabilitiesCapabilityRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_capability>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountCapabilitiesCapability(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getAccountsAccountCapabilitiesCapabilityResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountCapabilitiesCapabilityParamSchema = z.object({
    account: z.string().max(5000),
    capability: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountCapabilitiesCapabilityRequestBodySchema = z
    .never()
    .optional()

  const postAccountsAccountCapabilitiesCapabilityResponseBodyValidator =
    responseValidationFactory([["200", s_capability]], s_error)

  // postAccountsAccountCapabilitiesCapability
  router.post(
    `/v1/accounts/:account/capabilities/:capability`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountCapabilitiesCapabilityParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountCapabilitiesCapabilityRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_capability>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountCapabilitiesCapability(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountCapabilitiesCapabilityResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountExternalAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountExternalAccountsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    object: z.enum(["bank_account", "card"]).optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountExternalAccountsRequestBodySchema = z
    .never()
    .optional()

  const getAccountsAccountExternalAccountsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(
              z.union([z.lazy(() => s_bank_account), z.lazy(() => s_card)]),
            ),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getAccountsAccountExternalAccounts
  router.get(
    `/v1/accounts/:account/external_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountExternalAccountsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountExternalAccountsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountExternalAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: (t_bank_account | t_card)[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountExternalAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getAccountsAccountExternalAccountsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountExternalAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountExternalAccountsRequestBodySchema = z
    .never()
    .optional()

  const postAccountsAccountExternalAccountsResponseBodyValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  // postAccountsAccountExternalAccounts
  router.post(
    `/v1/accounts/:account/external_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountExternalAccountsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountExternalAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountExternalAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountExternalAccountsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountExternalAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const deleteAccountsAccountExternalAccountsIdResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_external_account]], s_error)

  // deleteAccountsAccountExternalAccountsId
  router.delete(
    `/v1/accounts/:account/external_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteAccountsAccountExternalAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteAccountsAccountExternalAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteAccountsAccountExternalAccountsId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteAccountsAccountExternalAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const getAccountsAccountExternalAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountExternalAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const getAccountsAccountExternalAccountsIdResponseBodyValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  // getAccountsAccountExternalAccountsId
  router.get(
    `/v1/accounts/:account/external_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountExternalAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountExternalAccountsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountExternalAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountExternalAccountsId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getAccountsAccountExternalAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountExternalAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const postAccountsAccountExternalAccountsIdResponseBodyValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  // postAccountsAccountExternalAccountsId
  router.post(
    `/v1/accounts/:account/external_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountExternalAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountExternalAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountExternalAccountsId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountExternalAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountLoginLinksParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountLoginLinksRequestBodySchema = z.never().optional()

  const postAccountsAccountLoginLinksResponseBodyValidator =
    responseValidationFactory([["200", s_login_link]], s_error)

  // postAccountsAccountLoginLinks
  router.post(
    `/v1/accounts/:account/login_links`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountLoginLinksParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountLoginLinksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_login_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountLoginLinks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountLoginLinksResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountPeopleParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountPeopleQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    relationship: z
      .object({
        authorizer: PermissiveBoolean.optional(),
        director: PermissiveBoolean.optional(),
        executive: PermissiveBoolean.optional(),
        legal_guardian: PermissiveBoolean.optional(),
        owner: PermissiveBoolean.optional(),
        representative: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPeopleRequestBodySchema = z.never().optional()

  const getAccountsAccountPeopleResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_person)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getAccountsAccountPeople
  router.get(
    `/v1/accounts/:account/people`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountPeopleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountPeopleQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountPeopleRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_person[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountPeople(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getAccountsAccountPeopleResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountPeopleParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPeopleRequestBodySchema = z.never().optional()

  const postAccountsAccountPeopleResponseBodyValidator =
    responseValidationFactory([["200", s_person]], s_error)

  // postAccountsAccountPeople
  router.post(
    `/v1/accounts/:account/people`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountPeopleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountPeopleRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountPeople(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAccountsAccountPeopleResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountPeoplePersonRequestBodySchema = z
    .never()
    .optional()

  const deleteAccountsAccountPeoplePersonResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_person]], s_error)

  // deleteAccountsAccountPeoplePerson
  router.delete(
    `/v1/accounts/:account/people/:person`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteAccountsAccountPeoplePersonParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteAccountsAccountPeoplePersonRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteAccountsAccountPeoplePerson(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteAccountsAccountPeoplePersonResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const getAccountsAccountPeoplePersonQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPeoplePersonRequestBodySchema = z.never().optional()

  const getAccountsAccountPeoplePersonResponseBodyValidator =
    responseValidationFactory([["200", s_person]], s_error)

  // getAccountsAccountPeoplePerson
  router.get(
    `/v1/accounts/:account/people/:person`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountPeoplePersonParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountPeoplePersonQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountPeoplePersonRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountPeoplePerson(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getAccountsAccountPeoplePersonResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPeoplePersonRequestBodySchema = z.never().optional()

  const postAccountsAccountPeoplePersonResponseBodyValidator =
    responseValidationFactory([["200", s_person]], s_error)

  // postAccountsAccountPeoplePerson
  router.post(
    `/v1/accounts/:account/people/:person`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountPeoplePersonParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountPeoplePersonRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountPeoplePerson(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountPeoplePersonResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountPersonsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountPersonsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    relationship: z
      .object({
        authorizer: PermissiveBoolean.optional(),
        director: PermissiveBoolean.optional(),
        executive: PermissiveBoolean.optional(),
        legal_guardian: PermissiveBoolean.optional(),
        owner: PermissiveBoolean.optional(),
        representative: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPersonsRequestBodySchema = z.never().optional()

  const getAccountsAccountPersonsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_person)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getAccountsAccountPersons
  router.get(
    `/v1/accounts/:account/persons`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountPersonsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountPersonsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountPersonsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_person[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountPersons(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getAccountsAccountPersonsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountPersonsParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPersonsRequestBodySchema = z.never().optional()

  const postAccountsAccountPersonsResponseBodyValidator =
    responseValidationFactory([["200", s_person]], s_error)

  // postAccountsAccountPersons
  router.post(
    `/v1/accounts/:account/persons`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountPersonsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountPersonsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountPersons(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountPersonsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountPersonsPersonRequestBodySchema = z
    .never()
    .optional()

  const deleteAccountsAccountPersonsPersonResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_person]], s_error)

  // deleteAccountsAccountPersonsPerson
  router.delete(
    `/v1/accounts/:account/persons/:person`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteAccountsAccountPersonsPersonParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteAccountsAccountPersonsPersonRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteAccountsAccountPersonsPerson(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteAccountsAccountPersonsPersonResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const getAccountsAccountPersonsPersonQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPersonsPersonRequestBodySchema = z.never().optional()

  const getAccountsAccountPersonsPersonResponseBodyValidator =
    responseValidationFactory([["200", s_person]], s_error)

  // getAccountsAccountPersonsPerson
  router.get(
    `/v1/accounts/:account/persons/:person`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAccountsAccountPersonsPersonParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAccountsAccountPersonsPersonQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAccountsAccountPersonsPersonRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAccountsAccountPersonsPerson(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getAccountsAccountPersonsPersonResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPersonsPersonRequestBodySchema = z.never().optional()

  const postAccountsAccountPersonsPersonResponseBodyValidator =
    responseValidationFactory([["200", s_person]], s_error)

  // postAccountsAccountPersonsPerson
  router.post(
    `/v1/accounts/:account/persons/:person`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountPersonsPersonParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountPersonsPersonRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_person>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountPersonsPerson(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postAccountsAccountPersonsPersonResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postAccountsAccountRejectParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountRejectRequestBodySchema = z.never()

  const postAccountsAccountRejectResponseBodyValidator =
    responseValidationFactory([["200", s_account]], s_error)

  // postAccountsAccountReject
  router.post(
    `/v1/accounts/:account/reject`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postAccountsAccountRejectParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postAccountsAccountRejectRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAccountsAccountReject(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAccountsAccountRejectResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getApplePayDomainsQuerySchema = z.object({
    domain_name: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplePayDomainsRequestBodySchema = z.never().optional()

  const getApplePayDomainsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_apple_pay_domain),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/apple_pay/domains")),
        }),
      ],
    ],
    s_error,
  )

  // getApplePayDomains
  router.get(
    `/v1/apple_pay/domains`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getApplePayDomainsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getApplePayDomainsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_apple_pay_domain[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getApplePayDomains(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getApplePayDomainsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplePayDomainsRequestBodySchema = z.never()

  const postApplePayDomainsResponseBodyValidator = responseValidationFactory(
    [["200", s_apple_pay_domain]],
    s_error,
  )

  // postApplePayDomains
  router.post(
    `/v1/apple_pay/domains`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postApplePayDomainsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_apple_pay_domain>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postApplePayDomains(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postApplePayDomainsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteApplePayDomainsDomainParamSchema = z.object({
    domain: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteApplePayDomainsDomainRequestBodySchema = z.never().optional()

  const deleteApplePayDomainsDomainResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_apple_pay_domain]], s_error)

  // deleteApplePayDomainsDomain
  router.delete(
    `/v1/apple_pay/domains/:domain`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteApplePayDomainsDomainParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteApplePayDomainsDomainRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_apple_pay_domain>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteApplePayDomainsDomain(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteApplePayDomainsDomainResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getApplePayDomainsDomainParamSchema = z.object({
    domain: z.string().max(5000),
  })

  const getApplePayDomainsDomainQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplePayDomainsDomainRequestBodySchema = z.never().optional()

  const getApplePayDomainsDomainResponseBodyValidator =
    responseValidationFactory([["200", s_apple_pay_domain]], s_error)

  // getApplePayDomainsDomain
  router.get(
    `/v1/apple_pay/domains/:domain`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getApplePayDomainsDomainParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getApplePayDomainsDomainQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getApplePayDomainsDomainRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_apple_pay_domain>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getApplePayDomainsDomain(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getApplePayDomainsDomainResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getApplicationFeesQuerySchema = z.object({
    charge: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesRequestBodySchema = z.never().optional()

  const getApplicationFeesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_application_fee)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/application_fees")),
        }),
      ],
    ],
    s_error,
  )

  // getApplicationFees
  router.get(
    `/v1/application_fees`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getApplicationFeesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getApplicationFeesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_application_fee[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getApplicationFees(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getApplicationFeesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getApplicationFeesFeeRefundsIdParamSchema = z.object({
    fee: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getApplicationFeesFeeRefundsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesFeeRefundsIdRequestBodySchema = z.never().optional()

  const getApplicationFeesFeeRefundsIdResponseBodyValidator =
    responseValidationFactory([["200", s_fee_refund]], s_error)

  // getApplicationFeesFeeRefundsId
  router.get(
    `/v1/application_fees/:fee/refunds/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getApplicationFeesFeeRefundsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getApplicationFeesFeeRefundsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getApplicationFeesFeeRefundsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_fee_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getApplicationFeesFeeRefundsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getApplicationFeesFeeRefundsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postApplicationFeesFeeRefundsIdParamSchema = z.object({
    fee: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplicationFeesFeeRefundsIdRequestBodySchema = z.never().optional()

  const postApplicationFeesFeeRefundsIdResponseBodyValidator =
    responseValidationFactory([["200", s_fee_refund]], s_error)

  // postApplicationFeesFeeRefundsId
  router.post(
    `/v1/application_fees/:fee/refunds/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postApplicationFeesFeeRefundsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postApplicationFeesFeeRefundsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_fee_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postApplicationFeesFeeRefundsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postApplicationFeesFeeRefundsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getApplicationFeesIdParamSchema = z.object({id: z.string().max(5000)})

  const getApplicationFeesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesIdRequestBodySchema = z.never().optional()

  const getApplicationFeesIdResponseBodyValidator = responseValidationFactory(
    [["200", s_application_fee]],
    s_error,
  )

  // getApplicationFeesId
  router.get(
    `/v1/application_fees/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getApplicationFeesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getApplicationFeesIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getApplicationFeesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_application_fee>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getApplicationFeesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getApplicationFeesIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postApplicationFeesIdRefundParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplicationFeesIdRefundRequestBodySchema = z.never().optional()

  const postApplicationFeesIdRefundResponseBodyValidator =
    responseValidationFactory([["200", s_application_fee]], s_error)

  // postApplicationFeesIdRefund
  router.post(
    `/v1/application_fees/:id/refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postApplicationFeesIdRefundParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postApplicationFeesIdRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_application_fee>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postApplicationFeesIdRefund(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postApplicationFeesIdRefundResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getApplicationFeesIdRefundsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getApplicationFeesIdRefundsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesIdRefundsRequestBodySchema = z.never().optional()

  const getApplicationFeesIdRefundsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_fee_refund)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getApplicationFeesIdRefunds
  router.get(
    `/v1/application_fees/:id/refunds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getApplicationFeesIdRefundsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getApplicationFeesIdRefundsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getApplicationFeesIdRefundsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_fee_refund[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getApplicationFeesIdRefunds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getApplicationFeesIdRefundsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postApplicationFeesIdRefundsParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplicationFeesIdRefundsRequestBodySchema = z.never().optional()

  const postApplicationFeesIdRefundsResponseBodyValidator =
    responseValidationFactory([["200", s_fee_refund]], s_error)

  // postApplicationFeesIdRefunds
  router.post(
    `/v1/application_fees/:id/refunds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postApplicationFeesIdRefundsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postApplicationFeesIdRefundsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_fee_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postApplicationFeesIdRefunds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postApplicationFeesIdRefundsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAppsSecretsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAppsSecretsRequestBodySchema = z.never().optional()

  const getAppsSecretsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_apps_secret),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/apps/secrets")),
        }),
      ],
    ],
    s_error,
  )

  // getAppsSecrets
  router.get(
    `/v1/apps/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getAppsSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAppsSecretsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_apps_secret[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAppsSecrets(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getAppsSecretsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAppsSecretsRequestBodySchema = z.never()

  const postAppsSecretsResponseBodyValidator = responseValidationFactory(
    [["200", s_apps_secret]],
    s_error,
  )

  // postAppsSecrets
  router.post(
    `/v1/apps/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postAppsSecretsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_apps_secret>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAppsSecrets(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAppsSecretsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAppsSecretsDeleteRequestBodySchema = z.never()

  const postAppsSecretsDeleteResponseBodyValidator = responseValidationFactory(
    [["200", s_apps_secret]],
    s_error,
  )

  // postAppsSecretsDelete
  router.post(
    `/v1/apps/secrets/delete`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postAppsSecretsDeleteRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_apps_secret>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postAppsSecretsDelete(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postAppsSecretsDeleteResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getAppsSecretsFindQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    name: z.string().max(5000),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAppsSecretsFindRequestBodySchema = z.never().optional()

  const getAppsSecretsFindResponseBodyValidator = responseValidationFactory(
    [["200", s_apps_secret]],
    s_error,
  )

  // getAppsSecretsFind
  router.get(
    `/v1/apps/secrets/find`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getAppsSecretsFindQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getAppsSecretsFindRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_apps_secret>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAppsSecretsFind(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getAppsSecretsFindResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBalanceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceRequestBodySchema = z.never().optional()

  const getBalanceResponseBodyValidator = responseValidationFactory(
    [["200", s_balance]],
    s_error,
  )

  // getBalance
  router.get(
    `/v1/balance`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBalanceQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBalanceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_balance>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBalance(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBalanceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBalanceHistoryQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payout: z.string().max(5000).optional(),
    source: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceHistoryRequestBodySchema = z.never().optional()

  const getBalanceHistoryResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_balance_transaction)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/balance_transactions")),
        }),
      ],
    ],
    s_error,
  )

  // getBalanceHistory
  router.get(
    `/v1/balance/history`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBalanceHistoryQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBalanceHistoryRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_balance_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBalanceHistory(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBalanceHistoryResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBalanceHistoryIdParamSchema = z.object({id: z.string().max(5000)})

  const getBalanceHistoryIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceHistoryIdRequestBodySchema = z.never().optional()

  const getBalanceHistoryIdResponseBodyValidator = responseValidationFactory(
    [["200", s_balance_transaction]],
    s_error,
  )

  // getBalanceHistoryId
  router.get(
    `/v1/balance/history/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBalanceHistoryIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBalanceHistoryIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBalanceHistoryIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_balance_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBalanceHistoryId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBalanceHistoryIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBalanceTransactionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payout: z.string().max(5000).optional(),
    source: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceTransactionsRequestBodySchema = z.never().optional()

  const getBalanceTransactionsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_balance_transaction)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/balance_transactions")),
        }),
      ],
    ],
    s_error,
  )

  // getBalanceTransactions
  router.get(
    `/v1/balance_transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBalanceTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBalanceTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_balance_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBalanceTransactions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBalanceTransactionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBalanceTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBalanceTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceTransactionsIdRequestBodySchema = z.never().optional()

  const getBalanceTransactionsIdResponseBodyValidator =
    responseValidationFactory([["200", s_balance_transaction]], s_error)

  // getBalanceTransactionsId
  router.get(
    `/v1/balance_transactions/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBalanceTransactionsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBalanceTransactionsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBalanceTransactionsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_balance_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBalanceTransactionsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBalanceTransactionsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingAlertsQuerySchema = z.object({
    alert_type: z.enum(["usage_threshold"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    meter: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingAlertsRequestBodySchema = z.never().optional()

  const getBillingAlertsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_billing_alert)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/billing/alerts")),
        }),
      ],
    ],
    s_error,
  )

  // getBillingAlerts
  router.get(
    `/v1/billing/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBillingAlertsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingAlertsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_billing_alert[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingAlerts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBillingAlertsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsRequestBodySchema = z.never()

  const postBillingAlertsResponseBodyValidator = responseValidationFactory(
    [["200", s_billing_alert]],
    s_error,
  )

  // postBillingAlerts
  router.post(
    `/v1/billing/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postBillingAlertsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_alert>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingAlerts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postBillingAlertsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingAlertsIdParamSchema = z.object({id: z.string().max(5000)})

  const getBillingAlertsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingAlertsIdRequestBodySchema = z.never().optional()

  const getBillingAlertsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_billing_alert]],
    s_error,
  )

  // getBillingAlertsId
  router.get(
    `/v1/billing/alerts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBillingAlertsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBillingAlertsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingAlertsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_alert>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingAlertsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBillingAlertsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingAlertsIdActivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsIdActivateRequestBodySchema = z.never().optional()

  const postBillingAlertsIdActivateResponseBodyValidator =
    responseValidationFactory([["200", s_billing_alert]], s_error)

  // postBillingAlertsIdActivate
  router.post(
    `/v1/billing/alerts/:id/activate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingAlertsIdActivateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingAlertsIdActivateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_alert>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingAlertsIdActivate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingAlertsIdActivateResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingAlertsIdArchiveParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsIdArchiveRequestBodySchema = z.never().optional()

  const postBillingAlertsIdArchiveResponseBodyValidator =
    responseValidationFactory([["200", s_billing_alert]], s_error)

  // postBillingAlertsIdArchive
  router.post(
    `/v1/billing/alerts/:id/archive`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingAlertsIdArchiveParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingAlertsIdArchiveRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_alert>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingAlertsIdArchive(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingAlertsIdArchiveResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingAlertsIdDeactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsIdDeactivateRequestBodySchema = z.never().optional()

  const postBillingAlertsIdDeactivateResponseBodyValidator =
    responseValidationFactory([["200", s_billing_alert]], s_error)

  // postBillingAlertsIdDeactivate
  router.post(
    `/v1/billing/alerts/:id/deactivate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingAlertsIdDeactivateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingAlertsIdDeactivateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_alert>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingAlertsIdDeactivate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingAlertsIdDeactivateResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingCreditBalanceSummaryQuerySchema = z.object({
    customer: z.string().max(5000),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    filter: z.object({
      applicability_scope: z
        .object({
          price_type: z.enum(["metered"]).optional(),
          prices: z.array(z.object({id: z.string().max(5000)})).optional(),
        })
        .optional(),
      credit_grant: z.string().max(5000).optional(),
      type: z.enum(["applicability_scope", "credit_grant"]),
    }),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditBalanceSummaryRequestBodySchema = z.never().optional()

  const getBillingCreditBalanceSummaryResponseBodyValidator =
    responseValidationFactory(
      [["200", s_billing_credit_balance_summary]],
      s_error,
    )

  // getBillingCreditBalanceSummary
  router.get(
    `/v1/billing/credit_balance_summary`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBillingCreditBalanceSummaryQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingCreditBalanceSummaryRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_credit_balance_summary>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingCreditBalanceSummary(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getBillingCreditBalanceSummaryResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingCreditBalanceTransactionsQuerySchema = z.object({
    credit_grant: z.string().max(5000).optional(),
    customer: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditBalanceTransactionsRequestBodySchema = z
    .never()
    .optional()

  const getBillingCreditBalanceTransactionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_billing_credit_balance_transaction)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/billing/credit_grants")),
          }),
        ],
      ],
      s_error,
    )

  // getBillingCreditBalanceTransactions
  router.get(
    `/v1/billing/credit_balance_transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBillingCreditBalanceTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingCreditBalanceTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_billing_credit_balance_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingCreditBalanceTransactions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getBillingCreditBalanceTransactionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingCreditBalanceTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingCreditBalanceTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditBalanceTransactionsIdRequestBodySchema = z
    .never()
    .optional()

  const getBillingCreditBalanceTransactionsIdResponseBodyValidator =
    responseValidationFactory(
      [["200", s_billing_credit_balance_transaction]],
      s_error,
    )

  // getBillingCreditBalanceTransactionsId
  router.get(
    `/v1/billing/credit_balance_transactions/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBillingCreditBalanceTransactionsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBillingCreditBalanceTransactionsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingCreditBalanceTransactionsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_credit_balance_transaction>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingCreditBalanceTransactionsId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getBillingCreditBalanceTransactionsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingCreditGrantsQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditGrantsRequestBodySchema = z.never().optional()

  const getBillingCreditGrantsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_billing_credit_grant)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/billing/credit_grants")),
        }),
      ],
    ],
    s_error,
  )

  // getBillingCreditGrants
  router.get(
    `/v1/billing/credit_grants`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBillingCreditGrantsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingCreditGrantsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_billing_credit_grant[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingCreditGrants(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBillingCreditGrantsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsRequestBodySchema = z.never()

  const postBillingCreditGrantsResponseBodyValidator =
    responseValidationFactory([["200", s_billing_credit_grant]], s_error)

  // postBillingCreditGrants
  router.post(
    `/v1/billing/credit_grants`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postBillingCreditGrantsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_credit_grant>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingCreditGrants(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postBillingCreditGrantsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingCreditGrantsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingCreditGrantsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditGrantsIdRequestBodySchema = z.never().optional()

  const getBillingCreditGrantsIdResponseBodyValidator =
    responseValidationFactory([["200", s_billing_credit_grant]], s_error)

  // getBillingCreditGrantsId
  router.get(
    `/v1/billing/credit_grants/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBillingCreditGrantsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBillingCreditGrantsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingCreditGrantsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_credit_grant>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingCreditGrantsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBillingCreditGrantsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingCreditGrantsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsIdRequestBodySchema = z.never().optional()

  const postBillingCreditGrantsIdResponseBodyValidator =
    responseValidationFactory([["200", s_billing_credit_grant]], s_error)

  // postBillingCreditGrantsId
  router.post(
    `/v1/billing/credit_grants/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingCreditGrantsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingCreditGrantsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_credit_grant>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingCreditGrantsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postBillingCreditGrantsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingCreditGrantsIdExpireParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsIdExpireRequestBodySchema = z.never().optional()

  const postBillingCreditGrantsIdExpireResponseBodyValidator =
    responseValidationFactory([["200", s_billing_credit_grant]], s_error)

  // postBillingCreditGrantsIdExpire
  router.post(
    `/v1/billing/credit_grants/:id/expire`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingCreditGrantsIdExpireParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingCreditGrantsIdExpireRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_credit_grant>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingCreditGrantsIdExpire(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingCreditGrantsIdExpireResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingCreditGrantsIdVoidParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsIdVoidRequestBodySchema = z.never().optional()

  const postBillingCreditGrantsIdVoidResponseBodyValidator =
    responseValidationFactory([["200", s_billing_credit_grant]], s_error)

  // postBillingCreditGrantsIdVoid
  router.post(
    `/v1/billing/credit_grants/:id/void`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingCreditGrantsIdVoidParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingCreditGrantsIdVoidRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_credit_grant>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingCreditGrantsIdVoid(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingCreditGrantsIdVoidResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMeterEventAdjustmentsRequestBodySchema = z.never()

  const postBillingMeterEventAdjustmentsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_billing_meter_event_adjustment]],
      s_error,
    )

  // postBillingMeterEventAdjustments
  router.post(
    `/v1/billing/meter_event_adjustments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postBillingMeterEventAdjustmentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_meter_event_adjustment>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingMeterEventAdjustments(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingMeterEventAdjustmentsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMeterEventsRequestBodySchema = z.never()

  const postBillingMeterEventsResponseBodyValidator = responseValidationFactory(
    [["200", s_billing_meter_event]],
    s_error,
  )

  // postBillingMeterEvents
  router.post(
    `/v1/billing/meter_events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postBillingMeterEventsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_meter_event>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingMeterEvents(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postBillingMeterEventsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingMetersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingMetersRequestBodySchema = z.never().optional()

  const getBillingMetersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_billing_meter),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/billing/meters")),
        }),
      ],
    ],
    s_error,
  )

  // getBillingMeters
  router.get(
    `/v1/billing/meters`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBillingMetersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingMetersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_billing_meter[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingMeters(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBillingMetersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersRequestBodySchema = z.never()

  const postBillingMetersResponseBodyValidator = responseValidationFactory(
    [["200", s_billing_meter]],
    s_error,
  )

  // postBillingMeters
  router.post(
    `/v1/billing/meters`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postBillingMetersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_meter>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingMeters(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postBillingMetersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingMetersIdParamSchema = z.object({id: z.string().max(5000)})

  const getBillingMetersIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingMetersIdRequestBodySchema = z.never().optional()

  const getBillingMetersIdResponseBodyValidator = responseValidationFactory(
    [["200", s_billing_meter]],
    s_error,
  )

  // getBillingMetersId
  router.get(
    `/v1/billing/meters/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBillingMetersIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBillingMetersIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingMetersIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_meter>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingMetersId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getBillingMetersIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingMetersIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersIdRequestBodySchema = z.never().optional()

  const postBillingMetersIdResponseBodyValidator = responseValidationFactory(
    [["200", s_billing_meter]],
    s_error,
  )

  // postBillingMetersId
  router.post(
    `/v1/billing/meters/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingMetersIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingMetersIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_meter>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingMetersId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postBillingMetersIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingMetersIdDeactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersIdDeactivateRequestBodySchema = z.never().optional()

  const postBillingMetersIdDeactivateResponseBodyValidator =
    responseValidationFactory([["200", s_billing_meter]], s_error)

  // postBillingMetersIdDeactivate
  router.post(
    `/v1/billing/meters/:id/deactivate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingMetersIdDeactivateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingMetersIdDeactivateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_meter>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingMetersIdDeactivate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingMetersIdDeactivateResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingMetersIdEventSummariesParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingMetersIdEventSummariesQuerySchema = z.object({
    customer: z.string().max(5000),
    end_time: z.coerce.number(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    start_time: z.coerce.number(),
    starting_after: z.string().max(5000).optional(),
    value_grouping_window: z.enum(["day", "hour"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingMetersIdEventSummariesRequestBodySchema = z.never().optional()

  const getBillingMetersIdEventSummariesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_billing_meter_event_summary),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/billing/meters/[^/]+/event_summaries")),
          }),
        ],
      ],
      s_error,
    )

  // getBillingMetersIdEventSummaries
  router.get(
    `/v1/billing/meters/:id/event_summaries`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBillingMetersIdEventSummariesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBillingMetersIdEventSummariesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingMetersIdEventSummariesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_billing_meter_event_summary[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingMetersIdEventSummaries(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getBillingMetersIdEventSummariesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingMetersIdReactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersIdReactivateRequestBodySchema = z.never().optional()

  const postBillingMetersIdReactivateResponseBodyValidator =
    responseValidationFactory([["200", s_billing_meter]], s_error)

  // postBillingMetersIdReactivate
  router.post(
    `/v1/billing/meters/:id/reactivate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingMetersIdReactivateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingMetersIdReactivateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_meter>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingMetersIdReactivate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingMetersIdReactivateResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingPortalConfigurationsQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    is_default: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingPortalConfigurationsRequestBodySchema = z.never().optional()

  const getBillingPortalConfigurationsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_billing_portal_configuration),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/billing_portal/configurations")),
          }),
        ],
      ],
      s_error,
    )

  // getBillingPortalConfigurations
  router.get(
    `/v1/billing_portal/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getBillingPortalConfigurationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingPortalConfigurationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_billing_portal_configuration[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingPortalConfigurations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getBillingPortalConfigurationsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingPortalConfigurationsRequestBodySchema = z.never()

  const postBillingPortalConfigurationsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_billing_portal_configuration]],
      s_error,
    )

  // postBillingPortalConfigurations
  router.post(
    `/v1/billing_portal/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postBillingPortalConfigurationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_portal_configuration>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingPortalConfigurations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingPortalConfigurationsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getBillingPortalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getBillingPortalConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingPortalConfigurationsConfigurationRequestBodySchema = z
    .never()
    .optional()

  const getBillingPortalConfigurationsConfigurationResponseBodyValidator =
    responseValidationFactory(
      [["200", s_billing_portal_configuration]],
      s_error,
    )

  // getBillingPortalConfigurationsConfiguration
  router.get(
    `/v1/billing_portal/configurations/:configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getBillingPortalConfigurationsConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getBillingPortalConfigurationsConfigurationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getBillingPortalConfigurationsConfigurationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_portal_configuration>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getBillingPortalConfigurationsConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getBillingPortalConfigurationsConfigurationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postBillingPortalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingPortalConfigurationsConfigurationRequestBodySchema = z
    .never()
    .optional()

  const postBillingPortalConfigurationsConfigurationResponseBodyValidator =
    responseValidationFactory(
      [["200", s_billing_portal_configuration]],
      s_error,
    )

  // postBillingPortalConfigurationsConfiguration
  router.post(
    `/v1/billing_portal/configurations/:configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postBillingPortalConfigurationsConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postBillingPortalConfigurationsConfigurationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_portal_configuration>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingPortalConfigurationsConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postBillingPortalConfigurationsConfigurationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingPortalSessionsRequestBodySchema = z.never()

  const postBillingPortalSessionsResponseBodyValidator =
    responseValidationFactory([["200", s_billing_portal_session]], s_error)

  // postBillingPortalSessions
  router.post(
    `/v1/billing_portal/sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postBillingPortalSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_portal_session>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postBillingPortalSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postBillingPortalSessionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getChargesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
    transfer_group: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesRequestBodySchema = z.never().optional()

  const getChargesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_charge)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/charges")),
        }),
      ],
    ],
    s_error,
  )

  // getCharges
  router.get(
    `/v1/charges`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getChargesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getChargesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_charge[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCharges(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getChargesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesRequestBodySchema = z.never().optional()

  const postChargesResponseBodyValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  // postCharges
  router.post(
    `/v1/charges`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postChargesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_charge>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCharges(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postChargesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getChargesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesSearchRequestBodySchema = z.never().optional()

  const getChargesSearchResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_charge)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getChargesSearch
  router.get(
    `/v1/charges/search`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getChargesSearchQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getChargesSearchRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_charge[]
              has_more: boolean
              next_page?: (string | null) | undefined
              object: "search_result"
              total_count?: number | undefined
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getChargesSearch(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getChargesSearchResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getChargesChargeParamSchema = z.object({charge: z.string().max(5000)})

  const getChargesChargeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeRequestBodySchema = z.never().optional()

  const getChargesChargeResponseBodyValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  // getChargesCharge
  router.get(
    `/v1/charges/:charge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getChargesChargeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getChargesChargeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getChargesChargeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_charge>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getChargesCharge(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getChargesChargeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postChargesChargeParamSchema = z.object({charge: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeRequestBodySchema = z.never().optional()

  const postChargesChargeResponseBodyValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  // postChargesCharge
  router.post(
    `/v1/charges/:charge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postChargesChargeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postChargesChargeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_charge>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postChargesCharge(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postChargesChargeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postChargesChargeCaptureParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeCaptureRequestBodySchema = z.never().optional()

  const postChargesChargeCaptureResponseBodyValidator =
    responseValidationFactory([["200", s_charge]], s_error)

  // postChargesChargeCapture
  router.post(
    `/v1/charges/:charge/capture`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postChargesChargeCaptureParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postChargesChargeCaptureRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_charge>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postChargesChargeCapture(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postChargesChargeCaptureResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getChargesChargeDisputeParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const getChargesChargeDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeDisputeRequestBodySchema = z.never().optional()

  const getChargesChargeDisputeResponseBodyValidator =
    responseValidationFactory([["200", s_dispute]], s_error)

  // getChargesChargeDispute
  router.get(
    `/v1/charges/:charge/dispute`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getChargesChargeDisputeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getChargesChargeDisputeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getChargesChargeDisputeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getChargesChargeDispute(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getChargesChargeDisputeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postChargesChargeDisputeParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeDisputeRequestBodySchema = z.never().optional()

  const postChargesChargeDisputeResponseBodyValidator =
    responseValidationFactory([["200", s_dispute]], s_error)

  // postChargesChargeDispute
  router.post(
    `/v1/charges/:charge/dispute`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postChargesChargeDisputeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postChargesChargeDisputeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postChargesChargeDispute(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postChargesChargeDisputeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postChargesChargeDisputeCloseParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeDisputeCloseRequestBodySchema = z.never().optional()

  const postChargesChargeDisputeCloseResponseBodyValidator =
    responseValidationFactory([["200", s_dispute]], s_error)

  // postChargesChargeDisputeClose
  router.post(
    `/v1/charges/:charge/dispute/close`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postChargesChargeDisputeCloseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postChargesChargeDisputeCloseRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postChargesChargeDisputeClose(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postChargesChargeDisputeCloseResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postChargesChargeRefundParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeRefundRequestBodySchema = z.never().optional()

  const postChargesChargeRefundResponseBodyValidator =
    responseValidationFactory([["200", s_charge]], s_error)

  // postChargesChargeRefund
  router.post(
    `/v1/charges/:charge/refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postChargesChargeRefundParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postChargesChargeRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_charge>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postChargesChargeRefund(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postChargesChargeRefundResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getChargesChargeRefundsParamSchema = z.object({charge: z.string()})

  const getChargesChargeRefundsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeRefundsRequestBodySchema = z.never().optional()

  const getChargesChargeRefundsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_refund)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getChargesChargeRefunds
  router.get(
    `/v1/charges/:charge/refunds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getChargesChargeRefundsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getChargesChargeRefundsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getChargesChargeRefundsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_refund[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getChargesChargeRefunds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getChargesChargeRefundsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postChargesChargeRefundsParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeRefundsRequestBodySchema = z.never().optional()

  const postChargesChargeRefundsResponseBodyValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  // postChargesChargeRefunds
  router.post(
    `/v1/charges/:charge/refunds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postChargesChargeRefundsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postChargesChargeRefundsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postChargesChargeRefunds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postChargesChargeRefundsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getChargesChargeRefundsRefundParamSchema = z.object({
    charge: z.string(),
    refund: z.string(),
  })

  const getChargesChargeRefundsRefundQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeRefundsRefundRequestBodySchema = z.never().optional()

  const getChargesChargeRefundsRefundResponseBodyValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  // getChargesChargeRefundsRefund
  router.get(
    `/v1/charges/:charge/refunds/:refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getChargesChargeRefundsRefundParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getChargesChargeRefundsRefundQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getChargesChargeRefundsRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getChargesChargeRefundsRefund(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getChargesChargeRefundsRefundResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postChargesChargeRefundsRefundParamSchema = z.object({
    charge: z.string(),
    refund: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeRefundsRefundRequestBodySchema = z.never().optional()

  const postChargesChargeRefundsRefundResponseBodyValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  // postChargesChargeRefundsRefund
  router.post(
    `/v1/charges/:charge/refunds/:refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postChargesChargeRefundsRefundParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postChargesChargeRefundsRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postChargesChargeRefundsRefund(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postChargesChargeRefundsRefundResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCheckoutSessionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    customer_details: z.object({email: z.string()}).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    payment_link: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["complete", "expired", "open"]).optional(),
    subscription: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCheckoutSessionsRequestBodySchema = z.never().optional()

  const getCheckoutSessionsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_checkout_session)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getCheckoutSessions
  router.get(
    `/v1/checkout/sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCheckoutSessionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCheckoutSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_checkout_session[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCheckoutSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCheckoutSessionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCheckoutSessionsRequestBodySchema = z.never().optional()

  const postCheckoutSessionsResponseBodyValidator = responseValidationFactory(
    [["200", s_checkout_session]],
    s_error,
  )

  // postCheckoutSessions
  router.post(
    `/v1/checkout/sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postCheckoutSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_checkout_session>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCheckoutSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCheckoutSessionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCheckoutSessionsSessionParamSchema = z.object({
    session: z.string().max(66),
  })

  const getCheckoutSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCheckoutSessionsSessionRequestBodySchema = z.never().optional()

  const getCheckoutSessionsSessionResponseBodyValidator =
    responseValidationFactory([["200", s_checkout_session]], s_error)

  // getCheckoutSessionsSession
  router.get(
    `/v1/checkout/sessions/:session`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCheckoutSessionsSessionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCheckoutSessionsSessionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCheckoutSessionsSessionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_checkout_session>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCheckoutSessionsSession(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCheckoutSessionsSessionResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCheckoutSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCheckoutSessionsSessionRequestBodySchema = z.never().optional()

  const postCheckoutSessionsSessionResponseBodyValidator =
    responseValidationFactory([["200", s_checkout_session]], s_error)

  // postCheckoutSessionsSession
  router.post(
    `/v1/checkout/sessions/:session`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCheckoutSessionsSessionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCheckoutSessionsSessionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_checkout_session>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCheckoutSessionsSession(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCheckoutSessionsSessionResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCheckoutSessionsSessionExpireParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCheckoutSessionsSessionExpireRequestBodySchema = z
    .never()
    .optional()

  const postCheckoutSessionsSessionExpireResponseBodyValidator =
    responseValidationFactory([["200", s_checkout_session]], s_error)

  // postCheckoutSessionsSessionExpire
  router.post(
    `/v1/checkout/sessions/:session/expire`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCheckoutSessionsSessionExpireParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCheckoutSessionsSessionExpireRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_checkout_session>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCheckoutSessionsSessionExpire(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCheckoutSessionsSessionExpireResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCheckoutSessionsSessionLineItemsParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getCheckoutSessionsSessionLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCheckoutSessionsSessionLineItemsRequestBodySchema = z
    .never()
    .optional()

  const getCheckoutSessionsSessionLineItemsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCheckoutSessionsSessionLineItems
  router.get(
    `/v1/checkout/sessions/:session/line_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCheckoutSessionsSessionLineItemsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCheckoutSessionsSessionLineItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCheckoutSessionsSessionLineItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCheckoutSessionsSessionLineItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCheckoutSessionsSessionLineItemsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getClimateOrdersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateOrdersRequestBodySchema = z.never().optional()

  const getClimateOrdersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_climate_order),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/climate/orders")),
        }),
      ],
    ],
    s_error,
  )

  // getClimateOrders
  router.get(
    `/v1/climate/orders`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getClimateOrdersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getClimateOrdersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_climate_order[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getClimateOrders(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getClimateOrdersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postClimateOrdersRequestBodySchema = z.never()

  const postClimateOrdersResponseBodyValidator = responseValidationFactory(
    [["200", s_climate_order]],
    s_error,
  )

  // postClimateOrders
  router.post(
    `/v1/climate/orders`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postClimateOrdersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_climate_order>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postClimateOrders(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postClimateOrdersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getClimateOrdersOrderParamSchema = z.object({
    order: z.string().max(5000),
  })

  const getClimateOrdersOrderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateOrdersOrderRequestBodySchema = z.never().optional()

  const getClimateOrdersOrderResponseBodyValidator = responseValidationFactory(
    [["200", s_climate_order]],
    s_error,
  )

  // getClimateOrdersOrder
  router.get(
    `/v1/climate/orders/:order`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getClimateOrdersOrderParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getClimateOrdersOrderQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getClimateOrdersOrderRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_climate_order>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getClimateOrdersOrder(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getClimateOrdersOrderResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postClimateOrdersOrderParamSchema = z.object({
    order: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postClimateOrdersOrderRequestBodySchema = z.never().optional()

  const postClimateOrdersOrderResponseBodyValidator = responseValidationFactory(
    [["200", s_climate_order]],
    s_error,
  )

  // postClimateOrdersOrder
  router.post(
    `/v1/climate/orders/:order`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postClimateOrdersOrderParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postClimateOrdersOrderRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_climate_order>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postClimateOrdersOrder(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postClimateOrdersOrderResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postClimateOrdersOrderCancelParamSchema = z.object({
    order: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postClimateOrdersOrderCancelRequestBodySchema = z.never().optional()

  const postClimateOrdersOrderCancelResponseBodyValidator =
    responseValidationFactory([["200", s_climate_order]], s_error)

  // postClimateOrdersOrderCancel
  router.post(
    `/v1/climate/orders/:order/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postClimateOrdersOrderCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postClimateOrdersOrderCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_climate_order>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postClimateOrdersOrderCancel(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postClimateOrdersOrderCancelResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getClimateProductsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateProductsRequestBodySchema = z.never().optional()

  const getClimateProductsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_climate_product),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/climate/products")),
        }),
      ],
    ],
    s_error,
  )

  // getClimateProducts
  router.get(
    `/v1/climate/products`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getClimateProductsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getClimateProductsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_climate_product[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getClimateProducts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getClimateProductsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getClimateProductsProductParamSchema = z.object({
    product: z.string().max(5000),
  })

  const getClimateProductsProductQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateProductsProductRequestBodySchema = z.never().optional()

  const getClimateProductsProductResponseBodyValidator =
    responseValidationFactory([["200", s_climate_product]], s_error)

  // getClimateProductsProduct
  router.get(
    `/v1/climate/products/:product`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getClimateProductsProductParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getClimateProductsProductQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getClimateProductsProductRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_climate_product>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getClimateProductsProduct(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getClimateProductsProductResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getClimateSuppliersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateSuppliersRequestBodySchema = z.never().optional()

  const getClimateSuppliersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_climate_supplier),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/climate/suppliers")),
        }),
      ],
    ],
    s_error,
  )

  // getClimateSuppliers
  router.get(
    `/v1/climate/suppliers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getClimateSuppliersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getClimateSuppliersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_climate_supplier[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getClimateSuppliers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getClimateSuppliersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getClimateSuppliersSupplierParamSchema = z.object({
    supplier: z.string().max(5000),
  })

  const getClimateSuppliersSupplierQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateSuppliersSupplierRequestBodySchema = z.never().optional()

  const getClimateSuppliersSupplierResponseBodyValidator =
    responseValidationFactory([["200", s_climate_supplier]], s_error)

  // getClimateSuppliersSupplier
  router.get(
    `/v1/climate/suppliers/:supplier`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getClimateSuppliersSupplierParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getClimateSuppliersSupplierQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getClimateSuppliersSupplierRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_climate_supplier>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getClimateSuppliersSupplier(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getClimateSuppliersSupplierResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getConfirmationTokensConfirmationTokenParamSchema = z.object({
    confirmation_token: z.string().max(5000),
  })

  const getConfirmationTokensConfirmationTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getConfirmationTokensConfirmationTokenRequestBodySchema = z
    .never()
    .optional()

  const getConfirmationTokensConfirmationTokenResponseBodyValidator =
    responseValidationFactory([["200", s_confirmation_token]], s_error)

  // getConfirmationTokensConfirmationToken
  router.get(
    `/v1/confirmation_tokens/:confirmation_token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getConfirmationTokensConfirmationTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getConfirmationTokensConfirmationTokenQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getConfirmationTokensConfirmationTokenRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_confirmation_token>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getConfirmationTokensConfirmationToken(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getConfirmationTokensConfirmationTokenResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCountrySpecsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCountrySpecsRequestBodySchema = z.never().optional()

  const getCountrySpecsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_country_spec),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/country_specs")),
        }),
      ],
    ],
    s_error,
  )

  // getCountrySpecs
  router.get(
    `/v1/country_specs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCountrySpecsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCountrySpecsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_country_spec[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCountrySpecs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCountrySpecsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCountrySpecsCountryParamSchema = z.object({
    country: z.string().max(5000),
  })

  const getCountrySpecsCountryQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCountrySpecsCountryRequestBodySchema = z.never().optional()

  const getCountrySpecsCountryResponseBodyValidator = responseValidationFactory(
    [["200", s_country_spec]],
    s_error,
  )

  // getCountrySpecsCountry
  router.get(
    `/v1/country_specs/:country`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCountrySpecsCountryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCountrySpecsCountryQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCountrySpecsCountryRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_country_spec>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCountrySpecsCountry(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCountrySpecsCountryResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCouponsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCouponsRequestBodySchema = z.never().optional()

  const getCouponsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_coupon),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/coupons")),
        }),
      ],
    ],
    s_error,
  )

  // getCoupons
  router.get(
    `/v1/coupons`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCouponsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCouponsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_coupon[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCoupons(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCouponsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCouponsRequestBodySchema = z.never().optional()

  const postCouponsResponseBodyValidator = responseValidationFactory(
    [["200", s_coupon]],
    s_error,
  )

  // postCoupons
  router.post(
    `/v1/coupons`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postCouponsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_coupon>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCoupons(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCouponsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCouponsCouponParamSchema = z.object({
    coupon: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCouponsCouponRequestBodySchema = z.never().optional()

  const deleteCouponsCouponResponseBodyValidator = responseValidationFactory(
    [["200", s_deleted_coupon]],
    s_error,
  )

  // deleteCouponsCoupon
  router.delete(
    `/v1/coupons/:coupon`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCouponsCouponParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCouponsCouponRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_coupon>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCouponsCoupon(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteCouponsCouponResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCouponsCouponParamSchema = z.object({coupon: z.string().max(5000)})

  const getCouponsCouponQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCouponsCouponRequestBodySchema = z.never().optional()

  const getCouponsCouponResponseBodyValidator = responseValidationFactory(
    [["200", s_coupon]],
    s_error,
  )

  // getCouponsCoupon
  router.get(
    `/v1/coupons/:coupon`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCouponsCouponParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCouponsCouponQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCouponsCouponRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_coupon>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCouponsCoupon(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCouponsCouponResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCouponsCouponParamSchema = z.object({coupon: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCouponsCouponRequestBodySchema = z.never().optional()

  const postCouponsCouponResponseBodyValidator = responseValidationFactory(
    [["200", s_coupon]],
    s_error,
  )

  // postCouponsCoupon
  router.post(
    `/v1/coupons/:coupon`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCouponsCouponParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCouponsCouponRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_coupon>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCouponsCoupon(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCouponsCouponResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCreditNotesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesRequestBodySchema = z.never().optional()

  const getCreditNotesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_credit_note)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getCreditNotes
  router.get(
    `/v1/credit_notes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCreditNotesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCreditNotesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_credit_note[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCreditNotes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCreditNotesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCreditNotesRequestBodySchema = z.never()

  const postCreditNotesResponseBodyValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  // postCreditNotes
  router.post(
    `/v1/credit_notes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postCreditNotesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_credit_note>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCreditNotes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCreditNotesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCreditNotesPreviewQuerySchema = z.object({
    amount: z.coerce.number().optional(),
    credit_amount: z.coerce.number().optional(),
    effective_at: z.coerce.number().optional(),
    email_type: z.enum(["credit_note", "none"]).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000),
    lines: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount: z.coerce.number().optional(),
            description: z.string().max(5000).optional(),
            invoice_line_item: z.string().max(5000).optional(),
            quantity: z.coerce.number().optional(),
            tax_amounts: z
              .union([
                z.array(
                  z.object({
                    amount: z.coerce.number(),
                    tax_rate: z.string().max(5000),
                    taxable_amount: z.coerce.number(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            type: z.enum(["custom_line_item", "invoice_line_item"]),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          }),
        ),
      )
      .optional(),
    memo: z.string().max(5000).optional(),
    metadata: z.record(z.string()).optional(),
    out_of_band_amount: z.coerce.number().optional(),
    reason: z
      .enum([
        "duplicate",
        "fraudulent",
        "order_change",
        "product_unsatisfactory",
      ])
      .optional(),
    refund_amount: z.coerce.number().optional(),
    refunds: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount_refunded: z.coerce.number().optional(),
            refund: z.string().optional(),
          }),
        ),
      )
      .optional(),
    shipping_cost: z
      .object({shipping_rate: z.string().max(5000).optional()})
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesPreviewRequestBodySchema = z.never().optional()

  const getCreditNotesPreviewResponseBodyValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  // getCreditNotesPreview
  router.get(
    `/v1/credit_notes/preview`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCreditNotesPreviewQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCreditNotesPreviewRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_credit_note>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCreditNotesPreview(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCreditNotesPreviewResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCreditNotesPreviewLinesQuerySchema = z.object({
    amount: z.coerce.number().optional(),
    credit_amount: z.coerce.number().optional(),
    effective_at: z.coerce.number().optional(),
    email_type: z.enum(["credit_note", "none"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000),
    limit: z.coerce.number().optional(),
    lines: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount: z.coerce.number().optional(),
            description: z.string().max(5000).optional(),
            invoice_line_item: z.string().max(5000).optional(),
            quantity: z.coerce.number().optional(),
            tax_amounts: z
              .union([
                z.array(
                  z.object({
                    amount: z.coerce.number(),
                    tax_rate: z.string().max(5000),
                    taxable_amount: z.coerce.number(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            type: z.enum(["custom_line_item", "invoice_line_item"]),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          }),
        ),
      )
      .optional(),
    memo: z.string().max(5000).optional(),
    metadata: z.record(z.string()).optional(),
    out_of_band_amount: z.coerce.number().optional(),
    reason: z
      .enum([
        "duplicate",
        "fraudulent",
        "order_change",
        "product_unsatisfactory",
      ])
      .optional(),
    refund_amount: z.coerce.number().optional(),
    refunds: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount_refunded: z.coerce.number().optional(),
            refund: z.string().optional(),
          }),
        ),
      )
      .optional(),
    shipping_cost: z
      .object({shipping_rate: z.string().max(5000).optional()})
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesPreviewLinesRequestBodySchema = z.never().optional()

  const getCreditNotesPreviewLinesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_credit_note_line_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCreditNotesPreviewLines
  router.get(
    `/v1/credit_notes/preview/lines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCreditNotesPreviewLinesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCreditNotesPreviewLinesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_credit_note_line_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCreditNotesPreviewLines(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCreditNotesPreviewLinesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCreditNotesCreditNoteLinesParamSchema = z.object({
    credit_note: z.string().max(5000),
  })

  const getCreditNotesCreditNoteLinesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesCreditNoteLinesRequestBodySchema = z.never().optional()

  const getCreditNotesCreditNoteLinesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_credit_note_line_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCreditNotesCreditNoteLines
  router.get(
    `/v1/credit_notes/:credit_note/lines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCreditNotesCreditNoteLinesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCreditNotesCreditNoteLinesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCreditNotesCreditNoteLinesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_credit_note_line_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCreditNotesCreditNoteLines(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCreditNotesCreditNoteLinesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCreditNotesIdParamSchema = z.object({id: z.string().max(5000)})

  const getCreditNotesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesIdRequestBodySchema = z.never().optional()

  const getCreditNotesIdResponseBodyValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  // getCreditNotesId
  router.get(
    `/v1/credit_notes/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCreditNotesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCreditNotesIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCreditNotesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_credit_note>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCreditNotesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCreditNotesIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCreditNotesIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCreditNotesIdRequestBodySchema = z.never().optional()

  const postCreditNotesIdResponseBodyValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  // postCreditNotesId
  router.post(
    `/v1/credit_notes/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCreditNotesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCreditNotesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_credit_note>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCreditNotesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCreditNotesIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCreditNotesIdVoidParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCreditNotesIdVoidRequestBodySchema = z.never().optional()

  const postCreditNotesIdVoidResponseBodyValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  // postCreditNotesIdVoid
  router.post(
    `/v1/credit_notes/:id/void`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCreditNotesIdVoidParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCreditNotesIdVoidRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_credit_note>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCreditNotesIdVoid(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCreditNotesIdVoidResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomerSessionsRequestBodySchema = z.never()

  const postCustomerSessionsResponseBodyValidator = responseValidationFactory(
    [["200", s_customer_session]],
    s_error,
  )

  // postCustomerSessions
  router.post(
    `/v1/customer_sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postCustomerSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer_session>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomerSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCustomerSessionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    email: z.string().max(512).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    test_clock: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersRequestBodySchema = z.never().optional()

  const getCustomersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_customer)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/customers")),
        }),
      ],
    ],
    s_error,
  )

  // getCustomers
  router.get(
    `/v1/customers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCustomersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_customer[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCustomersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersRequestBodySchema = z.never().optional()

  const postCustomersResponseBodyValidator = responseValidationFactory(
    [["200", s_customer]],
    s_error,
  )

  // postCustomers
  router.post(
    `/v1/customers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postCustomersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCustomersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersSearchRequestBodySchema = z.never().optional()

  const getCustomersSearchResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_customer)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getCustomersSearch
  router.get(
    `/v1/customers/search`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getCustomersSearchQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersSearchRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_customer[]
              has_more: boolean
              next_page?: (string | null) | undefined
              object: "search_result"
              total_count?: number | undefined
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersSearch(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCustomersSearchResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerRequestBodySchema = z.never().optional()

  const deleteCustomersCustomerResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_customer]], s_error)

  // deleteCustomersCustomer
  router.delete(
    `/v1/customers/:customer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_customer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomer(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteCustomersCustomerResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerRequestBodySchema = z.never().optional()

  const getCustomersCustomerResponseBodyValidator = responseValidationFactory(
    [["200", z.union([z.lazy(() => s_customer), s_deleted_customer])]],
    s_error,
  )

  // getCustomersCustomer
  router.get(
    `/v1/customers/:customer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer | t_deleted_customer>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomer(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCustomersCustomerResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerRequestBodySchema = z.never().optional()

  const postCustomersCustomerResponseBodyValidator = responseValidationFactory(
    [["200", s_customer]],
    s_error,
  )

  // postCustomersCustomer
  router.post(
    `/v1/customers/:customer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomer(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postCustomersCustomerResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerBalanceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBalanceTransactionsRequestBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerBalanceTransactionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_customer_balance_transaction)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerBalanceTransactions
  router.get(
    `/v1/customers/:customer/balance_transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerBalanceTransactionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerBalanceTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerBalanceTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_customer_balance_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerBalanceTransactions(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerBalanceTransactionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBalanceTransactionsRequestBodySchema = z.never()

  const postCustomersCustomerBalanceTransactionsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_customer_balance_transaction]],
      s_error,
    )

  // postCustomersCustomerBalanceTransactions
  router.post(
    `/v1/customers/:customer/balance_transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerBalanceTransactionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerBalanceTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer_balance_transaction>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerBalanceTransactions(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerBalanceTransactionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerBalanceTransactionsTransactionParamSchema =
    z.object({customer: z.string().max(5000), transaction: z.string()})

  const getCustomersCustomerBalanceTransactionsTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBalanceTransactionsTransactionRequestBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerBalanceTransactionsTransactionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_customer_balance_transaction]],
      s_error,
    )

  // getCustomersCustomerBalanceTransactionsTransaction
  router.get(
    `/v1/customers/:customer/balance_transactions/:transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerBalanceTransactionsTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerBalanceTransactionsTransactionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerBalanceTransactionsTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer_balance_transaction>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerBalanceTransactionsTransaction(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerBalanceTransactionsTransactionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerBalanceTransactionsTransactionParamSchema =
    z.object({
      customer: z.string().max(5000),
      transaction: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBalanceTransactionsTransactionRequestBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerBalanceTransactionsTransactionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_customer_balance_transaction]],
      s_error,
    )

  // postCustomersCustomerBalanceTransactionsTransaction
  router.post(
    `/v1/customers/:customer/balance_transactions/:transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerBalanceTransactionsTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerBalanceTransactionsTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer_balance_transaction>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerBalanceTransactionsTransaction(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerBalanceTransactionsTransactionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerBankAccountsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerBankAccountsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBankAccountsRequestBodySchema = z.never().optional()

  const getCustomersCustomerBankAccountsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_bank_account)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerBankAccounts
  router.get(
    `/v1/customers/:customer/bank_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerBankAccountsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerBankAccountsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerBankAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_bank_account[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerBankAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerBankAccountsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerBankAccountsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBankAccountsRequestBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerBankAccountsResponseBodyValidator =
    responseValidationFactory([["200", s_payment_source]], s_error)

  // postCustomersCustomerBankAccounts
  router.post(
    `/v1/customers/:customer/bank_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerBankAccountsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerBankAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerBankAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerBankAccountsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerBankAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const deleteCustomersCustomerBankAccountsIdResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
        ],
      ],
      s_error,
    )

  // deleteCustomersCustomerBankAccountsId
  router.delete(
    `/v1/customers/:customer/bank_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerBankAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerBankAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_payment_source | t_deleted_payment_source
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomerBankAccountsId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteCustomersCustomerBankAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getCustomersCustomerBankAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBankAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerBankAccountsIdResponseBodyValidator =
    responseValidationFactory([["200", s_bank_account]], s_error)

  // getCustomersCustomerBankAccountsId
  router.get(
    `/v1/customers/:customer/bank_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerBankAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerBankAccountsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerBankAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_bank_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerBankAccountsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerBankAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBankAccountsIdRequestBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerBankAccountsIdResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_card),
            z.lazy(() => s_bank_account),
            s_source,
          ]),
        ],
      ],
      s_error,
    )

  // postCustomersCustomerBankAccountsId
  router.post(
    `/v1/customers/:customer/bank_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerBankAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerBankAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_card | t_bank_account | t_source
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerBankAccountsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerBankAccountsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerBankAccountsIdVerifyParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBankAccountsIdVerifyRequestBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerBankAccountsIdVerifyResponseBodyValidator =
    responseValidationFactory([["200", s_bank_account]], s_error)

  // postCustomersCustomerBankAccountsIdVerify
  router.post(
    `/v1/customers/:customer/bank_accounts/:id/verify`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerBankAccountsIdVerifyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerBankAccountsIdVerifyRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_bank_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerBankAccountsIdVerify(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerBankAccountsIdVerifyResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerCardsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCardsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCardsRequestBodySchema = z.never().optional()

  const getCustomersCustomerCardsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_card)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerCards
  router.get(
    `/v1/customers/:customer/cards`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerCardsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerCardsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerCardsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_card[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerCards(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getCustomersCustomerCardsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerCardsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerCardsRequestBodySchema = z.never().optional()

  const postCustomersCustomerCardsResponseBodyValidator =
    responseValidationFactory([["200", s_payment_source]], s_error)

  // postCustomersCustomerCards
  router.post(
    `/v1/customers/:customer/cards`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerCardsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerCardsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerCards(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerCardsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerCardsIdRequestBodySchema = z.never().optional()

  const deleteCustomersCustomerCardsIdResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
        ],
      ],
      s_error,
    )

  // deleteCustomersCustomerCardsId
  router.delete(
    `/v1/customers/:customer/cards/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerCardsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerCardsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_payment_source | t_deleted_payment_source
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomerCardsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteCustomersCustomerCardsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getCustomersCustomerCardsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCardsIdRequestBodySchema = z.never().optional()

  const getCustomersCustomerCardsIdResponseBodyValidator =
    responseValidationFactory([["200", s_card]], s_error)

  // getCustomersCustomerCardsId
  router.get(
    `/v1/customers/:customer/cards/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerCardsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerCardsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerCardsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerCardsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerCardsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerCardsIdRequestBodySchema = z.never().optional()

  const postCustomersCustomerCardsIdResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_card),
            z.lazy(() => s_bank_account),
            s_source,
          ]),
        ],
      ],
      s_error,
    )

  // postCustomersCustomerCardsId
  router.post(
    `/v1/customers/:customer/cards/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerCardsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerCardsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_card | t_bank_account | t_source
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerCardsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerCardsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCashBalanceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCashBalanceRequestBodySchema = z.never().optional()

  const getCustomersCustomerCashBalanceResponseBodyValidator =
    responseValidationFactory([["200", s_cash_balance]], s_error)

  // getCustomersCustomerCashBalance
  router.get(
    `/v1/customers/:customer/cash_balance`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerCashBalanceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerCashBalanceQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerCashBalanceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_cash_balance>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerCashBalance(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerCashBalanceResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerCashBalanceRequestBodySchema = z.never().optional()

  const postCustomersCustomerCashBalanceResponseBodyValidator =
    responseValidationFactory([["200", s_cash_balance]], s_error)

  // postCustomersCustomerCashBalance
  router.post(
    `/v1/customers/:customer/cash_balance`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerCashBalanceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerCashBalanceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_cash_balance>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerCashBalance(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerCashBalanceResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerCashBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCashBalanceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCashBalanceTransactionsRequestBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerCashBalanceTransactionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_customer_cash_balance_transaction)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerCashBalanceTransactions
  router.get(
    `/v1/customers/:customer/cash_balance_transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerCashBalanceTransactionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerCashBalanceTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerCashBalanceTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_customer_cash_balance_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerCashBalanceTransactions(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerCashBalanceTransactionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerCashBalanceTransactionsTransactionParamSchema =
    z.object({customer: z.string().max(5000), transaction: z.string()})

  const getCustomersCustomerCashBalanceTransactionsTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCashBalanceTransactionsTransactionRequestBodySchema =
    z.never().optional()

  const getCustomersCustomerCashBalanceTransactionsTransactionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_customer_cash_balance_transaction]],
      s_error,
    )

  // getCustomersCustomerCashBalanceTransactionsTransaction
  router.get(
    `/v1/customers/:customer/cash_balance_transactions/:transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerCashBalanceTransactionsTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer_cash_balance_transaction>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerCashBalanceTransactionsTransaction(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerCashBalanceTransactionsTransactionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerDiscountParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerDiscountRequestBodySchema = z.never().optional()

  const deleteCustomersCustomerDiscountResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_discount]], s_error)

  // deleteCustomersCustomerDiscount
  router.delete(
    `/v1/customers/:customer/discount`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerDiscountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerDiscountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_discount>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomerDiscount(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteCustomersCustomerDiscountResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerDiscountParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerDiscountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerDiscountRequestBodySchema = z.never().optional()

  const getCustomersCustomerDiscountResponseBodyValidator =
    responseValidationFactory([["200", s_discount]], s_error)

  // getCustomersCustomerDiscount
  router.get(
    `/v1/customers/:customer/discount`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerDiscountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerDiscountQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerDiscountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_discount>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerDiscount(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerDiscountResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerFundingInstructionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerFundingInstructionsRequestBodySchema = z.never()

  const postCustomersCustomerFundingInstructionsResponseBodyValidator =
    responseValidationFactory([["200", s_funding_instructions]], s_error)

  // postCustomersCustomerFundingInstructions
  router.post(
    `/v1/customers/:customer/funding_instructions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerFundingInstructionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerFundingInstructionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_funding_instructions>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerFundingInstructions(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerFundingInstructionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerPaymentMethodsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerPaymentMethodsQuerySchema = z.object({
    allow_redisplay: z.enum(["always", "limited", "unspecified"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z
      .enum([
        "acss_debit",
        "affirm",
        "afterpay_clearpay",
        "alipay",
        "alma",
        "amazon_pay",
        "au_becs_debit",
        "bacs_debit",
        "bancontact",
        "billie",
        "blik",
        "boleto",
        "card",
        "cashapp",
        "crypto",
        "customer_balance",
        "eps",
        "fpx",
        "giropay",
        "grabpay",
        "ideal",
        "kakao_pay",
        "klarna",
        "konbini",
        "kr_card",
        "link",
        "mobilepay",
        "multibanco",
        "naver_pay",
        "nz_bank_account",
        "oxxo",
        "p24",
        "pay_by_bank",
        "payco",
        "paynow",
        "paypal",
        "pix",
        "promptpay",
        "revolut_pay",
        "samsung_pay",
        "satispay",
        "sepa_debit",
        "sofort",
        "swish",
        "twint",
        "us_bank_account",
        "wechat_pay",
        "zip",
      ])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerPaymentMethodsRequestBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerPaymentMethodsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_payment_method)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerPaymentMethods
  router.get(
    `/v1/customers/:customer/payment_methods`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerPaymentMethodsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerPaymentMethodsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerPaymentMethodsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payment_method[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerPaymentMethods(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerPaymentMethodsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerPaymentMethodsPaymentMethodParamSchema = z.object({
    customer: z.string().max(5000),
    payment_method: z.string().max(5000),
  })

  const getCustomersCustomerPaymentMethodsPaymentMethodQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerPaymentMethodsPaymentMethodRequestBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerPaymentMethodsPaymentMethodResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  // getCustomersCustomerPaymentMethodsPaymentMethod
  router.get(
    `/v1/customers/:customer/payment_methods/:payment_method`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerPaymentMethodsPaymentMethodRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerPaymentMethodsPaymentMethod(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerPaymentMethodsPaymentMethodResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerSourcesParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerSourcesQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    object: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSourcesRequestBodySchema = z.never().optional()

  const getCustomersCustomerSourcesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(
              z.union([
                z.lazy(() => s_bank_account),
                z.lazy(() => s_card),
                s_source,
              ]),
            ),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerSources
  router.get(
    `/v1/customers/:customer/sources`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerSourcesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerSourcesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerSourcesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: (t_bank_account | t_card | t_source)[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerSources(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerSourcesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerSourcesParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSourcesRequestBodySchema = z.never().optional()

  const postCustomersCustomerSourcesResponseBodyValidator =
    responseValidationFactory([["200", s_payment_source]], s_error)

  // postCustomersCustomerSources
  router.post(
    `/v1/customers/:customer/sources`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerSourcesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerSourcesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerSources(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerSourcesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerSourcesIdRequestBodySchema = z.never().optional()

  const deleteCustomersCustomerSourcesIdResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
        ],
      ],
      s_error,
    )

  // deleteCustomersCustomerSourcesId
  router.delete(
    `/v1/customers/:customer/sources/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerSourcesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerSourcesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_payment_source | t_deleted_payment_source
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomerSourcesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteCustomersCustomerSourcesIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(500),
  })

  const getCustomersCustomerSourcesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSourcesIdRequestBodySchema = z.never().optional()

  const getCustomersCustomerSourcesIdResponseBodyValidator =
    responseValidationFactory([["200", s_payment_source]], s_error)

  // getCustomersCustomerSourcesId
  router.get(
    `/v1/customers/:customer/sources/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerSourcesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerSourcesIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerSourcesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerSourcesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerSourcesIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSourcesIdRequestBodySchema = z.never().optional()

  const postCustomersCustomerSourcesIdResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_card),
            z.lazy(() => s_bank_account),
            s_source,
          ]),
        ],
      ],
      s_error,
    )

  // postCustomersCustomerSourcesId
  router.post(
    `/v1/customers/:customer/sources/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerSourcesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerSourcesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_card | t_bank_account | t_source
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerSourcesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerSourcesIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerSourcesIdVerifyParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSourcesIdVerifyRequestBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerSourcesIdVerifyResponseBodyValidator =
    responseValidationFactory([["200", s_bank_account]], s_error)

  // postCustomersCustomerSourcesIdVerify
  router.post(
    `/v1/customers/:customer/sources/:id/verify`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerSourcesIdVerifyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerSourcesIdVerifyRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_bank_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerSourcesIdVerify(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerSourcesIdVerifyResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerSubscriptionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerSubscriptionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSubscriptionsRequestBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerSubscriptionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_subscription)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerSubscriptions
  router.get(
    `/v1/customers/:customer/subscriptions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerSubscriptionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerSubscriptionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerSubscriptionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_subscription[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerSubscriptions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerSubscriptionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerSubscriptionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSubscriptionsRequestBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerSubscriptionsResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // postCustomersCustomerSubscriptions
  router.post(
    `/v1/customers/:customer/subscriptions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerSubscriptionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerSubscriptionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerSubscriptions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerSubscriptionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema =
    z.never().optional()

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // deleteCustomersCustomerSubscriptionsSubscriptionExposedId
  router.delete(
    `/v1/customers/:customer/subscriptions/:subscription_exposed_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomerSubscriptionsSubscriptionExposedId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema =
    z.never().optional()

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // getCustomersCustomerSubscriptionsSubscriptionExposedId
  router.get(
    `/v1/customers/:customer/subscriptions/:subscription_exposed_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerSubscriptionsSubscriptionExposedId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema =
    z.never().optional()

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // postCustomersCustomerSubscriptionsSubscriptionExposedId
  router.post(
    `/v1/customers/:customer/subscriptions/:subscription_exposed_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerSubscriptionsSubscriptionExposedIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerSubscriptionsSubscriptionExposedId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerSubscriptionsSubscriptionExposedIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema =
    z.never().optional()

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_discount]], s_error)

  // deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  router.delete(
    `/v1/customers/:customer/subscriptions/:subscription_exposed_id/discount`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_discount>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema =
    z.never().optional()

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseBodyValidator =
    responseValidationFactory([["200", s_discount]], s_error)

  // getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  router.get(
    `/v1/customers/:customer/subscriptions/:subscription_exposed_id/discount`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_discount>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerTaxIdsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerTaxIdsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerTaxIdsRequestBodySchema = z.never().optional()

  const getCustomersCustomerTaxIdsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_tax_id)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getCustomersCustomerTaxIds
  router.get(
    `/v1/customers/:customer/tax_ids`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerTaxIdsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerTaxIdsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerTaxIdsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_tax_id[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerTaxIds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerTaxIdsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postCustomersCustomerTaxIdsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerTaxIdsRequestBodySchema = z.never()

  const postCustomersCustomerTaxIdsResponseBodyValidator =
    responseValidationFactory([["200", s_tax_id]], s_error)

  // postCustomersCustomerTaxIds
  router.post(
    `/v1/customers/:customer/tax_ids`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postCustomersCustomerTaxIdsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postCustomersCustomerTaxIdsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_id>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postCustomersCustomerTaxIds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postCustomersCustomerTaxIdsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteCustomersCustomerTaxIdsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerTaxIdsIdRequestBodySchema = z.never().optional()

  const deleteCustomersCustomerTaxIdsIdResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_tax_id]], s_error)

  // deleteCustomersCustomerTaxIdsId
  router.delete(
    `/v1/customers/:customer/tax_ids/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteCustomersCustomerTaxIdsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteCustomersCustomerTaxIdsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_tax_id>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteCustomersCustomerTaxIdsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteCustomersCustomerTaxIdsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getCustomersCustomerTaxIdsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  const getCustomersCustomerTaxIdsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerTaxIdsIdRequestBodySchema = z.never().optional()

  const getCustomersCustomerTaxIdsIdResponseBodyValidator =
    responseValidationFactory([["200", s_tax_id]], s_error)

  // getCustomersCustomerTaxIdsId
  router.get(
    `/v1/customers/:customer/tax_ids/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getCustomersCustomerTaxIdsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getCustomersCustomerTaxIdsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getCustomersCustomerTaxIdsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_id>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getCustomersCustomerTaxIdsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getCustomersCustomerTaxIdsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getDisputesQuerySchema = z.object({
    charge: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getDisputesRequestBodySchema = z.never().optional()

  const getDisputesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_dispute)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/disputes")),
        }),
      ],
    ],
    s_error,
  )

  // getDisputes
  router.get(
    `/v1/disputes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getDisputesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getDisputesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_dispute[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getDisputes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getDisputesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const getDisputesDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getDisputesDisputeRequestBodySchema = z.never().optional()

  const getDisputesDisputeResponseBodyValidator = responseValidationFactory(
    [["200", s_dispute]],
    s_error,
  )

  // getDisputesDispute
  router.get(
    `/v1/disputes/:dispute`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getDisputesDisputeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getDisputesDisputeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getDisputesDisputeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getDisputesDispute(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getDisputesDisputeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postDisputesDisputeRequestBodySchema = z.never().optional()

  const postDisputesDisputeResponseBodyValidator = responseValidationFactory(
    [["200", s_dispute]],
    s_error,
  )

  // postDisputesDispute
  router.post(
    `/v1/disputes/:dispute`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postDisputesDisputeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postDisputesDisputeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postDisputesDispute(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postDisputesDisputeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postDisputesDisputeCloseParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postDisputesDisputeCloseRequestBodySchema = z.never().optional()

  const postDisputesDisputeCloseResponseBodyValidator =
    responseValidationFactory([["200", s_dispute]], s_error)

  // postDisputesDisputeClose
  router.post(
    `/v1/disputes/:dispute/close`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postDisputesDisputeCloseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postDisputesDisputeCloseRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postDisputesDisputeClose(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postDisputesDisputeCloseResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getEntitlementsActiveEntitlementsQuerySchema = z.object({
    customer: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsActiveEntitlementsRequestBodySchema = z
    .never()
    .optional()

  const getEntitlementsActiveEntitlementsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_entitlements_active_entitlement),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getEntitlementsActiveEntitlements
  router.get(
    `/v1/entitlements/active_entitlements`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getEntitlementsActiveEntitlementsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getEntitlementsActiveEntitlementsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_entitlements_active_entitlement[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEntitlementsActiveEntitlements(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getEntitlementsActiveEntitlementsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getEntitlementsActiveEntitlementsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getEntitlementsActiveEntitlementsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsActiveEntitlementsIdRequestBodySchema = z
    .never()
    .optional()

  const getEntitlementsActiveEntitlementsIdResponseBodyValidator =
    responseValidationFactory(
      [["200", s_entitlements_active_entitlement]],
      s_error,
    )

  // getEntitlementsActiveEntitlementsId
  router.get(
    `/v1/entitlements/active_entitlements/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getEntitlementsActiveEntitlementsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getEntitlementsActiveEntitlementsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getEntitlementsActiveEntitlementsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_entitlements_active_entitlement>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEntitlementsActiveEntitlementsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getEntitlementsActiveEntitlementsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getEntitlementsFeaturesQuerySchema = z.object({
    archived: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_key: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsFeaturesRequestBodySchema = z.never().optional()

  const getEntitlementsFeaturesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_entitlements_feature),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/entitlements/features")),
          }),
        ],
      ],
      s_error,
    )

  // getEntitlementsFeatures
  router.get(
    `/v1/entitlements/features`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getEntitlementsFeaturesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getEntitlementsFeaturesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_entitlements_feature[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEntitlementsFeatures(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getEntitlementsFeaturesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postEntitlementsFeaturesRequestBodySchema = z.never()

  const postEntitlementsFeaturesResponseBodyValidator =
    responseValidationFactory([["200", s_entitlements_feature]], s_error)

  // postEntitlementsFeatures
  router.post(
    `/v1/entitlements/features`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postEntitlementsFeaturesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_entitlements_feature>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postEntitlementsFeatures(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postEntitlementsFeaturesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getEntitlementsFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getEntitlementsFeaturesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsFeaturesIdRequestBodySchema = z.never().optional()

  const getEntitlementsFeaturesIdResponseBodyValidator =
    responseValidationFactory([["200", s_entitlements_feature]], s_error)

  // getEntitlementsFeaturesId
  router.get(
    `/v1/entitlements/features/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getEntitlementsFeaturesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getEntitlementsFeaturesIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getEntitlementsFeaturesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_entitlements_feature>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEntitlementsFeaturesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getEntitlementsFeaturesIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postEntitlementsFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postEntitlementsFeaturesIdRequestBodySchema = z.never().optional()

  const postEntitlementsFeaturesIdResponseBodyValidator =
    responseValidationFactory([["200", s_entitlements_feature]], s_error)

  // postEntitlementsFeaturesId
  router.post(
    `/v1/entitlements/features/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postEntitlementsFeaturesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postEntitlementsFeaturesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_entitlements_feature>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postEntitlementsFeaturesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postEntitlementsFeaturesIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postEphemeralKeysRequestBodySchema = z.never().optional()

  const postEphemeralKeysResponseBodyValidator = responseValidationFactory(
    [["200", s_ephemeral_key]],
    s_error,
  )

  // postEphemeralKeys
  router.post(
    `/v1/ephemeral_keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postEphemeralKeysRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ephemeral_key>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postEphemeralKeys(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postEphemeralKeysResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteEphemeralKeysKeyParamSchema = z.object({
    key: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteEphemeralKeysKeyRequestBodySchema = z.never().optional()

  const deleteEphemeralKeysKeyResponseBodyValidator = responseValidationFactory(
    [["200", s_ephemeral_key]],
    s_error,
  )

  // deleteEphemeralKeysKey
  router.delete(
    `/v1/ephemeral_keys/:key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteEphemeralKeysKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteEphemeralKeysKeyRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ephemeral_key>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteEphemeralKeysKey(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteEphemeralKeysKeyResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getEventsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    delivery_success: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
    types: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEventsRequestBodySchema = z.never().optional()

  const getEventsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_event),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/events")),
        }),
      ],
    ],
    s_error,
  )

  // getEvents
  router.get(
    `/v1/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getEventsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getEventsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_event[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEvents(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getEventsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getEventsIdParamSchema = z.object({id: z.string().max(5000)})

  const getEventsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEventsIdRequestBodySchema = z.never().optional()

  const getEventsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_event]],
    s_error,
  )

  // getEventsId
  router.get(
    `/v1/events/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getEventsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getEventsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getEventsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEventsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getEventsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getExchangeRatesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getExchangeRatesRequestBodySchema = z.never().optional()

  const getExchangeRatesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_exchange_rate),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/exchange_rates")),
        }),
      ],
    ],
    s_error,
  )

  // getExchangeRates
  router.get(
    `/v1/exchange_rates`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getExchangeRatesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getExchangeRatesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_exchange_rate[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getExchangeRates(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getExchangeRatesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getExchangeRatesRateIdParamSchema = z.object({
    rate_id: z.string().max(5000),
  })

  const getExchangeRatesRateIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getExchangeRatesRateIdRequestBodySchema = z.never().optional()

  const getExchangeRatesRateIdResponseBodyValidator = responseValidationFactory(
    [["200", s_exchange_rate]],
    s_error,
  )

  // getExchangeRatesRateId
  router.get(
    `/v1/exchange_rates/:rate_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getExchangeRatesRateIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getExchangeRatesRateIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getExchangeRatesRateIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_exchange_rate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getExchangeRatesRateId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getExchangeRatesRateIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postExternalAccountsIdParamSchema = z.object({id: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postExternalAccountsIdRequestBodySchema = z.never().optional()

  const postExternalAccountsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_external_account]],
    s_error,
  )

  // postExternalAccountsId
  router.post(
    `/v1/external_accounts/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postExternalAccountsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postExternalAccountsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_external_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postExternalAccountsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postExternalAccountsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFileLinksQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    expired: PermissiveBoolean.optional(),
    file: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFileLinksRequestBodySchema = z.never().optional()

  const getFileLinksResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_file_link)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/file_links")),
        }),
      ],
    ],
    s_error,
  )

  // getFileLinks
  router.get(
    `/v1/file_links`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getFileLinksQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFileLinksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_file_link[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFileLinks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getFileLinksResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFileLinksRequestBodySchema = z.never()

  const postFileLinksResponseBodyValidator = responseValidationFactory(
    [["200", s_file_link]],
    s_error,
  )

  // postFileLinks
  router.post(
    `/v1/file_links`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postFileLinksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_file_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFileLinks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postFileLinksResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFileLinksLinkParamSchema = z.object({link: z.string()})

  const getFileLinksLinkQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFileLinksLinkRequestBodySchema = z.never().optional()

  const getFileLinksLinkResponseBodyValidator = responseValidationFactory(
    [["200", s_file_link]],
    s_error,
  )

  // getFileLinksLink
  router.get(
    `/v1/file_links/:link`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getFileLinksLinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getFileLinksLinkQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFileLinksLinkRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_file_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFileLinksLink(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getFileLinksLinkResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postFileLinksLinkParamSchema = z.object({link: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFileLinksLinkRequestBodySchema = z.never().optional()

  const postFileLinksLinkResponseBodyValidator = responseValidationFactory(
    [["200", s_file_link]],
    s_error,
  )

  // postFileLinksLink
  router.post(
    `/v1/file_links/:link`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postFileLinksLinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postFileLinksLinkRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_file_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFileLinksLink(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postFileLinksLinkResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFilesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    purpose: z
      .enum([
        "account_requirement",
        "additional_verification",
        "business_icon",
        "business_logo",
        "customer_signature",
        "dispute_evidence",
        "document_provider_identity_document",
        "finance_report_run",
        "financial_account_statement",
        "identity_document",
        "identity_document_downloadable",
        "issuing_regulatory_reporting",
        "pci_document",
        "selfie",
        "sigma_scheduled_query",
        "tax_document_user_upload",
        "terminal_reader_splashscreen",
      ])
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFilesRequestBodySchema = z.never().optional()

  const getFilesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_file)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/files")),
        }),
      ],
    ],
    s_error,
  )

  // getFiles
  router.get(
    `/v1/files`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getFilesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFilesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_file[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFiles(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getFilesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'multipart/form-data' not yet supported

  const postFilesRequestBodySchema = z.never()

  const postFilesResponseBodyValidator = responseValidationFactory(
    [["200", s_file]],
    s_error,
  )

  // postFiles
  router.post(
    `/v1/files`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postFilesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_file>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFiles(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postFilesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFilesFileParamSchema = z.object({file: z.string().max(5000)})

  const getFilesFileQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFilesFileRequestBodySchema = z.never().optional()

  const getFilesFileResponseBodyValidator = responseValidationFactory(
    [["200", s_file]],
    s_error,
  )

  // getFilesFile
  router.get(
    `/v1/files/:file`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getFilesFileParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getFilesFileQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFilesFileRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_file>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFilesFile(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getFilesFileResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFinancialConnectionsAccountsQuerySchema = z.object({
    account_holder: z
      .object({
        account: z.string().max(5000).optional(),
        customer: z.string().max(5000).optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    session: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsAccountsRequestBodySchema = z.never().optional()

  const getFinancialConnectionsAccountsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_financial_connections_account)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/financial_connections/accounts")),
          }),
        ],
      ],
      s_error,
    )

  // getFinancialConnectionsAccounts
  router.get(
    `/v1/financial_connections/accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getFinancialConnectionsAccountsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFinancialConnectionsAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_financial_connections_account[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFinancialConnectionsAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getFinancialConnectionsAccountsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFinancialConnectionsAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getFinancialConnectionsAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsAccountsAccountRequestBodySchema = z
    .never()
    .optional()

  const getFinancialConnectionsAccountsAccountResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // getFinancialConnectionsAccountsAccount
  router.get(
    `/v1/financial_connections/accounts/:account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getFinancialConnectionsAccountsAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getFinancialConnectionsAccountsAccountQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFinancialConnectionsAccountsAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFinancialConnectionsAccountsAccount(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getFinancialConnectionsAccountsAccountResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postFinancialConnectionsAccountsAccountDisconnectParamSchema = z.object(
    {account: z.string().max(5000)},
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountDisconnectRequestBodySchema = z
    .never()
    .optional()

  const postFinancialConnectionsAccountsAccountDisconnectResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // postFinancialConnectionsAccountsAccountDisconnect
  router.post(
    `/v1/financial_connections/accounts/:account/disconnect`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postFinancialConnectionsAccountsAccountDisconnectParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postFinancialConnectionsAccountsAccountDisconnectRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFinancialConnectionsAccountsAccountDisconnect(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postFinancialConnectionsAccountsAccountDisconnectResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFinancialConnectionsAccountsAccountOwnersParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getFinancialConnectionsAccountsAccountOwnersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    ownership: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsAccountsAccountOwnersRequestBodySchema = z
    .never()
    .optional()

  const getFinancialConnectionsAccountsAccountOwnersResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_financial_connections_account_owner),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getFinancialConnectionsAccountsAccountOwners
  router.get(
    `/v1/financial_connections/accounts/:account/owners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getFinancialConnectionsAccountsAccountOwnersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getFinancialConnectionsAccountsAccountOwnersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFinancialConnectionsAccountsAccountOwnersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_financial_connections_account_owner[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFinancialConnectionsAccountsAccountOwners(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getFinancialConnectionsAccountsAccountOwnersResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postFinancialConnectionsAccountsAccountRefreshParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountRefreshRequestBodySchema =
    z.never()

  const postFinancialConnectionsAccountsAccountRefreshResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // postFinancialConnectionsAccountsAccountRefresh
  router.post(
    `/v1/financial_connections/accounts/:account/refresh`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postFinancialConnectionsAccountsAccountRefreshParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postFinancialConnectionsAccountsAccountRefreshRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFinancialConnectionsAccountsAccountRefresh(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postFinancialConnectionsAccountsAccountRefreshResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postFinancialConnectionsAccountsAccountSubscribeParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountSubscribeRequestBodySchema =
    z.never()

  const postFinancialConnectionsAccountsAccountSubscribeResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // postFinancialConnectionsAccountsAccountSubscribe
  router.post(
    `/v1/financial_connections/accounts/:account/subscribe`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postFinancialConnectionsAccountsAccountSubscribeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postFinancialConnectionsAccountsAccountSubscribeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFinancialConnectionsAccountsAccountSubscribe(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postFinancialConnectionsAccountsAccountSubscribeResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postFinancialConnectionsAccountsAccountUnsubscribeParamSchema =
    z.object({account: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountUnsubscribeRequestBodySchema =
    z.never()

  const postFinancialConnectionsAccountsAccountUnsubscribeResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // postFinancialConnectionsAccountsAccountUnsubscribe
  router.post(
    `/v1/financial_connections/accounts/:account/unsubscribe`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postFinancialConnectionsAccountsAccountUnsubscribeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFinancialConnectionsAccountsAccountUnsubscribe(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postFinancialConnectionsAccountsAccountUnsubscribeResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsSessionsRequestBodySchema = z.never()

  const postFinancialConnectionsSessionsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_session]],
      s_error,
    )

  // postFinancialConnectionsSessions
  router.post(
    `/v1/financial_connections/sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postFinancialConnectionsSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postFinancialConnectionsSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postFinancialConnectionsSessionsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFinancialConnectionsSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getFinancialConnectionsSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsSessionsSessionRequestBodySchema = z
    .never()
    .optional()

  const getFinancialConnectionsSessionsSessionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_session]],
      s_error,
    )

  // getFinancialConnectionsSessionsSession
  router.get(
    `/v1/financial_connections/sessions/:session`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getFinancialConnectionsSessionsSessionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getFinancialConnectionsSessionsSessionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFinancialConnectionsSessionsSessionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFinancialConnectionsSessionsSession(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getFinancialConnectionsSessionsSessionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFinancialConnectionsTransactionsQuerySchema = z.object({
    account: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    transacted_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    transaction_refresh: z.object({after: z.string().max(5000)}).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsTransactionsRequestBodySchema = z
    .never()
    .optional()

  const getFinancialConnectionsTransactionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_financial_connections_transaction),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/financial_connections/transactions")),
          }),
        ],
      ],
      s_error,
    )

  // getFinancialConnectionsTransactions
  router.get(
    `/v1/financial_connections/transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getFinancialConnectionsTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFinancialConnectionsTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_financial_connections_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFinancialConnectionsTransactions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getFinancialConnectionsTransactionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getFinancialConnectionsTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getFinancialConnectionsTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsTransactionsTransactionRequestBodySchema = z
    .never()
    .optional()

  const getFinancialConnectionsTransactionsTransactionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_transaction]],
      s_error,
    )

  // getFinancialConnectionsTransactionsTransaction
  router.get(
    `/v1/financial_connections/transactions/:transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getFinancialConnectionsTransactionsTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getFinancialConnectionsTransactionsTransactionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getFinancialConnectionsTransactionsTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_transaction>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getFinancialConnectionsTransactionsTransaction(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getFinancialConnectionsTransactionsTransactionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getForwardingRequestsQuerySchema = z.object({
    created: z
      .object({
        gt: z.coerce.number().optional(),
        gte: z.coerce.number().optional(),
        lt: z.coerce.number().optional(),
        lte: z.coerce.number().optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getForwardingRequestsRequestBodySchema = z.never().optional()

  const getForwardingRequestsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_forwarding_request),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getForwardingRequests
  router.get(
    `/v1/forwarding/requests`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getForwardingRequestsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getForwardingRequestsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_forwarding_request[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getForwardingRequests(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getForwardingRequestsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postForwardingRequestsRequestBodySchema = z.never()

  const postForwardingRequestsResponseBodyValidator = responseValidationFactory(
    [["200", s_forwarding_request]],
    s_error,
  )

  // postForwardingRequests
  router.post(
    `/v1/forwarding/requests`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postForwardingRequestsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_forwarding_request>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postForwardingRequests(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postForwardingRequestsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getForwardingRequestsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getForwardingRequestsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getForwardingRequestsIdRequestBodySchema = z.never().optional()

  const getForwardingRequestsIdResponseBodyValidator =
    responseValidationFactory([["200", s_forwarding_request]], s_error)

  // getForwardingRequestsId
  router.get(
    `/v1/forwarding/requests/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getForwardingRequestsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getForwardingRequestsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getForwardingRequestsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_forwarding_request>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getForwardingRequestsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getForwardingRequestsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIdentityVerificationReportsQuerySchema = z.object({
    client_reference_id: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["document", "id_number"]).optional(),
    verification_session: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationReportsRequestBodySchema = z.never().optional()

  const getIdentityVerificationReportsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_identity_verification_report),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/identity/verification_reports")),
          }),
        ],
      ],
      s_error,
    )

  // getIdentityVerificationReports
  router.get(
    `/v1/identity/verification_reports`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIdentityVerificationReportsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIdentityVerificationReportsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_identity_verification_report[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIdentityVerificationReports(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIdentityVerificationReportsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIdentityVerificationReportsReportParamSchema = z.object({
    report: z.string().max(5000),
  })

  const getIdentityVerificationReportsReportQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationReportsReportRequestBodySchema = z
    .never()
    .optional()

  const getIdentityVerificationReportsReportResponseBodyValidator =
    responseValidationFactory(
      [["200", s_identity_verification_report]],
      s_error,
    )

  // getIdentityVerificationReportsReport
  router.get(
    `/v1/identity/verification_reports/:report`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIdentityVerificationReportsReportParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIdentityVerificationReportsReportQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIdentityVerificationReportsReportRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_identity_verification_report>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIdentityVerificationReportsReport(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIdentityVerificationReportsReportResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIdentityVerificationSessionsQuerySchema = z.object({
    client_reference_id: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    related_customer: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "processing", "requires_input", "verified"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationSessionsRequestBodySchema = z.never().optional()

  const getIdentityVerificationSessionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_identity_verification_session),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/identity/verification_sessions")),
          }),
        ],
      ],
      s_error,
    )

  // getIdentityVerificationSessions
  router.get(
    `/v1/identity/verification_sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIdentityVerificationSessionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIdentityVerificationSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_identity_verification_session[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIdentityVerificationSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIdentityVerificationSessionsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsRequestBodySchema = z.never().optional()

  const postIdentityVerificationSessionsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  // postIdentityVerificationSessions
  router.post(
    `/v1/identity/verification_sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postIdentityVerificationSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_identity_verification_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIdentityVerificationSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIdentityVerificationSessionsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIdentityVerificationSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getIdentityVerificationSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationSessionsSessionRequestBodySchema = z
    .never()
    .optional()

  const getIdentityVerificationSessionsSessionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  // getIdentityVerificationSessionsSession
  router.get(
    `/v1/identity/verification_sessions/:session`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIdentityVerificationSessionsSessionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIdentityVerificationSessionsSessionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIdentityVerificationSessionsSessionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_identity_verification_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIdentityVerificationSessionsSession(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIdentityVerificationSessionsSessionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIdentityVerificationSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsSessionRequestBodySchema = z
    .never()
    .optional()

  const postIdentityVerificationSessionsSessionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  // postIdentityVerificationSessionsSession
  router.post(
    `/v1/identity/verification_sessions/:session`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIdentityVerificationSessionsSessionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIdentityVerificationSessionsSessionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_identity_verification_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIdentityVerificationSessionsSession(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIdentityVerificationSessionsSessionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIdentityVerificationSessionsSessionCancelParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsSessionCancelRequestBodySchema = z
    .never()
    .optional()

  const postIdentityVerificationSessionsSessionCancelResponseBodyValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  // postIdentityVerificationSessionsSessionCancel
  router.post(
    `/v1/identity/verification_sessions/:session/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIdentityVerificationSessionsSessionCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIdentityVerificationSessionsSessionCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_identity_verification_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIdentityVerificationSessionsSessionCancel(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIdentityVerificationSessionsSessionCancelResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIdentityVerificationSessionsSessionRedactParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsSessionRedactRequestBodySchema = z
    .never()
    .optional()

  const postIdentityVerificationSessionsSessionRedactResponseBodyValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  // postIdentityVerificationSessionsSessionRedact
  router.post(
    `/v1/identity/verification_sessions/:session/redact`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIdentityVerificationSessionsSessionRedactParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIdentityVerificationSessionsSessionRedactRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_identity_verification_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIdentityVerificationSessionsSessionRedact(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIdentityVerificationSessionsSessionRedactResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoicePaymentsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    payment: z
      .object({
        payment_intent: z.string().max(5000).optional(),
        type: z.enum(["payment_intent"]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "open", "paid"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicePaymentsRequestBodySchema = z.never().optional()

  const getInvoicePaymentsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoice_payment)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getInvoicePayments
  router.get(
    `/v1/invoice_payments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getInvoicePaymentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoicePaymentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_invoice_payment[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoicePayments(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getInvoicePaymentsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoicePaymentsInvoicePaymentParamSchema = z.object({
    invoice_payment: z.string().max(5000),
  })

  const getInvoicePaymentsInvoicePaymentQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicePaymentsInvoicePaymentRequestBodySchema = z.never().optional()

  const getInvoicePaymentsInvoicePaymentResponseBodyValidator =
    responseValidationFactory([["200", s_invoice_payment]], s_error)

  // getInvoicePaymentsInvoicePayment
  router.get(
    `/v1/invoice_payments/:invoice_payment`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getInvoicePaymentsInvoicePaymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getInvoicePaymentsInvoicePaymentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoicePaymentsInvoicePaymentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoicePaymentsInvoicePayment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getInvoicePaymentsInvoicePaymentResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoiceRenderingTemplatesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "archived"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceRenderingTemplatesRequestBodySchema = z.never().optional()

  const getInvoiceRenderingTemplatesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_invoice_rendering_template),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getInvoiceRenderingTemplates
  router.get(
    `/v1/invoice_rendering_templates`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getInvoiceRenderingTemplatesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoiceRenderingTemplatesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_invoice_rendering_template[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoiceRenderingTemplates(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getInvoiceRenderingTemplatesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoiceRenderingTemplatesTemplateParamSchema = z.object({
    template: z.string().max(5000),
  })

  const getInvoiceRenderingTemplatesTemplateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    version: z.coerce.number().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceRenderingTemplatesTemplateRequestBodySchema = z
    .never()
    .optional()

  const getInvoiceRenderingTemplatesTemplateResponseBodyValidator =
    responseValidationFactory([["200", s_invoice_rendering_template]], s_error)

  // getInvoiceRenderingTemplatesTemplate
  router.get(
    `/v1/invoice_rendering_templates/:template`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getInvoiceRenderingTemplatesTemplateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getInvoiceRenderingTemplatesTemplateQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoiceRenderingTemplatesTemplateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice_rendering_template>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoiceRenderingTemplatesTemplate(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getInvoiceRenderingTemplatesTemplateResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoiceRenderingTemplatesTemplateArchiveParamSchema = z.object({
    template: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceRenderingTemplatesTemplateArchiveRequestBodySchema = z
    .never()
    .optional()

  const postInvoiceRenderingTemplatesTemplateArchiveResponseBodyValidator =
    responseValidationFactory([["200", s_invoice_rendering_template]], s_error)

  // postInvoiceRenderingTemplatesTemplateArchive
  router.post(
    `/v1/invoice_rendering_templates/:template/archive`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoiceRenderingTemplatesTemplateArchiveParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoiceRenderingTemplatesTemplateArchiveRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice_rendering_template>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoiceRenderingTemplatesTemplateArchive(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoiceRenderingTemplatesTemplateArchiveResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoiceRenderingTemplatesTemplateUnarchiveParamSchema = z.object({
    template: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceRenderingTemplatesTemplateUnarchiveRequestBodySchema = z
    .never()
    .optional()

  const postInvoiceRenderingTemplatesTemplateUnarchiveResponseBodyValidator =
    responseValidationFactory([["200", s_invoice_rendering_template]], s_error)

  // postInvoiceRenderingTemplatesTemplateUnarchive
  router.post(
    `/v1/invoice_rendering_templates/:template/unarchive`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoiceRenderingTemplatesTemplateUnarchiveRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice_rendering_template>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoiceRenderingTemplatesTemplateUnarchive(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoiceRenderingTemplatesTemplateUnarchiveResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoiceitemsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    pending: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceitemsRequestBodySchema = z.never().optional()

  const getInvoiceitemsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoiceitem)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/invoiceitems")),
        }),
      ],
    ],
    s_error,
  )

  // getInvoiceitems
  router.get(
    `/v1/invoiceitems`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getInvoiceitemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoiceitemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_invoiceitem[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoiceitems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getInvoiceitemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceitemsRequestBodySchema = z.never()

  const postInvoiceitemsResponseBodyValidator = responseValidationFactory(
    [["200", s_invoiceitem]],
    s_error,
  )

  // postInvoiceitems
  router.post(
    `/v1/invoiceitems`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postInvoiceitemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoiceitem>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoiceitems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postInvoiceitemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteInvoiceitemsInvoiceitemRequestBodySchema = z.never().optional()

  const deleteInvoiceitemsInvoiceitemResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_invoiceitem]], s_error)

  // deleteInvoiceitemsInvoiceitem
  router.delete(
    `/v1/invoiceitems/:invoiceitem`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteInvoiceitemsInvoiceitemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteInvoiceitemsInvoiceitemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_invoiceitem>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteInvoiceitemsInvoiceitem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteInvoiceitemsInvoiceitemResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  const getInvoiceitemsInvoiceitemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceitemsInvoiceitemRequestBodySchema = z.never().optional()

  const getInvoiceitemsInvoiceitemResponseBodyValidator =
    responseValidationFactory([["200", s_invoiceitem]], s_error)

  // getInvoiceitemsInvoiceitem
  router.get(
    `/v1/invoiceitems/:invoiceitem`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getInvoiceitemsInvoiceitemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getInvoiceitemsInvoiceitemQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoiceitemsInvoiceitemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoiceitem>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoiceitemsInvoiceitem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getInvoiceitemsInvoiceitemResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceitemsInvoiceitemRequestBodySchema = z.never().optional()

  const postInvoiceitemsInvoiceitemResponseBodyValidator =
    responseValidationFactory([["200", s_invoiceitem]], s_error)

  // postInvoiceitemsInvoiceitem
  router.post(
    `/v1/invoiceitems/:invoiceitem`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoiceitemsInvoiceitemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoiceitemsInvoiceitemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoiceitem>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoiceitemsInvoiceitem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoiceitemsInvoiceitemResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoicesQuerySchema = z.object({
    collection_method: z
      .enum(["charge_automatically", "send_invoice"])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    due_date: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["draft", "open", "paid", "uncollectible", "void"])
      .optional(),
    subscription: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesRequestBodySchema = z.never().optional()

  const getInvoicesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoice)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/invoices")),
        }),
      ],
    ],
    s_error,
  )

  // getInvoices
  router.get(
    `/v1/invoices`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getInvoicesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoicesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_invoice[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoices(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getInvoicesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesRequestBodySchema = z.never().optional()

  const postInvoicesResponseBodyValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  // postInvoices
  router.post(
    `/v1/invoices`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postInvoicesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoices(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postInvoicesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesCreatePreviewRequestBodySchema = z.never().optional()

  const postInvoicesCreatePreviewResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesCreatePreview
  router.post(
    `/v1/invoices/create_preview`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postInvoicesCreatePreviewRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesCreatePreview(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postInvoicesCreatePreviewResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoicesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesSearchRequestBodySchema = z.never().optional()

  const getInvoicesSearchResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoice)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getInvoicesSearch
  router.get(
    `/v1/invoices/search`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getInvoicesSearchQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoicesSearchRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_invoice[]
              has_more: boolean
              next_page?: (string | null) | undefined
              object: "search_result"
              total_count?: number | undefined
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoicesSearch(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getInvoicesSearchResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteInvoicesInvoiceRequestBodySchema = z.never().optional()

  const deleteInvoicesInvoiceResponseBodyValidator = responseValidationFactory(
    [["200", s_deleted_invoice]],
    s_error,
  )

  // deleteInvoicesInvoice
  router.delete(
    `/v1/invoices/:invoice`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteInvoicesInvoiceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteInvoicesInvoiceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteInvoicesInvoice(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteInvoicesInvoiceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const getInvoicesInvoiceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesInvoiceRequestBodySchema = z.never().optional()

  const getInvoicesInvoiceResponseBodyValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  // getInvoicesInvoice
  router.get(
    `/v1/invoices/:invoice`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getInvoicesInvoiceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getInvoicesInvoiceQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoicesInvoiceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoicesInvoice(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getInvoicesInvoiceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceRequestBodySchema = z.never().optional()

  const postInvoicesInvoiceResponseBodyValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  // postInvoicesInvoice
  router.post(
    `/v1/invoices/:invoice`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoice(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postInvoicesInvoiceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceAddLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceAddLinesRequestBodySchema = z.never()

  const postInvoicesInvoiceAddLinesResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceAddLines
  router.post(
    `/v1/invoices/:invoice/add_lines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceAddLinesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceAddLinesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceAddLines(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoicesInvoiceAddLinesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceAttachPaymentParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceAttachPaymentRequestBodySchema = z.never().optional()

  const postInvoicesInvoiceAttachPaymentResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceAttachPayment
  router.post(
    `/v1/invoices/:invoice/attach_payment`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceAttachPaymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceAttachPaymentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceAttachPayment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoicesInvoiceAttachPaymentResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceFinalizeParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceFinalizeRequestBodySchema = z.never().optional()

  const postInvoicesInvoiceFinalizeResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceFinalize
  router.post(
    `/v1/invoices/:invoice/finalize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceFinalizeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceFinalizeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceFinalize(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoicesInvoiceFinalizeResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getInvoicesInvoiceLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const getInvoicesInvoiceLinesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesInvoiceLinesRequestBodySchema = z.never().optional()

  const getInvoicesInvoiceLinesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_line_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getInvoicesInvoiceLines
  router.get(
    `/v1/invoices/:invoice/lines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getInvoicesInvoiceLinesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getInvoicesInvoiceLinesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getInvoicesInvoiceLinesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_line_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getInvoicesInvoiceLines(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getInvoicesInvoiceLinesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceLinesLineItemIdParamSchema = z.object({
    invoice: z.string().max(5000),
    line_item_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceLinesLineItemIdRequestBodySchema = z
    .never()
    .optional()

  const postInvoicesInvoiceLinesLineItemIdResponseBodyValidator =
    responseValidationFactory([["200", s_line_item]], s_error)

  // postInvoicesInvoiceLinesLineItemId
  router.post(
    `/v1/invoices/:invoice/lines/:line_item_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceLinesLineItemIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceLinesLineItemIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_line_item>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceLinesLineItemId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoicesInvoiceLinesLineItemIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceMarkUncollectibleParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceMarkUncollectibleRequestBodySchema = z
    .never()
    .optional()

  const postInvoicesInvoiceMarkUncollectibleResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceMarkUncollectible
  router.post(
    `/v1/invoices/:invoice/mark_uncollectible`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceMarkUncollectibleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceMarkUncollectibleRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceMarkUncollectible(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoicesInvoiceMarkUncollectibleResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoicePayParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoicePayRequestBodySchema = z.never().optional()

  const postInvoicesInvoicePayResponseBodyValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  // postInvoicesInvoicePay
  router.post(
    `/v1/invoices/:invoice/pay`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoicePayParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoicePayRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoicePay(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postInvoicesInvoicePayResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceRemoveLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceRemoveLinesRequestBodySchema = z.never()

  const postInvoicesInvoiceRemoveLinesResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceRemoveLines
  router.post(
    `/v1/invoices/:invoice/remove_lines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceRemoveLinesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceRemoveLinesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceRemoveLines(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoicesInvoiceRemoveLinesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceSendParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceSendRequestBodySchema = z.never().optional()

  const postInvoicesInvoiceSendResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceSend
  router.post(
    `/v1/invoices/:invoice/send`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceSendParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceSendRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceSend(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postInvoicesInvoiceSendResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceUpdateLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceUpdateLinesRequestBodySchema = z.never()

  const postInvoicesInvoiceUpdateLinesResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceUpdateLines
  router.post(
    `/v1/invoices/:invoice/update_lines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceUpdateLinesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceUpdateLinesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceUpdateLines(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postInvoicesInvoiceUpdateLinesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postInvoicesInvoiceVoidParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceVoidRequestBodySchema = z.never().optional()

  const postInvoicesInvoiceVoidResponseBodyValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  // postInvoicesInvoiceVoid
  router.post(
    `/v1/invoices/:invoice/void`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postInvoicesInvoiceVoidParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postInvoicesInvoiceVoidRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_invoice>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postInvoicesInvoiceVoid(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postInvoicesInvoiceVoidResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingAuthorizationsQuerySchema = z.object({
    card: z.string().max(5000).optional(),
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["closed", "expired", "pending", "reversed"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingAuthorizationsRequestBodySchema = z.never().optional()

  const getIssuingAuthorizationsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_issuing_authorization)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/issuing/authorizations")),
          }),
        ],
      ],
      s_error,
    )

  // getIssuingAuthorizations
  router.get(
    `/v1/issuing/authorizations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingAuthorizationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingAuthorizationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_authorization[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingAuthorizations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingAuthorizationsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingAuthorizationsAuthorizationParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  const getIssuingAuthorizationsAuthorizationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingAuthorizationsAuthorizationRequestBodySchema = z
    .never()
    .optional()

  const getIssuingAuthorizationsAuthorizationResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // getIssuingAuthorizationsAuthorization
  router.get(
    `/v1/issuing/authorizations/:authorization`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingAuthorizationsAuthorizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingAuthorizationsAuthorizationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingAuthorizationsAuthorizationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingAuthorizationsAuthorization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIssuingAuthorizationsAuthorizationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingAuthorizationsAuthorizationParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingAuthorizationsAuthorizationRequestBodySchema = z
    .never()
    .optional()

  const postIssuingAuthorizationsAuthorizationResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postIssuingAuthorizationsAuthorization
  router.post(
    `/v1/issuing/authorizations/:authorization`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingAuthorizationsAuthorizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingAuthorizationsAuthorizationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingAuthorizationsAuthorization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingAuthorizationsAuthorizationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingAuthorizationsAuthorizationApproveParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingAuthorizationsAuthorizationApproveRequestBodySchema = z
    .never()
    .optional()

  const postIssuingAuthorizationsAuthorizationApproveResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postIssuingAuthorizationsAuthorizationApprove
  router.post(
    `/v1/issuing/authorizations/:authorization/approve`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingAuthorizationsAuthorizationApproveParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingAuthorizationsAuthorizationApproveRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingAuthorizationsAuthorizationApprove(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingAuthorizationsAuthorizationApproveResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingAuthorizationsAuthorizationDeclineParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingAuthorizationsAuthorizationDeclineRequestBodySchema = z
    .never()
    .optional()

  const postIssuingAuthorizationsAuthorizationDeclineResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postIssuingAuthorizationsAuthorizationDecline
  router.post(
    `/v1/issuing/authorizations/:authorization/decline`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingAuthorizationsAuthorizationDeclineParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingAuthorizationsAuthorizationDeclineRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingAuthorizationsAuthorizationDecline(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingAuthorizationsAuthorizationDeclineResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingCardholdersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    email: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    phone_number: z.string().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "blocked", "inactive"]).optional(),
    type: z.enum(["company", "individual"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardholdersRequestBodySchema = z.never().optional()

  const getIssuingCardholdersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_cardholder)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/issuing/cardholders")),
        }),
      ],
    ],
    s_error,
  )

  // getIssuingCardholders
  router.get(
    `/v1/issuing/cardholders`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingCardholdersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingCardholdersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_cardholder[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingCardholders(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingCardholdersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardholdersRequestBodySchema = z.never()

  const postIssuingCardholdersResponseBodyValidator = responseValidationFactory(
    [["200", s_issuing_cardholder]],
    s_error,
  )

  // postIssuingCardholders
  router.post(
    `/v1/issuing/cardholders`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postIssuingCardholdersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_cardholder>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingCardholders(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postIssuingCardholdersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingCardholdersCardholderParamSchema = z.object({
    cardholder: z.string().max(5000),
  })

  const getIssuingCardholdersCardholderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardholdersCardholderRequestBodySchema = z.never().optional()

  const getIssuingCardholdersCardholderResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_cardholder]], s_error)

  // getIssuingCardholdersCardholder
  router.get(
    `/v1/issuing/cardholders/:cardholder`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingCardholdersCardholderParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingCardholdersCardholderQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingCardholdersCardholderRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_cardholder>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingCardholdersCardholder(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIssuingCardholdersCardholderResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingCardholdersCardholderParamSchema = z.object({
    cardholder: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardholdersCardholderRequestBodySchema = z.never().optional()

  const postIssuingCardholdersCardholderResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_cardholder]], s_error)

  // postIssuingCardholdersCardholder
  router.post(
    `/v1/issuing/cardholders/:cardholder`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingCardholdersCardholderParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingCardholdersCardholderRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_cardholder>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingCardholdersCardholder(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingCardholdersCardholderResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingCardsQuerySchema = z.object({
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    exp_month: z.coerce.number().optional(),
    exp_year: z.coerce.number().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    last4: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    personalization_design: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "canceled", "inactive"]).optional(),
    type: z.enum(["physical", "virtual"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardsRequestBodySchema = z.never().optional()

  const getIssuingCardsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_card)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/issuing/cards")),
        }),
      ],
    ],
    s_error,
  )

  // getIssuingCards
  router.get(
    `/v1/issuing/cards`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingCardsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingCardsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_card[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingCards(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingCardsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardsRequestBodySchema = z.never()

  const postIssuingCardsResponseBodyValidator = responseValidationFactory(
    [["200", s_issuing_card]],
    s_error,
  )

  // postIssuingCards
  router.post(
    `/v1/issuing/cards`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postIssuingCardsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingCards(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postIssuingCardsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingCardsCardParamSchema = z.object({card: z.string().max(5000)})

  const getIssuingCardsCardQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardsCardRequestBodySchema = z.never().optional()

  const getIssuingCardsCardResponseBodyValidator = responseValidationFactory(
    [["200", s_issuing_card]],
    s_error,
  )

  // getIssuingCardsCard
  router.get(
    `/v1/issuing/cards/:card`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingCardsCardParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingCardsCardQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingCardsCardRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingCardsCard(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingCardsCardResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingCardsCardParamSchema = z.object({card: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardsCardRequestBodySchema = z.never().optional()

  const postIssuingCardsCardResponseBodyValidator = responseValidationFactory(
    [["200", s_issuing_card]],
    s_error,
  )

  // postIssuingCardsCard
  router.post(
    `/v1/issuing/cards/:card`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingCardsCardParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingCardsCardRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingCardsCard(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postIssuingCardsCardResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingDisputesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["expired", "lost", "submitted", "unsubmitted", "won"])
      .optional(),
    transaction: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingDisputesRequestBodySchema = z.never().optional()

  const getIssuingDisputesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_dispute)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/issuing/disputes")),
        }),
      ],
    ],
    s_error,
  )

  // getIssuingDisputes
  router.get(
    `/v1/issuing/disputes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingDisputesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingDisputesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_dispute[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingDisputes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingDisputesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingDisputesRequestBodySchema = z.never().optional()

  const postIssuingDisputesResponseBodyValidator = responseValidationFactory(
    [["200", s_issuing_dispute]],
    s_error,
  )

  // postIssuingDisputes
  router.post(
    `/v1/issuing/disputes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postIssuingDisputesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingDisputes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postIssuingDisputesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const getIssuingDisputesDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingDisputesDisputeRequestBodySchema = z.never().optional()

  const getIssuingDisputesDisputeResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_dispute]], s_error)

  // getIssuingDisputesDispute
  router.get(
    `/v1/issuing/disputes/:dispute`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingDisputesDisputeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingDisputesDisputeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingDisputesDisputeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingDisputesDispute(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingDisputesDisputeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingDisputesDisputeRequestBodySchema = z.never().optional()

  const postIssuingDisputesDisputeResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_dispute]], s_error)

  // postIssuingDisputesDispute
  router.post(
    `/v1/issuing/disputes/:dispute`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingDisputesDisputeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingDisputesDisputeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingDisputesDispute(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingDisputesDisputeResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingDisputesDisputeSubmitParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingDisputesDisputeSubmitRequestBodySchema = z.never().optional()

  const postIssuingDisputesDisputeSubmitResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_dispute]], s_error)

  // postIssuingDisputesDisputeSubmit
  router.post(
    `/v1/issuing/disputes/:dispute/submit`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingDisputesDisputeSubmitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingDisputesDisputeSubmitRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_dispute>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingDisputesDisputeSubmit(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingDisputesDisputeSubmitResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingPersonalizationDesignsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_keys: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(200)),
      )
      .optional(),
    preferences: z
      .object({
        is_default: PermissiveBoolean.optional(),
        is_platform_default: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive", "rejected", "review"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPersonalizationDesignsRequestBodySchema = z.never().optional()

  const getIssuingPersonalizationDesignsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_issuing_personalization_design)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/issuing/personalization_designs")),
          }),
        ],
      ],
      s_error,
    )

  // getIssuingPersonalizationDesigns
  router.get(
    `/v1/issuing/personalization_designs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingPersonalizationDesignsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingPersonalizationDesignsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_personalization_design[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingPersonalizationDesigns(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIssuingPersonalizationDesignsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingPersonalizationDesignsRequestBodySchema = z.never()

  const postIssuingPersonalizationDesignsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  // postIssuingPersonalizationDesigns
  router.post(
    `/v1/issuing/personalization_designs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postIssuingPersonalizationDesignsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_personalization_design>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingPersonalizationDesigns(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingPersonalizationDesignsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingPersonalizationDesignsPersonalizationDesignParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  const getIssuingPersonalizationDesignsPersonalizationDesignQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema =
    z.never().optional()

  const getIssuingPersonalizationDesignsPersonalizationDesignResponseBodyValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  // getIssuingPersonalizationDesignsPersonalizationDesign
  router.get(
    `/v1/issuing/personalization_designs/:personalization_design`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_personalization_design>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingPersonalizationDesignsPersonalizationDesign(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIssuingPersonalizationDesignsPersonalizationDesignResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingPersonalizationDesignsPersonalizationDesignParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema =
    z.never().optional()

  const postIssuingPersonalizationDesignsPersonalizationDesignResponseBodyValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  // postIssuingPersonalizationDesignsPersonalizationDesign
  router.post(
    `/v1/issuing/personalization_designs/:personalization_design`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingPersonalizationDesignsPersonalizationDesignRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_personalization_design>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingPersonalizationDesignsPersonalizationDesign(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingPersonalizationDesignsPersonalizationDesignResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingPhysicalBundlesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive", "review"]).optional(),
    type: z.enum(["custom", "standard"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPhysicalBundlesRequestBodySchema = z.never().optional()

  const getIssuingPhysicalBundlesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_issuing_physical_bundle),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/issuing/physical_bundles")),
          }),
        ],
      ],
      s_error,
    )

  // getIssuingPhysicalBundles
  router.get(
    `/v1/issuing/physical_bundles`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingPhysicalBundlesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingPhysicalBundlesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_physical_bundle[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingPhysicalBundles(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingPhysicalBundlesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingPhysicalBundlesPhysicalBundleParamSchema = z.object({
    physical_bundle: z.string().max(5000),
  })

  const getIssuingPhysicalBundlesPhysicalBundleQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPhysicalBundlesPhysicalBundleRequestBodySchema = z
    .never()
    .optional()

  const getIssuingPhysicalBundlesPhysicalBundleResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_physical_bundle]], s_error)

  // getIssuingPhysicalBundlesPhysicalBundle
  router.get(
    `/v1/issuing/physical_bundles/:physical_bundle`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingPhysicalBundlesPhysicalBundleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingPhysicalBundlesPhysicalBundleQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingPhysicalBundlesPhysicalBundleRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_physical_bundle>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingPhysicalBundlesPhysicalBundle(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIssuingPhysicalBundlesPhysicalBundleResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingSettlementsSettlementParamSchema = z.object({
    settlement: z.string().max(5000),
  })

  const getIssuingSettlementsSettlementQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingSettlementsSettlementRequestBodySchema = z.never().optional()

  const getIssuingSettlementsSettlementResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  // getIssuingSettlementsSettlement
  router.get(
    `/v1/issuing/settlements/:settlement`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingSettlementsSettlementParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingSettlementsSettlementQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingSettlementsSettlementRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_settlement>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingSettlementsSettlement(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIssuingSettlementsSettlementResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingSettlementsSettlementParamSchema = z.object({
    settlement: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingSettlementsSettlementRequestBodySchema = z.never().optional()

  const postIssuingSettlementsSettlementResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  // postIssuingSettlementsSettlement
  router.post(
    `/v1/issuing/settlements/:settlement`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingSettlementsSettlementParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingSettlementsSettlementRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_settlement>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingSettlementsSettlement(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingSettlementsSettlementResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingTokensQuerySchema = z.object({
    card: z.string().max(5000),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "deleted", "requested", "suspended"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTokensRequestBodySchema = z.never().optional()

  const getIssuingTokensResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_token)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getIssuingTokens
  router.get(
    `/v1/issuing/tokens`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingTokensQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingTokensRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_token[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingTokens(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingTokensResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingTokensTokenParamSchema = z.object({
    token: z.string().max(5000),
  })

  const getIssuingTokensTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTokensTokenRequestBodySchema = z.never().optional()

  const getIssuingTokensTokenResponseBodyValidator = responseValidationFactory(
    [["200", s_issuing_token]],
    s_error,
  )

  // getIssuingTokensToken
  router.get(
    `/v1/issuing/tokens/:token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingTokensTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingTokensTokenQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingTokensTokenRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_token>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingTokensToken(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingTokensTokenResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingTokensTokenParamSchema = z.object({
    token: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingTokensTokenRequestBodySchema = z.never()

  const postIssuingTokensTokenResponseBodyValidator = responseValidationFactory(
    [["200", s_issuing_token]],
    s_error,
  )

  // postIssuingTokensToken
  router.post(
    `/v1/issuing/tokens/:token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingTokensTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingTokensTokenRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_token>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingTokensToken(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postIssuingTokensTokenResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingTransactionsQuerySchema = z.object({
    card: z.string().max(5000).optional(),
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["capture", "refund"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTransactionsRequestBodySchema = z.never().optional()

  const getIssuingTransactionsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_transaction)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/issuing/transactions")),
        }),
      ],
    ],
    s_error,
  )

  // getIssuingTransactions
  router.get(
    `/v1/issuing/transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getIssuingTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_issuing_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingTransactions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getIssuingTransactionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getIssuingTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getIssuingTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTransactionsTransactionRequestBodySchema = z
    .never()
    .optional()

  const getIssuingTransactionsTransactionResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  // getIssuingTransactionsTransaction
  router.get(
    `/v1/issuing/transactions/:transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getIssuingTransactionsTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getIssuingTransactionsTransactionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getIssuingTransactionsTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getIssuingTransactionsTransaction(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getIssuingTransactionsTransactionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postIssuingTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingTransactionsTransactionRequestBodySchema = z
    .never()
    .optional()

  const postIssuingTransactionsTransactionResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  // postIssuingTransactionsTransaction
  router.post(
    `/v1/issuing/transactions/:transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postIssuingTransactionsTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postIssuingTransactionsTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postIssuingTransactionsTransaction(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postIssuingTransactionsTransactionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postLinkAccountSessionsRequestBodySchema = z.never()

  const postLinkAccountSessionsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_session]],
      s_error,
    )

  // postLinkAccountSessions
  router.post(
    `/v1/link_account_sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postLinkAccountSessionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postLinkAccountSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postLinkAccountSessionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getLinkAccountSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getLinkAccountSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkAccountSessionsSessionRequestBodySchema = z.never().optional()

  const getLinkAccountSessionsSessionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_session]],
      s_error,
    )

  // getLinkAccountSessionsSession
  router.get(
    `/v1/link_account_sessions/:session`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getLinkAccountSessionsSessionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getLinkAccountSessionsSessionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getLinkAccountSessionsSessionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_session>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getLinkAccountSessionsSession(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getLinkAccountSessionsSessionResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getLinkedAccountsQuerySchema = z.object({
    account_holder: z
      .object({
        account: z.string().max(5000).optional(),
        customer: z.string().max(5000).optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    session: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkedAccountsRequestBodySchema = z.never().optional()

  const getLinkedAccountsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_financial_connections_account)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/financial_connections/accounts")),
        }),
      ],
    ],
    s_error,
  )

  // getLinkedAccounts
  router.get(
    `/v1/linked_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getLinkedAccountsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getLinkedAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_financial_connections_account[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getLinkedAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getLinkedAccountsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getLinkedAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getLinkedAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkedAccountsAccountRequestBodySchema = z.never().optional()

  const getLinkedAccountsAccountResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // getLinkedAccountsAccount
  router.get(
    `/v1/linked_accounts/:account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getLinkedAccountsAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getLinkedAccountsAccountQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getLinkedAccountsAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getLinkedAccountsAccount(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getLinkedAccountsAccountResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postLinkedAccountsAccountDisconnectParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postLinkedAccountsAccountDisconnectRequestBodySchema = z
    .never()
    .optional()

  const postLinkedAccountsAccountDisconnectResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // postLinkedAccountsAccountDisconnect
  router.post(
    `/v1/linked_accounts/:account/disconnect`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postLinkedAccountsAccountDisconnectParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postLinkedAccountsAccountDisconnectRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postLinkedAccountsAccountDisconnect(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postLinkedAccountsAccountDisconnectResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getLinkedAccountsAccountOwnersParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getLinkedAccountsAccountOwnersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    ownership: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkedAccountsAccountOwnersRequestBodySchema = z.never().optional()

  const getLinkedAccountsAccountOwnersResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_financial_connections_account_owner),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getLinkedAccountsAccountOwners
  router.get(
    `/v1/linked_accounts/:account/owners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getLinkedAccountsAccountOwnersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getLinkedAccountsAccountOwnersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getLinkedAccountsAccountOwnersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_financial_connections_account_owner[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getLinkedAccountsAccountOwners(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getLinkedAccountsAccountOwnersResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postLinkedAccountsAccountRefreshParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postLinkedAccountsAccountRefreshRequestBodySchema = z.never()

  const postLinkedAccountsAccountRefreshResponseBodyValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  // postLinkedAccountsAccountRefresh
  router.post(
    `/v1/linked_accounts/:account/refresh`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postLinkedAccountsAccountRefreshParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postLinkedAccountsAccountRefreshRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_financial_connections_account>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postLinkedAccountsAccountRefresh(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postLinkedAccountsAccountRefreshResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getMandatesMandateParamSchema = z.object({mandate: z.string()})

  const getMandatesMandateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getMandatesMandateRequestBodySchema = z.never().optional()

  const getMandatesMandateResponseBodyValidator = responseValidationFactory(
    [["200", s_mandate]],
    s_error,
  )

  // getMandatesMandate
  router.get(
    `/v1/mandates/:mandate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getMandatesMandateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getMandatesMandateQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getMandatesMandateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_mandate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getMandatesMandate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getMandatesMandateResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentIntentsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentIntentsRequestBodySchema = z.never().optional()

  const getPaymentIntentsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payment_intent)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payment_intents")),
        }),
      ],
    ],
    s_error,
  )

  // getPaymentIntents
  router.get(
    `/v1/payment_intents`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPaymentIntentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentIntentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payment_intent[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentIntents(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPaymentIntentsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsRequestBodySchema = z.never()

  const postPaymentIntentsResponseBodyValidator = responseValidationFactory(
    [["200", s_payment_intent]],
    s_error,
  )

  // postPaymentIntents
  router.post(
    `/v1/payment_intents`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntents(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPaymentIntentsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentIntentsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentIntentsSearchRequestBodySchema = z.never().optional()

  const getPaymentIntentsSearchResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_payment_intent)),
            has_more: PermissiveBoolean,
            next_page: z.string().max(5000).nullable().optional(),
            object: z.enum(["search_result"]),
            total_count: z.coerce.number().optional(),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getPaymentIntentsSearch
  router.get(
    `/v1/payment_intents/search`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPaymentIntentsSearchQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentIntentsSearchRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payment_intent[]
              has_more: boolean
              next_page?: (string | null) | undefined
              object: "search_result"
              total_count?: number | undefined
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentIntentsSearch(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPaymentIntentsSearchResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const getPaymentIntentsIntentQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentIntentsIntentRequestBodySchema = z.never().optional()

  const getPaymentIntentsIntentResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // getPaymentIntentsIntent
  router.get(
    `/v1/payment_intents/:intent`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPaymentIntentsIntentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPaymentIntentsIntentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentIntentsIntentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentIntentsIntent(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPaymentIntentsIntentResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentRequestBodySchema = z.never().optional()

  const postPaymentIntentsIntentResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // postPaymentIntentsIntent
  router.post(
    `/v1/payment_intents/:intent`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentIntentsIntentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsIntentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntentsIntent(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPaymentIntentsIntentResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentIntentsIntentApplyCustomerBalanceParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentApplyCustomerBalanceRequestBodySchema = z
    .never()
    .optional()

  const postPaymentIntentsIntentApplyCustomerBalanceResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // postPaymentIntentsIntentApplyCustomerBalance
  router.post(
    `/v1/payment_intents/:intent/apply_customer_balance`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentIntentsIntentApplyCustomerBalanceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsIntentApplyCustomerBalanceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntentsIntentApplyCustomerBalance(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentIntentsIntentApplyCustomerBalanceResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentIntentsIntentCancelParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentCancelRequestBodySchema = z.never().optional()

  const postPaymentIntentsIntentCancelResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // postPaymentIntentsIntentCancel
  router.post(
    `/v1/payment_intents/:intent/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentIntentsIntentCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsIntentCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntentsIntentCancel(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentIntentsIntentCancelResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentIntentsIntentCaptureParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentCaptureRequestBodySchema = z.never().optional()

  const postPaymentIntentsIntentCaptureResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // postPaymentIntentsIntentCapture
  router.post(
    `/v1/payment_intents/:intent/capture`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentIntentsIntentCaptureParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsIntentCaptureRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntentsIntentCapture(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentIntentsIntentCaptureResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentIntentsIntentConfirmParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentConfirmRequestBodySchema = z.never().optional()

  const postPaymentIntentsIntentConfirmResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // postPaymentIntentsIntentConfirm
  router.post(
    `/v1/payment_intents/:intent/confirm`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentIntentsIntentConfirmParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsIntentConfirmRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntentsIntentConfirm(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentIntentsIntentConfirmResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentIntentsIntentIncrementAuthorizationParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentIncrementAuthorizationRequestBodySchema =
    z.never()

  const postPaymentIntentsIntentIncrementAuthorizationResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // postPaymentIntentsIntentIncrementAuthorization
  router.post(
    `/v1/payment_intents/:intent/increment_authorization`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentIntentsIntentIncrementAuthorizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsIntentIncrementAuthorizationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntentsIntentIncrementAuthorization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentIntentsIntentIncrementAuthorizationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentIntentsIntentVerifyMicrodepositsParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentVerifyMicrodepositsRequestBodySchema = z
    .never()
    .optional()

  const postPaymentIntentsIntentVerifyMicrodepositsResponseBodyValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  // postPaymentIntentsIntentVerifyMicrodeposits
  router.post(
    `/v1/payment_intents/:intent/verify_microdeposits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentIntentsIntentVerifyMicrodepositsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentIntentsIntentVerifyMicrodepositsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentIntentsIntentVerifyMicrodeposits(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentIntentsIntentVerifyMicrodepositsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentLinksQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentLinksRequestBodySchema = z.never().optional()

  const getPaymentLinksResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payment_link)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payment_links")),
        }),
      ],
    ],
    s_error,
  )

  // getPaymentLinks
  router.get(
    `/v1/payment_links`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPaymentLinksQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentLinksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payment_link[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentLinks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPaymentLinksResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentLinksRequestBodySchema = z.never()

  const postPaymentLinksResponseBodyValidator = responseValidationFactory(
    [["200", s_payment_link]],
    s_error,
  )

  // postPaymentLinks
  router.post(
    `/v1/payment_links`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPaymentLinksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentLinks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPaymentLinksResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentLinksPaymentLinkParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  const getPaymentLinksPaymentLinkQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentLinksPaymentLinkRequestBodySchema = z.never().optional()

  const getPaymentLinksPaymentLinkResponseBodyValidator =
    responseValidationFactory([["200", s_payment_link]], s_error)

  // getPaymentLinksPaymentLink
  router.get(
    `/v1/payment_links/:payment_link`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPaymentLinksPaymentLinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPaymentLinksPaymentLinkQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentLinksPaymentLinkRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentLinksPaymentLink(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getPaymentLinksPaymentLinkResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentLinksPaymentLinkParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentLinksPaymentLinkRequestBodySchema = z.never().optional()

  const postPaymentLinksPaymentLinkResponseBodyValidator =
    responseValidationFactory([["200", s_payment_link]], s_error)

  // postPaymentLinksPaymentLink
  router.post(
    `/v1/payment_links/:payment_link`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentLinksPaymentLinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentLinksPaymentLinkRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_link>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentLinksPaymentLink(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentLinksPaymentLinkResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentLinksPaymentLinkLineItemsParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  const getPaymentLinksPaymentLinkLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentLinksPaymentLinkLineItemsRequestBodySchema = z
    .never()
    .optional()

  const getPaymentLinksPaymentLinkLineItemsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getPaymentLinksPaymentLinkLineItems
  router.get(
    `/v1/payment_links/:payment_link/line_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPaymentLinksPaymentLinkLineItemsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPaymentLinksPaymentLinkLineItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentLinksPaymentLinkLineItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentLinksPaymentLinkLineItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getPaymentLinksPaymentLinkLineItemsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentMethodConfigurationsQuerySchema = z.object({
    application: z.union([z.string().max(100), z.enum([""])]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodConfigurationsRequestBodySchema = z.never().optional()

  const getPaymentMethodConfigurationsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_payment_method_configuration),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/payment_method_configurations")),
          }),
        ],
      ],
      s_error,
    )

  // getPaymentMethodConfigurations
  router.get(
    `/v1/payment_method_configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPaymentMethodConfigurationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentMethodConfigurationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payment_method_configuration[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentMethodConfigurations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getPaymentMethodConfigurationsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodConfigurationsRequestBodySchema = z.never().optional()

  const postPaymentMethodConfigurationsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_payment_method_configuration]],
      s_error,
    )

  // postPaymentMethodConfigurations
  router.post(
    `/v1/payment_method_configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodConfigurationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method_configuration>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodConfigurations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentMethodConfigurationsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentMethodConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getPaymentMethodConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodConfigurationsConfigurationRequestBodySchema = z
    .never()
    .optional()

  const getPaymentMethodConfigurationsConfigurationResponseBodyValidator =
    responseValidationFactory(
      [["200", s_payment_method_configuration]],
      s_error,
    )

  // getPaymentMethodConfigurationsConfiguration
  router.get(
    `/v1/payment_method_configurations/:configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPaymentMethodConfigurationsConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPaymentMethodConfigurationsConfigurationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentMethodConfigurationsConfigurationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method_configuration>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentMethodConfigurationsConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getPaymentMethodConfigurationsConfigurationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentMethodConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodConfigurationsConfigurationRequestBodySchema = z
    .never()
    .optional()

  const postPaymentMethodConfigurationsConfigurationResponseBodyValidator =
    responseValidationFactory(
      [["200", s_payment_method_configuration]],
      s_error,
    )

  // postPaymentMethodConfigurationsConfiguration
  router.post(
    `/v1/payment_method_configurations/:configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentMethodConfigurationsConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodConfigurationsConfigurationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method_configuration>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodConfigurationsConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentMethodConfigurationsConfigurationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentMethodDomainsQuerySchema = z.object({
    domain_name: z.string().max(5000).optional(),
    enabled: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodDomainsRequestBodySchema = z.never().optional()

  const getPaymentMethodDomainsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_payment_method_domain),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/payment_method_domains")),
          }),
        ],
      ],
      s_error,
    )

  // getPaymentMethodDomains
  router.get(
    `/v1/payment_method_domains`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPaymentMethodDomainsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentMethodDomainsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payment_method_domain[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentMethodDomains(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPaymentMethodDomainsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodDomainsRequestBodySchema = z.never()

  const postPaymentMethodDomainsResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method_domain]], s_error)

  // postPaymentMethodDomains
  router.post(
    `/v1/payment_method_domains`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodDomainsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method_domain>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodDomains(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPaymentMethodDomainsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentMethodDomainsPaymentMethodDomainParamSchema = z.object({
    payment_method_domain: z.string().max(5000),
  })

  const getPaymentMethodDomainsPaymentMethodDomainQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodDomainsPaymentMethodDomainRequestBodySchema = z
    .never()
    .optional()

  const getPaymentMethodDomainsPaymentMethodDomainResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method_domain]], s_error)

  // getPaymentMethodDomainsPaymentMethodDomain
  router.get(
    `/v1/payment_method_domains/:payment_method_domain`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPaymentMethodDomainsPaymentMethodDomainParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPaymentMethodDomainsPaymentMethodDomainQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentMethodDomainsPaymentMethodDomainRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method_domain>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentMethodDomainsPaymentMethodDomain(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getPaymentMethodDomainsPaymentMethodDomainResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentMethodDomainsPaymentMethodDomainParamSchema = z.object({
    payment_method_domain: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodDomainsPaymentMethodDomainRequestBodySchema = z
    .never()
    .optional()

  const postPaymentMethodDomainsPaymentMethodDomainResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method_domain]], s_error)

  // postPaymentMethodDomainsPaymentMethodDomain
  router.post(
    `/v1/payment_method_domains/:payment_method_domain`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentMethodDomainsPaymentMethodDomainParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodDomainsPaymentMethodDomainRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method_domain>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodDomainsPaymentMethodDomain(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentMethodDomainsPaymentMethodDomainResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentMethodDomainsPaymentMethodDomainValidateParamSchema =
    z.object({payment_method_domain: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodDomainsPaymentMethodDomainValidateRequestBodySchema = z
    .never()
    .optional()

  const postPaymentMethodDomainsPaymentMethodDomainValidateResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method_domain]], s_error)

  // postPaymentMethodDomainsPaymentMethodDomainValidate
  router.post(
    `/v1/payment_method_domains/:payment_method_domain/validate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodDomainsPaymentMethodDomainValidateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method_domain>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodDomainsPaymentMethodDomainValidate(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentMethodDomainsPaymentMethodDomainValidateResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentMethodsQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z
      .enum([
        "acss_debit",
        "affirm",
        "afterpay_clearpay",
        "alipay",
        "alma",
        "amazon_pay",
        "au_becs_debit",
        "bacs_debit",
        "bancontact",
        "billie",
        "blik",
        "boleto",
        "card",
        "cashapp",
        "crypto",
        "customer_balance",
        "eps",
        "fpx",
        "giropay",
        "grabpay",
        "ideal",
        "kakao_pay",
        "klarna",
        "konbini",
        "kr_card",
        "link",
        "mobilepay",
        "multibanco",
        "naver_pay",
        "nz_bank_account",
        "oxxo",
        "p24",
        "pay_by_bank",
        "payco",
        "paynow",
        "paypal",
        "pix",
        "promptpay",
        "revolut_pay",
        "samsung_pay",
        "satispay",
        "sepa_debit",
        "sofort",
        "swish",
        "twint",
        "us_bank_account",
        "wechat_pay",
        "zip",
      ])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodsRequestBodySchema = z.never().optional()

  const getPaymentMethodsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payment_method)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payment_methods")),
        }),
      ],
    ],
    s_error,
  )

  // getPaymentMethods
  router.get(
    `/v1/payment_methods`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPaymentMethodsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentMethodsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payment_method[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentMethods(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPaymentMethodsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsRequestBodySchema = z.never().optional()

  const postPaymentMethodsResponseBodyValidator = responseValidationFactory(
    [["200", s_payment_method]],
    s_error,
  )

  // postPaymentMethods
  router.post(
    `/v1/payment_methods`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethods(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPaymentMethodsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPaymentMethodsPaymentMethodParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  const getPaymentMethodsPaymentMethodQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodsPaymentMethodRequestBodySchema = z.never().optional()

  const getPaymentMethodsPaymentMethodResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  // getPaymentMethodsPaymentMethod
  router.get(
    `/v1/payment_methods/:payment_method`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPaymentMethodsPaymentMethodParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPaymentMethodsPaymentMethodQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPaymentMethodsPaymentMethodRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPaymentMethodsPaymentMethod(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getPaymentMethodsPaymentMethodResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentMethodsPaymentMethodParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsPaymentMethodRequestBodySchema = z.never().optional()

  const postPaymentMethodsPaymentMethodResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  // postPaymentMethodsPaymentMethod
  router.post(
    `/v1/payment_methods/:payment_method`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentMethodsPaymentMethodParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodsPaymentMethodRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodsPaymentMethod(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentMethodsPaymentMethodResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentMethodsPaymentMethodAttachParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsPaymentMethodAttachRequestBodySchema = z.never()

  const postPaymentMethodsPaymentMethodAttachResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  // postPaymentMethodsPaymentMethodAttach
  router.post(
    `/v1/payment_methods/:payment_method/attach`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentMethodsPaymentMethodAttachParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodsPaymentMethodAttachRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodsPaymentMethodAttach(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentMethodsPaymentMethodAttachResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPaymentMethodsPaymentMethodDetachParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsPaymentMethodDetachRequestBodySchema = z
    .never()
    .optional()

  const postPaymentMethodsPaymentMethodDetachResponseBodyValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  // postPaymentMethodsPaymentMethodDetach
  router.post(
    `/v1/payment_methods/:payment_method/detach`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPaymentMethodsPaymentMethodDetachParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPaymentMethodsPaymentMethodDetachRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payment_method>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPaymentMethodsPaymentMethodDetach(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPaymentMethodsPaymentMethodDetachResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPayoutsQuerySchema = z.object({
    arrival_date: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    destination: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPayoutsRequestBodySchema = z.never().optional()

  const getPayoutsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payout)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payouts")),
        }),
      ],
    ],
    s_error,
  )

  // getPayouts
  router.get(
    `/v1/payouts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPayoutsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPayoutsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_payout[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPayouts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPayoutsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsRequestBodySchema = z.never()

  const postPayoutsResponseBodyValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  // postPayouts
  router.post(
    `/v1/payouts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPayoutsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payout>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPayouts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPayoutsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPayoutsPayoutParamSchema = z.object({payout: z.string().max(5000)})

  const getPayoutsPayoutQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPayoutsPayoutRequestBodySchema = z.never().optional()

  const getPayoutsPayoutResponseBodyValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  // getPayoutsPayout
  router.get(
    `/v1/payouts/:payout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPayoutsPayoutParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPayoutsPayoutQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPayoutsPayoutRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payout>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPayoutsPayout(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPayoutsPayoutResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPayoutsPayoutParamSchema = z.object({payout: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsPayoutRequestBodySchema = z.never().optional()

  const postPayoutsPayoutResponseBodyValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  // postPayoutsPayout
  router.post(
    `/v1/payouts/:payout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPayoutsPayoutParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPayoutsPayoutRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payout>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPayoutsPayout(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPayoutsPayoutResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPayoutsPayoutCancelParamSchema = z.object({
    payout: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsPayoutCancelRequestBodySchema = z.never().optional()

  const postPayoutsPayoutCancelResponseBodyValidator =
    responseValidationFactory([["200", s_payout]], s_error)

  // postPayoutsPayoutCancel
  router.post(
    `/v1/payouts/:payout/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPayoutsPayoutCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPayoutsPayoutCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payout>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPayoutsPayoutCancel(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPayoutsPayoutCancelResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPayoutsPayoutReverseParamSchema = z.object({
    payout: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsPayoutReverseRequestBodySchema = z.never().optional()

  const postPayoutsPayoutReverseResponseBodyValidator =
    responseValidationFactory([["200", s_payout]], s_error)

  // postPayoutsPayoutReverse
  router.post(
    `/v1/payouts/:payout/reverse`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPayoutsPayoutReverseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPayoutsPayoutReverseRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_payout>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPayoutsPayoutReverse(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPayoutsPayoutReverseResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPlansQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    product: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPlansRequestBodySchema = z.never().optional()

  const getPlansResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_plan)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/plans")),
        }),
      ],
    ],
    s_error,
  )

  // getPlans
  router.get(
    `/v1/plans`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPlansQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPlansRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_plan[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPlans(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPlansResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPlansRequestBodySchema = z.never()

  const postPlansResponseBodyValidator = responseValidationFactory(
    [["200", s_plan]],
    s_error,
  )

  // postPlans
  router.post(
    `/v1/plans`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPlansRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_plan>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPlans(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPlansResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deletePlansPlanParamSchema = z.object({plan: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deletePlansPlanRequestBodySchema = z.never().optional()

  const deletePlansPlanResponseBodyValidator = responseValidationFactory(
    [["200", s_deleted_plan]],
    s_error,
  )

  // deletePlansPlan
  router.delete(
    `/v1/plans/:plan`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deletePlansPlanParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deletePlansPlanRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_plan>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deletePlansPlan(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deletePlansPlanResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPlansPlanParamSchema = z.object({plan: z.string().max(5000)})

  const getPlansPlanQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPlansPlanRequestBodySchema = z.never().optional()

  const getPlansPlanResponseBodyValidator = responseValidationFactory(
    [["200", s_plan]],
    s_error,
  )

  // getPlansPlan
  router.get(
    `/v1/plans/:plan`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPlansPlanParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPlansPlanQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPlansPlanRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_plan>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPlansPlan(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPlansPlanResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPlansPlanParamSchema = z.object({plan: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPlansPlanRequestBodySchema = z.never().optional()

  const postPlansPlanResponseBodyValidator = responseValidationFactory(
    [["200", s_plan]],
    s_error,
  )

  // postPlansPlan
  router.post(
    `/v1/plans/:plan`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPlansPlanParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPlansPlanRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_plan>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPlansPlan(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPlansPlanResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPricesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_keys: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    product: z.string().max(5000).optional(),
    recurring: z
      .object({
        interval: z.enum(["day", "month", "week", "year"]).optional(),
        meter: z.string().max(5000).optional(),
        usage_type: z.enum(["licensed", "metered"]).optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["one_time", "recurring"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPricesRequestBodySchema = z.never().optional()

  const getPricesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_price)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/prices")),
        }),
      ],
    ],
    s_error,
  )

  // getPrices
  router.get(
    `/v1/prices`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPricesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPricesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_price[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPrices(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPricesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPricesRequestBodySchema = z.never()

  const postPricesResponseBodyValidator = responseValidationFactory(
    [["200", s_price]],
    s_error,
  )

  // postPrices
  router.post(
    `/v1/prices`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPricesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_price>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPrices(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPricesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPricesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPricesSearchRequestBodySchema = z.never().optional()

  const getPricesSearchResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_price)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getPricesSearch
  router.get(
    `/v1/prices/search`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPricesSearchQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPricesSearchRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_price[]
              has_more: boolean
              next_page?: (string | null) | undefined
              object: "search_result"
              total_count?: number | undefined
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPricesSearch(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPricesSearchResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPricesPriceParamSchema = z.object({price: z.string().max(5000)})

  const getPricesPriceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPricesPriceRequestBodySchema = z.never().optional()

  const getPricesPriceResponseBodyValidator = responseValidationFactory(
    [["200", s_price]],
    s_error,
  )

  // getPricesPrice
  router.get(
    `/v1/prices/:price`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPricesPriceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPricesPriceQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPricesPriceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_price>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPricesPrice(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPricesPriceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPricesPriceParamSchema = z.object({price: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPricesPriceRequestBodySchema = z.never().optional()

  const postPricesPriceResponseBodyValidator = responseValidationFactory(
    [["200", s_price]],
    s_error,
  )

  // postPricesPrice
  router.post(
    `/v1/prices/:price`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPricesPriceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPricesPriceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_price>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPricesPrice(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPricesPriceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getProductsQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    ids: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    shippable: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
    url: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsRequestBodySchema = z.never().optional()

  const getProductsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_product)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/products")),
        }),
      ],
    ],
    s_error,
  )

  // getProducts
  router.get(
    `/v1/products`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getProductsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getProductsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_product[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getProducts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getProductsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postProductsRequestBodySchema = z.never()

  const postProductsResponseBodyValidator = responseValidationFactory(
    [["200", s_product]],
    s_error,
  )

  // postProducts
  router.post(
    `/v1/products`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postProductsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_product>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postProducts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postProductsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getProductsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsSearchRequestBodySchema = z.never().optional()

  const getProductsSearchResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_product)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getProductsSearch
  router.get(
    `/v1/products/search`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getProductsSearchQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getProductsSearchRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_product[]
              has_more: boolean
              next_page?: (string | null) | undefined
              object: "search_result"
              total_count?: number | undefined
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getProductsSearch(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getProductsSearchResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteProductsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteProductsIdRequestBodySchema = z.never().optional()

  const deleteProductsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_deleted_product]],
    s_error,
  )

  // deleteProductsId
  router.delete(
    `/v1/products/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteProductsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteProductsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_product>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteProductsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteProductsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getProductsIdParamSchema = z.object({id: z.string().max(5000)})

  const getProductsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsIdRequestBodySchema = z.never().optional()

  const getProductsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_product]],
    s_error,
  )

  // getProductsId
  router.get(
    `/v1/products/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getProductsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getProductsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getProductsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_product>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getProductsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getProductsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postProductsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postProductsIdRequestBodySchema = z.never().optional()

  const postProductsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_product]],
    s_error,
  )

  // postProductsId
  router.post(
    `/v1/products/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postProductsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postProductsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_product>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postProductsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postProductsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getProductsProductFeaturesParamSchema = z.object({
    product: z.string().max(5000),
  })

  const getProductsProductFeaturesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsProductFeaturesRequestBodySchema = z.never().optional()

  const getProductsProductFeaturesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_product_feature),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getProductsProductFeatures
  router.get(
    `/v1/products/:product/features`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getProductsProductFeaturesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getProductsProductFeaturesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getProductsProductFeaturesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_product_feature[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getProductsProductFeatures(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getProductsProductFeaturesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postProductsProductFeaturesParamSchema = z.object({
    product: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postProductsProductFeaturesRequestBodySchema = z.never()

  const postProductsProductFeaturesResponseBodyValidator =
    responseValidationFactory([["200", s_product_feature]], s_error)

  // postProductsProductFeatures
  router.post(
    `/v1/products/:product/features`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postProductsProductFeaturesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postProductsProductFeaturesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_product_feature>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postProductsProductFeatures(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postProductsProductFeaturesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteProductsProductFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
    product: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteProductsProductFeaturesIdRequestBodySchema = z.never().optional()

  const deleteProductsProductFeaturesIdResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_product_feature]], s_error)

  // deleteProductsProductFeaturesId
  router.delete(
    `/v1/products/:product/features/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteProductsProductFeaturesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteProductsProductFeaturesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_product_feature>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteProductsProductFeaturesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteProductsProductFeaturesIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getProductsProductFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
    product: z.string().max(5000),
  })

  const getProductsProductFeaturesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsProductFeaturesIdRequestBodySchema = z.never().optional()

  const getProductsProductFeaturesIdResponseBodyValidator =
    responseValidationFactory([["200", s_product_feature]], s_error)

  // getProductsProductFeaturesId
  router.get(
    `/v1/products/:product/features/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getProductsProductFeaturesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getProductsProductFeaturesIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getProductsProductFeaturesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_product_feature>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getProductsProductFeaturesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getProductsProductFeaturesIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPromotionCodesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    code: z.string().max(5000).optional(),
    coupon: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPromotionCodesRequestBodySchema = z.never().optional()

  const getPromotionCodesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_promotion_code)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/promotion_codes")),
        }),
      ],
    ],
    s_error,
  )

  // getPromotionCodes
  router.get(
    `/v1/promotion_codes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getPromotionCodesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPromotionCodesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_promotion_code[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPromotionCodes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getPromotionCodesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPromotionCodesRequestBodySchema = z.never()

  const postPromotionCodesResponseBodyValidator = responseValidationFactory(
    [["200", s_promotion_code]],
    s_error,
  )

  // postPromotionCodes
  router.post(
    `/v1/promotion_codes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postPromotionCodesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_promotion_code>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPromotionCodes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postPromotionCodesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getPromotionCodesPromotionCodeParamSchema = z.object({
    promotion_code: z.string().max(5000),
  })

  const getPromotionCodesPromotionCodeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPromotionCodesPromotionCodeRequestBodySchema = z.never().optional()

  const getPromotionCodesPromotionCodeResponseBodyValidator =
    responseValidationFactory([["200", s_promotion_code]], s_error)

  // getPromotionCodesPromotionCode
  router.get(
    `/v1/promotion_codes/:promotion_code`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPromotionCodesPromotionCodeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getPromotionCodesPromotionCodeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getPromotionCodesPromotionCodeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_promotion_code>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPromotionCodesPromotionCode(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getPromotionCodesPromotionCodeResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postPromotionCodesPromotionCodeParamSchema = z.object({
    promotion_code: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPromotionCodesPromotionCodeRequestBodySchema = z.never().optional()

  const postPromotionCodesPromotionCodeResponseBodyValidator =
    responseValidationFactory([["200", s_promotion_code]], s_error)

  // postPromotionCodesPromotionCode
  router.post(
    `/v1/promotion_codes/:promotion_code`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postPromotionCodesPromotionCodeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postPromotionCodesPromotionCodeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_promotion_code>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postPromotionCodesPromotionCode(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postPromotionCodesPromotionCodeResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getQuotesQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["accepted", "canceled", "draft", "open"]).optional(),
    test_clock: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesRequestBodySchema = z.never().optional()

  const getQuotesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_quote)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/quotes")),
        }),
      ],
    ],
    s_error,
  )

  // getQuotes
  router.get(
    `/v1/quotes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getQuotesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getQuotesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_quote[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getQuotes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getQuotesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesRequestBodySchema = z.never().optional()

  const postQuotesResponseBodyValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  // postQuotes
  router.post(
    `/v1/quotes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postQuotesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_quote>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postQuotes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postQuotesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getQuotesQuoteParamSchema = z.object({quote: z.string().max(5000)})

  const getQuotesQuoteQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuoteRequestBodySchema = z.never().optional()

  const getQuotesQuoteResponseBodyValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  // getQuotesQuote
  router.get(
    `/v1/quotes/:quote`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getQuotesQuoteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getQuotesQuoteQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getQuotesQuoteRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_quote>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getQuotesQuote(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getQuotesQuoteResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postQuotesQuoteParamSchema = z.object({quote: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteRequestBodySchema = z.never().optional()

  const postQuotesQuoteResponseBodyValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  // postQuotesQuote
  router.post(
    `/v1/quotes/:quote`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postQuotesQuoteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postQuotesQuoteRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_quote>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postQuotesQuote(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postQuotesQuoteResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postQuotesQuoteAcceptParamSchema = z.object({
    quote: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteAcceptRequestBodySchema = z.never().optional()

  const postQuotesQuoteAcceptResponseBodyValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  // postQuotesQuoteAccept
  router.post(
    `/v1/quotes/:quote/accept`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postQuotesQuoteAcceptParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postQuotesQuoteAcceptRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_quote>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postQuotesQuoteAccept(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postQuotesQuoteAcceptResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postQuotesQuoteCancelParamSchema = z.object({
    quote: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteCancelRequestBodySchema = z.never().optional()

  const postQuotesQuoteCancelResponseBodyValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  // postQuotesQuoteCancel
  router.post(
    `/v1/quotes/:quote/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postQuotesQuoteCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postQuotesQuoteCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_quote>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postQuotesQuoteCancel(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postQuotesQuoteCancelResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getQuotesQuoteComputedUpfrontLineItemsParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const getQuotesQuoteComputedUpfrontLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuoteComputedUpfrontLineItemsRequestBodySchema = z
    .never()
    .optional()

  const getQuotesQuoteComputedUpfrontLineItemsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getQuotesQuoteComputedUpfrontLineItems
  router.get(
    `/v1/quotes/:quote/computed_upfront_line_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getQuotesQuoteComputedUpfrontLineItemsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getQuotesQuoteComputedUpfrontLineItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getQuotesQuoteComputedUpfrontLineItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getQuotesQuoteComputedUpfrontLineItems(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getQuotesQuoteComputedUpfrontLineItemsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postQuotesQuoteFinalizeParamSchema = z.object({
    quote: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteFinalizeRequestBodySchema = z.never().optional()

  const postQuotesQuoteFinalizeResponseBodyValidator =
    responseValidationFactory([["200", s_quote]], s_error)

  // postQuotesQuoteFinalize
  router.post(
    `/v1/quotes/:quote/finalize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postQuotesQuoteFinalizeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postQuotesQuoteFinalizeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_quote>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postQuotesQuoteFinalize(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postQuotesQuoteFinalizeResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getQuotesQuoteLineItemsParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const getQuotesQuoteLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuoteLineItemsRequestBodySchema = z.never().optional()

  const getQuotesQuoteLineItemsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getQuotesQuoteLineItems
  router.get(
    `/v1/quotes/:quote/line_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getQuotesQuoteLineItemsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getQuotesQuoteLineItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getQuotesQuoteLineItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getQuotesQuoteLineItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getQuotesQuoteLineItemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getQuotesQuotePdfParamSchema = z.object({quote: z.string().max(5000)})

  const getQuotesQuotePdfQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuotePdfRequestBodySchema = z.never().optional()

  const getQuotesQuotePdfResponseBodyValidator = responseValidationFactory(
    [["200", z.string()]],
    s_error,
  )

  // getQuotesQuotePdf
  router.get(
    `/v1/quotes/:quote/pdf`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getQuotesQuotePdfParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getQuotesQuotePdfQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getQuotesQuotePdfRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getQuotesQuotePdf(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getQuotesQuotePdfResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRadarEarlyFraudWarningsQuerySchema = z.object({
    charge: z.string().optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarEarlyFraudWarningsRequestBodySchema = z.never().optional()

  const getRadarEarlyFraudWarningsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_radar_early_fraud_warning)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/radar/early_fraud_warnings")),
          }),
        ],
      ],
      s_error,
    )

  // getRadarEarlyFraudWarnings
  router.get(
    `/v1/radar/early_fraud_warnings`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getRadarEarlyFraudWarningsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRadarEarlyFraudWarningsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_radar_early_fraud_warning[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRadarEarlyFraudWarnings(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getRadarEarlyFraudWarningsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRadarEarlyFraudWarningsEarlyFraudWarningParamSchema = z.object({
    early_fraud_warning: z.string().max(5000),
  })

  const getRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarEarlyFraudWarningsEarlyFraudWarningRequestBodySchema = z
    .never()
    .optional()

  const getRadarEarlyFraudWarningsEarlyFraudWarningResponseBodyValidator =
    responseValidationFactory([["200", s_radar_early_fraud_warning]], s_error)

  // getRadarEarlyFraudWarningsEarlyFraudWarning
  router.get(
    `/v1/radar/early_fraud_warnings/:early_fraud_warning`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRadarEarlyFraudWarningsEarlyFraudWarningRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_radar_early_fraud_warning>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRadarEarlyFraudWarningsEarlyFraudWarning(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getRadarEarlyFraudWarningsEarlyFraudWarningResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRadarValueListItemsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    value: z.string().max(800).optional(),
    value_list: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListItemsRequestBodySchema = z.never().optional()

  const getRadarValueListItemsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_radar_value_list_item),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/radar/value_list_items")),
        }),
      ],
    ],
    s_error,
  )

  // getRadarValueListItems
  router.get(
    `/v1/radar/value_list_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getRadarValueListItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRadarValueListItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_radar_value_list_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRadarValueListItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getRadarValueListItemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRadarValueListItemsRequestBodySchema = z.never()

  const postRadarValueListItemsResponseBodyValidator =
    responseValidationFactory([["200", s_radar_value_list_item]], s_error)

  // postRadarValueListItems
  router.post(
    `/v1/radar/value_list_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postRadarValueListItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_radar_value_list_item>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postRadarValueListItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postRadarValueListItemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteRadarValueListItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteRadarValueListItemsItemRequestBodySchema = z.never().optional()

  const deleteRadarValueListItemsItemResponseBodyValidator =
    responseValidationFactory(
      [["200", s_deleted_radar_value_list_item]],
      s_error,
    )

  // deleteRadarValueListItemsItem
  router.delete(
    `/v1/radar/value_list_items/:item`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteRadarValueListItemsItemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteRadarValueListItemsItemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_radar_value_list_item>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteRadarValueListItemsItem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteRadarValueListItemsItemResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRadarValueListItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const getRadarValueListItemsItemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListItemsItemRequestBodySchema = z.never().optional()

  const getRadarValueListItemsItemResponseBodyValidator =
    responseValidationFactory([["200", s_radar_value_list_item]], s_error)

  // getRadarValueListItemsItem
  router.get(
    `/v1/radar/value_list_items/:item`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getRadarValueListItemsItemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getRadarValueListItemsItemQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRadarValueListItemsItemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_radar_value_list_item>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRadarValueListItemsItem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getRadarValueListItemsItemResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRadarValueListsQuerySchema = z.object({
    alias: z.string().max(100).optional(),
    contains: z.string().max(800).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListsRequestBodySchema = z.never().optional()

  const getRadarValueListsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_radar_value_list),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/radar/value_lists")),
        }),
      ],
    ],
    s_error,
  )

  // getRadarValueLists
  router.get(
    `/v1/radar/value_lists`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getRadarValueListsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRadarValueListsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_radar_value_list[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRadarValueLists(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getRadarValueListsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRadarValueListsRequestBodySchema = z.never()

  const postRadarValueListsResponseBodyValidator = responseValidationFactory(
    [["200", s_radar_value_list]],
    s_error,
  )

  // postRadarValueLists
  router.post(
    `/v1/radar/value_lists`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postRadarValueListsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_radar_value_list>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postRadarValueLists(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postRadarValueListsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteRadarValueListsValueListRequestBodySchema = z.never().optional()

  const deleteRadarValueListsValueListResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_radar_value_list]], s_error)

  // deleteRadarValueListsValueList
  router.delete(
    `/v1/radar/value_lists/:value_list`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteRadarValueListsValueListParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteRadarValueListsValueListRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_radar_value_list>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteRadarValueListsValueList(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteRadarValueListsValueListResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  const getRadarValueListsValueListQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListsValueListRequestBodySchema = z.never().optional()

  const getRadarValueListsValueListResponseBodyValidator =
    responseValidationFactory([["200", s_radar_value_list]], s_error)

  // getRadarValueListsValueList
  router.get(
    `/v1/radar/value_lists/:value_list`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getRadarValueListsValueListParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getRadarValueListsValueListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRadarValueListsValueListRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_radar_value_list>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRadarValueListsValueList(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getRadarValueListsValueListResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRadarValueListsValueListRequestBodySchema = z.never().optional()

  const postRadarValueListsValueListResponseBodyValidator =
    responseValidationFactory([["200", s_radar_value_list]], s_error)

  // postRadarValueListsValueList
  router.post(
    `/v1/radar/value_lists/:value_list`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postRadarValueListsValueListParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postRadarValueListsValueListRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_radar_value_list>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postRadarValueListsValueList(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postRadarValueListsValueListResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRefundsQuerySchema = z.object({
    charge: z.string().optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRefundsRequestBodySchema = z.never().optional()

  const getRefundsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_refund)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/refunds")),
        }),
      ],
    ],
    s_error,
  )

  // getRefunds
  router.get(
    `/v1/refunds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getRefundsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRefundsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_refund[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRefunds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getRefundsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRefundsRequestBodySchema = z.never().optional()

  const postRefundsResponseBodyValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  // postRefunds
  router.post(
    `/v1/refunds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postRefundsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postRefunds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postRefundsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRefundsRefundParamSchema = z.object({refund: z.string()})

  const getRefundsRefundQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRefundsRefundRequestBodySchema = z.never().optional()

  const getRefundsRefundResponseBodyValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  // getRefundsRefund
  router.get(
    `/v1/refunds/:refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getRefundsRefundParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getRefundsRefundQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getRefundsRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRefundsRefund(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getRefundsRefundResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postRefundsRefundParamSchema = z.object({refund: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRefundsRefundRequestBodySchema = z.never().optional()

  const postRefundsRefundResponseBodyValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  // postRefundsRefund
  router.post(
    `/v1/refunds/:refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postRefundsRefundParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postRefundsRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postRefundsRefund(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postRefundsRefundResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postRefundsRefundCancelParamSchema = z.object({refund: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRefundsRefundCancelRequestBodySchema = z.never().optional()

  const postRefundsRefundCancelResponseBodyValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  // postRefundsRefundCancel
  router.post(
    `/v1/refunds/:refund/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postRefundsRefundCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postRefundsRefundCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postRefundsRefundCancel(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postRefundsRefundCancelResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getReportingReportRunsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportRunsRequestBodySchema = z.never().optional()

  const getReportingReportRunsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_reporting_report_run)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/reporting/report_runs")),
        }),
      ],
    ],
    s_error,
  )

  // getReportingReportRuns
  router.get(
    `/v1/reporting/report_runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getReportingReportRunsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getReportingReportRunsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_reporting_report_run[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getReportingReportRuns(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getReportingReportRunsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postReportingReportRunsRequestBodySchema = z.never()

  const postReportingReportRunsResponseBodyValidator =
    responseValidationFactory([["200", s_reporting_report_run]], s_error)

  // postReportingReportRuns
  router.post(
    `/v1/reporting/report_runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postReportingReportRunsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reporting_report_run>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postReportingReportRuns(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postReportingReportRunsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getReportingReportRunsReportRunParamSchema = z.object({
    report_run: z.string().max(5000),
  })

  const getReportingReportRunsReportRunQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportRunsReportRunRequestBodySchema = z.never().optional()

  const getReportingReportRunsReportRunResponseBodyValidator =
    responseValidationFactory([["200", s_reporting_report_run]], s_error)

  // getReportingReportRunsReportRun
  router.get(
    `/v1/reporting/report_runs/:report_run`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getReportingReportRunsReportRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getReportingReportRunsReportRunQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getReportingReportRunsReportRunRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reporting_report_run>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getReportingReportRunsReportRun(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getReportingReportRunsReportRunResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getReportingReportTypesQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportTypesRequestBodySchema = z.never().optional()

  const getReportingReportTypesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_reporting_report_type),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getReportingReportTypes
  router.get(
    `/v1/reporting/report_types`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getReportingReportTypesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getReportingReportTypesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_reporting_report_type[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getReportingReportTypes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getReportingReportTypesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getReportingReportTypesReportTypeParamSchema = z.object({
    report_type: z.string(),
  })

  const getReportingReportTypesReportTypeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportTypesReportTypeRequestBodySchema = z
    .never()
    .optional()

  const getReportingReportTypesReportTypeResponseBodyValidator =
    responseValidationFactory([["200", s_reporting_report_type]], s_error)

  // getReportingReportTypesReportType
  router.get(
    `/v1/reporting/report_types/:report_type`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getReportingReportTypesReportTypeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getReportingReportTypesReportTypeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getReportingReportTypesReportTypeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reporting_report_type>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getReportingReportTypesReportType(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getReportingReportTypesReportTypeResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getReviewsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReviewsRequestBodySchema = z.never().optional()

  const getReviewsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_review)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getReviews
  router.get(
    `/v1/reviews`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getReviewsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getReviewsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_review[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getReviews(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getReviewsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getReviewsReviewParamSchema = z.object({review: z.string().max(5000)})

  const getReviewsReviewQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReviewsReviewRequestBodySchema = z.never().optional()

  const getReviewsReviewResponseBodyValidator = responseValidationFactory(
    [["200", s_review]],
    s_error,
  )

  // getReviewsReview
  router.get(
    `/v1/reviews/:review`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getReviewsReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getReviewsReviewQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getReviewsReviewRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_review>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getReviewsReview(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getReviewsReviewResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postReviewsReviewApproveParamSchema = z.object({
    review: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postReviewsReviewApproveRequestBodySchema = z.never().optional()

  const postReviewsReviewApproveResponseBodyValidator =
    responseValidationFactory([["200", s_review]], s_error)

  // postReviewsReviewApprove
  router.post(
    `/v1/reviews/:review/approve`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postReviewsReviewApproveParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postReviewsReviewApproveRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_review>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postReviewsReviewApprove(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postReviewsReviewApproveResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSetupAttemptsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    setup_intent: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSetupAttemptsRequestBodySchema = z.never().optional()

  const getSetupAttemptsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_setup_attempt)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/setup_attempts")),
        }),
      ],
    ],
    s_error,
  )

  // getSetupAttempts
  router.get(
    `/v1/setup_attempts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getSetupAttemptsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSetupAttemptsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_setup_attempt[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSetupAttempts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSetupAttemptsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSetupIntentsQuerySchema = z.object({
    attach_to_self: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_method: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSetupIntentsRequestBodySchema = z.never().optional()

  const getSetupIntentsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_setup_intent)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/setup_intents")),
        }),
      ],
    ],
    s_error,
  )

  // getSetupIntents
  router.get(
    `/v1/setup_intents`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getSetupIntentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSetupIntentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_setup_intent[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSetupIntents(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSetupIntentsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsRequestBodySchema = z.never().optional()

  const postSetupIntentsResponseBodyValidator = responseValidationFactory(
    [["200", s_setup_intent]],
    s_error,
  )

  // postSetupIntents
  router.post(
    `/v1/setup_intents`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postSetupIntentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_setup_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSetupIntents(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSetupIntentsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSetupIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const getSetupIntentsIntentQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSetupIntentsIntentRequestBodySchema = z.never().optional()

  const getSetupIntentsIntentResponseBodyValidator = responseValidationFactory(
    [["200", s_setup_intent]],
    s_error,
  )

  // getSetupIntentsIntent
  router.get(
    `/v1/setup_intents/:intent`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSetupIntentsIntentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSetupIntentsIntentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSetupIntentsIntentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_setup_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSetupIntentsIntent(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSetupIntentsIntentResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSetupIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentRequestBodySchema = z.never().optional()

  const postSetupIntentsIntentResponseBodyValidator = responseValidationFactory(
    [["200", s_setup_intent]],
    s_error,
  )

  // postSetupIntentsIntent
  router.post(
    `/v1/setup_intents/:intent`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSetupIntentsIntentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSetupIntentsIntentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_setup_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSetupIntentsIntent(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSetupIntentsIntentResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSetupIntentsIntentCancelParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentCancelRequestBodySchema = z.never().optional()

  const postSetupIntentsIntentCancelResponseBodyValidator =
    responseValidationFactory([["200", s_setup_intent]], s_error)

  // postSetupIntentsIntentCancel
  router.post(
    `/v1/setup_intents/:intent/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSetupIntentsIntentCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSetupIntentsIntentCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_setup_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSetupIntentsIntentCancel(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSetupIntentsIntentCancelResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSetupIntentsIntentConfirmParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentConfirmRequestBodySchema = z.never().optional()

  const postSetupIntentsIntentConfirmResponseBodyValidator =
    responseValidationFactory([["200", s_setup_intent]], s_error)

  // postSetupIntentsIntentConfirm
  router.post(
    `/v1/setup_intents/:intent/confirm`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSetupIntentsIntentConfirmParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSetupIntentsIntentConfirmRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_setup_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSetupIntentsIntentConfirm(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSetupIntentsIntentConfirmResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSetupIntentsIntentVerifyMicrodepositsParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentVerifyMicrodepositsRequestBodySchema = z
    .never()
    .optional()

  const postSetupIntentsIntentVerifyMicrodepositsResponseBodyValidator =
    responseValidationFactory([["200", s_setup_intent]], s_error)

  // postSetupIntentsIntentVerifyMicrodeposits
  router.post(
    `/v1/setup_intents/:intent/verify_microdeposits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSetupIntentsIntentVerifyMicrodepositsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSetupIntentsIntentVerifyMicrodepositsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_setup_intent>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSetupIntentsIntentVerifyMicrodeposits(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSetupIntentsIntentVerifyMicrodepositsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getShippingRatesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getShippingRatesRequestBodySchema = z.never().optional()

  const getShippingRatesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_shipping_rate),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/shipping_rates")),
        }),
      ],
    ],
    s_error,
  )

  // getShippingRates
  router.get(
    `/v1/shipping_rates`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getShippingRatesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getShippingRatesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_shipping_rate[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getShippingRates(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getShippingRatesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postShippingRatesRequestBodySchema = z.never()

  const postShippingRatesResponseBodyValidator = responseValidationFactory(
    [["200", s_shipping_rate]],
    s_error,
  )

  // postShippingRates
  router.post(
    `/v1/shipping_rates`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postShippingRatesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_shipping_rate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postShippingRates(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postShippingRatesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getShippingRatesShippingRateTokenParamSchema = z.object({
    shipping_rate_token: z.string().max(5000),
  })

  const getShippingRatesShippingRateTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getShippingRatesShippingRateTokenRequestBodySchema = z
    .never()
    .optional()

  const getShippingRatesShippingRateTokenResponseBodyValidator =
    responseValidationFactory([["200", s_shipping_rate]], s_error)

  // getShippingRatesShippingRateToken
  router.get(
    `/v1/shipping_rates/:shipping_rate_token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getShippingRatesShippingRateTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getShippingRatesShippingRateTokenQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getShippingRatesShippingRateTokenRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_shipping_rate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getShippingRatesShippingRateToken(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getShippingRatesShippingRateTokenResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postShippingRatesShippingRateTokenParamSchema = z.object({
    shipping_rate_token: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postShippingRatesShippingRateTokenRequestBodySchema = z
    .never()
    .optional()

  const postShippingRatesShippingRateTokenResponseBodyValidator =
    responseValidationFactory([["200", s_shipping_rate]], s_error)

  // postShippingRatesShippingRateToken
  router.post(
    `/v1/shipping_rates/:shipping_rate_token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postShippingRatesShippingRateTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postShippingRatesShippingRateTokenRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_shipping_rate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postShippingRatesShippingRateToken(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postShippingRatesShippingRateTokenResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSigmaSavedQueriesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSigmaSavedQueriesIdRequestBodySchema = z.never().optional()

  const postSigmaSavedQueriesIdResponseBodyValidator =
    responseValidationFactory([["200", s_sigma_sigma_api_query]], s_error)

  // postSigmaSavedQueriesId
  router.post(
    `/v1/sigma/saved_queries/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSigmaSavedQueriesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSigmaSavedQueriesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_sigma_sigma_api_query>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSigmaSavedQueriesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSigmaSavedQueriesIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSigmaScheduledQueryRunsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSigmaScheduledQueryRunsRequestBodySchema = z.never().optional()

  const getSigmaScheduledQueryRunsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_scheduled_query_run)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/sigma/scheduled_query_runs")),
          }),
        ],
      ],
      s_error,
    )

  // getSigmaScheduledQueryRuns
  router.get(
    `/v1/sigma/scheduled_query_runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getSigmaScheduledQueryRunsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSigmaScheduledQueryRunsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_scheduled_query_run[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSigmaScheduledQueryRuns(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getSigmaScheduledQueryRunsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSigmaScheduledQueryRunsScheduledQueryRunParamSchema = z.object({
    scheduled_query_run: z.string().max(5000),
  })

  const getSigmaScheduledQueryRunsScheduledQueryRunQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSigmaScheduledQueryRunsScheduledQueryRunRequestBodySchema = z
    .never()
    .optional()

  const getSigmaScheduledQueryRunsScheduledQueryRunResponseBodyValidator =
    responseValidationFactory([["200", s_scheduled_query_run]], s_error)

  // getSigmaScheduledQueryRunsScheduledQueryRun
  router.get(
    `/v1/sigma/scheduled_query_runs/:scheduled_query_run`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSigmaScheduledQueryRunsScheduledQueryRunRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_scheduled_query_run>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSigmaScheduledQueryRunsScheduledQueryRun(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getSigmaScheduledQueryRunsScheduledQueryRunResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSourcesRequestBodySchema = z.never().optional()

  const postSourcesResponseBodyValidator = responseValidationFactory(
    [["200", s_source]],
    s_error,
  )

  // postSources
  router.post(
    `/v1/sources`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postSourcesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSources(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSourcesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSourcesSourceParamSchema = z.object({source: z.string().max(5000)})

  const getSourcesSourceQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceRequestBodySchema = z.never().optional()

  const getSourcesSourceResponseBodyValidator = responseValidationFactory(
    [["200", s_source]],
    s_error,
  )

  // getSourcesSource
  router.get(
    `/v1/sources/:source`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSourcesSourceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSourcesSourceQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSourcesSourceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSourcesSource(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSourcesSourceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSourcesSourceParamSchema = z.object({source: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSourcesSourceRequestBodySchema = z.never().optional()

  const postSourcesSourceResponseBodyValidator = responseValidationFactory(
    [["200", s_source]],
    s_error,
  )

  // postSourcesSource
  router.post(
    `/v1/sources/:source`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSourcesSourceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSourcesSourceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSourcesSource(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSourcesSourceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSourcesSourceMandateNotificationsMandateNotificationParamSchema =
    z.object({
      mandate_notification: z.string().max(5000),
      source: z.string().max(5000),
    })

  const getSourcesSourceMandateNotificationsMandateNotificationQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceMandateNotificationsMandateNotificationRequestBodySchema =
    z.never().optional()

  const getSourcesSourceMandateNotificationsMandateNotificationResponseBodyValidator =
    responseValidationFactory([["200", s_source_mandate_notification]], s_error)

  // getSourcesSourceMandateNotificationsMandateNotification
  router.get(
    `/v1/sources/:source/mandate_notifications/:mandate_notification`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSourcesSourceMandateNotificationsMandateNotificationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSourcesSourceMandateNotificationsMandateNotificationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_source_mandate_notification>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSourcesSourceMandateNotificationsMandateNotification(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getSourcesSourceMandateNotificationsMandateNotificationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSourcesSourceSourceTransactionsParamSchema = z.object({
    source: z.string().max(5000),
  })

  const getSourcesSourceSourceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceSourceTransactionsRequestBodySchema = z
    .never()
    .optional()

  const getSourcesSourceSourceTransactionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_source_transaction),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getSourcesSourceSourceTransactions
  router.get(
    `/v1/sources/:source/source_transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSourcesSourceSourceTransactionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSourcesSourceSourceTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSourcesSourceSourceTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_source_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSourcesSourceSourceTransactions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getSourcesSourceSourceTransactionsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSourcesSourceSourceTransactionsSourceTransactionParamSchema =
    z.object({
      source: z.string().max(5000),
      source_transaction: z.string().max(5000),
    })

  const getSourcesSourceSourceTransactionsSourceTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceSourceTransactionsSourceTransactionRequestBodySchema = z
    .never()
    .optional()

  const getSourcesSourceSourceTransactionsSourceTransactionResponseBodyValidator =
    responseValidationFactory([["200", s_source_transaction]], s_error)

  // getSourcesSourceSourceTransactionsSourceTransaction
  router.get(
    `/v1/sources/:source/source_transactions/:source_transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSourcesSourceSourceTransactionsSourceTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSourcesSourceSourceTransactionsSourceTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_source_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSourcesSourceSourceTransactionsSourceTransaction(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getSourcesSourceSourceTransactionsSourceTransactionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSourcesSourceVerifyParamSchema = z.object({
    source: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSourcesSourceVerifyRequestBodySchema = z.never()

  const postSourcesSourceVerifyResponseBodyValidator =
    responseValidationFactory([["200", s_source]], s_error)

  // postSourcesSourceVerify
  router.post(
    `/v1/sources/:source/verify`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSourcesSourceVerifyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSourcesSourceVerifyRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_source>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSourcesSourceVerify(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSourcesSourceVerifyResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSubscriptionItemsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
    subscription: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionItemsRequestBodySchema = z.never().optional()

  const getSubscriptionItemsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_subscription_item)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/subscription_items")),
        }),
      ],
    ],
    s_error,
  )

  // getSubscriptionItems
  router.get(
    `/v1/subscription_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getSubscriptionItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSubscriptionItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_subscription_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSubscriptionItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSubscriptionItemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionItemsRequestBodySchema = z.never()

  const postSubscriptionItemsResponseBodyValidator = responseValidationFactory(
    [["200", s_subscription_item]],
    s_error,
  )

  // postSubscriptionItems
  router.post(
    `/v1/subscription_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postSubscriptionItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_item>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSubscriptionItemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteSubscriptionItemsItemRequestBodySchema = z.never().optional()

  const deleteSubscriptionItemsItemResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_subscription_item]], s_error)

  // deleteSubscriptionItemsItem
  router.delete(
    `/v1/subscription_items/:item`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteSubscriptionItemsItemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteSubscriptionItemsItemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_subscription_item>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteSubscriptionItemsItem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteSubscriptionItemsItemResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const getSubscriptionItemsItemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionItemsItemRequestBodySchema = z.never().optional()

  const getSubscriptionItemsItemResponseBodyValidator =
    responseValidationFactory([["200", s_subscription_item]], s_error)

  // getSubscriptionItemsItem
  router.get(
    `/v1/subscription_items/:item`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSubscriptionItemsItemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSubscriptionItemsItemQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSubscriptionItemsItemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_item>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSubscriptionItemsItem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSubscriptionItemsItemResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionItemsItemRequestBodySchema = z.never().optional()

  const postSubscriptionItemsItemResponseBodyValidator =
    responseValidationFactory([["200", s_subscription_item]], s_error)

  // postSubscriptionItemsItem
  router.post(
    `/v1/subscription_items/:item`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSubscriptionItemsItemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSubscriptionItemsItemRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_item>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionItemsItem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSubscriptionItemsItemResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSubscriptionSchedulesQuerySchema = z.object({
    canceled_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    completed_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    released_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    scheduled: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionSchedulesRequestBodySchema = z.never().optional()

  const getSubscriptionSchedulesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_subscription_schedule)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/subscription_schedules")),
          }),
        ],
      ],
      s_error,
    )

  // getSubscriptionSchedules
  router.get(
    `/v1/subscription_schedules`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getSubscriptionSchedulesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSubscriptionSchedulesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_subscription_schedule[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSubscriptionSchedules(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSubscriptionSchedulesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesRequestBodySchema = z.never().optional()

  const postSubscriptionSchedulesResponseBodyValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  // postSubscriptionSchedules
  router.post(
    `/v1/subscription_schedules`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postSubscriptionSchedulesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_schedule>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionSchedules(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSubscriptionSchedulesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSubscriptionSchedulesScheduleParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  const getSubscriptionSchedulesScheduleQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionSchedulesScheduleRequestBodySchema = z.never().optional()

  const getSubscriptionSchedulesScheduleResponseBodyValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  // getSubscriptionSchedulesSchedule
  router.get(
    `/v1/subscription_schedules/:schedule`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSubscriptionSchedulesScheduleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSubscriptionSchedulesScheduleQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSubscriptionSchedulesScheduleRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_schedule>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSubscriptionSchedulesSchedule(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getSubscriptionSchedulesScheduleResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSubscriptionSchedulesScheduleParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesScheduleRequestBodySchema = z
    .never()
    .optional()

  const postSubscriptionSchedulesScheduleResponseBodyValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  // postSubscriptionSchedulesSchedule
  router.post(
    `/v1/subscription_schedules/:schedule`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSubscriptionSchedulesScheduleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSubscriptionSchedulesScheduleRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_schedule>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionSchedulesSchedule(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSubscriptionSchedulesScheduleResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSubscriptionSchedulesScheduleCancelParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesScheduleCancelRequestBodySchema = z
    .never()
    .optional()

  const postSubscriptionSchedulesScheduleCancelResponseBodyValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  // postSubscriptionSchedulesScheduleCancel
  router.post(
    `/v1/subscription_schedules/:schedule/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSubscriptionSchedulesScheduleCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSubscriptionSchedulesScheduleCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_schedule>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionSchedulesScheduleCancel(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSubscriptionSchedulesScheduleCancelResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSubscriptionSchedulesScheduleReleaseParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesScheduleReleaseRequestBodySchema = z
    .never()
    .optional()

  const postSubscriptionSchedulesScheduleReleaseResponseBodyValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  // postSubscriptionSchedulesScheduleRelease
  router.post(
    `/v1/subscription_schedules/:schedule/release`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSubscriptionSchedulesScheduleReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSubscriptionSchedulesScheduleReleaseRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription_schedule>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionSchedulesScheduleRelease(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSubscriptionSchedulesScheduleReleaseResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSubscriptionsQuerySchema = z.object({
    automatic_tax: z.object({enabled: PermissiveBoolean}).optional(),
    collection_method: z
      .enum(["charge_automatically", "send_invoice"])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    current_period_end: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    current_period_start: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    price: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum([
        "active",
        "all",
        "canceled",
        "ended",
        "incomplete",
        "incomplete_expired",
        "past_due",
        "paused",
        "trialing",
        "unpaid",
      ])
      .optional(),
    test_clock: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionsRequestBodySchema = z.never().optional()

  const getSubscriptionsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_subscription)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/subscriptions")),
        }),
      ],
    ],
    s_error,
  )

  // getSubscriptions
  router.get(
    `/v1/subscriptions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getSubscriptionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSubscriptionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_subscription[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSubscriptions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSubscriptionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsRequestBodySchema = z.never()

  const postSubscriptionsResponseBodyValidator = responseValidationFactory(
    [["200", s_subscription]],
    s_error,
  )

  // postSubscriptions
  router.post(
    `/v1/subscriptions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postSubscriptionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postSubscriptionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSubscriptionsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionsSearchRequestBodySchema = z.never().optional()

  const getSubscriptionsSearchResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_subscription)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getSubscriptionsSearch
  router.get(
    `/v1/subscriptions/search`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getSubscriptionsSearchQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSubscriptionsSearchRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_subscription[]
              has_more: boolean
              next_page?: (string | null) | undefined
              object: "search_result"
              total_count?: number | undefined
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSubscriptionsSearch(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getSubscriptionsSearchResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteSubscriptionsSubscriptionExposedIdRequestBodySchema = z
    .never()
    .optional()

  const deleteSubscriptionsSubscriptionExposedIdResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // deleteSubscriptionsSubscriptionExposedId
  router.delete(
    `/v1/subscriptions/:subscription_exposed_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteSubscriptionsSubscriptionExposedIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteSubscriptionsSubscriptionExposedIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteSubscriptionsSubscriptionExposedId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteSubscriptionsSubscriptionExposedIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  const getSubscriptionsSubscriptionExposedIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionsSubscriptionExposedIdRequestBodySchema = z
    .never()
    .optional()

  const getSubscriptionsSubscriptionExposedIdResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // getSubscriptionsSubscriptionExposedId
  router.get(
    `/v1/subscriptions/:subscription_exposed_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getSubscriptionsSubscriptionExposedIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getSubscriptionsSubscriptionExposedIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getSubscriptionsSubscriptionExposedIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getSubscriptionsSubscriptionExposedId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getSubscriptionsSubscriptionExposedIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsSubscriptionExposedIdRequestBodySchema = z
    .never()
    .optional()

  const postSubscriptionsSubscriptionExposedIdResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // postSubscriptionsSubscriptionExposedId
  router.post(
    `/v1/subscriptions/:subscription_exposed_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSubscriptionsSubscriptionExposedIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSubscriptionsSubscriptionExposedIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionsSubscriptionExposedId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSubscriptionsSubscriptionExposedIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteSubscriptionsSubscriptionExposedIdDiscountParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema = z
    .never()
    .optional()

  const deleteSubscriptionsSubscriptionExposedIdDiscountResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_discount]], s_error)

  // deleteSubscriptionsSubscriptionExposedIdDiscount
  router.delete(
    `/v1/subscriptions/:subscription_exposed_id/discount`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteSubscriptionsSubscriptionExposedIdDiscountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_discount>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteSubscriptionsSubscriptionExposedIdDiscount(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteSubscriptionsSubscriptionExposedIdDiscountResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSubscriptionsSubscriptionMigrateParamSchema = z.object({
    subscription: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsSubscriptionMigrateRequestBodySchema = z.never()

  const postSubscriptionsSubscriptionMigrateResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // postSubscriptionsSubscriptionMigrate
  router.post(
    `/v1/subscriptions/:subscription/migrate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSubscriptionsSubscriptionMigrateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSubscriptionsSubscriptionMigrateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionsSubscriptionMigrate(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSubscriptionsSubscriptionMigrateResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postSubscriptionsSubscriptionResumeParamSchema = z.object({
    subscription: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsSubscriptionResumeRequestBodySchema = z
    .never()
    .optional()

  const postSubscriptionsSubscriptionResumeResponseBodyValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  // postSubscriptionsSubscriptionResume
  router.post(
    `/v1/subscriptions/:subscription/resume`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postSubscriptionsSubscriptionResumeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postSubscriptionsSubscriptionResumeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_subscription>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postSubscriptionsSubscriptionResume(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postSubscriptionsSubscriptionResumeResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxCalculationsRequestBodySchema = z.never()

  const postTaxCalculationsResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_calculation]],
    s_error,
  )

  // postTaxCalculations
  router.post(
    `/v1/tax/calculations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTaxCalculationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_calculation>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxCalculations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTaxCalculationsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxCalculationsCalculationParamSchema = z.object({
    calculation: z.string().max(5000),
  })

  const getTaxCalculationsCalculationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCalculationsCalculationRequestBodySchema = z.never().optional()

  const getTaxCalculationsCalculationResponseBodyValidator =
    responseValidationFactory([["200", s_tax_calculation]], s_error)

  // getTaxCalculationsCalculation
  router.get(
    `/v1/tax/calculations/:calculation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxCalculationsCalculationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxCalculationsCalculationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxCalculationsCalculationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_calculation>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxCalculationsCalculation(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTaxCalculationsCalculationResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxCalculationsCalculationLineItemsParamSchema = z.object({
    calculation: z.string().max(5000),
  })

  const getTaxCalculationsCalculationLineItemsQuerySchema = z.object({
    ending_before: z.string().max(500).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(500).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCalculationsCalculationLineItemsRequestBodySchema = z
    .never()
    .optional()

  const getTaxCalculationsCalculationLineItemsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_tax_calculation_line_item),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/tax/calculations/[^/]+/line_items")),
          }),
        ],
      ],
      s_error,
    )

  // getTaxCalculationsCalculationLineItems
  router.get(
    `/v1/tax/calculations/:calculation/line_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxCalculationsCalculationLineItemsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxCalculationsCalculationLineItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxCalculationsCalculationLineItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_tax_calculation_line_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxCalculationsCalculationLineItems(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTaxCalculationsCalculationLineItemsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxRegistrationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "all", "expired", "scheduled"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRegistrationsRequestBodySchema = z.never().optional()

  const getTaxRegistrationsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_tax_registration),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/tax/registrations")),
        }),
      ],
    ],
    s_error,
  )

  // getTaxRegistrations
  router.get(
    `/v1/tax/registrations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTaxRegistrationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxRegistrationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_tax_registration[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxRegistrations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxRegistrationsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRegistrationsRequestBodySchema = z.never()

  const postTaxRegistrationsResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_registration]],
    s_error,
  )

  // postTaxRegistrations
  router.post(
    `/v1/tax/registrations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTaxRegistrationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_registration>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxRegistrations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTaxRegistrationsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxRegistrationsIdParamSchema = z.object({id: z.string().max(5000)})

  const getTaxRegistrationsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRegistrationsIdRequestBodySchema = z.never().optional()

  const getTaxRegistrationsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_registration]],
    s_error,
  )

  // getTaxRegistrationsId
  router.get(
    `/v1/tax/registrations/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxRegistrationsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxRegistrationsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxRegistrationsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_registration>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxRegistrationsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxRegistrationsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTaxRegistrationsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRegistrationsIdRequestBodySchema = z.never().optional()

  const postTaxRegistrationsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_registration]],
    s_error,
  )

  // postTaxRegistrationsId
  router.post(
    `/v1/tax/registrations/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTaxRegistrationsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTaxRegistrationsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_registration>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxRegistrationsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTaxRegistrationsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxSettingsQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxSettingsRequestBodySchema = z.never().optional()

  const getTaxSettingsResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_settings]],
    s_error,
  )

  // getTaxSettings
  router.get(
    `/v1/tax/settings`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTaxSettingsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxSettingsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_settings>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxSettings(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxSettingsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxSettingsRequestBodySchema = z.never().optional()

  const postTaxSettingsResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_settings]],
    s_error,
  )

  // postTaxSettings
  router.post(
    `/v1/tax/settings`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTaxSettingsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_settings>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxSettings(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTaxSettingsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxTransactionsCreateFromCalculationRequestBodySchema = z.never()

  const postTaxTransactionsCreateFromCalculationResponseBodyValidator =
    responseValidationFactory([["200", s_tax_transaction]], s_error)

  // postTaxTransactionsCreateFromCalculation
  router.post(
    `/v1/tax/transactions/create_from_calculation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTaxTransactionsCreateFromCalculationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxTransactionsCreateFromCalculation(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTaxTransactionsCreateFromCalculationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxTransactionsCreateReversalRequestBodySchema = z.never()

  const postTaxTransactionsCreateReversalResponseBodyValidator =
    responseValidationFactory([["200", s_tax_transaction]], s_error)

  // postTaxTransactionsCreateReversal
  router.post(
    `/v1/tax/transactions/create_reversal`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTaxTransactionsCreateReversalRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxTransactionsCreateReversal(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTaxTransactionsCreateReversalResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getTaxTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxTransactionsTransactionRequestBodySchema = z.never().optional()

  const getTaxTransactionsTransactionResponseBodyValidator =
    responseValidationFactory([["200", s_tax_transaction]], s_error)

  // getTaxTransactionsTransaction
  router.get(
    `/v1/tax/transactions/:transaction`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxTransactionsTransactionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxTransactionsTransactionQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxTransactionsTransactionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxTransactionsTransaction(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTaxTransactionsTransactionResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxTransactionsTransactionLineItemsParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getTaxTransactionsTransactionLineItemsQuerySchema = z.object({
    ending_before: z.string().max(500).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(500).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxTransactionsTransactionLineItemsRequestBodySchema = z
    .never()
    .optional()

  const getTaxTransactionsTransactionLineItemsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_tax_transaction_line_item),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/tax/transactions/[^/]+/line_items")),
          }),
        ],
      ],
      s_error,
    )

  // getTaxTransactionsTransactionLineItems
  router.get(
    `/v1/tax/transactions/:transaction/line_items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxTransactionsTransactionLineItemsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxTransactionsTransactionLineItemsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxTransactionsTransactionLineItemsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_tax_transaction_line_item[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxTransactionsTransactionLineItems(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTaxTransactionsTransactionLineItemsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxCodesQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCodesRequestBodySchema = z.never().optional()

  const getTaxCodesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_tax_code),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getTaxCodes
  router.get(
    `/v1/tax_codes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTaxCodesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxCodesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_tax_code[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxCodes(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxCodesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxCodesIdParamSchema = z.object({id: z.string().max(5000)})

  const getTaxCodesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCodesIdRequestBodySchema = z.never().optional()

  const getTaxCodesIdResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_code]],
    s_error,
  )

  // getTaxCodesId
  router.get(
    `/v1/tax_codes/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxCodesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxCodesIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxCodesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_code>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxCodesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxCodesIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxIdsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    owner: z
      .object({
        account: z.string().optional(),
        customer: z.string().max(5000).optional(),
        type: z.enum(["account", "application", "customer", "self"]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxIdsRequestBodySchema = z.never().optional()

  const getTaxIdsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_tax_id)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getTaxIds
  router.get(
    `/v1/tax_ids`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTaxIdsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxIdsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_tax_id[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxIds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxIdsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxIdsRequestBodySchema = z.never()

  const postTaxIdsResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_id]],
    s_error,
  )

  // postTaxIds
  router.post(
    `/v1/tax_ids`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTaxIdsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_id>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxIds(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTaxIdsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteTaxIdsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTaxIdsIdRequestBodySchema = z.never().optional()

  const deleteTaxIdsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_deleted_tax_id]],
    s_error,
  )

  // deleteTaxIdsId
  router.delete(
    `/v1/tax_ids/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteTaxIdsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteTaxIdsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_tax_id>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteTaxIdsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteTaxIdsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxIdsIdParamSchema = z.object({id: z.string().max(5000)})

  const getTaxIdsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxIdsIdRequestBodySchema = z.never().optional()

  const getTaxIdsIdResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_id]],
    s_error,
  )

  // getTaxIdsId
  router.get(
    `/v1/tax_ids/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxIdsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxIdsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxIdsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_id>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxIdsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxIdsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxRatesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    inclusive: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRatesRequestBodySchema = z.never().optional()

  const getTaxRatesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_tax_rate),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/tax_rates")),
        }),
      ],
    ],
    s_error,
  )

  // getTaxRates
  router.get(
    `/v1/tax_rates`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTaxRatesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxRatesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_tax_rate[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxRates(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxRatesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRatesRequestBodySchema = z.never()

  const postTaxRatesResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_rate]],
    s_error,
  )

  // postTaxRates
  router.post(
    `/v1/tax_rates`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTaxRatesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_rate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxRates(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTaxRatesResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTaxRatesTaxRateParamSchema = z.object({
    tax_rate: z.string().max(5000),
  })

  const getTaxRatesTaxRateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRatesTaxRateRequestBodySchema = z.never().optional()

  const getTaxRatesTaxRateResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_rate]],
    s_error,
  )

  // getTaxRatesTaxRate
  router.get(
    `/v1/tax_rates/:tax_rate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTaxRatesTaxRateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTaxRatesTaxRateQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTaxRatesTaxRateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_rate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTaxRatesTaxRate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTaxRatesTaxRateResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTaxRatesTaxRateParamSchema = z.object({
    tax_rate: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRatesTaxRateRequestBodySchema = z.never().optional()

  const postTaxRatesTaxRateResponseBodyValidator = responseValidationFactory(
    [["200", s_tax_rate]],
    s_error,
  )

  // postTaxRatesTaxRate
  router.post(
    `/v1/tax_rates/:tax_rate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTaxRatesTaxRateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTaxRatesTaxRateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tax_rate>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTaxRatesTaxRate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTaxRatesTaxRateResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTerminalConfigurationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    is_account_default: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalConfigurationsRequestBodySchema = z.never().optional()

  const getTerminalConfigurationsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_terminal_configuration)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/terminal/configurations")),
          }),
        ],
      ],
      s_error,
    )

  // getTerminalConfigurations
  router.get(
    `/v1/terminal/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTerminalConfigurationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTerminalConfigurationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_terminal_configuration[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTerminalConfigurations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTerminalConfigurationsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalConfigurationsRequestBodySchema = z.never().optional()

  const postTerminalConfigurationsResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_configuration]], s_error)

  // postTerminalConfigurations
  router.post(
    `/v1/terminal/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTerminalConfigurationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_configuration>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalConfigurations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalConfigurationsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTerminalConfigurationsConfigurationRequestBodySchema = z
    .never()
    .optional()

  const deleteTerminalConfigurationsConfigurationResponseBodyValidator =
    responseValidationFactory(
      [["200", s_deleted_terminal_configuration]],
      s_error,
    )

  // deleteTerminalConfigurationsConfiguration
  router.delete(
    `/v1/terminal/configurations/:configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteTerminalConfigurationsConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteTerminalConfigurationsConfigurationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_terminal_configuration>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteTerminalConfigurationsConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteTerminalConfigurationsConfigurationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getTerminalConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalConfigurationsConfigurationRequestBodySchema = z
    .never()
    .optional()

  const getTerminalConfigurationsConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_terminal_configuration),
            s_deleted_terminal_configuration,
          ]),
        ],
      ],
      s_error,
    )

  // getTerminalConfigurationsConfiguration
  router.get(
    `/v1/terminal/configurations/:configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTerminalConfigurationsConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTerminalConfigurationsConfigurationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTerminalConfigurationsConfigurationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_terminal_configuration | t_deleted_terminal_configuration
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTerminalConfigurationsConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTerminalConfigurationsConfigurationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalConfigurationsConfigurationRequestBodySchema = z
    .never()
    .optional()

  const postTerminalConfigurationsConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_terminal_configuration),
            s_deleted_terminal_configuration,
          ]),
        ],
      ],
      s_error,
    )

  // postTerminalConfigurationsConfiguration
  router.post(
    `/v1/terminal/configurations/:configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalConfigurationsConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalConfigurationsConfigurationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_terminal_configuration | t_deleted_terminal_configuration
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalConfigurationsConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalConfigurationsConfigurationResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalConnectionTokensRequestBodySchema = z.never().optional()

  const postTerminalConnectionTokensResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_connection_token]], s_error)

  // postTerminalConnectionTokens
  router.post(
    `/v1/terminal/connection_tokens`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTerminalConnectionTokensRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_connection_token>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalConnectionTokens(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalConnectionTokensResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTerminalLocationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalLocationsRequestBodySchema = z.never().optional()

  const getTerminalLocationsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_terminal_location),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/terminal/locations")),
        }),
      ],
    ],
    s_error,
  )

  // getTerminalLocations
  router.get(
    `/v1/terminal/locations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTerminalLocationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTerminalLocationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_terminal_location[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTerminalLocations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTerminalLocationsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalLocationsRequestBodySchema = z.never()

  const postTerminalLocationsResponseBodyValidator = responseValidationFactory(
    [["200", s_terminal_location]],
    s_error,
  )

  // postTerminalLocations
  router.post(
    `/v1/terminal/locations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTerminalLocationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_location>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalLocations(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTerminalLocationsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTerminalLocationsLocationRequestBodySchema = z.never().optional()

  const deleteTerminalLocationsLocationResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_terminal_location]], s_error)

  // deleteTerminalLocationsLocation
  router.delete(
    `/v1/terminal/locations/:location`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteTerminalLocationsLocationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteTerminalLocationsLocationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_terminal_location>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteTerminalLocationsLocation(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteTerminalLocationsLocationResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  const getTerminalLocationsLocationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalLocationsLocationRequestBodySchema = z.never().optional()

  const getTerminalLocationsLocationResponseBodyValidator =
    responseValidationFactory(
      [["200", z.union([s_terminal_location, s_deleted_terminal_location])]],
      s_error,
    )

  // getTerminalLocationsLocation
  router.get(
    `/v1/terminal/locations/:location`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTerminalLocationsLocationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTerminalLocationsLocationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTerminalLocationsLocationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_terminal_location | t_deleted_terminal_location
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTerminalLocationsLocation(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTerminalLocationsLocationResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalLocationsLocationRequestBodySchema = z.never().optional()

  const postTerminalLocationsLocationResponseBodyValidator =
    responseValidationFactory(
      [["200", z.union([s_terminal_location, s_deleted_terminal_location])]],
      s_error,
    )

  // postTerminalLocationsLocation
  router.post(
    `/v1/terminal/locations/:location`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalLocationsLocationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalLocationsLocationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_terminal_location | t_deleted_terminal_location
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalLocationsLocation(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalLocationsLocationResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTerminalReadersQuerySchema = z.object({
    device_type: z
      .enum([
        "bbpos_chipper2x",
        "bbpos_wisepad3",
        "bbpos_wisepos_e",
        "mobile_phone_reader",
        "simulated_stripe_s700",
        "simulated_wisepos_e",
        "stripe_m2",
        "stripe_s700",
        "verifone_P400",
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    location: z.string().max(5000).optional(),
    serial_number: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["offline", "online"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalReadersRequestBodySchema = z.never().optional()

  const getTerminalReadersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_terminal_reader)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  // getTerminalReaders
  router.get(
    `/v1/terminal/readers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTerminalReadersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTerminalReadersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_terminal_reader[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTerminalReaders(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTerminalReadersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersRequestBodySchema = z.never()

  const postTerminalReadersResponseBodyValidator = responseValidationFactory(
    [["200", s_terminal_reader]],
    s_error,
  )

  // postTerminalReaders
  router.post(
    `/v1/terminal/readers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReaders(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTerminalReadersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTerminalReadersReaderRequestBodySchema = z.never().optional()

  const deleteTerminalReadersReaderResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_terminal_reader]], s_error)

  // deleteTerminalReadersReader
  router.delete(
    `/v1/terminal/readers/:reader`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteTerminalReadersReaderParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteTerminalReadersReaderRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteTerminalReadersReader(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteTerminalReadersReaderResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const getTerminalReadersReaderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalReadersReaderRequestBodySchema = z.never().optional()

  const getTerminalReadersReaderResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_terminal_reader), s_deleted_terminal_reader]),
        ],
      ],
      s_error,
    )

  // getTerminalReadersReader
  router.get(
    `/v1/terminal/readers/:reader`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTerminalReadersReaderParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTerminalReadersReaderQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTerminalReadersReaderRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_terminal_reader | t_deleted_terminal_reader
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTerminalReadersReader(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTerminalReadersReaderResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderRequestBodySchema = z.never().optional()

  const postTerminalReadersReaderResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_terminal_reader), s_deleted_terminal_reader]),
        ],
      ],
      s_error,
    )

  // postTerminalReadersReader
  router.post(
    `/v1/terminal/readers/:reader`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_terminal_reader | t_deleted_terminal_reader
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReader(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTerminalReadersReaderResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderCancelActionParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderCancelActionRequestBodySchema = z
    .never()
    .optional()

  const postTerminalReadersReaderCancelActionResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderCancelAction
  router.post(
    `/v1/terminal/readers/:reader/cancel_action`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderCancelActionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderCancelActionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderCancelAction(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderCancelActionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderCollectInputsParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderCollectInputsRequestBodySchema = z.never()

  const postTerminalReadersReaderCollectInputsResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderCollectInputs
  router.post(
    `/v1/terminal/readers/:reader/collect_inputs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderCollectInputsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderCollectInputsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderCollectInputs(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderCollectInputsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderCollectPaymentMethodParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderCollectPaymentMethodRequestBodySchema =
    z.never()

  const postTerminalReadersReaderCollectPaymentMethodResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderCollectPaymentMethod
  router.post(
    `/v1/terminal/readers/:reader/collect_payment_method`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderCollectPaymentMethodParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderCollectPaymentMethodRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderCollectPaymentMethod(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderCollectPaymentMethodResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderConfirmPaymentIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderConfirmPaymentIntentRequestBodySchema =
    z.never()

  const postTerminalReadersReaderConfirmPaymentIntentResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderConfirmPaymentIntent
  router.post(
    `/v1/terminal/readers/:reader/confirm_payment_intent`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderConfirmPaymentIntentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderConfirmPaymentIntentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderConfirmPaymentIntent(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderConfirmPaymentIntentResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderProcessPaymentIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderProcessPaymentIntentRequestBodySchema =
    z.never()

  const postTerminalReadersReaderProcessPaymentIntentResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderProcessPaymentIntent
  router.post(
    `/v1/terminal/readers/:reader/process_payment_intent`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderProcessPaymentIntentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderProcessPaymentIntentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderProcessPaymentIntent(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderProcessPaymentIntentResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderProcessSetupIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderProcessSetupIntentRequestBodySchema = z.never()

  const postTerminalReadersReaderProcessSetupIntentResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderProcessSetupIntent
  router.post(
    `/v1/terminal/readers/:reader/process_setup_intent`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderProcessSetupIntentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderProcessSetupIntentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderProcessSetupIntent(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderProcessSetupIntentResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderRefundPaymentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderRefundPaymentRequestBodySchema = z
    .never()
    .optional()

  const postTerminalReadersReaderRefundPaymentResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderRefundPayment
  router.post(
    `/v1/terminal/readers/:reader/refund_payment`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderRefundPaymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderRefundPaymentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderRefundPayment(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderRefundPaymentResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTerminalReadersReaderSetReaderDisplayParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderSetReaderDisplayRequestBodySchema = z.never()

  const postTerminalReadersReaderSetReaderDisplayResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTerminalReadersReaderSetReaderDisplay
  router.post(
    `/v1/terminal/readers/:reader/set_reader_display`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTerminalReadersReaderSetReaderDisplayParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTerminalReadersReaderSetReaderDisplayRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTerminalReadersReaderSetReaderDisplay(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTerminalReadersReaderSetReaderDisplayResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersConfirmationTokensRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersConfirmationTokensResponseBodyValidator =
    responseValidationFactory([["200", s_confirmation_token]], s_error)

  // postTestHelpersConfirmationTokens
  router.post(
    `/v1/test_helpers/confirmation_tokens`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersConfirmationTokensRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_confirmation_token>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersConfirmationTokens(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersConfirmationTokensResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersCustomersCustomerFundCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersCustomersCustomerFundCashBalanceRequestBodySchema =
    z.never()

  const postTestHelpersCustomersCustomerFundCashBalanceResponseBodyValidator =
    responseValidationFactory(
      [["200", s_customer_cash_balance_transaction]],
      s_error,
    )

  // postTestHelpersCustomersCustomerFundCashBalance
  router.post(
    `/v1/test_helpers/customers/:customer/fund_cash_balance`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersCustomersCustomerFundCashBalanceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersCustomersCustomerFundCashBalanceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_customer_cash_balance_transaction>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersCustomersCustomerFundCashBalance(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersCustomersCustomerFundCashBalanceResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsRequestBodySchema = z.never()

  const postTestHelpersIssuingAuthorizationsResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postTestHelpersIssuingAuthorizations
  router.post(
    `/v1/test_helpers/issuing/authorizations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingAuthorizationsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingAuthorizations(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingAuthorizationsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureRequestBodySchema =
    z.never().optional()

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postTestHelpersIssuingAuthorizationsAuthorizationCapture
  router.post(
    `/v1/test_helpers/issuing/authorizations/:authorization/capture`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationCaptureRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingAuthorizationsAuthorizationCapture(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingAuthorizationsAuthorizationCaptureResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireRequestBodySchema =
    z.never().optional()

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postTestHelpersIssuingAuthorizationsAuthorizationExpire
  router.post(
    `/v1/test_helpers/issuing/authorizations/:authorization/expire`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationExpireRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingAuthorizationsAuthorizationExpire(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingAuthorizationsAuthorizationExpireResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountRequestBodySchema =
    z.never()

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount
  router.post(
    `/v1/test_helpers/issuing/authorizations/:authorization/finalize_amount`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondRequestBodySchema =
    z.never()

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond
  router.post(
    `/v1/test_helpers/issuing/authorizations/:authorization/fraud_challenges/respond`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementRequestBodySchema =
    z.never()

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postTestHelpersIssuingAuthorizationsAuthorizationIncrement
  router.post(
    `/v1/test_helpers/issuing/authorizations/:authorization/increment`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationIncrementRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingAuthorizationsAuthorizationIncrement(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingAuthorizationsAuthorizationIncrementResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseRequestBodySchema =
    z.never().optional()

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  // postTestHelpersIssuingAuthorizationsAuthorizationReverse
  router.post(
    `/v1/test_helpers/issuing/authorizations/:authorization/reverse`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingAuthorizationsAuthorizationReverseRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_authorization>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingAuthorizationsAuthorizationReverse(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingAuthorizationsAuthorizationReverseResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingCardsCardShippingDeliverParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingDeliverRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingDeliverResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  // postTestHelpersIssuingCardsCardShippingDeliver
  router.post(
    `/v1/test_helpers/issuing/cards/:card/shipping/deliver`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingDeliverParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingDeliverRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingCardsCardShippingDeliver(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingCardsCardShippingDeliverResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingCardsCardShippingFailParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingFailRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingFailResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  // postTestHelpersIssuingCardsCardShippingFail
  router.post(
    `/v1/test_helpers/issuing/cards/:card/shipping/fail`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingFailParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingFailRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingCardsCardShippingFail(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingCardsCardShippingFailResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingCardsCardShippingReturnParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingReturnRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingReturnResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  // postTestHelpersIssuingCardsCardShippingReturn
  router.post(
    `/v1/test_helpers/issuing/cards/:card/shipping/return`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingReturnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingReturnRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingCardsCardShippingReturn(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingCardsCardShippingReturnResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingCardsCardShippingShipParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingShipRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingShipResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  // postTestHelpersIssuingCardsCardShippingShip
  router.post(
    `/v1/test_helpers/issuing/cards/:card/shipping/ship`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingShipParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingShipRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingCardsCardShippingShip(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingCardsCardShippingShipResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingCardsCardShippingSubmitParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingSubmitRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingSubmitResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  // postTestHelpersIssuingCardsCardShippingSubmit
  router.post(
    `/v1/test_helpers/issuing/cards/:card/shipping/submit`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingSubmitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingCardsCardShippingSubmitRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_card>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingCardsCardShippingSubmit(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingCardsCardShippingSubmitResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateRequestBodySchema =
    z.never().optional()

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponseBodyValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  // postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate
  router.post(
    `/v1/test_helpers/issuing/personalization_designs/:personalization_design/activate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_personalization_design>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateRequestBodySchema =
    z.never().optional()

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponseBodyValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  // postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate
  router.post(
    `/v1/test_helpers/issuing/personalization_designs/:personalization_design/deactivate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_personalization_design>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectRequestBodySchema =
    z.never()

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponseBodyValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  // postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject
  router.post(
    `/v1/test_helpers/issuing/personalization_designs/:personalization_design/reject`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_personalization_design>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingSettlementsRequestBodySchema = z.never()

  const postTestHelpersIssuingSettlementsResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  // postTestHelpersIssuingSettlements
  router.post(
    `/v1/test_helpers/issuing/settlements`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingSettlementsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_settlement>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingSettlements(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingSettlementsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingSettlementsSettlementCompleteParamSchema =
    z.object({settlement: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingSettlementsSettlementCompleteRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingSettlementsSettlementCompleteResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  // postTestHelpersIssuingSettlementsSettlementComplete
  router.post(
    `/v1/test_helpers/issuing/settlements/:settlement/complete`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingSettlementsSettlementCompleteRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_settlement>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingSettlementsSettlementComplete(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingSettlementsSettlementCompleteResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingTransactionsCreateForceCaptureRequestBodySchema =
    z.never()

  const postTestHelpersIssuingTransactionsCreateForceCaptureResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  // postTestHelpersIssuingTransactionsCreateForceCapture
  router.post(
    `/v1/test_helpers/issuing/transactions/create_force_capture`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingTransactionsCreateForceCaptureRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingTransactionsCreateForceCapture(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingTransactionsCreateForceCaptureResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingTransactionsCreateUnlinkedRefundRequestBodySchema =
    z.never()

  const postTestHelpersIssuingTransactionsCreateUnlinkedRefundResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  // postTestHelpersIssuingTransactionsCreateUnlinkedRefund
  router.post(
    `/v1/test_helpers/issuing/transactions/create_unlinked_refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingTransactionsCreateUnlinkedRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingTransactionsCreateUnlinkedRefund(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingTransactionsCreateUnlinkedRefundResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersIssuingTransactionsTransactionRefundParamSchema =
    z.object({transaction: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingTransactionsTransactionRefundRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingTransactionsTransactionRefundResponseBodyValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  // postTestHelpersIssuingTransactionsTransactionRefund
  router.post(
    `/v1/test_helpers/issuing/transactions/:transaction/refund`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersIssuingTransactionsTransactionRefundParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersIssuingTransactionsTransactionRefundRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issuing_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersIssuingTransactionsTransactionRefund(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersIssuingTransactionsTransactionRefundResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersRefundsRefundExpireParamSchema = z.object({
    refund: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersRefundsRefundExpireRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersRefundsRefundExpireResponseBodyValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  // postTestHelpersRefundsRefundExpire
  router.post(
    `/v1/test_helpers/refunds/:refund/expire`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersRefundsRefundExpireParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersRefundsRefundExpireRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_refund>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersRefundsRefundExpire(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersRefundsRefundExpireResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema =
    z.object({reader: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodRequestBodySchema =
    z.never().optional()

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTestHelpersTerminalReadersReaderPresentPaymentMethod
  router.post(
    `/v1/test_helpers/terminal/readers/:reader/present_payment_method`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTerminalReadersReaderPresentPaymentMethodRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTerminalReadersReaderPresentPaymentMethod(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTerminalReadersReaderPresentPaymentMethodResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema =
    z.object({reader: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTerminalReadersReaderSucceedInputCollectionRequestBodySchema =
    z.never().optional()

  const postTestHelpersTerminalReadersReaderSucceedInputCollectionResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTestHelpersTerminalReadersReaderSucceedInputCollection
  router.post(
    `/v1/test_helpers/terminal/readers/:reader/succeed_input_collection`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTerminalReadersReaderSucceedInputCollectionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTerminalReadersReaderSucceedInputCollection(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTerminalReadersReaderSucceedInputCollectionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema =
    z.object({reader: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTerminalReadersReaderTimeoutInputCollectionRequestBodySchema =
    z.never().optional()

  const postTestHelpersTerminalReadersReaderTimeoutInputCollectionResponseBodyValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  // postTestHelpersTerminalReadersReaderTimeoutInputCollection
  router.post(
    `/v1/test_helpers/terminal/readers/:reader/timeout_input_collection`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTerminalReadersReaderTimeoutInputCollectionRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_terminal_reader>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTerminalReadersReaderTimeoutInputCollection(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTerminalReadersReaderTimeoutInputCollectionResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTestHelpersTestClocksQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTestHelpersTestClocksRequestBodySchema = z.never().optional()

  const getTestHelpersTestClocksResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_test_helpers_test_clock),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/test_helpers/test_clocks")),
          }),
        ],
      ],
      s_error,
    )

  // getTestHelpersTestClocks
  router.get(
    `/v1/test_helpers/test_clocks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTestHelpersTestClocksQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTestHelpersTestClocksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_test_helpers_test_clock[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTestHelpersTestClocks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTestHelpersTestClocksResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTestClocksRequestBodySchema = z.never()

  const postTestHelpersTestClocksResponseBodyValidator =
    responseValidationFactory([["200", s_test_helpers_test_clock]], s_error)

  // postTestHelpersTestClocks
  router.post(
    `/v1/test_helpers/test_clocks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTestClocksRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_test_helpers_test_clock>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTestClocks(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTestHelpersTestClocksResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteTestHelpersTestClocksTestClockParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTestHelpersTestClocksTestClockRequestBodySchema = z
    .never()
    .optional()

  const deleteTestHelpersTestClocksTestClockResponseBodyValidator =
    responseValidationFactory(
      [["200", s_deleted_test_helpers_test_clock]],
      s_error,
    )

  // deleteTestHelpersTestClocksTestClock
  router.delete(
    `/v1/test_helpers/test_clocks/:test_clock`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteTestHelpersTestClocksTestClockParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteTestHelpersTestClocksTestClockRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_test_helpers_test_clock>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteTestHelpersTestClocksTestClock(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteTestHelpersTestClocksTestClockResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTestHelpersTestClocksTestClockParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  const getTestHelpersTestClocksTestClockQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTestHelpersTestClocksTestClockRequestBodySchema = z
    .never()
    .optional()

  const getTestHelpersTestClocksTestClockResponseBodyValidator =
    responseValidationFactory([["200", s_test_helpers_test_clock]], s_error)

  // getTestHelpersTestClocksTestClock
  router.get(
    `/v1/test_helpers/test_clocks/:test_clock`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTestHelpersTestClocksTestClockParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTestHelpersTestClocksTestClockQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTestHelpersTestClocksTestClockRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_test_helpers_test_clock>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTestHelpersTestClocksTestClock(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTestHelpersTestClocksTestClockResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTestClocksTestClockAdvanceParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTestClocksTestClockAdvanceRequestBodySchema = z.never()

  const postTestHelpersTestClocksTestClockAdvanceResponseBodyValidator =
    responseValidationFactory([["200", s_test_helpers_test_clock]], s_error)

  // postTestHelpersTestClocksTestClockAdvance
  router.post(
    `/v1/test_helpers/test_clocks/:test_clock/advance`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTestClocksTestClockAdvanceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTestClocksTestClockAdvanceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_test_helpers_test_clock>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTestClocksTestClockAdvance(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTestClocksTestClockAdvanceResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdFailParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryInboundTransfersIdFailRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryInboundTransfersIdFailResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  // postTestHelpersTreasuryInboundTransfersIdFail
  router.post(
    `/v1/test_helpers/treasury/inbound_transfers/:id/fail`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryInboundTransfersIdFailParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryInboundTransfersIdFailRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_inbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryInboundTransfersIdFail(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryInboundTransfersIdFailResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdReturnParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryInboundTransfersIdReturnRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryInboundTransfersIdReturnResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  // postTestHelpersTreasuryInboundTransfersIdReturn
  router.post(
    `/v1/test_helpers/treasury/inbound_transfers/:id/return`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryInboundTransfersIdReturnRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_inbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryInboundTransfersIdReturn(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryInboundTransfersIdReturnResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdSucceedParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryInboundTransfersIdSucceedRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryInboundTransfersIdSucceedResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  // postTestHelpersTreasuryInboundTransfersIdSucceed
  router.post(
    `/v1/test_helpers/treasury/inbound_transfers/:id/succeed`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryInboundTransfersIdSucceedRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_inbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryInboundTransfersIdSucceed(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryInboundTransfersIdSucceedResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdRequestBodySchema = z.never()

  const postTestHelpersTreasuryOutboundPaymentsIdResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  // postTestHelpersTreasuryOutboundPaymentsId
  router.post(
    `/v1/test_helpers/treasury/outbound_payments/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundPaymentsId(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundPaymentsIdResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdFailParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdFailRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryOutboundPaymentsIdFailResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  // postTestHelpersTreasuryOutboundPaymentsIdFail
  router.post(
    `/v1/test_helpers/treasury/outbound_payments/:id/fail`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdFailRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundPaymentsIdFail(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundPaymentsIdFailResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdPostParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdPostRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryOutboundPaymentsIdPostResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  // postTestHelpersTreasuryOutboundPaymentsIdPost
  router.post(
    `/v1/test_helpers/treasury/outbound_payments/:id/post`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdPostRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundPaymentsIdPost(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundPaymentsIdPostResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdReturnRequestBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryOutboundPaymentsIdReturnResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  // postTestHelpersTreasuryOutboundPaymentsIdReturn
  router.post(
    `/v1/test_helpers/treasury/outbound_payments/:id/return`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundPaymentsIdReturnRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundPaymentsIdReturn(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundPaymentsIdReturnResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferRequestBodySchema =
    z.never()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  // postTestHelpersTreasuryOutboundTransfersOutboundTransfer
  router.post(
    `/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundTransfersOutboundTransfer(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailRequestBodySchema =
    z.never().optional()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  // postTestHelpersTreasuryOutboundTransfersOutboundTransferFail
  router.post(
    `/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/fail`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferFailRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundTransfersOutboundTransferFail(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostRequestBodySchema =
    z.never().optional()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  // postTestHelpersTreasuryOutboundTransfersOutboundTransferPost
  router.post(
    `/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/post`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferPostRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundTransfersOutboundTransferPost(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnRequestBodySchema =
    z.never().optional()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  // postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn
  router.post(
    `/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/return`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryReceivedCreditsRequestBodySchema = z.never()

  const postTestHelpersTreasuryReceivedCreditsResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_received_credit]], s_error)

  // postTestHelpersTreasuryReceivedCredits
  router.post(
    `/v1/test_helpers/treasury/received_credits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryReceivedCreditsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_received_credit>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryReceivedCredits(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryReceivedCreditsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryReceivedDebitsRequestBodySchema = z.never()

  const postTestHelpersTreasuryReceivedDebitsResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_received_debit]], s_error)

  // postTestHelpersTreasuryReceivedDebits
  router.post(
    `/v1/test_helpers/treasury/received_debits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTestHelpersTreasuryReceivedDebitsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_received_debit>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTestHelpersTreasuryReceivedDebits(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTestHelpersTreasuryReceivedDebitsResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTokensRequestBodySchema = z.never().optional()

  const postTokensResponseBodyValidator = responseValidationFactory(
    [["200", s_token]],
    s_error,
  )

  // postTokens
  router.post(
    `/v1/tokens`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTokensRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_token>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTokens(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTokensResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTokensTokenParamSchema = z.object({token: z.string().max(5000)})

  const getTokensTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTokensTokenRequestBodySchema = z.never().optional()

  const getTokensTokenResponseBodyValidator = responseValidationFactory(
    [["200", s_token]],
    s_error,
  )

  // getTokensToken
  router.get(
    `/v1/tokens/:token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTokensTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTokensTokenQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTokensTokenRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_token>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTokensToken(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTokensTokenResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTopupsQuerySchema = z.object({
    amount: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "failed", "pending", "succeeded"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTopupsRequestBodySchema = z.never().optional()

  const getTopupsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_topup)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/topups")),
        }),
      ],
    ],
    s_error,
  )

  // getTopups
  router.get(
    `/v1/topups`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTopupsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTopupsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_topup[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTopups(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTopupsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTopupsRequestBodySchema = z.never()

  const postTopupsResponseBodyValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  // postTopups
  router.post(
    `/v1/topups`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTopupsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_topup>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTopups(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTopupsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTopupsTopupParamSchema = z.object({topup: z.string().max(5000)})

  const getTopupsTopupQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTopupsTopupRequestBodySchema = z.never().optional()

  const getTopupsTopupResponseBodyValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  // getTopupsTopup
  router.get(
    `/v1/topups/:topup`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTopupsTopupParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTopupsTopupQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTopupsTopupRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_topup>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTopupsTopup(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTopupsTopupResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTopupsTopupParamSchema = z.object({topup: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTopupsTopupRequestBodySchema = z.never().optional()

  const postTopupsTopupResponseBodyValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  // postTopupsTopup
  router.post(
    `/v1/topups/:topup`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTopupsTopupParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTopupsTopupRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_topup>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTopupsTopup(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTopupsTopupResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTopupsTopupCancelParamSchema = z.object({
    topup: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTopupsTopupCancelRequestBodySchema = z.never().optional()

  const postTopupsTopupCancelResponseBodyValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  // postTopupsTopupCancel
  router.post(
    `/v1/topups/:topup/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTopupsTopupCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTopupsTopupCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_topup>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTopupsTopupCancel(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTopupsTopupCancelResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTransfersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    destination: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    transfer_group: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersRequestBodySchema = z.never().optional()

  const getTransfersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_transfer)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/transfers")),
        }),
      ],
    ],
    s_error,
  )

  // getTransfers
  router.get(
    `/v1/transfers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTransfersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTransfersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_transfer[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTransfers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTransfersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersRequestBodySchema = z.never()

  const postTransfersResponseBodyValidator = responseValidationFactory(
    [["200", s_transfer]],
    s_error,
  )

  // postTransfers
  router.post(
    `/v1/transfers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTransfersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTransfers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTransfersResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTransfersIdReversalsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTransfersIdReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersIdReversalsRequestBodySchema = z.never().optional()

  const getTransfersIdReversalsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_transfer_reversal)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTransfersIdReversals
  router.get(
    `/v1/transfers/:id/reversals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTransfersIdReversalsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTransfersIdReversalsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTransfersIdReversalsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_transfer_reversal[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTransfersIdReversals(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTransfersIdReversalsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTransfersIdReversalsParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersIdReversalsRequestBodySchema = z.never().optional()

  const postTransfersIdReversalsResponseBodyValidator =
    responseValidationFactory([["200", s_transfer_reversal]], s_error)

  // postTransfersIdReversals
  router.post(
    `/v1/transfers/:id/reversals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTransfersIdReversalsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTransfersIdReversalsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_transfer_reversal>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTransfersIdReversals(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTransfersIdReversalsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTransfersTransferParamSchema = z.object({
    transfer: z.string().max(5000),
  })

  const getTransfersTransferQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersTransferRequestBodySchema = z.never().optional()

  const getTransfersTransferResponseBodyValidator = responseValidationFactory(
    [["200", s_transfer]],
    s_error,
  )

  // getTransfersTransfer
  router.get(
    `/v1/transfers/:transfer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTransfersTransferParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTransfersTransferQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTransfersTransferRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTransfersTransfer(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTransfersTransferResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTransfersTransferParamSchema = z.object({
    transfer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersTransferRequestBodySchema = z.never().optional()

  const postTransfersTransferResponseBodyValidator = responseValidationFactory(
    [["200", s_transfer]],
    s_error,
  )

  // postTransfersTransfer
  router.post(
    `/v1/transfers/:transfer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTransfersTransferParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTransfersTransferRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTransfersTransfer(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postTransfersTransferResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTransfersTransferReversalsIdParamSchema = z.object({
    id: z.string().max(5000),
    transfer: z.string().max(5000),
  })

  const getTransfersTransferReversalsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersTransferReversalsIdRequestBodySchema = z.never().optional()

  const getTransfersTransferReversalsIdResponseBodyValidator =
    responseValidationFactory([["200", s_transfer_reversal]], s_error)

  // getTransfersTransferReversalsId
  router.get(
    `/v1/transfers/:transfer/reversals/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTransfersTransferReversalsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTransfersTransferReversalsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTransfersTransferReversalsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_transfer_reversal>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTransfersTransferReversalsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTransfersTransferReversalsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTransfersTransferReversalsIdParamSchema = z.object({
    id: z.string().max(5000),
    transfer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersTransferReversalsIdRequestBodySchema = z.never().optional()

  const postTransfersTransferReversalsIdResponseBodyValidator =
    responseValidationFactory([["200", s_transfer_reversal]], s_error)

  // postTransfersTransferReversalsId
  router.post(
    `/v1/transfers/:transfer/reversals/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTransfersTransferReversalsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTransfersTransferReversalsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_transfer_reversal>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTransfersTransferReversalsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTransfersTransferReversalsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryCreditReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    received_credit: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "posted", "processing"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryCreditReversalsRequestBodySchema = z.never().optional()

  const getTreasuryCreditReversalsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_credit_reversal)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryCreditReversals
  router.get(
    `/v1/treasury/credit_reversals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryCreditReversalsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryCreditReversalsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_credit_reversal[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryCreditReversals(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryCreditReversalsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryCreditReversalsRequestBodySchema = z.never()

  const postTreasuryCreditReversalsResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_credit_reversal]], s_error)

  // postTreasuryCreditReversals
  router.post(
    `/v1/treasury/credit_reversals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTreasuryCreditReversalsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_credit_reversal>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryCreditReversals(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryCreditReversalsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryCreditReversalsCreditReversalParamSchema = z.object({
    credit_reversal: z.string().max(5000),
  })

  const getTreasuryCreditReversalsCreditReversalQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryCreditReversalsCreditReversalRequestBodySchema = z
    .never()
    .optional()

  const getTreasuryCreditReversalsCreditReversalResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_credit_reversal]], s_error)

  // getTreasuryCreditReversalsCreditReversal
  router.get(
    `/v1/treasury/credit_reversals/:credit_reversal`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryCreditReversalsCreditReversalParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryCreditReversalsCreditReversalQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryCreditReversalsCreditReversalRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_credit_reversal>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryCreditReversalsCreditReversal(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryCreditReversalsCreditReversalResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryDebitReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    received_debit: z.string().max(5000).optional(),
    resolution: z.enum(["lost", "won"]).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "completed", "processing"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryDebitReversalsRequestBodySchema = z.never().optional()

  const getTreasuryDebitReversalsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_debit_reversal)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryDebitReversals
  router.get(
    `/v1/treasury/debit_reversals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryDebitReversalsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryDebitReversalsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_debit_reversal[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryDebitReversals(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTreasuryDebitReversalsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryDebitReversalsRequestBodySchema = z.never()

  const postTreasuryDebitReversalsResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_debit_reversal]], s_error)

  // postTreasuryDebitReversals
  router.post(
    `/v1/treasury/debit_reversals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTreasuryDebitReversalsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_debit_reversal>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryDebitReversals(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryDebitReversalsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryDebitReversalsDebitReversalParamSchema = z.object({
    debit_reversal: z.string().max(5000),
  })

  const getTreasuryDebitReversalsDebitReversalQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryDebitReversalsDebitReversalRequestBodySchema = z
    .never()
    .optional()

  const getTreasuryDebitReversalsDebitReversalResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_debit_reversal]], s_error)

  // getTreasuryDebitReversalsDebitReversal
  router.get(
    `/v1/treasury/debit_reversals/:debit_reversal`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryDebitReversalsDebitReversalParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryDebitReversalsDebitReversalQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryDebitReversalsDebitReversalRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_debit_reversal>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryDebitReversalsDebitReversal(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryDebitReversalsDebitReversalResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryFinancialAccountsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["closed", "open"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryFinancialAccountsRequestBodySchema = z.never().optional()

  const getTreasuryFinancialAccountsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_treasury_financial_account),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/treasury/financial_accounts")),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryFinancialAccounts
  router.get(
    `/v1/treasury/financial_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryFinancialAccountsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryFinancialAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_financial_account[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryFinancialAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryFinancialAccountsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsRequestBodySchema = z.never()

  const postTreasuryFinancialAccountsResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  // postTreasuryFinancialAccounts
  router.post(
    `/v1/treasury/financial_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTreasuryFinancialAccountsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_financial_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryFinancialAccounts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryFinancialAccountsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryFinancialAccountsFinancialAccountParamSchema = z.object({
    financial_account: z.string().max(5000),
  })

  const getTreasuryFinancialAccountsFinancialAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryFinancialAccountsFinancialAccountRequestBodySchema = z
    .never()
    .optional()

  const getTreasuryFinancialAccountsFinancialAccountResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  // getTreasuryFinancialAccountsFinancialAccount
  router.get(
    `/v1/treasury/financial_accounts/:financial_account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryFinancialAccountsFinancialAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryFinancialAccountsFinancialAccountQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryFinancialAccountsFinancialAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_financial_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryFinancialAccountsFinancialAccount(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryFinancialAccountsFinancialAccountResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountParamSchema = z.object({
    financial_account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsFinancialAccountRequestBodySchema = z
    .never()
    .optional()

  const postTreasuryFinancialAccountsFinancialAccountResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  // postTreasuryFinancialAccountsFinancialAccount
  router.post(
    `/v1/treasury/financial_accounts/:financial_account`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTreasuryFinancialAccountsFinancialAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTreasuryFinancialAccountsFinancialAccountRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_financial_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryFinancialAccountsFinancialAccount(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryFinancialAccountsFinancialAccountResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountCloseParamSchema =
    z.object({financial_account: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsFinancialAccountCloseRequestBodySchema = z
    .never()
    .optional()

  const postTreasuryFinancialAccountsFinancialAccountCloseResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  // postTreasuryFinancialAccountsFinancialAccountClose
  router.post(
    `/v1/treasury/financial_accounts/:financial_account/close`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTreasuryFinancialAccountsFinancialAccountCloseRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_financial_account>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryFinancialAccountsFinancialAccountClose(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryFinancialAccountsFinancialAccountCloseResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema =
    z.object({financial_account: z.string().max(5000)})

  const getTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema =
    z.never().optional()

  const getTreasuryFinancialAccountsFinancialAccountFeaturesResponseBodyValidator =
    responseValidationFactory(
      [["200", s_treasury_financial_account_features]],
      s_error,
    )

  // getTreasuryFinancialAccountsFinancialAccountFeatures
  router.get(
    `/v1/treasury/financial_accounts/:financial_account/features`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_financial_account_features>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryFinancialAccountsFinancialAccountFeatures(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryFinancialAccountsFinancialAccountFeaturesResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema =
    z.object({financial_account: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema =
    z.never().optional()

  const postTreasuryFinancialAccountsFinancialAccountFeaturesResponseBodyValidator =
    responseValidationFactory(
      [["200", s_treasury_financial_account_features]],
      s_error,
    )

  // postTreasuryFinancialAccountsFinancialAccountFeatures
  router.post(
    `/v1/treasury/financial_accounts/:financial_account/features`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTreasuryFinancialAccountsFinancialAccountFeaturesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_financial_account_features>(
              200,
            )
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryFinancialAccountsFinancialAccountFeatures(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryFinancialAccountsFinancialAccountFeaturesResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryInboundTransfersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "processing", "succeeded"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryInboundTransfersRequestBodySchema = z.never().optional()

  const getTreasuryInboundTransfersResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_inbound_transfer)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryInboundTransfers
  router.get(
    `/v1/treasury/inbound_transfers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryInboundTransfersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryInboundTransfersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_inbound_transfer[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryInboundTransfers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryInboundTransfersResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryInboundTransfersRequestBodySchema = z.never()

  const postTreasuryInboundTransfersResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  // postTreasuryInboundTransfers
  router.post(
    `/v1/treasury/inbound_transfers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTreasuryInboundTransfersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_inbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryInboundTransfers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryInboundTransfersResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryInboundTransfersIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryInboundTransfersIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryInboundTransfersIdRequestBodySchema = z.never().optional()

  const getTreasuryInboundTransfersIdResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  // getTreasuryInboundTransfersId
  router.get(
    `/v1/treasury/inbound_transfers/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryInboundTransfersIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryInboundTransfersIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryInboundTransfersIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_inbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryInboundTransfersId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryInboundTransfersIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTreasuryInboundTransfersInboundTransferCancelParamSchema = z.object(
    {inbound_transfer: z.string().max(5000)},
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryInboundTransfersInboundTransferCancelRequestBodySchema = z
    .never()
    .optional()

  const postTreasuryInboundTransfersInboundTransferCancelResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  // postTreasuryInboundTransfersInboundTransferCancel
  router.post(
    `/v1/treasury/inbound_transfers/:inbound_transfer/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTreasuryInboundTransfersInboundTransferCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTreasuryInboundTransfersInboundTransferCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_inbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryInboundTransfersInboundTransferCancel(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryInboundTransfersInboundTransferCancelResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryOutboundPaymentsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "posted", "processing", "returned"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundPaymentsRequestBodySchema = z.never().optional()

  const getTreasuryOutboundPaymentsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_outbound_payment)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/treasury/outbound_payments")),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryOutboundPayments
  router.get(
    `/v1/treasury/outbound_payments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryOutboundPaymentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryOutboundPaymentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_outbound_payment[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryOutboundPayments(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryOutboundPaymentsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundPaymentsRequestBodySchema = z.never()

  const postTreasuryOutboundPaymentsResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  // postTreasuryOutboundPayments
  router.post(
    `/v1/treasury/outbound_payments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTreasuryOutboundPaymentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryOutboundPayments(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryOutboundPaymentsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryOutboundPaymentsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryOutboundPaymentsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundPaymentsIdRequestBodySchema = z.never().optional()

  const getTreasuryOutboundPaymentsIdResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  // getTreasuryOutboundPaymentsId
  router.get(
    `/v1/treasury/outbound_payments/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryOutboundPaymentsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryOutboundPaymentsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryOutboundPaymentsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryOutboundPaymentsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryOutboundPaymentsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTreasuryOutboundPaymentsIdCancelParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundPaymentsIdCancelRequestBodySchema = z
    .never()
    .optional()

  const postTreasuryOutboundPaymentsIdCancelResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  // postTreasuryOutboundPaymentsIdCancel
  router.post(
    `/v1/treasury/outbound_payments/:id/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTreasuryOutboundPaymentsIdCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTreasuryOutboundPaymentsIdCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_payment>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryOutboundPaymentsIdCancel(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryOutboundPaymentsIdCancelResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryOutboundTransfersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "posted", "processing", "returned"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundTransfersRequestBodySchema = z.never().optional()

  const getTreasuryOutboundTransfersResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_outbound_transfer)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryOutboundTransfers
  router.get(
    `/v1/treasury/outbound_transfers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryOutboundTransfersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryOutboundTransfersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_outbound_transfer[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryOutboundTransfers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryOutboundTransfersResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundTransfersRequestBodySchema = z.never()

  const postTreasuryOutboundTransfersResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  // postTreasuryOutboundTransfers
  router.post(
    `/v1/treasury/outbound_transfers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postTreasuryOutboundTransfersRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryOutboundTransfers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryOutboundTransfersResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryOutboundTransfersOutboundTransferParamSchema = z.object({
    outbound_transfer: z.string().max(5000),
  })

  const getTreasuryOutboundTransfersOutboundTransferQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundTransfersOutboundTransferRequestBodySchema = z
    .never()
    .optional()

  const getTreasuryOutboundTransfersOutboundTransferResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  // getTreasuryOutboundTransfersOutboundTransfer
  router.get(
    `/v1/treasury/outbound_transfers/:outbound_transfer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryOutboundTransfersOutboundTransferParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryOutboundTransfersOutboundTransferQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryOutboundTransfersOutboundTransferRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryOutboundTransfersOutboundTransfer(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryOutboundTransfersOutboundTransferResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postTreasuryOutboundTransfersOutboundTransferCancelParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundTransfersOutboundTransferCancelRequestBodySchema = z
    .never()
    .optional()

  const postTreasuryOutboundTransfersOutboundTransferCancelResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  // postTreasuryOutboundTransfersOutboundTransferCancel
  router.post(
    `/v1/treasury/outbound_transfers/:outbound_transfer/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postTreasuryOutboundTransfersOutboundTransferCancelRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_outbound_transfer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postTreasuryOutboundTransfersOutboundTransferCancel(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postTreasuryOutboundTransfersOutboundTransferCancelResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryReceivedCreditsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    linked_flows: z
      .object({
        source_flow_type: z.enum([
          "credit_reversal",
          "other",
          "outbound_payment",
          "outbound_transfer",
          "payout",
        ]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["failed", "succeeded"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedCreditsRequestBodySchema = z.never().optional()

  const getTreasuryReceivedCreditsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_received_credit)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryReceivedCredits
  router.get(
    `/v1/treasury/received_credits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryReceivedCreditsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryReceivedCreditsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_received_credit[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryReceivedCredits(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryReceivedCreditsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryReceivedCreditsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryReceivedCreditsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedCreditsIdRequestBodySchema = z.never().optional()

  const getTreasuryReceivedCreditsIdResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_received_credit]], s_error)

  // getTreasuryReceivedCreditsId
  router.get(
    `/v1/treasury/received_credits/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryReceivedCreditsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryReceivedCreditsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryReceivedCreditsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_received_credit>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryReceivedCreditsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryReceivedCreditsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryReceivedDebitsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["failed", "succeeded"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedDebitsRequestBodySchema = z.never().optional()

  const getTreasuryReceivedDebitsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_received_debit)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryReceivedDebits
  router.get(
    `/v1/treasury/received_debits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryReceivedDebitsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryReceivedDebitsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_received_debit[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryReceivedDebits(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTreasuryReceivedDebitsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryReceivedDebitsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryReceivedDebitsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedDebitsIdRequestBodySchema = z.never().optional()

  const getTreasuryReceivedDebitsIdResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_received_debit]], s_error)

  // getTreasuryReceivedDebitsId
  router.get(
    `/v1/treasury/received_debits/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryReceivedDebitsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryReceivedDebitsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryReceivedDebitsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_received_debit>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryReceivedDebitsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryReceivedDebitsIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryTransactionEntriesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    effective_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    order_by: z.enum(["created", "effective_at"]).optional(),
    starting_after: z.string().max(5000).optional(),
    transaction: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionEntriesRequestBodySchema = z.never().optional()

  const getTreasuryTransactionEntriesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_transaction_entry)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/treasury/transaction_entries")),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryTransactionEntries
  router.get(
    `/v1/treasury/transaction_entries`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryTransactionEntriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryTransactionEntriesRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_transaction_entry[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryTransactionEntries(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryTransactionEntriesResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryTransactionEntriesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryTransactionEntriesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionEntriesIdRequestBodySchema = z.never().optional()

  const getTreasuryTransactionEntriesIdResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_transaction_entry]], s_error)

  // getTreasuryTransactionEntriesId
  router.get(
    `/v1/treasury/transaction_entries/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryTransactionEntriesIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryTransactionEntriesIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryTransactionEntriesIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_transaction_entry>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryTransactionEntriesId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getTreasuryTransactionEntriesIdResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryTransactionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    order_by: z.enum(["created", "posted_at"]).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["open", "posted", "void"]).optional(),
    status_transitions: z
      .object({
        posted_at: z
          .union([
            z.object({
              gt: z.coerce.number().optional(),
              gte: z.coerce.number().optional(),
              lt: z.coerce.number().optional(),
              lte: z.coerce.number().optional(),
            }),
            z.coerce.number(),
          ])
          .optional(),
      })
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionsRequestBodySchema = z.never().optional()

  const getTreasuryTransactionsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_transaction)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  // getTreasuryTransactions
  router.get(
    `/v1/treasury/transactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTreasuryTransactionsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryTransactionsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_treasury_transaction[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryTransactions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTreasuryTransactionsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTreasuryTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionsIdRequestBodySchema = z.never().optional()

  const getTreasuryTransactionsIdResponseBodyValidator =
    responseValidationFactory([["200", s_treasury_transaction]], s_error)

  // getTreasuryTransactionsId
  router.get(
    `/v1/treasury/transactions/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTreasuryTransactionsIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getTreasuryTransactionsIdQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getTreasuryTransactionsIdRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_treasury_transaction>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTreasuryTransactionsId(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTreasuryTransactionsIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getWebhookEndpointsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getWebhookEndpointsRequestBodySchema = z.never().optional()

  const getWebhookEndpointsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_webhook_endpoint),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/webhook_endpoints")),
        }),
      ],
    ],
    s_error,
  )

  // getWebhookEndpoints
  router.get(
    `/v1/webhook_endpoints`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getWebhookEndpointsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getWebhookEndpointsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              data: t_webhook_endpoint[]
              has_more: boolean
              object: "list"
              url: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getWebhookEndpoints(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getWebhookEndpointsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postWebhookEndpointsRequestBodySchema = z.never()

  const postWebhookEndpointsResponseBodyValidator = responseValidationFactory(
    [["200", s_webhook_endpoint]],
    s_error,
  )

  // postWebhookEndpoints
  router.post(
    `/v1/webhook_endpoints`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            postWebhookEndpointsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_endpoint>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postWebhookEndpoints(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(postWebhookEndpointsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteWebhookEndpointsWebhookEndpointRequestBodySchema = z
    .never()
    .optional()

  const deleteWebhookEndpointsWebhookEndpointResponseBodyValidator =
    responseValidationFactory([["200", s_deleted_webhook_endpoint]], s_error)

  // deleteWebhookEndpointsWebhookEndpoint
  router.delete(
    `/v1/webhook_endpoints/:webhook_endpoint`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteWebhookEndpointsWebhookEndpointParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deleteWebhookEndpointsWebhookEndpointRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deleted_webhook_endpoint>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteWebhookEndpointsWebhookEndpoint(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            deleteWebhookEndpointsWebhookEndpointResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  const getWebhookEndpointsWebhookEndpointQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getWebhookEndpointsWebhookEndpointRequestBodySchema = z
    .never()
    .optional()

  const getWebhookEndpointsWebhookEndpointResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_endpoint]], s_error)

  // getWebhookEndpointsWebhookEndpoint
  router.get(
    `/v1/webhook_endpoints/:webhook_endpoint`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getWebhookEndpointsWebhookEndpointParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getWebhookEndpointsWebhookEndpointQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            getWebhookEndpointsWebhookEndpointRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_endpoint>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getWebhookEndpointsWebhookEndpoint(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            getWebhookEndpointsWebhookEndpointResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const postWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postWebhookEndpointsWebhookEndpointRequestBodySchema = z
    .never()
    .optional()

  const postWebhookEndpointsWebhookEndpointResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_endpoint]], s_error)

  // postWebhookEndpointsWebhookEndpoint
  router.post(
    `/v1/webhook_endpoints/:webhook_endpoint`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            postWebhookEndpointsWebhookEndpointParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            postWebhookEndpointsWebhookEndpointRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_endpoint>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_error>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .postWebhookEndpointsWebhookEndpoint(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            postWebhookEndpointsWebhookEndpointResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Stripe API
  return startServer(config)
}
