/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {RequestInputType} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  handleImplementationError,
  handleResponse,
  type Params,
  type ServerConfig,
  type SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v4"
import {type NextFunction, type Request, type Response, Router} from "express"
import {z} from "zod/v4"
import type {
  EmptyObject,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody,
  t_ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsAddSelectedRepoToOrgSecretParamSchema,
  t_ActionsAddSelectedRepoToOrgVariableParamSchema,
  t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema,
  t_ActionsApproveWorkflowRunParamSchema,
  t_ActionsCancelWorkflowRunParamSchema,
  t_ActionsCreateEnvironmentVariableParamSchema,
  t_ActionsCreateEnvironmentVariableRequestBody,
  t_ActionsCreateHostedRunnerForOrgParamSchema,
  t_ActionsCreateHostedRunnerForOrgRequestBody,
  t_ActionsCreateOrgVariableParamSchema,
  t_ActionsCreateOrgVariableRequestBody,
  t_ActionsCreateOrUpdateEnvironmentSecretParamSchema,
  t_ActionsCreateOrUpdateEnvironmentSecretRequestBody,
  t_ActionsCreateOrUpdateOrgSecretParamSchema,
  t_ActionsCreateOrUpdateOrgSecretRequestBody,
  t_ActionsCreateOrUpdateRepoSecretParamSchema,
  t_ActionsCreateOrUpdateRepoSecretRequestBody,
  t_ActionsCreateRegistrationTokenForOrgParamSchema,
  t_ActionsCreateRegistrationTokenForRepoParamSchema,
  t_ActionsCreateRemoveTokenForOrgParamSchema,
  t_ActionsCreateRemoveTokenForRepoParamSchema,
  t_ActionsCreateRepoVariableParamSchema,
  t_ActionsCreateRepoVariableRequestBody,
  t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema,
  t_ActionsCreateSelfHostedRunnerGroupForOrgRequestBody,
  t_ActionsCreateWorkflowDispatchParamSchema,
  t_ActionsCreateWorkflowDispatchRequestBody,
  t_ActionsDeleteActionsCacheByIdParamSchema,
  t_ActionsDeleteActionsCacheByKeyParamSchema,
  t_ActionsDeleteActionsCacheByKeyQuerySchema,
  t_ActionsDeleteArtifactParamSchema,
  t_ActionsDeleteEnvironmentSecretParamSchema,
  t_ActionsDeleteEnvironmentVariableParamSchema,
  t_ActionsDeleteHostedRunnerForOrgParamSchema,
  t_ActionsDeleteOrgSecretParamSchema,
  t_ActionsDeleteOrgVariableParamSchema,
  t_ActionsDeleteRepoSecretParamSchema,
  t_ActionsDeleteRepoVariableParamSchema,
  t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema,
  t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema,
  t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
  t_ActionsDeleteWorkflowRunLogsParamSchema,
  t_ActionsDeleteWorkflowRunParamSchema,
  t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
  t_ActionsDisableWorkflowParamSchema,
  t_ActionsDownloadArtifactParamSchema,
  t_ActionsDownloadJobLogsForWorkflowRunParamSchema,
  t_ActionsDownloadWorkflowRunAttemptLogsParamSchema,
  t_ActionsDownloadWorkflowRunLogsParamSchema,
  t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
  t_ActionsEnableWorkflowParamSchema,
  t_ActionsForceCancelWorkflowRunParamSchema,
  t_ActionsGenerateRunnerJitconfigForOrgParamSchema,
  t_ActionsGenerateRunnerJitconfigForOrgRequestBody,
  t_ActionsGenerateRunnerJitconfigForRepoParamSchema,
  t_ActionsGenerateRunnerJitconfigForRepoRequestBody,
  t_ActionsGetActionsCacheListParamSchema,
  t_ActionsGetActionsCacheListQuerySchema,
  t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema,
  t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema,
  t_ActionsGetActionsCacheUsageForOrgParamSchema,
  t_ActionsGetActionsCacheUsageParamSchema,
  t_ActionsGetAllowedActionsOrganizationParamSchema,
  t_ActionsGetAllowedActionsRepositoryParamSchema,
  t_ActionsGetArtifactParamSchema,
  t_ActionsGetCustomOidcSubClaimForRepoParamSchema,
  t_ActionsGetEnvironmentPublicKeyParamSchema,
  t_ActionsGetEnvironmentSecretParamSchema,
  t_ActionsGetEnvironmentVariableParamSchema,
  t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
  t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
  t_ActionsGetGithubActionsPermissionsOrganizationParamSchema,
  t_ActionsGetGithubActionsPermissionsRepositoryParamSchema,
  t_ActionsGetHostedRunnerForOrgParamSchema,
  t_ActionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema,
  t_ActionsGetHostedRunnersLimitsForOrgParamSchema,
  t_ActionsGetHostedRunnersMachineSpecsForOrgParamSchema,
  t_ActionsGetHostedRunnersPartnerImagesForOrgParamSchema,
  t_ActionsGetHostedRunnersPlatformsForOrgParamSchema,
  t_ActionsGetJobForWorkflowRunParamSchema,
  t_ActionsGetOrgPublicKeyParamSchema,
  t_ActionsGetOrgSecretParamSchema,
  t_ActionsGetOrgVariableParamSchema,
  t_ActionsGetPendingDeploymentsForRunParamSchema,
  t_ActionsGetRepoPublicKeyParamSchema,
  t_ActionsGetRepoSecretParamSchema,
  t_ActionsGetRepoVariableParamSchema,
  t_ActionsGetReviewsForRunParamSchema,
  t_ActionsGetSelfHostedRunnerForOrgParamSchema,
  t_ActionsGetSelfHostedRunnerForRepoParamSchema,
  t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema,
  t_ActionsGetWorkflowAccessToRepositoryParamSchema,
  t_ActionsGetWorkflowParamSchema,
  t_ActionsGetWorkflowRunAttemptParamSchema,
  t_ActionsGetWorkflowRunAttemptQuerySchema,
  t_ActionsGetWorkflowRunParamSchema,
  t_ActionsGetWorkflowRunQuerySchema,
  t_ActionsGetWorkflowRunUsageParamSchema,
  t_ActionsGetWorkflowUsageParamSchema,
  t_ActionsListArtifactsForRepoParamSchema,
  t_ActionsListArtifactsForRepoQuerySchema,
  t_ActionsListEnvironmentSecretsParamSchema,
  t_ActionsListEnvironmentSecretsQuerySchema,
  t_ActionsListEnvironmentVariablesParamSchema,
  t_ActionsListEnvironmentVariablesQuerySchema,
  t_ActionsListGithubHostedRunnersInGroupForOrgParamSchema,
  t_ActionsListGithubHostedRunnersInGroupForOrgQuerySchema,
  t_ActionsListHostedRunnersForOrgParamSchema,
  t_ActionsListHostedRunnersForOrgQuerySchema,
  t_ActionsListJobsForWorkflowRunAttemptParamSchema,
  t_ActionsListJobsForWorkflowRunAttemptQuerySchema,
  t_ActionsListJobsForWorkflowRunParamSchema,
  t_ActionsListJobsForWorkflowRunQuerySchema,
  t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema,
  t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema,
  t_ActionsListOrgSecretsParamSchema,
  t_ActionsListOrgSecretsQuerySchema,
  t_ActionsListOrgVariablesParamSchema,
  t_ActionsListOrgVariablesQuerySchema,
  t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
  t_ActionsListRepoOrganizationSecretsParamSchema,
  t_ActionsListRepoOrganizationSecretsQuerySchema,
  t_ActionsListRepoOrganizationVariablesParamSchema,
  t_ActionsListRepoOrganizationVariablesQuerySchema,
  t_ActionsListRepoSecretsParamSchema,
  t_ActionsListRepoSecretsQuerySchema,
  t_ActionsListRepoVariablesParamSchema,
  t_ActionsListRepoVariablesQuerySchema,
  t_ActionsListRepoWorkflowsParamSchema,
  t_ActionsListRepoWorkflowsQuerySchema,
  t_ActionsListRunnerApplicationsForOrgParamSchema,
  t_ActionsListRunnerApplicationsForRepoParamSchema,
  t_ActionsListSelectedReposForOrgSecretParamSchema,
  t_ActionsListSelectedReposForOrgSecretQuerySchema,
  t_ActionsListSelectedReposForOrgVariableParamSchema,
  t_ActionsListSelectedReposForOrgVariableQuerySchema,
  t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
  t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
  t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema,
  t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema,
  t_ActionsListSelfHostedRunnersForOrgParamSchema,
  t_ActionsListSelfHostedRunnersForOrgQuerySchema,
  t_ActionsListSelfHostedRunnersForRepoParamSchema,
  t_ActionsListSelfHostedRunnersForRepoQuerySchema,
  t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema,
  t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema,
  t_ActionsListWorkflowRunArtifactsParamSchema,
  t_ActionsListWorkflowRunArtifactsQuerySchema,
  t_ActionsListWorkflowRunsForRepoParamSchema,
  t_ActionsListWorkflowRunsForRepoQuerySchema,
  t_ActionsListWorkflowRunsParamSchema,
  t_ActionsListWorkflowRunsQuerySchema,
  t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
  t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
  t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
  t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
  t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema,
  t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema,
  t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
  t_ActionsReRunJobForWorkflowRunParamSchema,
  t_ActionsReRunJobForWorkflowRunRequestBody,
  t_ActionsReRunWorkflowFailedJobsParamSchema,
  t_ActionsReRunWorkflowFailedJobsRequestBody,
  t_ActionsReRunWorkflowParamSchema,
  t_ActionsReRunWorkflowRequestBody,
  t_ActionsReviewCustomGatesForRunParamSchema,
  t_ActionsReviewCustomGatesForRunRequestBody,
  t_ActionsReviewPendingDeploymentsForRunParamSchema,
  t_ActionsReviewPendingDeploymentsForRunRequestBody,
  t_ActionsSetAllowedActionsOrganizationParamSchema,
  t_ActionsSetAllowedActionsRepositoryParamSchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody,
  t_ActionsSetCustomOidcSubClaimForRepoParamSchema,
  t_ActionsSetCustomOidcSubClaimForRepoRequestBody,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
  t_ActionsSetGithubActionsPermissionsOrganizationParamSchema,
  t_ActionsSetGithubActionsPermissionsOrganizationRequestBody,
  t_ActionsSetGithubActionsPermissionsRepositoryParamSchema,
  t_ActionsSetGithubActionsPermissionsRepositoryRequestBody,
  t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody,
  t_ActionsSetSelectedReposForOrgSecretParamSchema,
  t_ActionsSetSelectedReposForOrgSecretRequestBody,
  t_ActionsSetSelectedReposForOrgVariableParamSchema,
  t_ActionsSetSelectedReposForOrgVariableRequestBody,
  t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
  t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody,
  t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema,
  t_ActionsSetSelfHostedRunnersInGroupForOrgRequestBody,
  t_ActionsSetWorkflowAccessToRepositoryParamSchema,
  t_ActionsUpdateEnvironmentVariableParamSchema,
  t_ActionsUpdateEnvironmentVariableRequestBody,
  t_ActionsUpdateHostedRunnerForOrgParamSchema,
  t_ActionsUpdateHostedRunnerForOrgRequestBody,
  t_ActionsUpdateOrgVariableParamSchema,
  t_ActionsUpdateOrgVariableRequestBody,
  t_ActionsUpdateRepoVariableParamSchema,
  t_ActionsUpdateRepoVariableRequestBody,
  t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
  t_ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody,
  t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema,
  t_ActivityDeleteRepoSubscriptionParamSchema,
  t_ActivityDeleteThreadSubscriptionParamSchema,
  t_ActivityGetRepoSubscriptionParamSchema,
  t_ActivityGetThreadParamSchema,
  t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema,
  t_ActivityListEventsForAuthenticatedUserParamSchema,
  t_ActivityListEventsForAuthenticatedUserQuerySchema,
  t_ActivityListNotificationsForAuthenticatedUserQuerySchema,
  t_ActivityListOrgEventsForAuthenticatedUserParamSchema,
  t_ActivityListOrgEventsForAuthenticatedUserQuerySchema,
  t_ActivityListPublicEventsForRepoNetworkParamSchema,
  t_ActivityListPublicEventsForRepoNetworkQuerySchema,
  t_ActivityListPublicEventsForUserParamSchema,
  t_ActivityListPublicEventsForUserQuerySchema,
  t_ActivityListPublicEventsQuerySchema,
  t_ActivityListPublicOrgEventsParamSchema,
  t_ActivityListPublicOrgEventsQuerySchema,
  t_ActivityListReceivedEventsForUserParamSchema,
  t_ActivityListReceivedEventsForUserQuerySchema,
  t_ActivityListReceivedPublicEventsForUserParamSchema,
  t_ActivityListReceivedPublicEventsForUserQuerySchema,
  t_ActivityListRepoEventsParamSchema,
  t_ActivityListRepoEventsQuerySchema,
  t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema,
  t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema,
  t_ActivityListReposStarredByAuthenticatedUserQuerySchema,
  t_ActivityListReposStarredByUserParamSchema,
  t_ActivityListReposStarredByUserQuerySchema,
  t_ActivityListReposWatchedByUserParamSchema,
  t_ActivityListReposWatchedByUserQuerySchema,
  t_ActivityListStargazersForRepoParamSchema,
  t_ActivityListStargazersForRepoQuerySchema,
  t_ActivityListWatchedReposForAuthenticatedUserQuerySchema,
  t_ActivityListWatchersForRepoParamSchema,
  t_ActivityListWatchersForRepoQuerySchema,
  t_ActivityMarkNotificationsAsReadRequestBody,
  t_ActivityMarkRepoNotificationsAsReadParamSchema,
  t_ActivityMarkRepoNotificationsAsReadRequestBody,
  t_ActivityMarkThreadAsDoneParamSchema,
  t_ActivityMarkThreadAsReadParamSchema,
  t_ActivitySetRepoSubscriptionParamSchema,
  t_ActivitySetRepoSubscriptionRequestBody,
  t_ActivitySetThreadSubscriptionParamSchema,
  t_ActivitySetThreadSubscriptionRequestBody,
  t_ActivityStarRepoForAuthenticatedUserParamSchema,
  t_ActivityUnstarRepoForAuthenticatedUserParamSchema,
  t_ApiInsightsGetRouteStatsByActorParamSchema,
  t_ApiInsightsGetRouteStatsByActorQuerySchema,
  t_ApiInsightsGetSubjectStatsParamSchema,
  t_ApiInsightsGetSubjectStatsQuerySchema,
  t_ApiInsightsGetSummaryStatsByActorParamSchema,
  t_ApiInsightsGetSummaryStatsByActorQuerySchema,
  t_ApiInsightsGetSummaryStatsByUserParamSchema,
  t_ApiInsightsGetSummaryStatsByUserQuerySchema,
  t_ApiInsightsGetSummaryStatsParamSchema,
  t_ApiInsightsGetSummaryStatsQuerySchema,
  t_ApiInsightsGetTimeStatsByActorParamSchema,
  t_ApiInsightsGetTimeStatsByActorQuerySchema,
  t_ApiInsightsGetTimeStatsByUserParamSchema,
  t_ApiInsightsGetTimeStatsByUserQuerySchema,
  t_ApiInsightsGetTimeStatsParamSchema,
  t_ApiInsightsGetTimeStatsQuerySchema,
  t_ApiInsightsGetUserStatsParamSchema,
  t_ApiInsightsGetUserStatsQuerySchema,
  t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema,
  t_AppsCheckTokenParamSchema,
  t_AppsCheckTokenRequestBody,
  t_AppsCreateFromManifestParamSchema,
  t_AppsCreateInstallationAccessTokenParamSchema,
  t_AppsCreateInstallationAccessTokenRequestBody,
  t_AppsDeleteAuthorizationParamSchema,
  t_AppsDeleteAuthorizationRequestBody,
  t_AppsDeleteInstallationParamSchema,
  t_AppsDeleteTokenParamSchema,
  t_AppsDeleteTokenRequestBody,
  t_AppsGetBySlugParamSchema,
  t_AppsGetInstallationParamSchema,
  t_AppsGetOrgInstallationParamSchema,
  t_AppsGetRepoInstallationParamSchema,
  t_AppsGetSubscriptionPlanForAccountParamSchema,
  t_AppsGetSubscriptionPlanForAccountStubbedParamSchema,
  t_AppsGetUserInstallationParamSchema,
  t_AppsGetWebhookDeliveryParamSchema,
  t_AppsListAccountsForPlanParamSchema,
  t_AppsListAccountsForPlanQuerySchema,
  t_AppsListAccountsForPlanStubbedParamSchema,
  t_AppsListAccountsForPlanStubbedQuerySchema,
  t_AppsListInstallationReposForAuthenticatedUserParamSchema,
  t_AppsListInstallationReposForAuthenticatedUserQuerySchema,
  t_AppsListInstallationRequestsForAuthenticatedAppQuerySchema,
  t_AppsListInstallationsForAuthenticatedUserQuerySchema,
  t_AppsListInstallationsQuerySchema,
  t_AppsListPlansQuerySchema,
  t_AppsListPlansStubbedQuerySchema,
  t_AppsListReposAccessibleToInstallationQuerySchema,
  t_AppsListSubscriptionsForAuthenticatedUserQuerySchema,
  t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
  t_AppsListWebhookDeliveriesQuerySchema,
  t_AppsRedeliverWebhookDeliveryParamSchema,
  t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
  t_AppsResetTokenParamSchema,
  t_AppsResetTokenRequestBody,
  t_AppsScopeTokenParamSchema,
  t_AppsScopeTokenRequestBody,
  t_AppsSuspendInstallationParamSchema,
  t_AppsUnsuspendInstallationParamSchema,
  t_AppsUpdateWebhookConfigForAppRequestBody,
  t_actions_billing_usage,
  t_actions_cache_list,
  t_actions_cache_usage_by_repository,
  t_actions_cache_usage_org_enterprise,
  t_actions_get_default_workflow_permissions,
  t_actions_hosted_runner,
  t_actions_hosted_runner_image,
  t_actions_hosted_runner_limits,
  t_actions_hosted_runner_machine_spec,
  t_actions_organization_permissions,
  t_actions_public_key,
  t_actions_repository_permissions,
  t_actions_secret,
  t_actions_set_default_workflow_permissions,
  t_actions_variable,
  t_actions_workflow_access_to_repository,
  t_activity,
  t_api_insights_route_stats,
  t_api_insights_subject_stats,
  t_api_insights_summary_stats,
  t_api_insights_time_stats,
  t_api_insights_user_stats,
  t_api_overview,
  t_artifact,
  t_authentication_token,
  t_authorization,
  t_autolink,
  t_BillingGetGithubActionsBillingOrgParamSchema,
  t_BillingGetGithubActionsBillingUserParamSchema,
  t_BillingGetGithubBillingUsageReportOrgParamSchema,
  t_BillingGetGithubBillingUsageReportOrgQuerySchema,
  t_BillingGetGithubBillingUsageReportUserParamSchema,
  t_BillingGetGithubBillingUsageReportUserQuerySchema,
  t_BillingGetGithubPackagesBillingOrgParamSchema,
  t_BillingGetGithubPackagesBillingUserParamSchema,
  t_BillingGetSharedStorageBillingOrgParamSchema,
  t_BillingGetSharedStorageBillingUserParamSchema,
  t_base_gist,
  t_basic_error,
  t_billing_usage_report,
  t_billing_usage_report_user,
  t_blob,
  t_branch_protection,
  t_branch_restriction_policy,
  t_branch_short,
  t_branch_with_protection,
  t_CampaignsCreateCampaignParamSchema,
  t_CampaignsCreateCampaignRequestBody,
  t_CampaignsDeleteCampaignParamSchema,
  t_CampaignsGetCampaignSummaryParamSchema,
  t_CampaignsListOrgCampaignsParamSchema,
  t_CampaignsListOrgCampaignsQuerySchema,
  t_CampaignsUpdateCampaignParamSchema,
  t_CampaignsUpdateCampaignRequestBody,
  t_ChecksCreateParamSchema,
  t_ChecksCreateRequestBody,
  t_ChecksCreateSuiteParamSchema,
  t_ChecksCreateSuiteRequestBody,
  t_ChecksGetParamSchema,
  t_ChecksGetSuiteParamSchema,
  t_ChecksListAnnotationsParamSchema,
  t_ChecksListAnnotationsQuerySchema,
  t_ChecksListForRefParamSchema,
  t_ChecksListForRefQuerySchema,
  t_ChecksListForSuiteParamSchema,
  t_ChecksListForSuiteQuerySchema,
  t_ChecksListSuitesForRefParamSchema,
  t_ChecksListSuitesForRefQuerySchema,
  t_ChecksRerequestRunParamSchema,
  t_ChecksRerequestSuiteParamSchema,
  t_ChecksSetSuitesPreferencesParamSchema,
  t_ChecksSetSuitesPreferencesRequestBody,
  t_ChecksUpdateParamSchema,
  t_ChecksUpdateRequestBody,
  t_ClassroomGetAClassroomParamSchema,
  t_ClassroomGetAnAssignmentParamSchema,
  t_ClassroomGetAssignmentGradesParamSchema,
  t_ClassroomListAcceptedAssignmentsForAnAssignmentParamSchema,
  t_ClassroomListAcceptedAssignmentsForAnAssignmentQuerySchema,
  t_ClassroomListAssignmentsForAClassroomParamSchema,
  t_ClassroomListAssignmentsForAClassroomQuerySchema,
  t_ClassroomListClassroomsQuerySchema,
  t_CodeScanningCommitAutofixParamSchema,
  t_CodeScanningCreateAutofixParamSchema,
  t_CodeScanningCreateVariantAnalysisParamSchema,
  t_CodeScanningCreateVariantAnalysisRequestBody,
  t_CodeScanningDeleteAnalysisParamSchema,
  t_CodeScanningDeleteAnalysisQuerySchema,
  t_CodeScanningDeleteCodeqlDatabaseParamSchema,
  t_CodeScanningGetAlertParamSchema,
  t_CodeScanningGetAnalysisParamSchema,
  t_CodeScanningGetAutofixParamSchema,
  t_CodeScanningGetCodeqlDatabaseParamSchema,
  t_CodeScanningGetDefaultSetupParamSchema,
  t_CodeScanningGetSarifParamSchema,
  t_CodeScanningGetVariantAnalysisParamSchema,
  t_CodeScanningGetVariantAnalysisRepoTaskParamSchema,
  t_CodeScanningListAlertInstancesParamSchema,
  t_CodeScanningListAlertInstancesQuerySchema,
  t_CodeScanningListAlertsForOrgParamSchema,
  t_CodeScanningListAlertsForOrgQuerySchema,
  t_CodeScanningListAlertsForRepoParamSchema,
  t_CodeScanningListAlertsForRepoQuerySchema,
  t_CodeScanningListCodeqlDatabasesParamSchema,
  t_CodeScanningListRecentAnalysesParamSchema,
  t_CodeScanningListRecentAnalysesQuerySchema,
  t_CodeScanningUpdateAlertParamSchema,
  t_CodeScanningUpdateAlertRequestBody,
  t_CodeScanningUpdateDefaultSetupParamSchema,
  t_CodeScanningUploadSarifParamSchema,
  t_CodeScanningUploadSarifRequestBody,
  t_CodeSecurityAttachConfigurationParamSchema,
  t_CodeSecurityAttachConfigurationRequestBody,
  t_CodeSecurityAttachEnterpriseConfigurationParamSchema,
  t_CodeSecurityAttachEnterpriseConfigurationRequestBody,
  t_CodeSecurityCreateConfigurationForEnterpriseParamSchema,
  t_CodeSecurityCreateConfigurationForEnterpriseRequestBody,
  t_CodeSecurityCreateConfigurationParamSchema,
  t_CodeSecurityCreateConfigurationRequestBody,
  t_CodeSecurityDeleteConfigurationForEnterpriseParamSchema,
  t_CodeSecurityDeleteConfigurationParamSchema,
  t_CodeSecurityDetachConfigurationParamSchema,
  t_CodeSecurityDetachConfigurationRequestBody,
  t_CodeSecurityGetConfigurationForRepositoryParamSchema,
  t_CodeSecurityGetConfigurationParamSchema,
  t_CodeSecurityGetConfigurationsForEnterpriseParamSchema,
  t_CodeSecurityGetConfigurationsForEnterpriseQuerySchema,
  t_CodeSecurityGetConfigurationsForOrgParamSchema,
  t_CodeSecurityGetConfigurationsForOrgQuerySchema,
  t_CodeSecurityGetDefaultConfigurationsForEnterpriseParamSchema,
  t_CodeSecurityGetDefaultConfigurationsParamSchema,
  t_CodeSecurityGetRepositoriesForConfigurationParamSchema,
  t_CodeSecurityGetRepositoriesForConfigurationQuerySchema,
  t_CodeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema,
  t_CodeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema,
  t_CodeSecurityGetSingleConfigurationForEnterpriseParamSchema,
  t_CodeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema,
  t_CodeSecuritySetConfigurationAsDefaultForEnterpriseRequestBody,
  t_CodeSecuritySetConfigurationAsDefaultParamSchema,
  t_CodeSecuritySetConfigurationAsDefaultRequestBody,
  t_CodeSecurityUpdateConfigurationParamSchema,
  t_CodeSecurityUpdateConfigurationRequestBody,
  t_CodeSecurityUpdateEnterpriseConfigurationParamSchema,
  t_CodeSecurityUpdateEnterpriseConfigurationRequestBody,
  t_CodesOfConductGetConductCodeParamSchema,
  t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
  t_CodespacesAddSelectedRepoToOrgSecretParamSchema,
  t_CodespacesCheckPermissionsForDevcontainerParamSchema,
  t_CodespacesCheckPermissionsForDevcontainerQuerySchema,
  t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema,
  t_CodespacesCreateForAuthenticatedUserRequestBody,
  t_CodespacesCreateOrUpdateOrgSecretParamSchema,
  t_CodespacesCreateOrUpdateOrgSecretRequestBody,
  t_CodespacesCreateOrUpdateRepoSecretParamSchema,
  t_CodespacesCreateOrUpdateRepoSecretRequestBody,
  t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
  t_CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody,
  t_CodespacesCreateWithPrForAuthenticatedUserParamSchema,
  t_CodespacesCreateWithPrForAuthenticatedUserRequestBody,
  t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema,
  t_CodespacesCreateWithRepoForAuthenticatedUserRequestBody,
  t_CodespacesDeleteCodespacesAccessUsersParamSchema,
  t_CodespacesDeleteCodespacesAccessUsersRequestBody,
  t_CodespacesDeleteForAuthenticatedUserParamSchema,
  t_CodespacesDeleteFromOrganizationParamSchema,
  t_CodespacesDeleteOrgSecretParamSchema,
  t_CodespacesDeleteRepoSecretParamSchema,
  t_CodespacesDeleteSecretForAuthenticatedUserParamSchema,
  t_CodespacesExportForAuthenticatedUserParamSchema,
  t_CodespacesGetCodespacesForUserInOrgParamSchema,
  t_CodespacesGetCodespacesForUserInOrgQuerySchema,
  t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema,
  t_CodespacesGetForAuthenticatedUserParamSchema,
  t_CodespacesGetOrgPublicKeyParamSchema,
  t_CodespacesGetOrgSecretParamSchema,
  t_CodespacesGetRepoPublicKeyParamSchema,
  t_CodespacesGetRepoSecretParamSchema,
  t_CodespacesGetSecretForAuthenticatedUserParamSchema,
  t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
  t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
  t_CodespacesListForAuthenticatedUserQuerySchema,
  t_CodespacesListInOrganizationParamSchema,
  t_CodespacesListInOrganizationQuerySchema,
  t_CodespacesListInRepositoryForAuthenticatedUserParamSchema,
  t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema,
  t_CodespacesListOrgSecretsParamSchema,
  t_CodespacesListOrgSecretsQuerySchema,
  t_CodespacesListRepoSecretsParamSchema,
  t_CodespacesListRepoSecretsQuerySchema,
  t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
  t_CodespacesListSecretsForAuthenticatedUserQuerySchema,
  t_CodespacesListSelectedReposForOrgSecretParamSchema,
  t_CodespacesListSelectedReposForOrgSecretQuerySchema,
  t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
  t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
  t_CodespacesPublishForAuthenticatedUserParamSchema,
  t_CodespacesPublishForAuthenticatedUserRequestBody,
  t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
  t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema,
  t_CodespacesRepoMachinesForAuthenticatedUserParamSchema,
  t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema,
  t_CodespacesSetCodespacesAccessParamSchema,
  t_CodespacesSetCodespacesAccessRequestBody,
  t_CodespacesSetCodespacesAccessUsersParamSchema,
  t_CodespacesSetCodespacesAccessUsersRequestBody,
  t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
  t_CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody,
  t_CodespacesSetSelectedReposForOrgSecretParamSchema,
  t_CodespacesSetSelectedReposForOrgSecretRequestBody,
  t_CodespacesStartForAuthenticatedUserParamSchema,
  t_CodespacesStopForAuthenticatedUserParamSchema,
  t_CodespacesStopInOrganizationParamSchema,
  t_CodespacesUpdateForAuthenticatedUserParamSchema,
  t_CodespacesUpdateForAuthenticatedUserRequestBody,
  t_CopilotAddCopilotSeatsForTeamsParamSchema,
  t_CopilotAddCopilotSeatsForTeamsRequestBody,
  t_CopilotAddCopilotSeatsForUsersParamSchema,
  t_CopilotAddCopilotSeatsForUsersRequestBody,
  t_CopilotCancelCopilotSeatAssignmentForTeamsParamSchema,
  t_CopilotCancelCopilotSeatAssignmentForTeamsRequestBody,
  t_CopilotCancelCopilotSeatAssignmentForUsersParamSchema,
  t_CopilotCancelCopilotSeatAssignmentForUsersRequestBody,
  t_CopilotCopilotMetricsForOrganizationParamSchema,
  t_CopilotCopilotMetricsForOrganizationQuerySchema,
  t_CopilotCopilotMetricsForTeamParamSchema,
  t_CopilotCopilotMetricsForTeamQuerySchema,
  t_CopilotGetCopilotOrganizationDetailsParamSchema,
  t_CopilotGetCopilotSeatDetailsForUserParamSchema,
  t_CopilotListCopilotSeatsParamSchema,
  t_CopilotListCopilotSeatsQuerySchema,
  t_CredentialsRevokeRequestBody,
  t_campaign_summary,
  t_check_annotation,
  t_check_automated_security_fixes,
  t_check_run,
  t_check_suite,
  t_check_suite_preference,
  t_classroom,
  t_classroom_accepted_assignment,
  t_classroom_assignment,
  t_classroom_assignment_grade,
  t_clone_traffic,
  t_code_frequency_stat,
  t_code_of_conduct,
  t_code_scanning_alert,
  t_code_scanning_alert_instance,
  t_code_scanning_alert_items,
  t_code_scanning_analysis,
  t_code_scanning_analysis_deletion,
  t_code_scanning_autofix,
  t_code_scanning_autofix_commits,
  t_code_scanning_autofix_commits_response,
  t_code_scanning_codeql_database,
  t_code_scanning_default_setup,
  t_code_scanning_default_setup_update,
  t_code_scanning_default_setup_update_response,
  t_code_scanning_organization_alert_items,
  t_code_scanning_sarifs_receipt,
  t_code_scanning_sarifs_status,
  t_code_scanning_variant_analysis,
  t_code_scanning_variant_analysis_repo_task,
  t_code_search_result_item,
  t_code_security_configuration,
  t_code_security_configuration_for_repository,
  t_code_security_configuration_repositories,
  t_code_security_default_configurations,
  t_codeowners_errors,
  t_codespace,
  t_codespace_export_details,
  t_codespace_machine,
  t_codespace_with_full_repository,
  t_codespaces_org_secret,
  t_codespaces_permissions_check_for_devcontainer,
  t_codespaces_public_key,
  t_codespaces_secret,
  t_codespaces_user_public_key,
  t_collaborator,
  t_combined_billing_usage,
  t_combined_commit_status,
  t_commit,
  t_commit_activity,
  t_commit_comment,
  t_commit_comparison,
  t_commit_search_result_item,
  t_community_profile,
  t_content_directory,
  t_content_file,
  t_content_submodule,
  t_content_symlink,
  t_content_traffic,
  t_contributor,
  t_contributor_activity,
  t_copilot_organization_details,
  t_copilot_seat_details,
  t_copilot_usage_metrics_day,
  t_custom_deployment_rule_app,
  t_custom_property,
  t_custom_property_set_payload,
  t_custom_property_value,
  t_DependabotAddSelectedRepoToOrgSecretParamSchema,
  t_DependabotCreateOrUpdateOrgSecretParamSchema,
  t_DependabotCreateOrUpdateOrgSecretRequestBody,
  t_DependabotCreateOrUpdateRepoSecretParamSchema,
  t_DependabotCreateOrUpdateRepoSecretRequestBody,
  t_DependabotDeleteOrgSecretParamSchema,
  t_DependabotDeleteRepoSecretParamSchema,
  t_DependabotGetAlertParamSchema,
  t_DependabotGetOrgPublicKeyParamSchema,
  t_DependabotGetOrgSecretParamSchema,
  t_DependabotGetRepoPublicKeyParamSchema,
  t_DependabotGetRepoSecretParamSchema,
  t_DependabotListAlertsForEnterpriseParamSchema,
  t_DependabotListAlertsForEnterpriseQuerySchema,
  t_DependabotListAlertsForOrgParamSchema,
  t_DependabotListAlertsForOrgQuerySchema,
  t_DependabotListAlertsForRepoParamSchema,
  t_DependabotListAlertsForRepoQuerySchema,
  t_DependabotListOrgSecretsParamSchema,
  t_DependabotListOrgSecretsQuerySchema,
  t_DependabotListRepoSecretsParamSchema,
  t_DependabotListRepoSecretsQuerySchema,
  t_DependabotListSelectedReposForOrgSecretParamSchema,
  t_DependabotListSelectedReposForOrgSecretQuerySchema,
  t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema,
  t_DependabotRepositoryAccessForOrgParamSchema,
  t_DependabotRepositoryAccessForOrgQuerySchema,
  t_DependabotSetRepositoryAccessDefaultLevelParamSchema,
  t_DependabotSetRepositoryAccessDefaultLevelRequestBody,
  t_DependabotSetSelectedReposForOrgSecretParamSchema,
  t_DependabotSetSelectedReposForOrgSecretRequestBody,
  t_DependabotUpdateAlertParamSchema,
  t_DependabotUpdateAlertRequestBody,
  t_DependabotUpdateRepositoryAccessForOrgParamSchema,
  t_DependabotUpdateRepositoryAccessForOrgRequestBody,
  t_DependencyGraphCreateRepositorySnapshotParamSchema,
  t_DependencyGraphDiffRangeParamSchema,
  t_DependencyGraphDiffRangeQuerySchema,
  t_DependencyGraphExportSbomParamSchema,
  t_dependabot_alert,
  t_dependabot_alert_with_repository,
  t_dependabot_public_key,
  t_dependabot_repository_access_details,
  t_dependabot_secret,
  t_dependency_graph_diff,
  t_dependency_graph_spdx_sbom,
  t_deploy_key,
  t_deployment,
  t_deployment_branch_policy,
  t_deployment_branch_policy_name_pattern,
  t_deployment_branch_policy_name_pattern_with_type,
  t_deployment_protection_rule,
  t_deployment_status,
  t_diff_entry,
  t_email,
  t_empty_object,
  t_environment,
  t_environment_approvals,
  t_event,
  t_feed,
  t_file_commit,
  t_full_repository,
  t_GistsCheckIsStarredParamSchema,
  t_GistsCreateCommentParamSchema,
  t_GistsCreateCommentRequestBody,
  t_GistsCreateRequestBody,
  t_GistsDeleteCommentParamSchema,
  t_GistsDeleteParamSchema,
  t_GistsForkParamSchema,
  t_GistsGetCommentParamSchema,
  t_GistsGetParamSchema,
  t_GistsGetRevisionParamSchema,
  t_GistsListCommentsParamSchema,
  t_GistsListCommentsQuerySchema,
  t_GistsListCommitsParamSchema,
  t_GistsListCommitsQuerySchema,
  t_GistsListForksParamSchema,
  t_GistsListForksQuerySchema,
  t_GistsListForUserParamSchema,
  t_GistsListForUserQuerySchema,
  t_GistsListPublicQuerySchema,
  t_GistsListQuerySchema,
  t_GistsListStarredQuerySchema,
  t_GistsStarParamSchema,
  t_GistsUnstarParamSchema,
  t_GistsUpdateCommentParamSchema,
  t_GistsUpdateCommentRequestBody,
  t_GistsUpdateParamSchema,
  t_GistsUpdateRequestBody,
  t_GitCreateBlobParamSchema,
  t_GitCreateBlobRequestBody,
  t_GitCreateCommitParamSchema,
  t_GitCreateCommitRequestBody,
  t_GitCreateRefParamSchema,
  t_GitCreateRefRequestBody,
  t_GitCreateTagParamSchema,
  t_GitCreateTagRequestBody,
  t_GitCreateTreeParamSchema,
  t_GitCreateTreeRequestBody,
  t_GitDeleteRefParamSchema,
  t_GitGetBlobParamSchema,
  t_GitGetCommitParamSchema,
  t_GitGetRefParamSchema,
  t_GitGetTagParamSchema,
  t_GitGetTreeParamSchema,
  t_GitGetTreeQuerySchema,
  t_GitignoreGetTemplateParamSchema,
  t_GitListMatchingRefsParamSchema,
  t_GitUpdateRefParamSchema,
  t_GitUpdateRefRequestBody,
  t_gist_comment,
  t_gist_commit,
  t_gist_simple,
  t_git_commit,
  t_git_ref,
  t_git_tag,
  t_git_tree,
  t_gitignore_template,
  t_global_advisory,
  t_gpg_key,
  t_HostedComputeCreateNetworkConfigurationForOrgParamSchema,
  t_HostedComputeCreateNetworkConfigurationForOrgRequestBody,
  t_HostedComputeDeleteNetworkConfigurationFromOrgParamSchema,
  t_HostedComputeGetNetworkConfigurationForOrgParamSchema,
  t_HostedComputeGetNetworkSettingsForOrgParamSchema,
  t_HostedComputeListNetworkConfigurationsForOrgParamSchema,
  t_HostedComputeListNetworkConfigurationsForOrgQuerySchema,
  t_HostedComputeUpdateNetworkConfigurationForOrgParamSchema,
  t_HostedComputeUpdateNetworkConfigurationForOrgRequestBody,
  t_hook,
  t_hook_delivery,
  t_hook_delivery_item,
  t_hovercard,
  t_InteractionsGetRestrictionsForOrgParamSchema,
  t_InteractionsGetRestrictionsForRepoParamSchema,
  t_InteractionsRemoveRestrictionsForOrgParamSchema,
  t_InteractionsRemoveRestrictionsForRepoParamSchema,
  t_InteractionsSetRestrictionsForOrgParamSchema,
  t_InteractionsSetRestrictionsForRepoParamSchema,
  t_IssuesAddAssigneesParamSchema,
  t_IssuesAddAssigneesRequestBody,
  t_IssuesAddLabelsParamSchema,
  t_IssuesAddLabelsRequestBody,
  t_IssuesAddSubIssueParamSchema,
  t_IssuesAddSubIssueRequestBody,
  t_IssuesCheckUserCanBeAssignedParamSchema,
  t_IssuesCheckUserCanBeAssignedToIssueParamSchema,
  t_IssuesCreateCommentParamSchema,
  t_IssuesCreateCommentRequestBody,
  t_IssuesCreateLabelParamSchema,
  t_IssuesCreateLabelRequestBody,
  t_IssuesCreateMilestoneParamSchema,
  t_IssuesCreateMilestoneRequestBody,
  t_IssuesCreateParamSchema,
  t_IssuesCreateRequestBody,
  t_IssuesDeleteCommentParamSchema,
  t_IssuesDeleteLabelParamSchema,
  t_IssuesDeleteMilestoneParamSchema,
  t_IssuesGetCommentParamSchema,
  t_IssuesGetEventParamSchema,
  t_IssuesGetLabelParamSchema,
  t_IssuesGetMilestoneParamSchema,
  t_IssuesGetParamSchema,
  t_IssuesListAssigneesParamSchema,
  t_IssuesListAssigneesQuerySchema,
  t_IssuesListCommentsForRepoParamSchema,
  t_IssuesListCommentsForRepoQuerySchema,
  t_IssuesListCommentsParamSchema,
  t_IssuesListCommentsQuerySchema,
  t_IssuesListEventsForRepoParamSchema,
  t_IssuesListEventsForRepoQuerySchema,
  t_IssuesListEventsForTimelineParamSchema,
  t_IssuesListEventsForTimelineQuerySchema,
  t_IssuesListEventsParamSchema,
  t_IssuesListEventsQuerySchema,
  t_IssuesListForAuthenticatedUserQuerySchema,
  t_IssuesListForOrgParamSchema,
  t_IssuesListForOrgQuerySchema,
  t_IssuesListForRepoParamSchema,
  t_IssuesListForRepoQuerySchema,
  t_IssuesListLabelsForMilestoneParamSchema,
  t_IssuesListLabelsForMilestoneQuerySchema,
  t_IssuesListLabelsForRepoParamSchema,
  t_IssuesListLabelsForRepoQuerySchema,
  t_IssuesListLabelsOnIssueParamSchema,
  t_IssuesListLabelsOnIssueQuerySchema,
  t_IssuesListMilestonesParamSchema,
  t_IssuesListMilestonesQuerySchema,
  t_IssuesListQuerySchema,
  t_IssuesListSubIssuesParamSchema,
  t_IssuesListSubIssuesQuerySchema,
  t_IssuesLockParamSchema,
  t_IssuesLockRequestBody,
  t_IssuesRemoveAllLabelsParamSchema,
  t_IssuesRemoveAssigneesParamSchema,
  t_IssuesRemoveAssigneesRequestBody,
  t_IssuesRemoveLabelParamSchema,
  t_IssuesRemoveSubIssueParamSchema,
  t_IssuesRemoveSubIssueRequestBody,
  t_IssuesReprioritizeSubIssueParamSchema,
  t_IssuesReprioritizeSubIssueRequestBody,
  t_IssuesSetLabelsParamSchema,
  t_IssuesSetLabelsRequestBody,
  t_IssuesUnlockParamSchema,
  t_IssuesUpdateCommentParamSchema,
  t_IssuesUpdateCommentRequestBody,
  t_IssuesUpdateLabelParamSchema,
  t_IssuesUpdateLabelRequestBody,
  t_IssuesUpdateMilestoneParamSchema,
  t_IssuesUpdateMilestoneRequestBody,
  t_IssuesUpdateParamSchema,
  t_IssuesUpdateRequestBody,
  t_import,
  t_installation,
  t_installation_token,
  t_integration,
  t_integration_installation_request,
  t_interaction_limit,
  t_interaction_limit_response,
  t_issue,
  t_issue_comment,
  t_issue_event,
  t_issue_event_for_issue,
  t_issue_search_result_item,
  t_issue_type,
  t_job,
  t_key,
  t_key_simple,
  t_LicensesGetAllCommonlyUsedQuerySchema,
  t_LicensesGetForRepoParamSchema,
  t_LicensesGetForRepoQuerySchema,
  t_LicensesGetParamSchema,
  t_label,
  t_label_search_result_item,
  t_language,
  t_license,
  t_license_content,
  t_license_simple,
  t_MarkdownRenderRequestBody,
  t_MetaGetOctocatQuerySchema,
  t_MigrationsCancelImportParamSchema,
  t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema,
  t_MigrationsDeleteArchiveForOrgParamSchema,
  t_MigrationsDownloadArchiveForOrgParamSchema,
  t_MigrationsGetArchiveForAuthenticatedUserParamSchema,
  t_MigrationsGetCommitAuthorsParamSchema,
  t_MigrationsGetCommitAuthorsQuerySchema,
  t_MigrationsGetImportStatusParamSchema,
  t_MigrationsGetLargeFilesParamSchema,
  t_MigrationsGetStatusForAuthenticatedUserParamSchema,
  t_MigrationsGetStatusForAuthenticatedUserQuerySchema,
  t_MigrationsGetStatusForOrgParamSchema,
  t_MigrationsGetStatusForOrgQuerySchema,
  t_MigrationsListForAuthenticatedUserQuerySchema,
  t_MigrationsListForOrgParamSchema,
  t_MigrationsListForOrgQuerySchema,
  t_MigrationsListReposForAuthenticatedUserParamSchema,
  t_MigrationsListReposForAuthenticatedUserQuerySchema,
  t_MigrationsListReposForOrgParamSchema,
  t_MigrationsListReposForOrgQuerySchema,
  t_MigrationsMapCommitAuthorParamSchema,
  t_MigrationsMapCommitAuthorRequestBody,
  t_MigrationsSetLfsPreferenceParamSchema,
  t_MigrationsSetLfsPreferenceRequestBody,
  t_MigrationsStartForAuthenticatedUserRequestBody,
  t_MigrationsStartForOrgParamSchema,
  t_MigrationsStartForOrgRequestBody,
  t_MigrationsStartImportParamSchema,
  t_MigrationsStartImportRequestBody,
  t_MigrationsUnlockRepoForAuthenticatedUserParamSchema,
  t_MigrationsUnlockRepoForOrgParamSchema,
  t_MigrationsUpdateImportParamSchema,
  t_MigrationsUpdateImportRequestBody,
  t_marketplace_listing_plan,
  t_marketplace_purchase,
  t_merged_upstream,
  t_migration,
  t_milestone,
  t_minimal_repository,
  t_network_configuration,
  t_network_settings,
  t_OidcGetOidcCustomSubTemplateForOrgParamSchema,
  t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema,
  t_OrgsAddSecurityManagerTeamParamSchema,
  t_OrgsAssignTeamToOrgRoleParamSchema,
  t_OrgsAssignUserToOrgRoleParamSchema,
  t_OrgsBlockUserParamSchema,
  t_OrgsCancelInvitationParamSchema,
  t_OrgsCheckBlockedUserParamSchema,
  t_OrgsCheckMembershipForUserParamSchema,
  t_OrgsCheckPublicMembershipForUserParamSchema,
  t_OrgsConvertMemberToOutsideCollaboratorParamSchema,
  t_OrgsConvertMemberToOutsideCollaboratorRequestBody,
  t_OrgsCreateInvitationParamSchema,
  t_OrgsCreateInvitationRequestBody,
  t_OrgsCreateIssueTypeParamSchema,
  t_OrgsCreateOrUpdateCustomPropertiesParamSchema,
  t_OrgsCreateOrUpdateCustomPropertiesRequestBody,
  t_OrgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema,
  t_OrgsCreateOrUpdateCustomPropertiesValuesForReposRequestBody,
  t_OrgsCreateOrUpdateCustomPropertyParamSchema,
  t_OrgsCreateWebhookParamSchema,
  t_OrgsCreateWebhookRequestBody,
  t_OrgsDeleteAttestationsBulkParamSchema,
  t_OrgsDeleteAttestationsBulkRequestBody,
  t_OrgsDeleteAttestationsByIdParamSchema,
  t_OrgsDeleteAttestationsBySubjectDigestParamSchema,
  t_OrgsDeleteIssueTypeParamSchema,
  t_OrgsDeleteParamSchema,
  t_OrgsDeleteWebhookParamSchema,
  t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
  t_OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestBody,
  t_OrgsGetAllCustomPropertiesParamSchema,
  t_OrgsGetCustomPropertyParamSchema,
  t_OrgsGetMembershipForAuthenticatedUserParamSchema,
  t_OrgsGetMembershipForUserParamSchema,
  t_OrgsGetOrgRoleParamSchema,
  t_OrgsGetOrgRulesetHistoryParamSchema,
  t_OrgsGetOrgRulesetHistoryQuerySchema,
  t_OrgsGetOrgRulesetVersionParamSchema,
  t_OrgsGetParamSchema,
  t_OrgsGetWebhookConfigForOrgParamSchema,
  t_OrgsGetWebhookDeliveryParamSchema,
  t_OrgsGetWebhookParamSchema,
  t_OrgsListAppInstallationsParamSchema,
  t_OrgsListAppInstallationsQuerySchema,
  t_OrgsListAttestationsBulkParamSchema,
  t_OrgsListAttestationsBulkQuerySchema,
  t_OrgsListAttestationsBulkRequestBody,
  t_OrgsListAttestationsParamSchema,
  t_OrgsListAttestationsQuerySchema,
  t_OrgsListBlockedUsersParamSchema,
  t_OrgsListBlockedUsersQuerySchema,
  t_OrgsListCustomPropertiesValuesForReposParamSchema,
  t_OrgsListCustomPropertiesValuesForReposQuerySchema,
  t_OrgsListFailedInvitationsParamSchema,
  t_OrgsListFailedInvitationsQuerySchema,
  t_OrgsListForAuthenticatedUserQuerySchema,
  t_OrgsListForUserParamSchema,
  t_OrgsListForUserQuerySchema,
  t_OrgsListInvitationTeamsParamSchema,
  t_OrgsListInvitationTeamsQuerySchema,
  t_OrgsListIssueTypesParamSchema,
  t_OrgsListMembershipsForAuthenticatedUserQuerySchema,
  t_OrgsListMembersParamSchema,
  t_OrgsListMembersQuerySchema,
  t_OrgsListOrgRolesParamSchema,
  t_OrgsListOrgRoleTeamsParamSchema,
  t_OrgsListOrgRoleTeamsQuerySchema,
  t_OrgsListOrgRoleUsersParamSchema,
  t_OrgsListOrgRoleUsersQuerySchema,
  t_OrgsListOutsideCollaboratorsParamSchema,
  t_OrgsListOutsideCollaboratorsQuerySchema,
  t_OrgsListPatGrantRepositoriesParamSchema,
  t_OrgsListPatGrantRepositoriesQuerySchema,
  t_OrgsListPatGrantRequestRepositoriesParamSchema,
  t_OrgsListPatGrantRequestRepositoriesQuerySchema,
  t_OrgsListPatGrantRequestsParamSchema,
  t_OrgsListPatGrantRequestsQuerySchema,
  t_OrgsListPatGrantsParamSchema,
  t_OrgsListPatGrantsQuerySchema,
  t_OrgsListPendingInvitationsParamSchema,
  t_OrgsListPendingInvitationsQuerySchema,
  t_OrgsListPublicMembersParamSchema,
  t_OrgsListPublicMembersQuerySchema,
  t_OrgsListQuerySchema,
  t_OrgsListSecurityManagerTeamsParamSchema,
  t_OrgsListWebhookDeliveriesParamSchema,
  t_OrgsListWebhookDeliveriesQuerySchema,
  t_OrgsListWebhooksParamSchema,
  t_OrgsListWebhooksQuerySchema,
  t_OrgsPingWebhookParamSchema,
  t_OrgsRedeliverWebhookDeliveryParamSchema,
  t_OrgsRemoveCustomPropertyParamSchema,
  t_OrgsRemoveMemberParamSchema,
  t_OrgsRemoveMembershipForUserParamSchema,
  t_OrgsRemoveOutsideCollaboratorParamSchema,
  t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema,
  t_OrgsRemoveSecurityManagerTeamParamSchema,
  t_OrgsReviewPatGrantRequestParamSchema,
  t_OrgsReviewPatGrantRequestRequestBody,
  t_OrgsReviewPatGrantRequestsInBulkParamSchema,
  t_OrgsReviewPatGrantRequestsInBulkRequestBody,
  t_OrgsRevokeAllOrgRolesTeamParamSchema,
  t_OrgsRevokeAllOrgRolesUserParamSchema,
  t_OrgsRevokeOrgRoleTeamParamSchema,
  t_OrgsRevokeOrgRoleUserParamSchema,
  t_OrgsSetMembershipForUserParamSchema,
  t_OrgsSetMembershipForUserRequestBody,
  t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema,
  t_OrgsUnblockUserParamSchema,
  t_OrgsUpdateIssueTypeParamSchema,
  t_OrgsUpdateMembershipForAuthenticatedUserParamSchema,
  t_OrgsUpdateMembershipForAuthenticatedUserRequestBody,
  t_OrgsUpdateParamSchema,
  t_OrgsUpdatePatAccessesParamSchema,
  t_OrgsUpdatePatAccessesRequestBody,
  t_OrgsUpdatePatAccessParamSchema,
  t_OrgsUpdatePatAccessRequestBody,
  t_OrgsUpdateRequestBody,
  t_OrgsUpdateWebhookConfigForOrgParamSchema,
  t_OrgsUpdateWebhookConfigForOrgRequestBody,
  t_OrgsUpdateWebhookParamSchema,
  t_OrgsUpdateWebhookRequestBody,
  t_oidc_custom_sub,
  t_oidc_custom_sub_repo,
  t_org_hook,
  t_org_membership,
  t_org_private_registry_configuration,
  t_org_private_registry_configuration_with_selected_repositories,
  t_org_repo_custom_property_values,
  t_organization_actions_secret,
  t_organization_actions_variable,
  t_organization_create_issue_type,
  t_organization_dependabot_secret,
  t_organization_full,
  t_organization_invitation,
  t_organization_programmatic_access_grant,
  t_organization_programmatic_access_grant_request,
  t_organization_role,
  t_organization_secret_scanning_alert,
  t_organization_simple,
  t_organization_update_issue_type,
  t_PackagesDeletePackageForAuthenticatedUserParamSchema,
  t_PackagesDeletePackageForOrgParamSchema,
  t_PackagesDeletePackageForUserParamSchema,
  t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema,
  t_PackagesDeletePackageVersionForOrgParamSchema,
  t_PackagesDeletePackageVersionForUserParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
  t_PackagesGetPackageForAuthenticatedUserParamSchema,
  t_PackagesGetPackageForOrganizationParamSchema,
  t_PackagesGetPackageForUserParamSchema,
  t_PackagesGetPackageVersionForAuthenticatedUserParamSchema,
  t_PackagesGetPackageVersionForOrganizationParamSchema,
  t_PackagesGetPackageVersionForUserParamSchema,
  t_PackagesListDockerMigrationConflictingPackagesForOrganizationParamSchema,
  t_PackagesListDockerMigrationConflictingPackagesForUserParamSchema,
  t_PackagesListPackagesForAuthenticatedUserQuerySchema,
  t_PackagesListPackagesForOrganizationParamSchema,
  t_PackagesListPackagesForOrganizationQuerySchema,
  t_PackagesListPackagesForUserParamSchema,
  t_PackagesListPackagesForUserQuerySchema,
  t_PackagesRestorePackageForAuthenticatedUserParamSchema,
  t_PackagesRestorePackageForAuthenticatedUserQuerySchema,
  t_PackagesRestorePackageForOrgParamSchema,
  t_PackagesRestorePackageForOrgQuerySchema,
  t_PackagesRestorePackageForUserParamSchema,
  t_PackagesRestorePackageForUserQuerySchema,
  t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema,
  t_PackagesRestorePackageVersionForOrgParamSchema,
  t_PackagesRestorePackageVersionForUserParamSchema,
  t_PrivateRegistriesCreateOrgPrivateRegistryParamSchema,
  t_PrivateRegistriesCreateOrgPrivateRegistryRequestBody,
  t_PrivateRegistriesDeleteOrgPrivateRegistryParamSchema,
  t_PrivateRegistriesGetOrgPrivateRegistryParamSchema,
  t_PrivateRegistriesGetOrgPublicKeyParamSchema,
  t_PrivateRegistriesListOrgPrivateRegistriesParamSchema,
  t_PrivateRegistriesListOrgPrivateRegistriesQuerySchema,
  t_PrivateRegistriesUpdateOrgPrivateRegistryParamSchema,
  t_PrivateRegistriesUpdateOrgPrivateRegistryRequestBody,
  t_ProjectsClassicAddCollaboratorParamSchema,
  t_ProjectsClassicAddCollaboratorRequestBody,
  t_ProjectsClassicCreateCardParamSchema,
  t_ProjectsClassicCreateCardRequestBody,
  t_ProjectsClassicCreateColumnParamSchema,
  t_ProjectsClassicCreateColumnRequestBody,
  t_ProjectsClassicCreateForAuthenticatedUserRequestBody,
  t_ProjectsClassicCreateForOrgParamSchema,
  t_ProjectsClassicCreateForOrgRequestBody,
  t_ProjectsClassicCreateForRepoParamSchema,
  t_ProjectsClassicCreateForRepoRequestBody,
  t_ProjectsClassicDeleteCardParamSchema,
  t_ProjectsClassicDeleteColumnParamSchema,
  t_ProjectsClassicDeleteParamSchema,
  t_ProjectsClassicGetCardParamSchema,
  t_ProjectsClassicGetColumnParamSchema,
  t_ProjectsClassicGetParamSchema,
  t_ProjectsClassicGetPermissionForUserParamSchema,
  t_ProjectsClassicListCardsParamSchema,
  t_ProjectsClassicListCardsQuerySchema,
  t_ProjectsClassicListCollaboratorsParamSchema,
  t_ProjectsClassicListCollaboratorsQuerySchema,
  t_ProjectsClassicListColumnsParamSchema,
  t_ProjectsClassicListColumnsQuerySchema,
  t_ProjectsClassicListForOrgParamSchema,
  t_ProjectsClassicListForOrgQuerySchema,
  t_ProjectsClassicListForRepoParamSchema,
  t_ProjectsClassicListForRepoQuerySchema,
  t_ProjectsClassicListForUserParamSchema,
  t_ProjectsClassicListForUserQuerySchema,
  t_ProjectsClassicMoveCardParamSchema,
  t_ProjectsClassicMoveCardRequestBody,
  t_ProjectsClassicMoveColumnParamSchema,
  t_ProjectsClassicMoveColumnRequestBody,
  t_ProjectsClassicRemoveCollaboratorParamSchema,
  t_ProjectsClassicUpdateCardParamSchema,
  t_ProjectsClassicUpdateCardRequestBody,
  t_ProjectsClassicUpdateColumnParamSchema,
  t_ProjectsClassicUpdateColumnRequestBody,
  t_ProjectsClassicUpdateParamSchema,
  t_ProjectsClassicUpdateRequestBody,
  t_PullsCheckIfMergedParamSchema,
  t_PullsCreateParamSchema,
  t_PullsCreateReplyForReviewCommentParamSchema,
  t_PullsCreateReplyForReviewCommentRequestBody,
  t_PullsCreateRequestBody,
  t_PullsCreateReviewCommentParamSchema,
  t_PullsCreateReviewCommentRequestBody,
  t_PullsCreateReviewParamSchema,
  t_PullsCreateReviewRequestBody,
  t_PullsDeletePendingReviewParamSchema,
  t_PullsDeleteReviewCommentParamSchema,
  t_PullsDismissReviewParamSchema,
  t_PullsDismissReviewRequestBody,
  t_PullsGetParamSchema,
  t_PullsGetReviewCommentParamSchema,
  t_PullsGetReviewParamSchema,
  t_PullsListCommentsForReviewParamSchema,
  t_PullsListCommentsForReviewQuerySchema,
  t_PullsListCommitsParamSchema,
  t_PullsListCommitsQuerySchema,
  t_PullsListFilesParamSchema,
  t_PullsListFilesQuerySchema,
  t_PullsListParamSchema,
  t_PullsListQuerySchema,
  t_PullsListRequestedReviewersParamSchema,
  t_PullsListReviewCommentsForRepoParamSchema,
  t_PullsListReviewCommentsForRepoQuerySchema,
  t_PullsListReviewCommentsParamSchema,
  t_PullsListReviewCommentsQuerySchema,
  t_PullsListReviewsParamSchema,
  t_PullsListReviewsQuerySchema,
  t_PullsMergeParamSchema,
  t_PullsMergeRequestBody,
  t_PullsRemoveRequestedReviewersParamSchema,
  t_PullsRemoveRequestedReviewersRequestBody,
  t_PullsRequestReviewersParamSchema,
  t_PullsRequestReviewersRequestBody,
  t_PullsSubmitReviewParamSchema,
  t_PullsSubmitReviewRequestBody,
  t_PullsUpdateBranchParamSchema,
  t_PullsUpdateBranchRequestBody,
  t_PullsUpdateParamSchema,
  t_PullsUpdateRequestBody,
  t_PullsUpdateReviewCommentParamSchema,
  t_PullsUpdateReviewCommentRequestBody,
  t_PullsUpdateReviewParamSchema,
  t_PullsUpdateReviewRequestBody,
  t_package,
  t_package_version,
  t_packages_billing_usage,
  t_page,
  t_page_build,
  t_page_build_status,
  t_page_deployment,
  t_pages_deployment_status,
  t_pages_health_check,
  t_participation_stats,
  t_pending_deployment,
  t_porter_author,
  t_porter_large_file,
  t_private_user,
  t_private_vulnerability_report_create,
  t_project,
  t_project_card,
  t_project_collaborator_permission,
  t_project_column,
  t_protected_branch,
  t_protected_branch_admin_enforced,
  t_protected_branch_pull_request_review,
  t_public_user,
  t_pull_request,
  t_pull_request_merge_result,
  t_pull_request_review,
  t_pull_request_review_comment,
  t_pull_request_review_request,
  t_pull_request_simple,
  t_ReactionsCreateForCommitCommentParamSchema,
  t_ReactionsCreateForCommitCommentRequestBody,
  t_ReactionsCreateForIssueCommentParamSchema,
  t_ReactionsCreateForIssueCommentRequestBody,
  t_ReactionsCreateForIssueParamSchema,
  t_ReactionsCreateForIssueRequestBody,
  t_ReactionsCreateForPullRequestReviewCommentParamSchema,
  t_ReactionsCreateForPullRequestReviewCommentRequestBody,
  t_ReactionsCreateForReleaseParamSchema,
  t_ReactionsCreateForReleaseRequestBody,
  t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema,
  t_ReactionsCreateForTeamDiscussionCommentInOrgRequestBody,
  t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema,
  t_ReactionsCreateForTeamDiscussionCommentLegacyRequestBody,
  t_ReactionsCreateForTeamDiscussionInOrgParamSchema,
  t_ReactionsCreateForTeamDiscussionInOrgRequestBody,
  t_ReactionsCreateForTeamDiscussionLegacyParamSchema,
  t_ReactionsCreateForTeamDiscussionLegacyRequestBody,
  t_ReactionsDeleteForCommitCommentParamSchema,
  t_ReactionsDeleteForIssueCommentParamSchema,
  t_ReactionsDeleteForIssueParamSchema,
  t_ReactionsDeleteForPullRequestCommentParamSchema,
  t_ReactionsDeleteForReleaseParamSchema,
  t_ReactionsDeleteForTeamDiscussionCommentParamSchema,
  t_ReactionsDeleteForTeamDiscussionParamSchema,
  t_ReactionsListForCommitCommentParamSchema,
  t_ReactionsListForCommitCommentQuerySchema,
  t_ReactionsListForIssueCommentParamSchema,
  t_ReactionsListForIssueCommentQuerySchema,
  t_ReactionsListForIssueParamSchema,
  t_ReactionsListForIssueQuerySchema,
  t_ReactionsListForPullRequestReviewCommentParamSchema,
  t_ReactionsListForPullRequestReviewCommentQuerySchema,
  t_ReactionsListForReleaseParamSchema,
  t_ReactionsListForReleaseQuerySchema,
  t_ReactionsListForTeamDiscussionCommentInOrgParamSchema,
  t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema,
  t_ReactionsListForTeamDiscussionCommentLegacyParamSchema,
  t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema,
  t_ReactionsListForTeamDiscussionInOrgParamSchema,
  t_ReactionsListForTeamDiscussionInOrgQuerySchema,
  t_ReactionsListForTeamDiscussionLegacyParamSchema,
  t_ReactionsListForTeamDiscussionLegacyQuerySchema,
  t_ReposAcceptInvitationForAuthenticatedUserParamSchema,
  t_ReposAddAppAccessRestrictionsParamSchema,
  t_ReposAddAppAccessRestrictionsRequestBody,
  t_ReposAddCollaboratorParamSchema,
  t_ReposAddCollaboratorRequestBody,
  t_ReposAddStatusCheckContextsParamSchema,
  t_ReposAddStatusCheckContextsRequestBody,
  t_ReposAddTeamAccessRestrictionsParamSchema,
  t_ReposAddTeamAccessRestrictionsRequestBody,
  t_ReposAddUserAccessRestrictionsParamSchema,
  t_ReposAddUserAccessRestrictionsRequestBody,
  t_ReposCancelPagesDeploymentParamSchema,
  t_ReposCheckAutomatedSecurityFixesParamSchema,
  t_ReposCheckCollaboratorParamSchema,
  t_ReposCheckPrivateVulnerabilityReportingParamSchema,
  t_ReposCheckVulnerabilityAlertsParamSchema,
  t_ReposCodeownersErrorsParamSchema,
  t_ReposCodeownersErrorsQuerySchema,
  t_ReposCompareCommitsParamSchema,
  t_ReposCompareCommitsQuerySchema,
  t_ReposCreateAttestationParamSchema,
  t_ReposCreateAttestationRequestBody,
  t_ReposCreateAutolinkParamSchema,
  t_ReposCreateAutolinkRequestBody,
  t_ReposCreateCommitCommentParamSchema,
  t_ReposCreateCommitCommentRequestBody,
  t_ReposCreateCommitSignatureProtectionParamSchema,
  t_ReposCreateCommitStatusParamSchema,
  t_ReposCreateCommitStatusRequestBody,
  t_ReposCreateDeployKeyParamSchema,
  t_ReposCreateDeployKeyRequestBody,
  t_ReposCreateDeploymentBranchPolicyParamSchema,
  t_ReposCreateDeploymentParamSchema,
  t_ReposCreateDeploymentProtectionRuleParamSchema,
  t_ReposCreateDeploymentProtectionRuleRequestBody,
  t_ReposCreateDeploymentRequestBody,
  t_ReposCreateDeploymentStatusParamSchema,
  t_ReposCreateDeploymentStatusRequestBody,
  t_ReposCreateDispatchEventParamSchema,
  t_ReposCreateDispatchEventRequestBody,
  t_ReposCreateForAuthenticatedUserRequestBody,
  t_ReposCreateForkParamSchema,
  t_ReposCreateForkRequestBody,
  t_ReposCreateInOrgParamSchema,
  t_ReposCreateInOrgRequestBody,
  t_ReposCreateOrgRulesetParamSchema,
  t_ReposCreateOrgRulesetRequestBody,
  t_ReposCreateOrUpdateCustomPropertiesValuesParamSchema,
  t_ReposCreateOrUpdateCustomPropertiesValuesRequestBody,
  t_ReposCreateOrUpdateEnvironmentParamSchema,
  t_ReposCreateOrUpdateEnvironmentRequestBody,
  t_ReposCreateOrUpdateFileContentsParamSchema,
  t_ReposCreateOrUpdateFileContentsRequestBody,
  t_ReposCreatePagesDeploymentParamSchema,
  t_ReposCreatePagesDeploymentRequestBody,
  t_ReposCreatePagesSiteParamSchema,
  t_ReposCreatePagesSiteRequestBody,
  t_ReposCreateReleaseParamSchema,
  t_ReposCreateReleaseRequestBody,
  t_ReposCreateRepoRulesetParamSchema,
  t_ReposCreateRepoRulesetRequestBody,
  t_ReposCreateTagProtectionParamSchema,
  t_ReposCreateTagProtectionRequestBody,
  t_ReposCreateUsingTemplateParamSchema,
  t_ReposCreateUsingTemplateRequestBody,
  t_ReposCreateWebhookParamSchema,
  t_ReposCreateWebhookRequestBody,
  t_ReposDeclineInvitationForAuthenticatedUserParamSchema,
  t_ReposDeleteAccessRestrictionsParamSchema,
  t_ReposDeleteAdminBranchProtectionParamSchema,
  t_ReposDeleteAnEnvironmentParamSchema,
  t_ReposDeleteAutolinkParamSchema,
  t_ReposDeleteBranchProtectionParamSchema,
  t_ReposDeleteCommitCommentParamSchema,
  t_ReposDeleteCommitSignatureProtectionParamSchema,
  t_ReposDeleteDeployKeyParamSchema,
  t_ReposDeleteDeploymentBranchPolicyParamSchema,
  t_ReposDeleteDeploymentParamSchema,
  t_ReposDeleteFileParamSchema,
  t_ReposDeleteFileRequestBody,
  t_ReposDeleteInvitationParamSchema,
  t_ReposDeleteOrgRulesetParamSchema,
  t_ReposDeletePagesSiteParamSchema,
  t_ReposDeleteParamSchema,
  t_ReposDeletePullRequestReviewProtectionParamSchema,
  t_ReposDeleteReleaseAssetParamSchema,
  t_ReposDeleteReleaseParamSchema,
  t_ReposDeleteRepoRulesetParamSchema,
  t_ReposDeleteTagProtectionParamSchema,
  t_ReposDeleteWebhookParamSchema,
  t_ReposDisableAutomatedSecurityFixesParamSchema,
  t_ReposDisableDeploymentProtectionRuleParamSchema,
  t_ReposDisablePrivateVulnerabilityReportingParamSchema,
  t_ReposDisableVulnerabilityAlertsParamSchema,
  t_ReposDownloadTarballArchiveParamSchema,
  t_ReposDownloadZipballArchiveParamSchema,
  t_ReposEnableAutomatedSecurityFixesParamSchema,
  t_ReposEnablePrivateVulnerabilityReportingParamSchema,
  t_ReposEnableVulnerabilityAlertsParamSchema,
  t_ReposGenerateReleaseNotesParamSchema,
  t_ReposGenerateReleaseNotesRequestBody,
  t_ReposGetAccessRestrictionsParamSchema,
  t_ReposGetAdminBranchProtectionParamSchema,
  t_ReposGetAllDeploymentProtectionRulesParamSchema,
  t_ReposGetAllEnvironmentsParamSchema,
  t_ReposGetAllEnvironmentsQuerySchema,
  t_ReposGetAllStatusCheckContextsParamSchema,
  t_ReposGetAllTopicsParamSchema,
  t_ReposGetAllTopicsQuerySchema,
  t_ReposGetAppsWithAccessToProtectedBranchParamSchema,
  t_ReposGetAutolinkParamSchema,
  t_ReposGetBranchParamSchema,
  t_ReposGetBranchProtectionParamSchema,
  t_ReposGetBranchRulesParamSchema,
  t_ReposGetBranchRulesQuerySchema,
  t_ReposGetClonesParamSchema,
  t_ReposGetClonesQuerySchema,
  t_ReposGetCodeFrequencyStatsParamSchema,
  t_ReposGetCollaboratorPermissionLevelParamSchema,
  t_ReposGetCombinedStatusForRefParamSchema,
  t_ReposGetCombinedStatusForRefQuerySchema,
  t_ReposGetCommitActivityStatsParamSchema,
  t_ReposGetCommitCommentParamSchema,
  t_ReposGetCommitParamSchema,
  t_ReposGetCommitQuerySchema,
  t_ReposGetCommitSignatureProtectionParamSchema,
  t_ReposGetCommunityProfileMetricsParamSchema,
  t_ReposGetContentParamSchema,
  t_ReposGetContentQuerySchema,
  t_ReposGetContributorsStatsParamSchema,
  t_ReposGetCustomDeploymentProtectionRuleParamSchema,
  t_ReposGetCustomPropertiesValuesParamSchema,
  t_ReposGetDeployKeyParamSchema,
  t_ReposGetDeploymentBranchPolicyParamSchema,
  t_ReposGetDeploymentParamSchema,
  t_ReposGetDeploymentStatusParamSchema,
  t_ReposGetEnvironmentParamSchema,
  t_ReposGetLatestPagesBuildParamSchema,
  t_ReposGetLatestReleaseParamSchema,
  t_ReposGetOrgRuleSuiteParamSchema,
  t_ReposGetOrgRuleSuitesParamSchema,
  t_ReposGetOrgRuleSuitesQuerySchema,
  t_ReposGetOrgRulesetParamSchema,
  t_ReposGetOrgRulesetsParamSchema,
  t_ReposGetOrgRulesetsQuerySchema,
  t_ReposGetPagesBuildParamSchema,
  t_ReposGetPagesDeploymentParamSchema,
  t_ReposGetPagesHealthCheckParamSchema,
  t_ReposGetPagesParamSchema,
  t_ReposGetParamSchema,
  t_ReposGetParticipationStatsParamSchema,
  t_ReposGetPullRequestReviewProtectionParamSchema,
  t_ReposGetPunchCardStatsParamSchema,
  t_ReposGetReadmeInDirectoryParamSchema,
  t_ReposGetReadmeInDirectoryQuerySchema,
  t_ReposGetReadmeParamSchema,
  t_ReposGetReadmeQuerySchema,
  t_ReposGetReleaseAssetParamSchema,
  t_ReposGetReleaseByTagParamSchema,
  t_ReposGetReleaseParamSchema,
  t_ReposGetRepoRuleSuiteParamSchema,
  t_ReposGetRepoRuleSuitesParamSchema,
  t_ReposGetRepoRuleSuitesQuerySchema,
  t_ReposGetRepoRulesetHistoryParamSchema,
  t_ReposGetRepoRulesetHistoryQuerySchema,
  t_ReposGetRepoRulesetParamSchema,
  t_ReposGetRepoRulesetQuerySchema,
  t_ReposGetRepoRulesetsParamSchema,
  t_ReposGetRepoRulesetsQuerySchema,
  t_ReposGetRepoRulesetVersionParamSchema,
  t_ReposGetStatusChecksProtectionParamSchema,
  t_ReposGetTeamsWithAccessToProtectedBranchParamSchema,
  t_ReposGetTopPathsParamSchema,
  t_ReposGetTopReferrersParamSchema,
  t_ReposGetUsersWithAccessToProtectedBranchParamSchema,
  t_ReposGetViewsParamSchema,
  t_ReposGetViewsQuerySchema,
  t_ReposGetWebhookConfigForRepoParamSchema,
  t_ReposGetWebhookDeliveryParamSchema,
  t_ReposGetWebhookParamSchema,
  t_ReposListActivitiesParamSchema,
  t_ReposListActivitiesQuerySchema,
  t_ReposListAttestationsParamSchema,
  t_ReposListAttestationsQuerySchema,
  t_ReposListAutolinksParamSchema,
  t_ReposListBranchesForHeadCommitParamSchema,
  t_ReposListBranchesParamSchema,
  t_ReposListBranchesQuerySchema,
  t_ReposListCollaboratorsParamSchema,
  t_ReposListCollaboratorsQuerySchema,
  t_ReposListCommentsForCommitParamSchema,
  t_ReposListCommentsForCommitQuerySchema,
  t_ReposListCommitCommentsForRepoParamSchema,
  t_ReposListCommitCommentsForRepoQuerySchema,
  t_ReposListCommitStatusesForRefParamSchema,
  t_ReposListCommitStatusesForRefQuerySchema,
  t_ReposListCommitsParamSchema,
  t_ReposListCommitsQuerySchema,
  t_ReposListContributorsParamSchema,
  t_ReposListContributorsQuerySchema,
  t_ReposListCustomDeploymentRuleIntegrationsParamSchema,
  t_ReposListCustomDeploymentRuleIntegrationsQuerySchema,
  t_ReposListDeployKeysParamSchema,
  t_ReposListDeployKeysQuerySchema,
  t_ReposListDeploymentBranchPoliciesParamSchema,
  t_ReposListDeploymentBranchPoliciesQuerySchema,
  t_ReposListDeploymentStatusesParamSchema,
  t_ReposListDeploymentStatusesQuerySchema,
  t_ReposListDeploymentsParamSchema,
  t_ReposListDeploymentsQuerySchema,
  t_ReposListForAuthenticatedUserQuerySchema,
  t_ReposListForksParamSchema,
  t_ReposListForksQuerySchema,
  t_ReposListForOrgParamSchema,
  t_ReposListForOrgQuerySchema,
  t_ReposListForUserParamSchema,
  t_ReposListForUserQuerySchema,
  t_ReposListInvitationsForAuthenticatedUserQuerySchema,
  t_ReposListInvitationsParamSchema,
  t_ReposListInvitationsQuerySchema,
  t_ReposListLanguagesParamSchema,
  t_ReposListPagesBuildsParamSchema,
  t_ReposListPagesBuildsQuerySchema,
  t_ReposListPublicQuerySchema,
  t_ReposListPullRequestsAssociatedWithCommitParamSchema,
  t_ReposListPullRequestsAssociatedWithCommitQuerySchema,
  t_ReposListReleaseAssetsParamSchema,
  t_ReposListReleaseAssetsQuerySchema,
  t_ReposListReleasesParamSchema,
  t_ReposListReleasesQuerySchema,
  t_ReposListTagProtectionParamSchema,
  t_ReposListTagsParamSchema,
  t_ReposListTagsQuerySchema,
  t_ReposListTeamsParamSchema,
  t_ReposListTeamsQuerySchema,
  t_ReposListWebhookDeliveriesParamSchema,
  t_ReposListWebhookDeliveriesQuerySchema,
  t_ReposListWebhooksParamSchema,
  t_ReposListWebhooksQuerySchema,
  t_ReposMergeParamSchema,
  t_ReposMergeRequestBody,
  t_ReposMergeUpstreamParamSchema,
  t_ReposMergeUpstreamRequestBody,
  t_ReposPingWebhookParamSchema,
  t_ReposRedeliverWebhookDeliveryParamSchema,
  t_ReposRemoveAppAccessRestrictionsParamSchema,
  t_ReposRemoveAppAccessRestrictionsRequestBody,
  t_ReposRemoveCollaboratorParamSchema,
  t_ReposRemoveStatusCheckContextsParamSchema,
  t_ReposRemoveStatusCheckContextsRequestBody,
  t_ReposRemoveStatusCheckProtectionParamSchema,
  t_ReposRemoveTeamAccessRestrictionsParamSchema,
  t_ReposRemoveTeamAccessRestrictionsRequestBody,
  t_ReposRemoveUserAccessRestrictionsParamSchema,
  t_ReposRemoveUserAccessRestrictionsRequestBody,
  t_ReposRenameBranchParamSchema,
  t_ReposRenameBranchRequestBody,
  t_ReposReplaceAllTopicsParamSchema,
  t_ReposReplaceAllTopicsRequestBody,
  t_ReposRequestPagesBuildParamSchema,
  t_ReposSetAdminBranchProtectionParamSchema,
  t_ReposSetAppAccessRestrictionsParamSchema,
  t_ReposSetAppAccessRestrictionsRequestBody,
  t_ReposSetStatusCheckContextsParamSchema,
  t_ReposSetStatusCheckContextsRequestBody,
  t_ReposSetTeamAccessRestrictionsParamSchema,
  t_ReposSetTeamAccessRestrictionsRequestBody,
  t_ReposSetUserAccessRestrictionsParamSchema,
  t_ReposSetUserAccessRestrictionsRequestBody,
  t_ReposTestPushWebhookParamSchema,
  t_ReposTransferParamSchema,
  t_ReposTransferRequestBody,
  t_ReposUpdateBranchProtectionParamSchema,
  t_ReposUpdateBranchProtectionRequestBody,
  t_ReposUpdateCommitCommentParamSchema,
  t_ReposUpdateCommitCommentRequestBody,
  t_ReposUpdateDeploymentBranchPolicyParamSchema,
  t_ReposUpdateInformationAboutPagesSiteParamSchema,
  t_ReposUpdateInformationAboutPagesSiteRequestBody,
  t_ReposUpdateInvitationParamSchema,
  t_ReposUpdateInvitationRequestBody,
  t_ReposUpdateOrgRulesetParamSchema,
  t_ReposUpdateOrgRulesetRequestBody,
  t_ReposUpdateParamSchema,
  t_ReposUpdatePullRequestReviewProtectionParamSchema,
  t_ReposUpdatePullRequestReviewProtectionRequestBody,
  t_ReposUpdateReleaseAssetParamSchema,
  t_ReposUpdateReleaseAssetRequestBody,
  t_ReposUpdateReleaseParamSchema,
  t_ReposUpdateReleaseRequestBody,
  t_ReposUpdateRepoRulesetParamSchema,
  t_ReposUpdateRepoRulesetRequestBody,
  t_ReposUpdateRequestBody,
  t_ReposUpdateStatusCheckProtectionParamSchema,
  t_ReposUpdateStatusCheckProtectionRequestBody,
  t_ReposUpdateWebhookConfigForRepoParamSchema,
  t_ReposUpdateWebhookConfigForRepoRequestBody,
  t_ReposUpdateWebhookParamSchema,
  t_ReposUpdateWebhookRequestBody,
  t_ReposUploadReleaseAssetParamSchema,
  t_ReposUploadReleaseAssetQuerySchema,
  t_rate_limit_overview,
  t_reaction,
  t_referrer_traffic,
  t_release,
  t_release_asset,
  t_release_notes_content,
  t_repo_codespaces_secret,
  t_repo_search_result_item,
  t_repository,
  t_repository_advisory,
  t_repository_advisory_create,
  t_repository_advisory_update,
  t_repository_collaborator_permission,
  t_repository_invitation,
  t_repository_rule_detailed,
  t_repository_rule_violation_error,
  t_repository_ruleset,
  t_repository_subscription,
  t_review_comment,
  t_root,
  t_rule_suite,
  t_rule_suites,
  t_ruleset_version,
  t_ruleset_version_with_state,
  t_runner,
  t_runner_application,
  t_runner_groups_org,
  t_runner_label,
  t_SearchCodeQuerySchema,
  t_SearchCommitsQuerySchema,
  t_SearchIssuesAndPullRequestsQuerySchema,
  t_SearchLabelsQuerySchema,
  t_SearchReposQuerySchema,
  t_SearchTopicsQuerySchema,
  t_SearchUsersQuerySchema,
  t_SecretScanningCreatePushProtectionBypassParamSchema,
  t_SecretScanningCreatePushProtectionBypassRequestBody,
  t_SecretScanningGetAlertParamSchema,
  t_SecretScanningGetAlertQuerySchema,
  t_SecretScanningGetScanHistoryParamSchema,
  t_SecretScanningListAlertsForEnterpriseParamSchema,
  t_SecretScanningListAlertsForEnterpriseQuerySchema,
  t_SecretScanningListAlertsForOrgParamSchema,
  t_SecretScanningListAlertsForOrgQuerySchema,
  t_SecretScanningListAlertsForRepoParamSchema,
  t_SecretScanningListAlertsForRepoQuerySchema,
  t_SecretScanningListLocationsForAlertParamSchema,
  t_SecretScanningListLocationsForAlertQuerySchema,
  t_SecretScanningUpdateAlertParamSchema,
  t_SecretScanningUpdateAlertRequestBody,
  t_SecurityAdvisoriesCreateForkParamSchema,
  t_SecurityAdvisoriesCreatePrivateVulnerabilityReportParamSchema,
  t_SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema,
  t_SecurityAdvisoriesCreateRepositoryAdvisoryParamSchema,
  t_SecurityAdvisoriesGetGlobalAdvisoryParamSchema,
  t_SecurityAdvisoriesGetRepositoryAdvisoryParamSchema,
  t_SecurityAdvisoriesListGlobalAdvisoriesQuerySchema,
  t_SecurityAdvisoriesListOrgRepositoryAdvisoriesParamSchema,
  t_SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema,
  t_SecurityAdvisoriesListRepositoryAdvisoriesParamSchema,
  t_SecurityAdvisoriesListRepositoryAdvisoriesQuerySchema,
  t_SecurityAdvisoriesUpdateRepositoryAdvisoryParamSchema,
  t_scim_error,
  t_secret_scanning_alert,
  t_secret_scanning_location,
  t_secret_scanning_push_protection_bypass,
  t_secret_scanning_scan_history,
  t_selected_actions,
  t_short_blob,
  t_short_branch,
  t_simple_classroom,
  t_simple_classroom_assignment,
  t_simple_user,
  t_snapshot,
  t_social_account,
  t_ssh_signing_key,
  t_stargazer,
  t_starred_repository,
  t_status,
  t_status_check_policy,
  t_TeamsAddMemberLegacyParamSchema,
  t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema,
  t_TeamsAddOrUpdateMembershipForUserInOrgRequestBody,
  t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema,
  t_TeamsAddOrUpdateMembershipForUserLegacyRequestBody,
  t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema,
  t_TeamsAddOrUpdateProjectPermissionsInOrgRequestBody,
  t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema,
  t_TeamsAddOrUpdateProjectPermissionsLegacyRequestBody,
  t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema,
  t_TeamsAddOrUpdateRepoPermissionsInOrgRequestBody,
  t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema,
  t_TeamsAddOrUpdateRepoPermissionsLegacyRequestBody,
  t_TeamsCheckPermissionsForProjectInOrgParamSchema,
  t_TeamsCheckPermissionsForProjectLegacyParamSchema,
  t_TeamsCheckPermissionsForRepoInOrgParamSchema,
  t_TeamsCheckPermissionsForRepoLegacyParamSchema,
  t_TeamsCreateDiscussionCommentInOrgParamSchema,
  t_TeamsCreateDiscussionCommentInOrgRequestBody,
  t_TeamsCreateDiscussionCommentLegacyParamSchema,
  t_TeamsCreateDiscussionCommentLegacyRequestBody,
  t_TeamsCreateDiscussionInOrgParamSchema,
  t_TeamsCreateDiscussionInOrgRequestBody,
  t_TeamsCreateDiscussionLegacyParamSchema,
  t_TeamsCreateDiscussionLegacyRequestBody,
  t_TeamsCreateParamSchema,
  t_TeamsCreateRequestBody,
  t_TeamsDeleteDiscussionCommentInOrgParamSchema,
  t_TeamsDeleteDiscussionCommentLegacyParamSchema,
  t_TeamsDeleteDiscussionInOrgParamSchema,
  t_TeamsDeleteDiscussionLegacyParamSchema,
  t_TeamsDeleteInOrgParamSchema,
  t_TeamsDeleteLegacyParamSchema,
  t_TeamsGetByNameParamSchema,
  t_TeamsGetDiscussionCommentInOrgParamSchema,
  t_TeamsGetDiscussionCommentLegacyParamSchema,
  t_TeamsGetDiscussionInOrgParamSchema,
  t_TeamsGetDiscussionLegacyParamSchema,
  t_TeamsGetLegacyParamSchema,
  t_TeamsGetMemberLegacyParamSchema,
  t_TeamsGetMembershipForUserInOrgParamSchema,
  t_TeamsGetMembershipForUserLegacyParamSchema,
  t_TeamsListChildInOrgParamSchema,
  t_TeamsListChildInOrgQuerySchema,
  t_TeamsListChildLegacyParamSchema,
  t_TeamsListChildLegacyQuerySchema,
  t_TeamsListDiscussionCommentsInOrgParamSchema,
  t_TeamsListDiscussionCommentsInOrgQuerySchema,
  t_TeamsListDiscussionCommentsLegacyParamSchema,
  t_TeamsListDiscussionCommentsLegacyQuerySchema,
  t_TeamsListDiscussionsInOrgParamSchema,
  t_TeamsListDiscussionsInOrgQuerySchema,
  t_TeamsListDiscussionsLegacyParamSchema,
  t_TeamsListDiscussionsLegacyQuerySchema,
  t_TeamsListForAuthenticatedUserQuerySchema,
  t_TeamsListMembersInOrgParamSchema,
  t_TeamsListMembersInOrgQuerySchema,
  t_TeamsListMembersLegacyParamSchema,
  t_TeamsListMembersLegacyQuerySchema,
  t_TeamsListParamSchema,
  t_TeamsListPendingInvitationsInOrgParamSchema,
  t_TeamsListPendingInvitationsInOrgQuerySchema,
  t_TeamsListPendingInvitationsLegacyParamSchema,
  t_TeamsListPendingInvitationsLegacyQuerySchema,
  t_TeamsListProjectsInOrgParamSchema,
  t_TeamsListProjectsInOrgQuerySchema,
  t_TeamsListProjectsLegacyParamSchema,
  t_TeamsListProjectsLegacyQuerySchema,
  t_TeamsListQuerySchema,
  t_TeamsListReposInOrgParamSchema,
  t_TeamsListReposInOrgQuerySchema,
  t_TeamsListReposLegacyParamSchema,
  t_TeamsListReposLegacyQuerySchema,
  t_TeamsRemoveMemberLegacyParamSchema,
  t_TeamsRemoveMembershipForUserInOrgParamSchema,
  t_TeamsRemoveMembershipForUserLegacyParamSchema,
  t_TeamsRemoveProjectInOrgParamSchema,
  t_TeamsRemoveProjectLegacyParamSchema,
  t_TeamsRemoveRepoInOrgParamSchema,
  t_TeamsRemoveRepoLegacyParamSchema,
  t_TeamsUpdateDiscussionCommentInOrgParamSchema,
  t_TeamsUpdateDiscussionCommentInOrgRequestBody,
  t_TeamsUpdateDiscussionCommentLegacyParamSchema,
  t_TeamsUpdateDiscussionCommentLegacyRequestBody,
  t_TeamsUpdateDiscussionInOrgParamSchema,
  t_TeamsUpdateDiscussionInOrgRequestBody,
  t_TeamsUpdateDiscussionLegacyParamSchema,
  t_TeamsUpdateDiscussionLegacyRequestBody,
  t_TeamsUpdateInOrgParamSchema,
  t_TeamsUpdateInOrgRequestBody,
  t_TeamsUpdateLegacyParamSchema,
  t_TeamsUpdateLegacyRequestBody,
  t_tag,
  t_tag_protection,
  t_team,
  t_team_discussion,
  t_team_discussion_comment,
  t_team_full,
  t_team_membership,
  t_team_project,
  t_team_repository,
  t_team_role_assignment,
  t_team_simple,
  t_thread,
  t_thread_subscription,
  t_timeline_issue_events,
  t_topic,
  t_topic_search_result_item,
  t_UsersAddEmailForAuthenticatedUserRequestBody,
  t_UsersAddSocialAccountForAuthenticatedUserRequestBody,
  t_UsersBlockParamSchema,
  t_UsersCheckBlockedParamSchema,
  t_UsersCheckFollowingForUserParamSchema,
  t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema,
  t_UsersCreateGpgKeyForAuthenticatedUserRequestBody,
  t_UsersCreatePublicSshKeyForAuthenticatedUserRequestBody,
  t_UsersCreateSshSigningKeyForAuthenticatedUserRequestBody,
  t_UsersDeleteAttestationsBulkParamSchema,
  t_UsersDeleteAttestationsBulkRequestBody,
  t_UsersDeleteAttestationsByIdParamSchema,
  t_UsersDeleteAttestationsBySubjectDigestParamSchema,
  t_UsersDeleteEmailForAuthenticatedUserRequestBody,
  t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema,
  t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema,
  t_UsersDeleteSocialAccountForAuthenticatedUserRequestBody,
  t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
  t_UsersFollowParamSchema,
  t_UsersGetByIdParamSchema,
  t_UsersGetByUsernameParamSchema,
  t_UsersGetContextForUserParamSchema,
  t_UsersGetContextForUserQuerySchema,
  t_UsersGetGpgKeyForAuthenticatedUserParamSchema,
  t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema,
  t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema,
  t_UsersListAttestationsBulkParamSchema,
  t_UsersListAttestationsBulkQuerySchema,
  t_UsersListAttestationsBulkRequestBody,
  t_UsersListAttestationsParamSchema,
  t_UsersListAttestationsQuerySchema,
  t_UsersListBlockedByAuthenticatedUserQuerySchema,
  t_UsersListEmailsForAuthenticatedUserQuerySchema,
  t_UsersListFollowedByAuthenticatedUserQuerySchema,
  t_UsersListFollowersForAuthenticatedUserQuerySchema,
  t_UsersListFollowersForUserParamSchema,
  t_UsersListFollowersForUserQuerySchema,
  t_UsersListFollowingForUserParamSchema,
  t_UsersListFollowingForUserQuerySchema,
  t_UsersListGpgKeysForAuthenticatedUserQuerySchema,
  t_UsersListGpgKeysForUserParamSchema,
  t_UsersListGpgKeysForUserQuerySchema,
  t_UsersListPublicEmailsForAuthenticatedUserQuerySchema,
  t_UsersListPublicKeysForUserParamSchema,
  t_UsersListPublicKeysForUserQuerySchema,
  t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema,
  t_UsersListQuerySchema,
  t_UsersListSocialAccountsForAuthenticatedUserQuerySchema,
  t_UsersListSocialAccountsForUserParamSchema,
  t_UsersListSocialAccountsForUserQuerySchema,
  t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema,
  t_UsersListSshSigningKeysForUserParamSchema,
  t_UsersListSshSigningKeysForUserQuerySchema,
  t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody,
  t_UsersUnblockParamSchema,
  t_UsersUnfollowParamSchema,
  t_UsersUpdateAuthenticatedRequestBody,
  t_user_marketplace_purchase,
  t_user_role_assignment,
  t_user_search_result_item,
  t_validation_error,
  t_validation_error_simple,
  t_view_traffic,
  t_webhook_config,
  t_workflow,
  t_workflow_run,
  t_workflow_run_usage,
  t_workflow_usage,
} from "./models.ts"
import {
  PermissiveBoolean,
  s_ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody,
  s_ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody,
  s_ActionsCreateEnvironmentVariableRequestBody,
  s_ActionsCreateHostedRunnerForOrgRequestBody,
  s_ActionsCreateOrgVariableRequestBody,
  s_ActionsCreateOrUpdateEnvironmentSecretRequestBody,
  s_ActionsCreateOrUpdateOrgSecretRequestBody,
  s_ActionsCreateOrUpdateRepoSecretRequestBody,
  s_ActionsCreateRepoVariableRequestBody,
  s_ActionsCreateSelfHostedRunnerGroupForOrgRequestBody,
  s_ActionsCreateWorkflowDispatchRequestBody,
  s_ActionsGenerateRunnerJitconfigForOrgRequestBody,
  s_ActionsGenerateRunnerJitconfigForRepoRequestBody,
  s_ActionsReRunJobForWorkflowRunRequestBody,
  s_ActionsReRunWorkflowFailedJobsRequestBody,
  s_ActionsReRunWorkflowRequestBody,
  s_ActionsReviewCustomGatesForRunRequestBody,
  s_ActionsReviewPendingDeploymentsForRunRequestBody,
  s_ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody,
  s_ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody,
  s_ActionsSetCustomOidcSubClaimForRepoRequestBody,
  s_ActionsSetGithubActionsPermissionsOrganizationRequestBody,
  s_ActionsSetGithubActionsPermissionsRepositoryRequestBody,
  s_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody,
  s_ActionsSetSelectedReposForOrgSecretRequestBody,
  s_ActionsSetSelectedReposForOrgVariableRequestBody,
  s_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody,
  s_ActionsSetSelfHostedRunnersInGroupForOrgRequestBody,
  s_ActionsUpdateEnvironmentVariableRequestBody,
  s_ActionsUpdateHostedRunnerForOrgRequestBody,
  s_ActionsUpdateOrgVariableRequestBody,
  s_ActionsUpdateRepoVariableRequestBody,
  s_ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody,
  s_ActivityMarkNotificationsAsReadRequestBody,
  s_ActivityMarkRepoNotificationsAsReadRequestBody,
  s_ActivitySetRepoSubscriptionRequestBody,
  s_ActivitySetThreadSubscriptionRequestBody,
  s_AppsCheckTokenRequestBody,
  s_AppsCreateInstallationAccessTokenRequestBody,
  s_AppsDeleteAuthorizationRequestBody,
  s_AppsDeleteTokenRequestBody,
  s_AppsResetTokenRequestBody,
  s_AppsScopeTokenRequestBody,
  s_AppsUpdateWebhookConfigForAppRequestBody,
  s_actions_billing_usage,
  s_actions_cache_list,
  s_actions_cache_usage_by_repository,
  s_actions_cache_usage_org_enterprise,
  s_actions_get_default_workflow_permissions,
  s_actions_hosted_runner,
  s_actions_hosted_runner_image,
  s_actions_hosted_runner_limits,
  s_actions_hosted_runner_machine_spec,
  s_actions_organization_permissions,
  s_actions_public_key,
  s_actions_repository_permissions,
  s_actions_secret,
  s_actions_set_default_workflow_permissions,
  s_actions_variable,
  s_actions_workflow_access_to_repository,
  s_activity,
  s_alert_number,
  s_api_insights_route_stats,
  s_api_insights_subject_stats,
  s_api_insights_summary_stats,
  s_api_insights_time_stats,
  s_api_insights_user_stats,
  s_api_overview,
  s_artifact,
  s_authentication_token,
  s_authorization,
  s_autolink,
  s_base_gist,
  s_basic_error,
  s_billing_usage_report,
  s_billing_usage_report_user,
  s_blob,
  s_branch_protection,
  s_branch_restriction_policy,
  s_branch_short,
  s_branch_with_protection,
  s_CampaignsCreateCampaignRequestBody,
  s_CampaignsUpdateCampaignRequestBody,
  s_ChecksCreateRequestBody,
  s_ChecksCreateSuiteRequestBody,
  s_ChecksSetSuitesPreferencesRequestBody,
  s_ChecksUpdateRequestBody,
  s_CodeScanningCreateVariantAnalysisRequestBody,
  s_CodeScanningUpdateAlertRequestBody,
  s_CodeScanningUploadSarifRequestBody,
  s_CodeSecurityAttachConfigurationRequestBody,
  s_CodeSecurityAttachEnterpriseConfigurationRequestBody,
  s_CodeSecurityCreateConfigurationForEnterpriseRequestBody,
  s_CodeSecurityCreateConfigurationRequestBody,
  s_CodeSecurityDetachConfigurationRequestBody,
  s_CodeSecuritySetConfigurationAsDefaultForEnterpriseRequestBody,
  s_CodeSecuritySetConfigurationAsDefaultRequestBody,
  s_CodeSecurityUpdateConfigurationRequestBody,
  s_CodeSecurityUpdateEnterpriseConfigurationRequestBody,
  s_CodespacesCreateForAuthenticatedUserRequestBody,
  s_CodespacesCreateOrUpdateOrgSecretRequestBody,
  s_CodespacesCreateOrUpdateRepoSecretRequestBody,
  s_CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody,
  s_CodespacesCreateWithPrForAuthenticatedUserRequestBody,
  s_CodespacesCreateWithRepoForAuthenticatedUserRequestBody,
  s_CodespacesDeleteCodespacesAccessUsersRequestBody,
  s_CodespacesPublishForAuthenticatedUserRequestBody,
  s_CodespacesSetCodespacesAccessRequestBody,
  s_CodespacesSetCodespacesAccessUsersRequestBody,
  s_CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody,
  s_CodespacesSetSelectedReposForOrgSecretRequestBody,
  s_CodespacesUpdateForAuthenticatedUserRequestBody,
  s_CopilotAddCopilotSeatsForTeamsRequestBody,
  s_CopilotAddCopilotSeatsForUsersRequestBody,
  s_CopilotCancelCopilotSeatAssignmentForTeamsRequestBody,
  s_CopilotCancelCopilotSeatAssignmentForUsersRequestBody,
  s_CredentialsRevokeRequestBody,
  s_campaign_state,
  s_campaign_summary,
  s_check_annotation,
  s_check_automated_security_fixes,
  s_check_run,
  s_check_suite,
  s_check_suite_preference,
  s_classroom,
  s_classroom_accepted_assignment,
  s_classroom_assignment,
  s_classroom_assignment_grade,
  s_clone_traffic,
  s_code_frequency_stat,
  s_code_of_conduct,
  s_code_scanning_alert,
  s_code_scanning_alert_instance,
  s_code_scanning_alert_items,
  s_code_scanning_alert_severity,
  s_code_scanning_alert_state_query,
  s_code_scanning_analysis,
  s_code_scanning_analysis_deletion,
  s_code_scanning_analysis_sarif_id,
  s_code_scanning_analysis_tool_guid,
  s_code_scanning_analysis_tool_name,
  s_code_scanning_autofix,
  s_code_scanning_autofix_commits,
  s_code_scanning_autofix_commits_response,
  s_code_scanning_codeql_database,
  s_code_scanning_default_setup,
  s_code_scanning_default_setup_update,
  s_code_scanning_default_setup_update_response,
  s_code_scanning_organization_alert_items,
  s_code_scanning_ref,
  s_code_scanning_sarifs_receipt,
  s_code_scanning_sarifs_status,
  s_code_scanning_variant_analysis,
  s_code_scanning_variant_analysis_repo_task,
  s_code_search_result_item,
  s_code_security_configuration,
  s_code_security_configuration_for_repository,
  s_code_security_configuration_repositories,
  s_code_security_default_configurations,
  s_codeowners_errors,
  s_codespace,
  s_codespace_export_details,
  s_codespace_machine,
  s_codespace_with_full_repository,
  s_codespaces_org_secret,
  s_codespaces_permissions_check_for_devcontainer,
  s_codespaces_public_key,
  s_codespaces_secret,
  s_codespaces_user_public_key,
  s_collaborator,
  s_combined_billing_usage,
  s_combined_commit_status,
  s_commit,
  s_commit_activity,
  s_commit_comment,
  s_commit_comparison,
  s_commit_search_result_item,
  s_community_profile,
  s_content_directory,
  s_content_file,
  s_content_submodule,
  s_content_symlink,
  s_content_traffic,
  s_contributor,
  s_contributor_activity,
  s_copilot_organization_details,
  s_copilot_seat_details,
  s_copilot_usage_metrics_day,
  s_custom_deployment_rule_app,
  s_custom_property,
  s_custom_property_set_payload,
  s_custom_property_value,
  s_DependabotCreateOrUpdateOrgSecretRequestBody,
  s_DependabotCreateOrUpdateRepoSecretRequestBody,
  s_DependabotSetRepositoryAccessDefaultLevelRequestBody,
  s_DependabotSetSelectedReposForOrgSecretRequestBody,
  s_DependabotUpdateAlertRequestBody,
  s_DependabotUpdateRepositoryAccessForOrgRequestBody,
  s_dependabot_alert,
  s_dependabot_alert_with_repository,
  s_dependabot_public_key,
  s_dependabot_repository_access_details,
  s_dependabot_secret,
  s_dependency_graph_diff,
  s_dependency_graph_spdx_sbom,
  s_deploy_key,
  s_deployment,
  s_deployment_branch_policy,
  s_deployment_branch_policy_name_pattern,
  s_deployment_branch_policy_name_pattern_with_type,
  s_deployment_protection_rule,
  s_deployment_status,
  s_diff_entry,
  s_email,
  s_empty_object,
  s_environment,
  s_environment_approvals,
  s_event,
  s_feed,
  s_file_commit,
  s_full_repository,
  s_GistsCreateCommentRequestBody,
  s_GistsCreateRequestBody,
  s_GistsUpdateCommentRequestBody,
  s_GistsUpdateRequestBody,
  s_GitCreateBlobRequestBody,
  s_GitCreateCommitRequestBody,
  s_GitCreateRefRequestBody,
  s_GitCreateTagRequestBody,
  s_GitCreateTreeRequestBody,
  s_GitUpdateRefRequestBody,
  s_gist_comment,
  s_gist_commit,
  s_gist_simple,
  s_git_commit,
  s_git_ref,
  s_git_tag,
  s_git_tree,
  s_gitignore_template,
  s_global_advisory,
  s_gpg_key,
  s_HostedComputeCreateNetworkConfigurationForOrgRequestBody,
  s_HostedComputeUpdateNetworkConfigurationForOrgRequestBody,
  s_hook,
  s_hook_delivery,
  s_hook_delivery_item,
  s_hovercard,
  s_IssuesAddAssigneesRequestBody,
  s_IssuesAddLabelsRequestBody,
  s_IssuesAddSubIssueRequestBody,
  s_IssuesCreateCommentRequestBody,
  s_IssuesCreateLabelRequestBody,
  s_IssuesCreateMilestoneRequestBody,
  s_IssuesCreateRequestBody,
  s_IssuesLockRequestBody,
  s_IssuesRemoveAssigneesRequestBody,
  s_IssuesRemoveSubIssueRequestBody,
  s_IssuesReprioritizeSubIssueRequestBody,
  s_IssuesSetLabelsRequestBody,
  s_IssuesUpdateCommentRequestBody,
  s_IssuesUpdateLabelRequestBody,
  s_IssuesUpdateMilestoneRequestBody,
  s_IssuesUpdateRequestBody,
  s_import,
  s_installation,
  s_installation_token,
  s_integration,
  s_integration_installation_request,
  s_interaction_limit,
  s_interaction_limit_response,
  s_issue,
  s_issue_comment,
  s_issue_event,
  s_issue_event_for_issue,
  s_issue_search_result_item,
  s_issue_type,
  s_job,
  s_key,
  s_key_simple,
  s_label,
  s_label_search_result_item,
  s_language,
  s_license,
  s_license_content,
  s_license_simple,
  s_MarkdownRenderRequestBody,
  s_MigrationsMapCommitAuthorRequestBody,
  s_MigrationsSetLfsPreferenceRequestBody,
  s_MigrationsStartForAuthenticatedUserRequestBody,
  s_MigrationsStartForOrgRequestBody,
  s_MigrationsStartImportRequestBody,
  s_MigrationsUpdateImportRequestBody,
  s_marketplace_listing_plan,
  s_marketplace_purchase,
  s_merged_upstream,
  s_migration,
  s_milestone,
  s_minimal_repository,
  s_network_configuration,
  s_network_settings,
  s_OrgsConvertMemberToOutsideCollaboratorRequestBody,
  s_OrgsCreateInvitationRequestBody,
  s_OrgsCreateOrUpdateCustomPropertiesRequestBody,
  s_OrgsCreateOrUpdateCustomPropertiesValuesForReposRequestBody,
  s_OrgsCreateWebhookRequestBody,
  s_OrgsDeleteAttestationsBulkRequestBody,
  s_OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestBody,
  s_OrgsListAttestationsBulkRequestBody,
  s_OrgsReviewPatGrantRequestRequestBody,
  s_OrgsReviewPatGrantRequestsInBulkRequestBody,
  s_OrgsSetMembershipForUserRequestBody,
  s_OrgsUpdateMembershipForAuthenticatedUserRequestBody,
  s_OrgsUpdatePatAccessesRequestBody,
  s_OrgsUpdatePatAccessRequestBody,
  s_OrgsUpdateRequestBody,
  s_OrgsUpdateWebhookConfigForOrgRequestBody,
  s_OrgsUpdateWebhookRequestBody,
  s_oidc_custom_sub,
  s_oidc_custom_sub_repo,
  s_org_hook,
  s_org_membership,
  s_org_private_registry_configuration,
  s_org_private_registry_configuration_with_selected_repositories,
  s_org_repo_custom_property_values,
  s_organization_actions_secret,
  s_organization_actions_variable,
  s_organization_create_issue_type,
  s_organization_dependabot_secret,
  s_organization_full,
  s_organization_invitation,
  s_organization_programmatic_access_grant,
  s_organization_programmatic_access_grant_request,
  s_organization_role,
  s_organization_secret_scanning_alert,
  s_organization_simple,
  s_organization_update_issue_type,
  s_PrivateRegistriesCreateOrgPrivateRegistryRequestBody,
  s_PrivateRegistriesUpdateOrgPrivateRegistryRequestBody,
  s_ProjectsClassicAddCollaboratorRequestBody,
  s_ProjectsClassicCreateCardRequestBody,
  s_ProjectsClassicCreateColumnRequestBody,
  s_ProjectsClassicCreateForAuthenticatedUserRequestBody,
  s_ProjectsClassicCreateForOrgRequestBody,
  s_ProjectsClassicCreateForRepoRequestBody,
  s_ProjectsClassicMoveCardRequestBody,
  s_ProjectsClassicMoveColumnRequestBody,
  s_ProjectsClassicUpdateCardRequestBody,
  s_ProjectsClassicUpdateColumnRequestBody,
  s_ProjectsClassicUpdateRequestBody,
  s_PullsCreateReplyForReviewCommentRequestBody,
  s_PullsCreateRequestBody,
  s_PullsCreateReviewCommentRequestBody,
  s_PullsCreateReviewRequestBody,
  s_PullsDismissReviewRequestBody,
  s_PullsMergeRequestBody,
  s_PullsRemoveRequestedReviewersRequestBody,
  s_PullsRequestReviewersRequestBody,
  s_PullsSubmitReviewRequestBody,
  s_PullsUpdateBranchRequestBody,
  s_PullsUpdateRequestBody,
  s_PullsUpdateReviewCommentRequestBody,
  s_PullsUpdateReviewRequestBody,
  s_package,
  s_package_version,
  s_packages_billing_usage,
  s_page,
  s_page_build,
  s_page_build_status,
  s_page_deployment,
  s_pages_deployment_status,
  s_pages_health_check,
  s_participation_stats,
  s_pending_deployment,
  s_porter_author,
  s_porter_large_file,
  s_private_user,
  s_private_vulnerability_report_create,
  s_project,
  s_project_card,
  s_project_collaborator_permission,
  s_project_column,
  s_protected_branch,
  s_protected_branch_admin_enforced,
  s_protected_branch_pull_request_review,
  s_public_user,
  s_pull_request,
  s_pull_request_merge_result,
  s_pull_request_review,
  s_pull_request_review_comment,
  s_pull_request_review_request,
  s_pull_request_simple,
  s_ReactionsCreateForCommitCommentRequestBody,
  s_ReactionsCreateForIssueCommentRequestBody,
  s_ReactionsCreateForIssueRequestBody,
  s_ReactionsCreateForPullRequestReviewCommentRequestBody,
  s_ReactionsCreateForReleaseRequestBody,
  s_ReactionsCreateForTeamDiscussionCommentInOrgRequestBody,
  s_ReactionsCreateForTeamDiscussionCommentLegacyRequestBody,
  s_ReactionsCreateForTeamDiscussionInOrgRequestBody,
  s_ReactionsCreateForTeamDiscussionLegacyRequestBody,
  s_ReposAddAppAccessRestrictionsRequestBody,
  s_ReposAddCollaboratorRequestBody,
  s_ReposAddStatusCheckContextsRequestBody,
  s_ReposAddTeamAccessRestrictionsRequestBody,
  s_ReposAddUserAccessRestrictionsRequestBody,
  s_ReposCreateAttestationRequestBody,
  s_ReposCreateAutolinkRequestBody,
  s_ReposCreateCommitCommentRequestBody,
  s_ReposCreateCommitStatusRequestBody,
  s_ReposCreateDeployKeyRequestBody,
  s_ReposCreateDeploymentProtectionRuleRequestBody,
  s_ReposCreateDeploymentRequestBody,
  s_ReposCreateDeploymentStatusRequestBody,
  s_ReposCreateDispatchEventRequestBody,
  s_ReposCreateForAuthenticatedUserRequestBody,
  s_ReposCreateForkRequestBody,
  s_ReposCreateInOrgRequestBody,
  s_ReposCreateOrgRulesetRequestBody,
  s_ReposCreateOrUpdateCustomPropertiesValuesRequestBody,
  s_ReposCreateOrUpdateEnvironmentRequestBody,
  s_ReposCreateOrUpdateFileContentsRequestBody,
  s_ReposCreatePagesDeploymentRequestBody,
  s_ReposCreatePagesSiteRequestBody,
  s_ReposCreateReleaseRequestBody,
  s_ReposCreateRepoRulesetRequestBody,
  s_ReposCreateTagProtectionRequestBody,
  s_ReposCreateUsingTemplateRequestBody,
  s_ReposCreateWebhookRequestBody,
  s_ReposDeleteFileRequestBody,
  s_ReposGenerateReleaseNotesRequestBody,
  s_ReposMergeRequestBody,
  s_ReposMergeUpstreamRequestBody,
  s_ReposRemoveAppAccessRestrictionsRequestBody,
  s_ReposRemoveStatusCheckContextsRequestBody,
  s_ReposRemoveTeamAccessRestrictionsRequestBody,
  s_ReposRemoveUserAccessRestrictionsRequestBody,
  s_ReposRenameBranchRequestBody,
  s_ReposReplaceAllTopicsRequestBody,
  s_ReposSetAppAccessRestrictionsRequestBody,
  s_ReposSetStatusCheckContextsRequestBody,
  s_ReposSetTeamAccessRestrictionsRequestBody,
  s_ReposSetUserAccessRestrictionsRequestBody,
  s_ReposTransferRequestBody,
  s_ReposUpdateBranchProtectionRequestBody,
  s_ReposUpdateCommitCommentRequestBody,
  s_ReposUpdateInformationAboutPagesSiteRequestBody,
  s_ReposUpdateInvitationRequestBody,
  s_ReposUpdateOrgRulesetRequestBody,
  s_ReposUpdatePullRequestReviewProtectionRequestBody,
  s_ReposUpdateReleaseAssetRequestBody,
  s_ReposUpdateReleaseRequestBody,
  s_ReposUpdateRepoRulesetRequestBody,
  s_ReposUpdateRequestBody,
  s_ReposUpdateStatusCheckProtectionRequestBody,
  s_ReposUpdateWebhookConfigForRepoRequestBody,
  s_ReposUpdateWebhookRequestBody,
  s_rate_limit_overview,
  s_reaction,
  s_referrer_traffic,
  s_release,
  s_release_asset,
  s_release_notes_content,
  s_repo_codespaces_secret,
  s_repo_search_result_item,
  s_repository,
  s_repository_advisory,
  s_repository_advisory_create,
  s_repository_advisory_update,
  s_repository_collaborator_permission,
  s_repository_invitation,
  s_repository_rule_detailed,
  s_repository_rule_violation_error,
  s_repository_ruleset,
  s_repository_subscription,
  s_review_comment,
  s_root,
  s_rule_suite,
  s_rule_suites,
  s_ruleset_version,
  s_ruleset_version_with_state,
  s_runner,
  s_runner_application,
  s_runner_groups_org,
  s_runner_label,
  s_SecretScanningCreatePushProtectionBypassRequestBody,
  s_SecretScanningUpdateAlertRequestBody,
  s_scim_error,
  s_secret_scanning_alert,
  s_secret_scanning_location,
  s_secret_scanning_push_protection_bypass,
  s_secret_scanning_scan_history,
  s_security_advisory_ecosystems,
  s_selected_actions,
  s_short_blob,
  s_short_branch,
  s_simple_classroom,
  s_simple_classroom_assignment,
  s_simple_user,
  s_snapshot,
  s_social_account,
  s_ssh_signing_key,
  s_stargazer,
  s_starred_repository,
  s_status,
  s_status_check_policy,
  s_TeamsAddOrUpdateMembershipForUserInOrgRequestBody,
  s_TeamsAddOrUpdateMembershipForUserLegacyRequestBody,
  s_TeamsAddOrUpdateProjectPermissionsInOrgRequestBody,
  s_TeamsAddOrUpdateProjectPermissionsLegacyRequestBody,
  s_TeamsAddOrUpdateRepoPermissionsInOrgRequestBody,
  s_TeamsAddOrUpdateRepoPermissionsLegacyRequestBody,
  s_TeamsCreateDiscussionCommentInOrgRequestBody,
  s_TeamsCreateDiscussionCommentLegacyRequestBody,
  s_TeamsCreateDiscussionInOrgRequestBody,
  s_TeamsCreateDiscussionLegacyRequestBody,
  s_TeamsCreateRequestBody,
  s_TeamsUpdateDiscussionCommentInOrgRequestBody,
  s_TeamsUpdateDiscussionCommentLegacyRequestBody,
  s_TeamsUpdateDiscussionInOrgRequestBody,
  s_TeamsUpdateDiscussionLegacyRequestBody,
  s_TeamsUpdateInOrgRequestBody,
  s_TeamsUpdateLegacyRequestBody,
  s_tag,
  s_tag_protection,
  s_team,
  s_team_discussion,
  s_team_discussion_comment,
  s_team_full,
  s_team_membership,
  s_team_project,
  s_team_repository,
  s_team_role_assignment,
  s_team_simple,
  s_thread,
  s_thread_subscription,
  s_timeline_issue_events,
  s_topic,
  s_topic_search_result_item,
  s_UsersAddEmailForAuthenticatedUserRequestBody,
  s_UsersAddSocialAccountForAuthenticatedUserRequestBody,
  s_UsersCreateGpgKeyForAuthenticatedUserRequestBody,
  s_UsersCreatePublicSshKeyForAuthenticatedUserRequestBody,
  s_UsersCreateSshSigningKeyForAuthenticatedUserRequestBody,
  s_UsersDeleteAttestationsBulkRequestBody,
  s_UsersDeleteEmailForAuthenticatedUserRequestBody,
  s_UsersDeleteSocialAccountForAuthenticatedUserRequestBody,
  s_UsersListAttestationsBulkRequestBody,
  s_UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody,
  s_UsersUpdateAuthenticatedRequestBody,
  s_user_marketplace_purchase,
  s_user_role_assignment,
  s_user_search_result_item,
  s_validation_error,
  s_validation_error_simple,
  s_view_traffic,
  s_webhook_config,
  s_workflow,
  s_workflow_run,
  s_workflow_run_usage,
  s_workflow_usage,
} from "./schemas.ts"

export type MetaRootResponder = {
  with200(): ExpressRuntimeResponse<t_root>
} & ExpressRuntimeResponder

export type MetaRoot = (
  params: Params<void, void, void, void>,
  respond: MetaRootResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesListGlobalAdvisoriesResponder = {
  with200(): ExpressRuntimeResponse<t_global_advisory[]>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
  with429(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesListGlobalAdvisories = (
  params: Params<
    void,
    t_SecurityAdvisoriesListGlobalAdvisoriesQuerySchema,
    void,
    void
  >,
  respond: SecurityAdvisoriesListGlobalAdvisoriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesGetGlobalAdvisoryResponder = {
  with200(): ExpressRuntimeResponse<t_global_advisory>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesGetGlobalAdvisory = (
  params: Params<
    t_SecurityAdvisoriesGetGlobalAdvisoryParamSchema,
    void,
    void,
    void
  >,
  respond: SecurityAdvisoriesGetGlobalAdvisoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetAuthenticatedResponder = {
  with200(): ExpressRuntimeResponse<t_integration>
} & ExpressRuntimeResponder

export type AppsGetAuthenticated = (
  params: Params<void, void, void, void>,
  respond: AppsGetAuthenticatedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsCreateFromManifestResponder = {
  with201(): ExpressRuntimeResponse<
    t_integration & {
      client_id: string
      client_secret: string
      pem: string
      webhook_secret: string | null
      [key: string]: unknown | undefined
    }
  >
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type AppsCreateFromManifest = (
  params: Params<t_AppsCreateFromManifestParamSchema, void, void, void>,
  respond: AppsCreateFromManifestResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetWebhookConfigForAppResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_config>
} & ExpressRuntimeResponder

export type AppsGetWebhookConfigForApp = (
  params: Params<void, void, void, void>,
  respond: AppsGetWebhookConfigForAppResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsUpdateWebhookConfigForAppResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_config>
} & ExpressRuntimeResponder

export type AppsUpdateWebhookConfigForApp = (
  params: Params<void, void, t_AppsUpdateWebhookConfigForAppRequestBody, void>,
  respond: AppsUpdateWebhookConfigForAppResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListWebhookDeliveriesResponder = {
  with200(): ExpressRuntimeResponse<t_hook_delivery_item[]>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsListWebhookDeliveries = (
  params: Params<void, t_AppsListWebhookDeliveriesQuerySchema, void, void>,
  respond: AppsListWebhookDeliveriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetWebhookDeliveryResponder = {
  with200(): ExpressRuntimeResponse<t_hook_delivery>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsGetWebhookDelivery = (
  params: Params<t_AppsGetWebhookDeliveryParamSchema, void, void, void>,
  respond: AppsGetWebhookDeliveryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsRedeliverWebhookDeliveryResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsRedeliverWebhookDelivery = (
  params: Params<t_AppsRedeliverWebhookDeliveryParamSchema, void, void, void>,
  respond: AppsRedeliverWebhookDeliveryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListInstallationRequestsForAuthenticatedAppResponder = {
  with200(): ExpressRuntimeResponse<t_integration_installation_request[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListInstallationRequestsForAuthenticatedApp = (
  params: Params<
    void,
    t_AppsListInstallationRequestsForAuthenticatedAppQuerySchema,
    void,
    void
  >,
  respond: AppsListInstallationRequestsForAuthenticatedAppResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListInstallationsResponder = {
  with200(): ExpressRuntimeResponse<t_installation[]>
} & ExpressRuntimeResponder

export type AppsListInstallations = (
  params: Params<void, t_AppsListInstallationsQuerySchema, void, void>,
  respond: AppsListInstallationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetInstallationResponder = {
  with200(): ExpressRuntimeResponse<t_installation>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsGetInstallation = (
  params: Params<t_AppsGetInstallationParamSchema, void, void, void>,
  respond: AppsGetInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsDeleteInstallationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsDeleteInstallation = (
  params: Params<t_AppsDeleteInstallationParamSchema, void, void, void>,
  respond: AppsDeleteInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsCreateInstallationAccessTokenResponder = {
  with201(): ExpressRuntimeResponse<t_installation_token>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsCreateInstallationAccessToken = (
  params: Params<
    t_AppsCreateInstallationAccessTokenParamSchema,
    void,
    t_AppsCreateInstallationAccessTokenRequestBody | undefined,
    void
  >,
  respond: AppsCreateInstallationAccessTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsSuspendInstallationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsSuspendInstallation = (
  params: Params<t_AppsSuspendInstallationParamSchema, void, void, void>,
  respond: AppsSuspendInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsUnsuspendInstallationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsUnsuspendInstallation = (
  params: Params<t_AppsUnsuspendInstallationParamSchema, void, void, void>,
  respond: AppsUnsuspendInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsDeleteAuthorizationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsDeleteAuthorization = (
  params: Params<
    t_AppsDeleteAuthorizationParamSchema,
    void,
    t_AppsDeleteAuthorizationRequestBody,
    void
  >,
  respond: AppsDeleteAuthorizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsCheckTokenResponder = {
  with200(): ExpressRuntimeResponse<t_authorization>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsCheckToken = (
  params: Params<
    t_AppsCheckTokenParamSchema,
    void,
    t_AppsCheckTokenRequestBody,
    void
  >,
  respond: AppsCheckTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsResetTokenResponder = {
  with200(): ExpressRuntimeResponse<t_authorization>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsResetToken = (
  params: Params<
    t_AppsResetTokenParamSchema,
    void,
    t_AppsResetTokenRequestBody,
    void
  >,
  respond: AppsResetTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsDeleteTokenResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsDeleteToken = (
  params: Params<
    t_AppsDeleteTokenParamSchema,
    void,
    t_AppsDeleteTokenRequestBody,
    void
  >,
  respond: AppsDeleteTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsScopeTokenResponder = {
  with200(): ExpressRuntimeResponse<t_authorization>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsScopeToken = (
  params: Params<
    t_AppsScopeTokenParamSchema,
    void,
    t_AppsScopeTokenRequestBody,
    void
  >,
  respond: AppsScopeTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetBySlugResponder = {
  with200(): ExpressRuntimeResponse<t_integration>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsGetBySlug = (
  params: Params<t_AppsGetBySlugParamSchema, void, void, void>,
  respond: AppsGetBySlugResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ClassroomGetAnAssignmentResponder = {
  with200(): ExpressRuntimeResponse<t_classroom_assignment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ClassroomGetAnAssignment = (
  params: Params<t_ClassroomGetAnAssignmentParamSchema, void, void, void>,
  respond: ClassroomGetAnAssignmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ClassroomListAcceptedAssignmentsForAnAssignmentResponder = {
  with200(): ExpressRuntimeResponse<t_classroom_accepted_assignment[]>
} & ExpressRuntimeResponder

export type ClassroomListAcceptedAssignmentsForAnAssignment = (
  params: Params<
    t_ClassroomListAcceptedAssignmentsForAnAssignmentParamSchema,
    t_ClassroomListAcceptedAssignmentsForAnAssignmentQuerySchema,
    void,
    void
  >,
  respond: ClassroomListAcceptedAssignmentsForAnAssignmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ClassroomGetAssignmentGradesResponder = {
  with200(): ExpressRuntimeResponse<t_classroom_assignment_grade[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ClassroomGetAssignmentGrades = (
  params: Params<t_ClassroomGetAssignmentGradesParamSchema, void, void, void>,
  respond: ClassroomGetAssignmentGradesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ClassroomListClassroomsResponder = {
  with200(): ExpressRuntimeResponse<t_simple_classroom[]>
} & ExpressRuntimeResponder

export type ClassroomListClassrooms = (
  params: Params<void, t_ClassroomListClassroomsQuerySchema, void, void>,
  respond: ClassroomListClassroomsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ClassroomGetAClassroomResponder = {
  with200(): ExpressRuntimeResponse<t_classroom>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ClassroomGetAClassroom = (
  params: Params<t_ClassroomGetAClassroomParamSchema, void, void, void>,
  respond: ClassroomGetAClassroomResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ClassroomListAssignmentsForAClassroomResponder = {
  with200(): ExpressRuntimeResponse<t_simple_classroom_assignment[]>
} & ExpressRuntimeResponder

export type ClassroomListAssignmentsForAClassroom = (
  params: Params<
    t_ClassroomListAssignmentsForAClassroomParamSchema,
    t_ClassroomListAssignmentsForAClassroomQuerySchema,
    void,
    void
  >,
  respond: ClassroomListAssignmentsForAClassroomResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodesOfConductGetAllCodesOfConductResponder = {
  with200(): ExpressRuntimeResponse<t_code_of_conduct[]>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type CodesOfConductGetAllCodesOfConduct = (
  params: Params<void, void, void, void>,
  respond: CodesOfConductGetAllCodesOfConductResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodesOfConductGetConductCodeResponder = {
  with200(): ExpressRuntimeResponse<t_code_of_conduct>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodesOfConductGetConductCode = (
  params: Params<t_CodesOfConductGetConductCodeParamSchema, void, void, void>,
  respond: CodesOfConductGetConductCodeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CredentialsRevokeResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CredentialsRevoke = (
  params: Params<void, void, t_CredentialsRevokeRequestBody, void>,
  respond: CredentialsRevokeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type EmojisGetResponder = {
  with200(): ExpressRuntimeResponse<{
    [key: string]: string | undefined
  }>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type EmojisGet = (
  params: Params<void, void, void, void>,
  respond: EmojisGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetConfigurationsForEnterpriseResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_configuration[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetConfigurationsForEnterprise = (
  params: Params<
    t_CodeSecurityGetConfigurationsForEnterpriseParamSchema,
    t_CodeSecurityGetConfigurationsForEnterpriseQuerySchema,
    void,
    void
  >,
  respond: CodeSecurityGetConfigurationsForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityCreateConfigurationForEnterpriseResponder = {
  with201(): ExpressRuntimeResponse<t_code_security_configuration>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityCreateConfigurationForEnterprise = (
  params: Params<
    t_CodeSecurityCreateConfigurationForEnterpriseParamSchema,
    void,
    t_CodeSecurityCreateConfigurationForEnterpriseRequestBody,
    void
  >,
  respond: CodeSecurityCreateConfigurationForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetDefaultConfigurationsForEnterpriseResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_default_configurations>
} & ExpressRuntimeResponder

export type CodeSecurityGetDefaultConfigurationsForEnterprise = (
  params: Params<
    t_CodeSecurityGetDefaultConfigurationsForEnterpriseParamSchema,
    void,
    void,
    void
  >,
  respond: CodeSecurityGetDefaultConfigurationsForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetSingleConfigurationForEnterpriseResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_configuration>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetSingleConfigurationForEnterprise = (
  params: Params<
    t_CodeSecurityGetSingleConfigurationForEnterpriseParamSchema,
    void,
    void,
    void
  >,
  respond: CodeSecurityGetSingleConfigurationForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityUpdateEnterpriseConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_configuration>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityUpdateEnterpriseConfiguration = (
  params: Params<
    t_CodeSecurityUpdateEnterpriseConfigurationParamSchema,
    void,
    t_CodeSecurityUpdateEnterpriseConfigurationRequestBody,
    void
  >,
  respond: CodeSecurityUpdateEnterpriseConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityDeleteConfigurationForEnterpriseResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityDeleteConfigurationForEnterprise = (
  params: Params<
    t_CodeSecurityDeleteConfigurationForEnterpriseParamSchema,
    void,
    void,
    void
  >,
  respond: CodeSecurityDeleteConfigurationForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityAttachEnterpriseConfigurationResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityAttachEnterpriseConfiguration = (
  params: Params<
    t_CodeSecurityAttachEnterpriseConfigurationParamSchema,
    void,
    t_CodeSecurityAttachEnterpriseConfigurationRequestBody,
    void
  >,
  respond: CodeSecurityAttachEnterpriseConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecuritySetConfigurationAsDefaultForEnterpriseResponder = {
  with200(): ExpressRuntimeResponse<{
    configuration?: t_code_security_configuration | undefined
    default_for_new_repos?:
      | ("all" | "none" | "private_and_internal" | "public")
      | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecuritySetConfigurationAsDefaultForEnterprise = (
  params: Params<
    t_CodeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema,
    void,
    t_CodeSecuritySetConfigurationAsDefaultForEnterpriseRequestBody,
    void
  >,
  respond: CodeSecuritySetConfigurationAsDefaultForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetRepositoriesForEnterpriseConfigurationResponder = {
  with200(): ExpressRuntimeResponse<
    t_code_security_configuration_repositories[]
  >
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetRepositoriesForEnterpriseConfiguration = (
  params: Params<
    t_CodeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema,
    t_CodeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema,
    void,
    void
  >,
  respond: CodeSecurityGetRepositoriesForEnterpriseConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotListAlertsForEnterpriseResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_alert_with_repository[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type DependabotListAlertsForEnterprise = (
  params: Params<
    t_DependabotListAlertsForEnterpriseParamSchema,
    t_DependabotListAlertsForEnterpriseQuerySchema,
    void,
    void
  >,
  respond: DependabotListAlertsForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningListAlertsForEnterpriseResponder = {
  with200(): ExpressRuntimeResponse<t_organization_secret_scanning_alert[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningListAlertsForEnterprise = (
  params: Params<
    t_SecretScanningListAlertsForEnterpriseParamSchema,
    t_SecretScanningListAlertsForEnterpriseQuerySchema,
    void,
    void
  >,
  respond: SecretScanningListAlertsForEnterpriseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListPublicEventsResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type ActivityListPublicEvents = (
  params: Params<void, t_ActivityListPublicEventsQuerySchema, void, void>,
  respond: ActivityListPublicEventsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityGetFeedsResponder = {
  with200(): ExpressRuntimeResponse<t_feed>
} & ExpressRuntimeResponder

export type ActivityGetFeeds = (
  params: Params<void, void, void, void>,
  respond: ActivityGetFeedsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsListResponder = {
  with200(): ExpressRuntimeResponse<t_base_gist[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsList = (
  params: Params<void, t_GistsListQuerySchema, void, void>,
  respond: GistsListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsCreateResponder = {
  with201(): ExpressRuntimeResponse<t_gist_simple>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GistsCreate = (
  params: Params<void, void, t_GistsCreateRequestBody, void>,
  respond: GistsCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsListPublicResponder = {
  with200(): ExpressRuntimeResponse<t_base_gist[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GistsListPublic = (
  params: Params<void, t_GistsListPublicQuerySchema, void, void>,
  respond: GistsListPublicResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsListStarredResponder = {
  with200(): ExpressRuntimeResponse<t_base_gist[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsListStarred = (
  params: Params<void, t_GistsListStarredQuerySchema, void, void>,
  respond: GistsListStarredResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsGetResponder = {
  with200(): ExpressRuntimeResponse<t_gist_simple>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<{
    block?:
      | {
          created_at?: string | undefined
          html_url?: (string | null) | undefined
          reason?: string | undefined
        }
      | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsGet = (
  params: Params<t_GistsGetParamSchema, void, void, void>,
  respond: GistsGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_gist_simple>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GistsUpdate = (
  params: Params<
    t_GistsUpdateParamSchema,
    void,
    t_GistsUpdateRequestBody,
    void
  >,
  respond: GistsUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsDeleteResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsDelete = (
  params: Params<t_GistsDeleteParamSchema, void, void, void>,
  respond: GistsDeleteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsListCommentsResponder = {
  with200(): ExpressRuntimeResponse<t_gist_comment[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsListComments = (
  params: Params<
    t_GistsListCommentsParamSchema,
    t_GistsListCommentsQuerySchema,
    void,
    void
  >,
  respond: GistsListCommentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsCreateCommentResponder = {
  with201(): ExpressRuntimeResponse<t_gist_comment>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsCreateComment = (
  params: Params<
    t_GistsCreateCommentParamSchema,
    void,
    t_GistsCreateCommentRequestBody,
    void
  >,
  respond: GistsCreateCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsGetCommentResponder = {
  with200(): ExpressRuntimeResponse<t_gist_comment>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<{
    block?:
      | {
          created_at?: string | undefined
          html_url?: (string | null) | undefined
          reason?: string | undefined
        }
      | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsGetComment = (
  params: Params<t_GistsGetCommentParamSchema, void, void, void>,
  respond: GistsGetCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsUpdateCommentResponder = {
  with200(): ExpressRuntimeResponse<t_gist_comment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsUpdateComment = (
  params: Params<
    t_GistsUpdateCommentParamSchema,
    void,
    t_GistsUpdateCommentRequestBody,
    void
  >,
  respond: GistsUpdateCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsDeleteCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsDeleteComment = (
  params: Params<t_GistsDeleteCommentParamSchema, void, void, void>,
  respond: GistsDeleteCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsListCommitsResponder = {
  with200(): ExpressRuntimeResponse<t_gist_commit[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsListCommits = (
  params: Params<
    t_GistsListCommitsParamSchema,
    t_GistsListCommitsQuerySchema,
    void,
    void
  >,
  respond: GistsListCommitsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsListForksResponder = {
  with200(): ExpressRuntimeResponse<t_gist_simple[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsListForks = (
  params: Params<
    t_GistsListForksParamSchema,
    t_GistsListForksQuerySchema,
    void,
    void
  >,
  respond: GistsListForksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsForkResponder = {
  with201(): ExpressRuntimeResponse<t_base_gist>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GistsFork = (
  params: Params<t_GistsForkParamSchema, void, void, void>,
  respond: GistsForkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsCheckIsStarredResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<EmptyObject>
} & ExpressRuntimeResponder

export type GistsCheckIsStarred = (
  params: Params<t_GistsCheckIsStarredParamSchema, void, void, void>,
  respond: GistsCheckIsStarredResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsStarResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsStar = (
  params: Params<t_GistsStarParamSchema, void, void, void>,
  respond: GistsStarResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsUnstarResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GistsUnstar = (
  params: Params<t_GistsUnstarParamSchema, void, void, void>,
  respond: GistsUnstarResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsGetRevisionResponder = {
  with200(): ExpressRuntimeResponse<t_gist_simple>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GistsGetRevision = (
  params: Params<t_GistsGetRevisionParamSchema, void, void, void>,
  respond: GistsGetRevisionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitignoreGetAllTemplatesResponder = {
  with200(): ExpressRuntimeResponse<string[]>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type GitignoreGetAllTemplates = (
  params: Params<void, void, void, void>,
  respond: GitignoreGetAllTemplatesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitignoreGetTemplateResponder = {
  with200(): ExpressRuntimeResponse<t_gitignore_template>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type GitignoreGetTemplate = (
  params: Params<t_GitignoreGetTemplateParamSchema, void, void, void>,
  respond: GitignoreGetTemplateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListReposAccessibleToInstallationResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_repository[]
    repository_selection?: string | undefined
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListReposAccessibleToInstallation = (
  params: Params<
    void,
    t_AppsListReposAccessibleToInstallationQuerySchema,
    void,
    void
  >,
  respond: AppsListReposAccessibleToInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsRevokeInstallationAccessTokenResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type AppsRevokeInstallationAccessToken = (
  params: Params<void, void, void, void>,
  respond: AppsRevokeInstallationAccessTokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListResponder = {
  with200(): ExpressRuntimeResponse<t_issue[]>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesList = (
  params: Params<void, t_IssuesListQuerySchema, void, void>,
  respond: IssuesListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LicensesGetAllCommonlyUsedResponder = {
  with200(): ExpressRuntimeResponse<t_license_simple[]>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type LicensesGetAllCommonlyUsed = (
  params: Params<void, t_LicensesGetAllCommonlyUsedQuerySchema, void, void>,
  respond: LicensesGetAllCommonlyUsedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LicensesGetResponder = {
  with200(): ExpressRuntimeResponse<t_license>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type LicensesGet = (
  params: Params<t_LicensesGetParamSchema, void, void, void>,
  respond: LicensesGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MarkdownRenderResponder = {
  with200(): ExpressRuntimeResponse<string>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type MarkdownRender = (
  params: Params<void, void, t_MarkdownRenderRequestBody, void>,
  respond: MarkdownRenderResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MarkdownRenderRawResponder = {
  with200(): ExpressRuntimeResponse<string>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type MarkdownRenderRaw = (
  params: Params<void, void, string | undefined, void>,
  respond: MarkdownRenderRawResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetSubscriptionPlanForAccountResponder = {
  with200(): ExpressRuntimeResponse<t_marketplace_purchase>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsGetSubscriptionPlanForAccount = (
  params: Params<
    t_AppsGetSubscriptionPlanForAccountParamSchema,
    void,
    void,
    void
  >,
  respond: AppsGetSubscriptionPlanForAccountResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListPlansResponder = {
  with200(): ExpressRuntimeResponse<t_marketplace_listing_plan[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListPlans = (
  params: Params<void, t_AppsListPlansQuerySchema, void, void>,
  respond: AppsListPlansResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListAccountsForPlanResponder = {
  with200(): ExpressRuntimeResponse<t_marketplace_purchase[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type AppsListAccountsForPlan = (
  params: Params<
    t_AppsListAccountsForPlanParamSchema,
    t_AppsListAccountsForPlanQuerySchema,
    void,
    void
  >,
  respond: AppsListAccountsForPlanResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetSubscriptionPlanForAccountStubbedResponder = {
  with200(): ExpressRuntimeResponse<t_marketplace_purchase>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type AppsGetSubscriptionPlanForAccountStubbed = (
  params: Params<
    t_AppsGetSubscriptionPlanForAccountStubbedParamSchema,
    void,
    void,
    void
  >,
  respond: AppsGetSubscriptionPlanForAccountStubbedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListPlansStubbedResponder = {
  with200(): ExpressRuntimeResponse<t_marketplace_listing_plan[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListPlansStubbed = (
  params: Params<void, t_AppsListPlansStubbedQuerySchema, void, void>,
  respond: AppsListPlansStubbedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListAccountsForPlanStubbedResponder = {
  with200(): ExpressRuntimeResponse<t_marketplace_purchase[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListAccountsForPlanStubbed = (
  params: Params<
    t_AppsListAccountsForPlanStubbedParamSchema,
    t_AppsListAccountsForPlanStubbedQuerySchema,
    void,
    void
  >,
  respond: AppsListAccountsForPlanStubbedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MetaGetResponder = {
  with200(): ExpressRuntimeResponse<t_api_overview>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type MetaGet = (
  params: Params<void, void, void, void>,
  respond: MetaGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListPublicEventsForRepoNetworkResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityListPublicEventsForRepoNetwork = (
  params: Params<
    t_ActivityListPublicEventsForRepoNetworkParamSchema,
    t_ActivityListPublicEventsForRepoNetworkQuerySchema,
    void,
    void
  >,
  respond: ActivityListPublicEventsForRepoNetworkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListNotificationsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_thread[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ActivityListNotificationsForAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListNotificationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListNotificationsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityMarkNotificationsAsReadResponder = {
  with202(): ExpressRuntimeResponse<{
    message?: string | undefined
  }>
  with205(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityMarkNotificationsAsRead = (
  params: Params<
    void,
    void,
    t_ActivityMarkNotificationsAsReadRequestBody | undefined,
    void
  >,
  respond: ActivityMarkNotificationsAsReadResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityGetThreadResponder = {
  with200(): ExpressRuntimeResponse<t_thread>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityGetThread = (
  params: Params<t_ActivityGetThreadParamSchema, void, void, void>,
  respond: ActivityGetThreadResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityMarkThreadAsReadResponder = {
  with205(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityMarkThreadAsRead = (
  params: Params<t_ActivityMarkThreadAsReadParamSchema, void, void, void>,
  respond: ActivityMarkThreadAsReadResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityMarkThreadAsDoneResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActivityMarkThreadAsDone = (
  params: Params<t_ActivityMarkThreadAsDoneParamSchema, void, void, void>,
  respond: ActivityMarkThreadAsDoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityGetThreadSubscriptionForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_thread_subscription>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityGetThreadSubscriptionForAuthenticatedUser = (
  params: Params<
    t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: ActivityGetThreadSubscriptionForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivitySetThreadSubscriptionResponder = {
  with200(): ExpressRuntimeResponse<t_thread_subscription>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivitySetThreadSubscription = (
  params: Params<
    t_ActivitySetThreadSubscriptionParamSchema,
    void,
    t_ActivitySetThreadSubscriptionRequestBody | undefined,
    void
  >,
  respond: ActivitySetThreadSubscriptionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityDeleteThreadSubscriptionResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityDeleteThreadSubscription = (
  params: Params<
    t_ActivityDeleteThreadSubscriptionParamSchema,
    void,
    void,
    void
  >,
  respond: ActivityDeleteThreadSubscriptionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MetaGetOctocatResponder = {
  with200(): ExpressRuntimeResponse<string>
} & ExpressRuntimeResponder

export type MetaGetOctocat = (
  params: Params<void, t_MetaGetOctocatQuerySchema, void, void>,
  respond: MetaGetOctocatResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListResponder = {
  with200(): ExpressRuntimeResponse<t_organization_simple[]>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsList = (
  params: Params<void, t_OrgsListQuerySchema, void, void>,
  respond: OrgsListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotRepositoryAccessForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_repository_access_details>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type DependabotRepositoryAccessForOrg = (
  params: Params<
    t_DependabotRepositoryAccessForOrgParamSchema,
    t_DependabotRepositoryAccessForOrgQuerySchema,
    void,
    void
  >,
  respond: DependabotRepositoryAccessForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotUpdateRepositoryAccessForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type DependabotUpdateRepositoryAccessForOrg = (
  params: Params<
    t_DependabotUpdateRepositoryAccessForOrgParamSchema,
    void,
    t_DependabotUpdateRepositoryAccessForOrgRequestBody,
    void
  >,
  respond: DependabotUpdateRepositoryAccessForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotSetRepositoryAccessDefaultLevelResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type DependabotSetRepositoryAccessDefaultLevel = (
  params: Params<
    t_DependabotSetRepositoryAccessDefaultLevelParamSchema,
    void,
    t_DependabotSetRepositoryAccessDefaultLevelRequestBody,
    void
  >,
  respond: DependabotSetRepositoryAccessDefaultLevelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetGithubBillingUsageReportOrgResponder = {
  with200(): ExpressRuntimeResponse<t_billing_usage_report>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type BillingGetGithubBillingUsageReportOrg = (
  params: Params<
    t_BillingGetGithubBillingUsageReportOrgParamSchema,
    t_BillingGetGithubBillingUsageReportOrgQuerySchema,
    void,
    void
  >,
  respond: BillingGetGithubBillingUsageReportOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetResponder = {
  with200(): ExpressRuntimeResponse<t_organization_full>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGet = (
  params: Params<t_OrgsGetParamSchema, void, void, void>,
  respond: OrgsGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_organization_full>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<
    t_validation_error | t_validation_error_simple
  >
} & ExpressRuntimeResponder

export type OrgsUpdate = (
  params: Params<
    t_OrgsUpdateParamSchema,
    void,
    t_OrgsUpdateRequestBody | undefined,
    void
  >,
  respond: OrgsUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsDeleteResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsDelete = (
  params: Params<t_OrgsDeleteParamSchema, void, void, void>,
  respond: OrgsDeleteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetActionsCacheUsageForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_actions_cache_usage_org_enterprise>
} & ExpressRuntimeResponder

export type ActionsGetActionsCacheUsageForOrg = (
  params: Params<
    t_ActionsGetActionsCacheUsageForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetActionsCacheUsageForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetActionsCacheUsageByRepoForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    repository_cache_usages: t_actions_cache_usage_by_repository[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsGetActionsCacheUsageByRepoForOrg = (
  params: Params<
    t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema,
    t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema,
    void,
    void
  >,
  respond: ActionsGetActionsCacheUsageByRepoForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListHostedRunnersForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    runners: t_actions_hosted_runner[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListHostedRunnersForOrg = (
  params: Params<
    t_ActionsListHostedRunnersForOrgParamSchema,
    t_ActionsListHostedRunnersForOrgQuerySchema,
    void,
    void
  >,
  respond: ActionsListHostedRunnersForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateHostedRunnerForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_actions_hosted_runner>
} & ExpressRuntimeResponder

export type ActionsCreateHostedRunnerForOrg = (
  params: Params<
    t_ActionsCreateHostedRunnerForOrgParamSchema,
    void,
    t_ActionsCreateHostedRunnerForOrgRequestBody,
    void
  >,
  respond: ActionsCreateHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetHostedRunnersGithubOwnedImagesForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    images: t_actions_hosted_runner_image[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsGetHostedRunnersGithubOwnedImagesForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetHostedRunnersGithubOwnedImagesForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetHostedRunnersPartnerImagesForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    images: t_actions_hosted_runner_image[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsGetHostedRunnersPartnerImagesForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersPartnerImagesForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetHostedRunnersPartnerImagesForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetHostedRunnersLimitsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_actions_hosted_runner_limits>
} & ExpressRuntimeResponder

export type ActionsGetHostedRunnersLimitsForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersLimitsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetHostedRunnersLimitsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetHostedRunnersMachineSpecsForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    machine_specs: t_actions_hosted_runner_machine_spec[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsGetHostedRunnersMachineSpecsForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersMachineSpecsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetHostedRunnersMachineSpecsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetHostedRunnersPlatformsForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    platforms: string[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsGetHostedRunnersPlatformsForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersPlatformsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetHostedRunnersPlatformsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_actions_hosted_runner>
} & ExpressRuntimeResponder

export type ActionsGetHostedRunnerForOrg = (
  params: Params<t_ActionsGetHostedRunnerForOrgParamSchema, void, void, void>,
  respond: ActionsGetHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsUpdateHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_actions_hosted_runner>
} & ExpressRuntimeResponder

export type ActionsUpdateHostedRunnerForOrg = (
  params: Params<
    t_ActionsUpdateHostedRunnerForOrgParamSchema,
    void,
    t_ActionsUpdateHostedRunnerForOrgRequestBody,
    void
  >,
  respond: ActionsUpdateHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteHostedRunnerForOrgResponder = {
  with202(): ExpressRuntimeResponse<t_actions_hosted_runner>
} & ExpressRuntimeResponder

export type ActionsDeleteHostedRunnerForOrg = (
  params: Params<
    t_ActionsDeleteHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDeleteHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OidcGetOidcCustomSubTemplateForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_oidc_custom_sub>
} & ExpressRuntimeResponder

export type OidcGetOidcCustomSubTemplateForOrg = (
  params: Params<
    t_OidcGetOidcCustomSubTemplateForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: OidcGetOidcCustomSubTemplateForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OidcUpdateOidcCustomSubTemplateForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OidcUpdateOidcCustomSubTemplateForOrg = (
  params: Params<
    t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema,
    void,
    t_oidc_custom_sub,
    void
  >,
  respond: OidcUpdateOidcCustomSubTemplateForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetGithubActionsPermissionsOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_actions_organization_permissions>
} & ExpressRuntimeResponder

export type ActionsGetGithubActionsPermissionsOrganization = (
  params: Params<
    t_ActionsGetGithubActionsPermissionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetGithubActionsPermissionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetGithubActionsPermissionsOrganizationResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetGithubActionsPermissionsOrganization = (
  params: Params<
    t_ActionsSetGithubActionsPermissionsOrganizationParamSchema,
    void,
    t_ActionsSetGithubActionsPermissionsOrganizationRequestBody,
    void
  >,
  respond: ActionsSetGithubActionsPermissionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponder =
  {
    with200(): ExpressRuntimeResponse<{
      repositories: t_repository[]
      total_count: number
    }>
  } & ExpressRuntimeResponder

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganization = (
  params: Params<
    t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
    t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
    void,
    void
  >,
  respond: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponder =
  {
    with204(): ExpressRuntimeResponse<void>
  } & ExpressRuntimeResponder

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization = (
  params: Params<
    t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
    void,
    t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody,
    void
  >,
  respond: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationResponder =
  {
    with204(): ExpressRuntimeResponse<void>
  } & ExpressRuntimeResponder

export type ActionsEnableSelectedRepositoryGithubActionsOrganization = (
  params: Params<
    t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsEnableSelectedRepositoryGithubActionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationResponder =
  {
    with204(): ExpressRuntimeResponse<void>
  } & ExpressRuntimeResponder

export type ActionsDisableSelectedRepositoryGithubActionsOrganization = (
  params: Params<
    t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDisableSelectedRepositoryGithubActionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetAllowedActionsOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_selected_actions>
} & ExpressRuntimeResponder

export type ActionsGetAllowedActionsOrganization = (
  params: Params<
    t_ActionsGetAllowedActionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetAllowedActionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetAllowedActionsOrganizationResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetAllowedActionsOrganization = (
  params: Params<
    t_ActionsSetAllowedActionsOrganizationParamSchema,
    void,
    t_selected_actions | undefined,
    void
  >,
  respond: ActionsSetAllowedActionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponder =
  {
    with200(): ExpressRuntimeResponse<t_actions_get_default_workflow_permissions>
  } & ExpressRuntimeResponder

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization = (
  params: Params<
    t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponder =
  {
    with204(): ExpressRuntimeResponse<void>
  } & ExpressRuntimeResponder

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization = (
  params: Params<
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
    void,
    t_actions_set_default_workflow_permissions | undefined,
    void
  >,
  respond: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListSelfHostedRunnerGroupsForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    runner_groups: t_runner_groups_org[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListSelfHostedRunnerGroupsForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema,
    t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema,
    void,
    void
  >,
  respond: ActionsListSelfHostedRunnerGroupsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateSelfHostedRunnerGroupForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_runner_groups_org>
} & ExpressRuntimeResponder

export type ActionsCreateSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema,
    void,
    t_ActionsCreateSelfHostedRunnerGroupForOrgRequestBody,
    void
  >,
  respond: ActionsCreateSelfHostedRunnerGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetSelfHostedRunnerGroupForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_runner_groups_org>
} & ExpressRuntimeResponder

export type ActionsGetSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetSelfHostedRunnerGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsUpdateSelfHostedRunnerGroupForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_runner_groups_org>
} & ExpressRuntimeResponder

export type ActionsUpdateSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
    void,
    t_ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody,
    void
  >,
  respond: ActionsUpdateSelfHostedRunnerGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteSelfHostedRunnerGroupFromOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteSelfHostedRunnerGroupFromOrg = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDeleteSelfHostedRunnerGroupFromOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListGithubHostedRunnersInGroupForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    runners: t_actions_hosted_runner[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListGithubHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsListGithubHostedRunnersInGroupForOrgParamSchema,
    t_ActionsListGithubHostedRunnersInGroupForOrgQuerySchema,
    void,
    void
  >,
  respond: ActionsListGithubHostedRunnersInGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_minimal_repository[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
    void,
    void
  >,
  respond: ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody,
    void
  >,
  respond: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListSelfHostedRunnersInGroupForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    runners: t_runner[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListSelfHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema,
    t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema,
    void,
    void
  >,
  respond: ActionsListSelfHostedRunnersInGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetSelfHostedRunnersInGroupForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetSelfHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema,
    void,
    t_ActionsSetSelfHostedRunnersInGroupForOrgRequestBody,
    void
  >,
  respond: ActionsSetSelfHostedRunnersInGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsAddSelfHostedRunnerToGroupForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsAddSelfHostedRunnerToGroupForOrg = (
  params: Params<
    t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsAddSelfHostedRunnerToGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsRemoveSelfHostedRunnerFromGroupForOrg = (
  params: Params<
    t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveSelfHostedRunnerFromGroupForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListSelfHostedRunnersForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    runners: t_runner[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListSelfHostedRunnersForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnersForOrgParamSchema,
    t_ActionsListSelfHostedRunnersForOrgQuerySchema,
    void,
    void
  >,
  respond: ActionsListSelfHostedRunnersForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRunnerApplicationsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_runner_application[]>
} & ExpressRuntimeResponder

export type ActionsListRunnerApplicationsForOrg = (
  params: Params<
    t_ActionsListRunnerApplicationsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsListRunnerApplicationsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGenerateRunnerJitconfigForOrgResponder = {
  with201(): ExpressRuntimeResponse<{
    encoded_jit_config: string
    runner: t_runner
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsGenerateRunnerJitconfigForOrg = (
  params: Params<
    t_ActionsGenerateRunnerJitconfigForOrgParamSchema,
    void,
    t_ActionsGenerateRunnerJitconfigForOrgRequestBody,
    void
  >,
  respond: ActionsGenerateRunnerJitconfigForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateRegistrationTokenForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_authentication_token>
} & ExpressRuntimeResponder

export type ActionsCreateRegistrationTokenForOrg = (
  params: Params<
    t_ActionsCreateRegistrationTokenForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsCreateRegistrationTokenForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateRemoveTokenForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_authentication_token>
} & ExpressRuntimeResponder

export type ActionsCreateRemoveTokenForOrg = (
  params: Params<t_ActionsCreateRemoveTokenForOrgParamSchema, void, void, void>,
  respond: ActionsCreateRemoveTokenForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetSelfHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_runner>
} & ExpressRuntimeResponder

export type ActionsGetSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsGetSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetSelfHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteSelfHostedRunnerFromOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsDeleteSelfHostedRunnerFromOrg = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDeleteSelfHostedRunnerFromOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListLabelsForSelfHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsListLabelsForSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsListLabelsForSelfHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
    void,
    t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody,
    void
  >,
  respond: ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
    void,
    t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody,
    void
  >,
  respond: ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListOrgSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_organization_actions_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListOrgSecrets = (
  params: Params<
    t_ActionsListOrgSecretsParamSchema,
    t_ActionsListOrgSecretsQuerySchema,
    void,
    void
  >,
  respond: ActionsListOrgSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetOrgPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<t_actions_public_key>
} & ExpressRuntimeResponder

export type ActionsGetOrgPublicKey = (
  params: Params<t_ActionsGetOrgPublicKeyParamSchema, void, void, void>,
  respond: ActionsGetOrgPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetOrgSecretResponder = {
  with200(): ExpressRuntimeResponse<t_organization_actions_secret>
} & ExpressRuntimeResponder

export type ActionsGetOrgSecret = (
  params: Params<t_ActionsGetOrgSecretParamSchema, void, void, void>,
  respond: ActionsGetOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateOrUpdateOrgSecretResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsCreateOrUpdateOrgSecret = (
  params: Params<
    t_ActionsCreateOrUpdateOrgSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateOrgSecretRequestBody,
    void
  >,
  respond: ActionsCreateOrUpdateOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteOrgSecret = (
  params: Params<t_ActionsDeleteOrgSecretParamSchema, void, void, void>,
  respond: ActionsDeleteOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListSelectedReposForOrgSecretResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_minimal_repository[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListSelectedReposForOrgSecret = (
  params: Params<
    t_ActionsListSelectedReposForOrgSecretParamSchema,
    t_ActionsListSelectedReposForOrgSecretQuerySchema,
    void,
    void
  >,
  respond: ActionsListSelectedReposForOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetSelectedReposForOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetSelectedReposForOrgSecret = (
  params: Params<
    t_ActionsSetSelectedReposForOrgSecretParamSchema,
    void,
    t_ActionsSetSelectedReposForOrgSecretRequestBody,
    void
  >,
  respond: ActionsSetSelectedReposForOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsAddSelectedRepoToOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsAddSelectedRepoToOrgSecret = (
  params: Params<
    t_ActionsAddSelectedRepoToOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsAddSelectedRepoToOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveSelectedRepoFromOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveSelectedRepoFromOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListOrgVariablesResponder = {
  with200(): ExpressRuntimeResponse<{
    total_count: number
    variables: t_organization_actions_variable[]
  }>
} & ExpressRuntimeResponder

export type ActionsListOrgVariables = (
  params: Params<
    t_ActionsListOrgVariablesParamSchema,
    t_ActionsListOrgVariablesQuerySchema,
    void,
    void
  >,
  respond: ActionsListOrgVariablesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateOrgVariableResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
} & ExpressRuntimeResponder

export type ActionsCreateOrgVariable = (
  params: Params<
    t_ActionsCreateOrgVariableParamSchema,
    void,
    t_ActionsCreateOrgVariableRequestBody,
    void
  >,
  respond: ActionsCreateOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetOrgVariableResponder = {
  with200(): ExpressRuntimeResponse<t_organization_actions_variable>
} & ExpressRuntimeResponder

export type ActionsGetOrgVariable = (
  params: Params<t_ActionsGetOrgVariableParamSchema, void, void, void>,
  respond: ActionsGetOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsUpdateOrgVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsUpdateOrgVariable = (
  params: Params<
    t_ActionsUpdateOrgVariableParamSchema,
    void,
    t_ActionsUpdateOrgVariableRequestBody,
    void
  >,
  respond: ActionsUpdateOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteOrgVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteOrgVariable = (
  params: Params<t_ActionsDeleteOrgVariableParamSchema, void, void, void>,
  respond: ActionsDeleteOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListSelectedReposForOrgVariableResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_minimal_repository[]
    total_count: number
  }>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsListSelectedReposForOrgVariable = (
  params: Params<
    t_ActionsListSelectedReposForOrgVariableParamSchema,
    t_ActionsListSelectedReposForOrgVariableQuerySchema,
    void,
    void
  >,
  respond: ActionsListSelectedReposForOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetSelectedReposForOrgVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetSelectedReposForOrgVariable = (
  params: Params<
    t_ActionsSetSelectedReposForOrgVariableParamSchema,
    void,
    t_ActionsSetSelectedReposForOrgVariableRequestBody,
    void
  >,
  respond: ActionsSetSelectedReposForOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsAddSelectedRepoToOrgVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsAddSelectedRepoToOrgVariable = (
  params: Params<
    t_ActionsAddSelectedRepoToOrgVariableParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsAddSelectedRepoToOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveSelectedRepoFromOrgVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsRemoveSelectedRepoFromOrgVariable = (
  params: Params<
    t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveSelectedRepoFromOrgVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListAttestationsBulkResponder = {
  with200(): ExpressRuntimeResponse<{
    attestations_subject_digests?:
      | {
          [key: string]:
            | (
                | {
                    bundle?:
                      | {
                          dsseEnvelope?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                          mediaType?: string | undefined
                          verificationMaterial?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                        }
                      | undefined
                    bundle_url?: string | undefined
                    repository_id?: number | undefined
                  }[]
                | null
              )
            | undefined
        }
      | undefined
    page_info?:
      | {
          has_next?: boolean | undefined
          has_previous?: boolean | undefined
          next?: string | undefined
          previous?: string | undefined
        }
      | undefined
  }>
} & ExpressRuntimeResponder

export type OrgsListAttestationsBulk = (
  params: Params<
    t_OrgsListAttestationsBulkParamSchema,
    t_OrgsListAttestationsBulkQuerySchema,
    t_OrgsListAttestationsBulkRequestBody,
    void
  >,
  respond: OrgsListAttestationsBulkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsDeleteAttestationsBulkResponder = {
  with200(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsDeleteAttestationsBulk = (
  params: Params<
    t_OrgsDeleteAttestationsBulkParamSchema,
    void,
    t_OrgsDeleteAttestationsBulkRequestBody,
    void
  >,
  respond: OrgsDeleteAttestationsBulkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsDeleteAttestationsBySubjectDigestResponder = {
  with200(): ExpressRuntimeResponse<void>
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsDeleteAttestationsBySubjectDigest = (
  params: Params<
    t_OrgsDeleteAttestationsBySubjectDigestParamSchema,
    void,
    void,
    void
  >,
  respond: OrgsDeleteAttestationsBySubjectDigestResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsDeleteAttestationsByIdResponder = {
  with200(): ExpressRuntimeResponse<void>
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsDeleteAttestationsById = (
  params: Params<t_OrgsDeleteAttestationsByIdParamSchema, void, void, void>,
  respond: OrgsDeleteAttestationsByIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListAttestationsResponder = {
  with200(): ExpressRuntimeResponse<{
    attestations?:
      | {
          bundle?:
            | {
                dsseEnvelope?:
                  | {
                      [key: string]: unknown | undefined
                    }
                  | undefined
                mediaType?: string | undefined
                verificationMaterial?:
                  | {
                      [key: string]: unknown | undefined
                    }
                  | undefined
              }
            | undefined
          bundle_url?: string | undefined
          repository_id?: number | undefined
        }[]
      | undefined
  }>
} & ExpressRuntimeResponder

export type OrgsListAttestations = (
  params: Params<
    t_OrgsListAttestationsParamSchema,
    t_OrgsListAttestationsQuerySchema,
    void,
    void
  >,
  respond: OrgsListAttestationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListBlockedUsersResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
} & ExpressRuntimeResponder

export type OrgsListBlockedUsers = (
  params: Params<
    t_OrgsListBlockedUsersParamSchema,
    t_OrgsListBlockedUsersQuerySchema,
    void,
    void
  >,
  respond: OrgsListBlockedUsersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCheckBlockedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsCheckBlockedUser = (
  params: Params<t_OrgsCheckBlockedUserParamSchema, void, void, void>,
  respond: OrgsCheckBlockedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsBlockUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsBlockUser = (
  params: Params<t_OrgsBlockUserParamSchema, void, void, void>,
  respond: OrgsBlockUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUnblockUserResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsUnblockUser = (
  params: Params<t_OrgsUnblockUserParamSchema, void, void, void>,
  respond: OrgsUnblockUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CampaignsListOrgCampaignsResponder = {
  with200(): ExpressRuntimeResponse<t_campaign_summary[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CampaignsListOrgCampaigns = (
  params: Params<
    t_CampaignsListOrgCampaignsParamSchema,
    t_CampaignsListOrgCampaignsQuerySchema,
    void,
    void
  >,
  respond: CampaignsListOrgCampaignsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CampaignsCreateCampaignResponder = {
  with200(): ExpressRuntimeResponse<t_campaign_summary>
  with400(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with429(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CampaignsCreateCampaign = (
  params: Params<
    t_CampaignsCreateCampaignParamSchema,
    void,
    t_CampaignsCreateCampaignRequestBody,
    void
  >,
  respond: CampaignsCreateCampaignResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CampaignsGetCampaignSummaryResponder = {
  with200(): ExpressRuntimeResponse<t_campaign_summary>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CampaignsGetCampaignSummary = (
  params: Params<t_CampaignsGetCampaignSummaryParamSchema, void, void, void>,
  respond: CampaignsGetCampaignSummaryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CampaignsUpdateCampaignResponder = {
  with200(): ExpressRuntimeResponse<t_campaign_summary>
  with400(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CampaignsUpdateCampaign = (
  params: Params<
    t_CampaignsUpdateCampaignParamSchema,
    void,
    t_CampaignsUpdateCampaignRequestBody,
    void
  >,
  respond: CampaignsUpdateCampaignResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CampaignsDeleteCampaignResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CampaignsDeleteCampaign = (
  params: Params<t_CampaignsDeleteCampaignParamSchema, void, void, void>,
  respond: CampaignsDeleteCampaignResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningListAlertsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_organization_alert_items[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningListAlertsForOrg = (
  params: Params<
    t_CodeScanningListAlertsForOrgParamSchema,
    t_CodeScanningListAlertsForOrgQuerySchema,
    void,
    void
  >,
  respond: CodeScanningListAlertsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetConfigurationsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_configuration[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetConfigurationsForOrg = (
  params: Params<
    t_CodeSecurityGetConfigurationsForOrgParamSchema,
    t_CodeSecurityGetConfigurationsForOrgQuerySchema,
    void,
    void
  >,
  respond: CodeSecurityGetConfigurationsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityCreateConfigurationResponder = {
  with201(): ExpressRuntimeResponse<t_code_security_configuration>
} & ExpressRuntimeResponder

export type CodeSecurityCreateConfiguration = (
  params: Params<
    t_CodeSecurityCreateConfigurationParamSchema,
    void,
    t_CodeSecurityCreateConfigurationRequestBody,
    void
  >,
  respond: CodeSecurityCreateConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetDefaultConfigurationsResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_default_configurations>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetDefaultConfigurations = (
  params: Params<
    t_CodeSecurityGetDefaultConfigurationsParamSchema,
    void,
    void,
    void
  >,
  respond: CodeSecurityGetDefaultConfigurationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityDetachConfigurationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityDetachConfiguration = (
  params: Params<
    t_CodeSecurityDetachConfigurationParamSchema,
    void,
    t_CodeSecurityDetachConfigurationRequestBody,
    void
  >,
  respond: CodeSecurityDetachConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_configuration>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetConfiguration = (
  params: Params<t_CodeSecurityGetConfigurationParamSchema, void, void, void>,
  respond: CodeSecurityGetConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityUpdateConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_configuration>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type CodeSecurityUpdateConfiguration = (
  params: Params<
    t_CodeSecurityUpdateConfigurationParamSchema,
    void,
    t_CodeSecurityUpdateConfigurationRequestBody,
    void
  >,
  respond: CodeSecurityUpdateConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityDeleteConfigurationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityDeleteConfiguration = (
  params: Params<
    t_CodeSecurityDeleteConfigurationParamSchema,
    void,
    void,
    void
  >,
  respond: CodeSecurityDeleteConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityAttachConfigurationResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
} & ExpressRuntimeResponder

export type CodeSecurityAttachConfiguration = (
  params: Params<
    t_CodeSecurityAttachConfigurationParamSchema,
    void,
    t_CodeSecurityAttachConfigurationRequestBody,
    void
  >,
  respond: CodeSecurityAttachConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecuritySetConfigurationAsDefaultResponder = {
  with200(): ExpressRuntimeResponse<{
    configuration?: t_code_security_configuration | undefined
    default_for_new_repos?:
      | ("all" | "none" | "private_and_internal" | "public")
      | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecuritySetConfigurationAsDefault = (
  params: Params<
    t_CodeSecuritySetConfigurationAsDefaultParamSchema,
    void,
    t_CodeSecuritySetConfigurationAsDefaultRequestBody,
    void
  >,
  respond: CodeSecuritySetConfigurationAsDefaultResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetRepositoriesForConfigurationResponder = {
  with200(): ExpressRuntimeResponse<
    t_code_security_configuration_repositories[]
  >
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetRepositoriesForConfiguration = (
  params: Params<
    t_CodeSecurityGetRepositoriesForConfigurationParamSchema,
    t_CodeSecurityGetRepositoriesForConfigurationQuerySchema,
    void,
    void
  >,
  respond: CodeSecurityGetRepositoriesForConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListInOrganizationResponder = {
  with200(): ExpressRuntimeResponse<{
    codespaces: t_codespace[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesListInOrganization = (
  params: Params<
    t_CodespacesListInOrganizationParamSchema,
    t_CodespacesListInOrganizationQuerySchema,
    void,
    void
  >,
  respond: CodespacesListInOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesSetCodespacesAccessResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesSetCodespacesAccess = (
  params: Params<
    t_CodespacesSetCodespacesAccessParamSchema,
    void,
    t_CodespacesSetCodespacesAccessRequestBody,
    void
  >,
  respond: CodespacesSetCodespacesAccessResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesSetCodespacesAccessUsersResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesSetCodespacesAccessUsers = (
  params: Params<
    t_CodespacesSetCodespacesAccessUsersParamSchema,
    void,
    t_CodespacesSetCodespacesAccessUsersRequestBody,
    void
  >,
  respond: CodespacesSetCodespacesAccessUsersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesDeleteCodespacesAccessUsersResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesDeleteCodespacesAccessUsers = (
  params: Params<
    t_CodespacesDeleteCodespacesAccessUsersParamSchema,
    void,
    t_CodespacesDeleteCodespacesAccessUsersRequestBody,
    void
  >,
  respond: CodespacesDeleteCodespacesAccessUsersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListOrgSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_codespaces_org_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type CodespacesListOrgSecrets = (
  params: Params<
    t_CodespacesListOrgSecretsParamSchema,
    t_CodespacesListOrgSecretsQuerySchema,
    void,
    void
  >,
  respond: CodespacesListOrgSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetOrgPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<t_codespaces_public_key>
} & ExpressRuntimeResponder

export type CodespacesGetOrgPublicKey = (
  params: Params<t_CodespacesGetOrgPublicKeyParamSchema, void, void, void>,
  respond: CodespacesGetOrgPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetOrgSecretResponder = {
  with200(): ExpressRuntimeResponse<t_codespaces_org_secret>
} & ExpressRuntimeResponder

export type CodespacesGetOrgSecret = (
  params: Params<t_CodespacesGetOrgSecretParamSchema, void, void, void>,
  respond: CodespacesGetOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCreateOrUpdateOrgSecretResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type CodespacesCreateOrUpdateOrgSecret = (
  params: Params<
    t_CodespacesCreateOrUpdateOrgSecretParamSchema,
    void,
    t_CodespacesCreateOrUpdateOrgSecretRequestBody,
    void
  >,
  respond: CodespacesCreateOrUpdateOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesDeleteOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesDeleteOrgSecret = (
  params: Params<t_CodespacesDeleteOrgSecretParamSchema, void, void, void>,
  respond: CodespacesDeleteOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListSelectedReposForOrgSecretResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_minimal_repository[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesListSelectedReposForOrgSecret = (
  params: Params<
    t_CodespacesListSelectedReposForOrgSecretParamSchema,
    t_CodespacesListSelectedReposForOrgSecretQuerySchema,
    void,
    void
  >,
  respond: CodespacesListSelectedReposForOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesSetSelectedReposForOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type CodespacesSetSelectedReposForOrgSecret = (
  params: Params<
    t_CodespacesSetSelectedReposForOrgSecretParamSchema,
    void,
    t_CodespacesSetSelectedReposForOrgSecretRequestBody,
    void
  >,
  respond: CodespacesSetSelectedReposForOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesAddSelectedRepoToOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type CodespacesAddSelectedRepoToOrgSecret = (
  params: Params<
    t_CodespacesAddSelectedRepoToOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesAddSelectedRepoToOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesRemoveSelectedRepoFromOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type CodespacesRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesRemoveSelectedRepoFromOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotGetCopilotOrganizationDetailsResponder = {
  with200(): ExpressRuntimeResponse<t_copilot_organization_details>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotGetCopilotOrganizationDetails = (
  params: Params<
    t_CopilotGetCopilotOrganizationDetailsParamSchema,
    void,
    void,
    void
  >,
  respond: CopilotGetCopilotOrganizationDetailsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotListCopilotSeatsResponder = {
  with200(): ExpressRuntimeResponse<{
    seats?: t_copilot_seat_details[] | undefined
    total_seats?: number | undefined
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotListCopilotSeats = (
  params: Params<
    t_CopilotListCopilotSeatsParamSchema,
    t_CopilotListCopilotSeatsQuerySchema,
    void,
    void
  >,
  respond: CopilotListCopilotSeatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotAddCopilotSeatsForTeamsResponder = {
  with201(): ExpressRuntimeResponse<{
    seats_created: number
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotAddCopilotSeatsForTeams = (
  params: Params<
    t_CopilotAddCopilotSeatsForTeamsParamSchema,
    void,
    t_CopilotAddCopilotSeatsForTeamsRequestBody,
    void
  >,
  respond: CopilotAddCopilotSeatsForTeamsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotCancelCopilotSeatAssignmentForTeamsResponder = {
  with200(): ExpressRuntimeResponse<{
    seats_cancelled: number
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotCancelCopilotSeatAssignmentForTeams = (
  params: Params<
    t_CopilotCancelCopilotSeatAssignmentForTeamsParamSchema,
    void,
    t_CopilotCancelCopilotSeatAssignmentForTeamsRequestBody,
    void
  >,
  respond: CopilotCancelCopilotSeatAssignmentForTeamsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotAddCopilotSeatsForUsersResponder = {
  with201(): ExpressRuntimeResponse<{
    seats_created: number
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotAddCopilotSeatsForUsers = (
  params: Params<
    t_CopilotAddCopilotSeatsForUsersParamSchema,
    void,
    t_CopilotAddCopilotSeatsForUsersRequestBody,
    void
  >,
  respond: CopilotAddCopilotSeatsForUsersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotCancelCopilotSeatAssignmentForUsersResponder = {
  with200(): ExpressRuntimeResponse<{
    seats_cancelled: number
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotCancelCopilotSeatAssignmentForUsers = (
  params: Params<
    t_CopilotCancelCopilotSeatAssignmentForUsersParamSchema,
    void,
    t_CopilotCancelCopilotSeatAssignmentForUsersRequestBody,
    void
  >,
  respond: CopilotCancelCopilotSeatAssignmentForUsersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotCopilotMetricsForOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_copilot_usage_metrics_day[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotCopilotMetricsForOrganization = (
  params: Params<
    t_CopilotCopilotMetricsForOrganizationParamSchema,
    t_CopilotCopilotMetricsForOrganizationQuerySchema,
    void,
    void
  >,
  respond: CopilotCopilotMetricsForOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotListAlertsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_alert_with_repository[]>
  with304(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type DependabotListAlertsForOrg = (
  params: Params<
    t_DependabotListAlertsForOrgParamSchema,
    t_DependabotListAlertsForOrgQuerySchema,
    void,
    void
  >,
  respond: DependabotListAlertsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotListOrgSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_organization_dependabot_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type DependabotListOrgSecrets = (
  params: Params<
    t_DependabotListOrgSecretsParamSchema,
    t_DependabotListOrgSecretsQuerySchema,
    void,
    void
  >,
  respond: DependabotListOrgSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotGetOrgPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_public_key>
} & ExpressRuntimeResponder

export type DependabotGetOrgPublicKey = (
  params: Params<t_DependabotGetOrgPublicKeyParamSchema, void, void, void>,
  respond: DependabotGetOrgPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotGetOrgSecretResponder = {
  with200(): ExpressRuntimeResponse<t_organization_dependabot_secret>
} & ExpressRuntimeResponder

export type DependabotGetOrgSecret = (
  params: Params<t_DependabotGetOrgSecretParamSchema, void, void, void>,
  respond: DependabotGetOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotCreateOrUpdateOrgSecretResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DependabotCreateOrUpdateOrgSecret = (
  params: Params<
    t_DependabotCreateOrUpdateOrgSecretParamSchema,
    void,
    t_DependabotCreateOrUpdateOrgSecretRequestBody,
    void
  >,
  respond: DependabotCreateOrUpdateOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotDeleteOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DependabotDeleteOrgSecret = (
  params: Params<t_DependabotDeleteOrgSecretParamSchema, void, void, void>,
  respond: DependabotDeleteOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotListSelectedReposForOrgSecretResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_minimal_repository[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type DependabotListSelectedReposForOrgSecret = (
  params: Params<
    t_DependabotListSelectedReposForOrgSecretParamSchema,
    t_DependabotListSelectedReposForOrgSecretQuerySchema,
    void,
    void
  >,
  respond: DependabotListSelectedReposForOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotSetSelectedReposForOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DependabotSetSelectedReposForOrgSecret = (
  params: Params<
    t_DependabotSetSelectedReposForOrgSecretParamSchema,
    void,
    t_DependabotSetSelectedReposForOrgSecretRequestBody,
    void
  >,
  respond: DependabotSetSelectedReposForOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotAddSelectedRepoToOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DependabotAddSelectedRepoToOrgSecret = (
  params: Params<
    t_DependabotAddSelectedRepoToOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: DependabotAddSelectedRepoToOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotRemoveSelectedRepoFromOrgSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DependabotRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: DependabotRemoveSelectedRepoFromOrgSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesListDockerMigrationConflictingPackagesForOrganizationResponder =
  {
    with200(): ExpressRuntimeResponse<t_package[]>
    with401(): ExpressRuntimeResponse<t_basic_error>
    with403(): ExpressRuntimeResponse<t_basic_error>
  } & ExpressRuntimeResponder

export type PackagesListDockerMigrationConflictingPackagesForOrganization = (
  params: Params<
    t_PackagesListDockerMigrationConflictingPackagesForOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesListDockerMigrationConflictingPackagesForOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListPublicOrgEventsResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
} & ExpressRuntimeResponder

export type ActivityListPublicOrgEvents = (
  params: Params<
    t_ActivityListPublicOrgEventsParamSchema,
    t_ActivityListPublicOrgEventsQuerySchema,
    void,
    void
  >,
  respond: ActivityListPublicOrgEventsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListFailedInvitationsResponder = {
  with200(): ExpressRuntimeResponse<t_organization_invitation[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListFailedInvitations = (
  params: Params<
    t_OrgsListFailedInvitationsParamSchema,
    t_OrgsListFailedInvitationsQuerySchema,
    void,
    void
  >,
  respond: OrgsListFailedInvitationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListWebhooksResponder = {
  with200(): ExpressRuntimeResponse<t_org_hook[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListWebhooks = (
  params: Params<
    t_OrgsListWebhooksParamSchema,
    t_OrgsListWebhooksQuerySchema,
    void,
    void
  >,
  respond: OrgsListWebhooksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCreateWebhookResponder = {
  with201(): ExpressRuntimeResponse<t_org_hook>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsCreateWebhook = (
  params: Params<
    t_OrgsCreateWebhookParamSchema,
    void,
    t_OrgsCreateWebhookRequestBody,
    void
  >,
  respond: OrgsCreateWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetWebhookResponder = {
  with200(): ExpressRuntimeResponse<t_org_hook>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGetWebhook = (
  params: Params<t_OrgsGetWebhookParamSchema, void, void, void>,
  respond: OrgsGetWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUpdateWebhookResponder = {
  with200(): ExpressRuntimeResponse<t_org_hook>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsUpdateWebhook = (
  params: Params<
    t_OrgsUpdateWebhookParamSchema,
    void,
    t_OrgsUpdateWebhookRequestBody | undefined,
    void
  >,
  respond: OrgsUpdateWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsDeleteWebhookResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsDeleteWebhook = (
  params: Params<t_OrgsDeleteWebhookParamSchema, void, void, void>,
  respond: OrgsDeleteWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetWebhookConfigForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_config>
} & ExpressRuntimeResponder

export type OrgsGetWebhookConfigForOrg = (
  params: Params<t_OrgsGetWebhookConfigForOrgParamSchema, void, void, void>,
  respond: OrgsGetWebhookConfigForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUpdateWebhookConfigForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_config>
} & ExpressRuntimeResponder

export type OrgsUpdateWebhookConfigForOrg = (
  params: Params<
    t_OrgsUpdateWebhookConfigForOrgParamSchema,
    void,
    t_OrgsUpdateWebhookConfigForOrgRequestBody | undefined,
    void
  >,
  respond: OrgsUpdateWebhookConfigForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListWebhookDeliveriesResponder = {
  with200(): ExpressRuntimeResponse<t_hook_delivery_item[]>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsListWebhookDeliveries = (
  params: Params<
    t_OrgsListWebhookDeliveriesParamSchema,
    t_OrgsListWebhookDeliveriesQuerySchema,
    void,
    void
  >,
  respond: OrgsListWebhookDeliveriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetWebhookDeliveryResponder = {
  with200(): ExpressRuntimeResponse<t_hook_delivery>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsGetWebhookDelivery = (
  params: Params<t_OrgsGetWebhookDeliveryParamSchema, void, void, void>,
  respond: OrgsGetWebhookDeliveryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRedeliverWebhookDeliveryResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsRedeliverWebhookDelivery = (
  params: Params<t_OrgsRedeliverWebhookDeliveryParamSchema, void, void, void>,
  respond: OrgsRedeliverWebhookDeliveryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsPingWebhookResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsPingWebhook = (
  params: Params<t_OrgsPingWebhookParamSchema, void, void, void>,
  respond: OrgsPingWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetRouteStatsByActorResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_route_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetRouteStatsByActor = (
  params: Params<
    t_ApiInsightsGetRouteStatsByActorParamSchema,
    t_ApiInsightsGetRouteStatsByActorQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetRouteStatsByActorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetSubjectStatsResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_subject_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetSubjectStats = (
  params: Params<
    t_ApiInsightsGetSubjectStatsParamSchema,
    t_ApiInsightsGetSubjectStatsQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetSubjectStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetSummaryStatsResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_summary_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetSummaryStats = (
  params: Params<
    t_ApiInsightsGetSummaryStatsParamSchema,
    t_ApiInsightsGetSummaryStatsQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetSummaryStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetSummaryStatsByUserResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_summary_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetSummaryStatsByUser = (
  params: Params<
    t_ApiInsightsGetSummaryStatsByUserParamSchema,
    t_ApiInsightsGetSummaryStatsByUserQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetSummaryStatsByUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetSummaryStatsByActorResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_summary_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetSummaryStatsByActor = (
  params: Params<
    t_ApiInsightsGetSummaryStatsByActorParamSchema,
    t_ApiInsightsGetSummaryStatsByActorQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetSummaryStatsByActorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetTimeStatsResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_time_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetTimeStats = (
  params: Params<
    t_ApiInsightsGetTimeStatsParamSchema,
    t_ApiInsightsGetTimeStatsQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetTimeStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetTimeStatsByUserResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_time_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetTimeStatsByUser = (
  params: Params<
    t_ApiInsightsGetTimeStatsByUserParamSchema,
    t_ApiInsightsGetTimeStatsByUserQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetTimeStatsByUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetTimeStatsByActorResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_time_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetTimeStatsByActor = (
  params: Params<
    t_ApiInsightsGetTimeStatsByActorParamSchema,
    t_ApiInsightsGetTimeStatsByActorQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetTimeStatsByActorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ApiInsightsGetUserStatsResponder = {
  with200(): ExpressRuntimeResponse<t_api_insights_user_stats>
} & ExpressRuntimeResponder

export type ApiInsightsGetUserStats = (
  params: Params<
    t_ApiInsightsGetUserStatsParamSchema,
    t_ApiInsightsGetUserStatsQuerySchema,
    void,
    void
  >,
  respond: ApiInsightsGetUserStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetOrgInstallationResponder = {
  with200(): ExpressRuntimeResponse<t_installation>
} & ExpressRuntimeResponder

export type AppsGetOrgInstallation = (
  params: Params<t_AppsGetOrgInstallationParamSchema, void, void, void>,
  respond: AppsGetOrgInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListAppInstallationsResponder = {
  with200(): ExpressRuntimeResponse<{
    installations: t_installation[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type OrgsListAppInstallations = (
  params: Params<
    t_OrgsListAppInstallationsParamSchema,
    t_OrgsListAppInstallationsQuerySchema,
    void,
    void
  >,
  respond: OrgsListAppInstallationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsGetRestrictionsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_interaction_limit_response | EmptyObject>
} & ExpressRuntimeResponder

export type InteractionsGetRestrictionsForOrg = (
  params: Params<
    t_InteractionsGetRestrictionsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: InteractionsGetRestrictionsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsSetRestrictionsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_interaction_limit_response>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type InteractionsSetRestrictionsForOrg = (
  params: Params<
    t_InteractionsSetRestrictionsForOrgParamSchema,
    void,
    t_interaction_limit,
    void
  >,
  respond: InteractionsSetRestrictionsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsRemoveRestrictionsForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type InteractionsRemoveRestrictionsForOrg = (
  params: Params<
    t_InteractionsRemoveRestrictionsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: InteractionsRemoveRestrictionsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListPendingInvitationsResponder = {
  with200(): ExpressRuntimeResponse<t_organization_invitation[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListPendingInvitations = (
  params: Params<
    t_OrgsListPendingInvitationsParamSchema,
    t_OrgsListPendingInvitationsQuerySchema,
    void,
    void
  >,
  respond: OrgsListPendingInvitationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCreateInvitationResponder = {
  with201(): ExpressRuntimeResponse<t_organization_invitation>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsCreateInvitation = (
  params: Params<
    t_OrgsCreateInvitationParamSchema,
    void,
    t_OrgsCreateInvitationRequestBody | undefined,
    void
  >,
  respond: OrgsCreateInvitationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCancelInvitationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsCancelInvitation = (
  params: Params<t_OrgsCancelInvitationParamSchema, void, void, void>,
  respond: OrgsCancelInvitationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListInvitationTeamsResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListInvitationTeams = (
  params: Params<
    t_OrgsListInvitationTeamsParamSchema,
    t_OrgsListInvitationTeamsQuerySchema,
    void,
    void
  >,
  respond: OrgsListInvitationTeamsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListIssueTypesResponder = {
  with200(): ExpressRuntimeResponse<t_issue_type[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListIssueTypes = (
  params: Params<t_OrgsListIssueTypesParamSchema, void, void, void>,
  respond: OrgsListIssueTypesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCreateIssueTypeResponder = {
  with200(): ExpressRuntimeResponse<t_issue_type>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type OrgsCreateIssueType = (
  params: Params<
    t_OrgsCreateIssueTypeParamSchema,
    void,
    t_organization_create_issue_type,
    void
  >,
  respond: OrgsCreateIssueTypeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUpdateIssueTypeResponder = {
  with200(): ExpressRuntimeResponse<t_issue_type>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type OrgsUpdateIssueType = (
  params: Params<
    t_OrgsUpdateIssueTypeParamSchema,
    void,
    t_organization_update_issue_type,
    void
  >,
  respond: OrgsUpdateIssueTypeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsDeleteIssueTypeResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type OrgsDeleteIssueType = (
  params: Params<t_OrgsDeleteIssueTypeParamSchema, void, void, void>,
  respond: OrgsDeleteIssueTypeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_issue[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListForOrg = (
  params: Params<
    t_IssuesListForOrgParamSchema,
    t_IssuesListForOrgQuerySchema,
    void,
    void
  >,
  respond: IssuesListForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListMembersResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsListMembers = (
  params: Params<
    t_OrgsListMembersParamSchema,
    t_OrgsListMembersQuerySchema,
    void,
    void
  >,
  respond: OrgsListMembersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCheckMembershipForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with302(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsCheckMembershipForUser = (
  params: Params<t_OrgsCheckMembershipForUserParamSchema, void, void, void>,
  respond: OrgsCheckMembershipForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRemoveMemberResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsRemoveMember = (
  params: Params<t_OrgsRemoveMemberParamSchema, void, void, void>,
  respond: OrgsRemoveMemberResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetCodespacesForUserInOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    codespaces: t_codespace[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesGetCodespacesForUserInOrg = (
  params: Params<
    t_CodespacesGetCodespacesForUserInOrgParamSchema,
    t_CodespacesGetCodespacesForUserInOrgQuerySchema,
    void,
    void
  >,
  respond: CodespacesGetCodespacesForUserInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesDeleteFromOrganizationResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesDeleteFromOrganization = (
  params: Params<
    t_CodespacesDeleteFromOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesDeleteFromOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesStopInOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_codespace>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesStopInOrganization = (
  params: Params<t_CodespacesStopInOrganizationParamSchema, void, void, void>,
  respond: CodespacesStopInOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotGetCopilotSeatDetailsForUserResponder = {
  with200(): ExpressRuntimeResponse<t_copilot_seat_details>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotGetCopilotSeatDetailsForUser = (
  params: Params<
    t_CopilotGetCopilotSeatDetailsForUserParamSchema,
    void,
    void,
    void
  >,
  respond: CopilotGetCopilotSeatDetailsForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetMembershipForUserResponder = {
  with200(): ExpressRuntimeResponse<t_org_membership>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGetMembershipForUser = (
  params: Params<t_OrgsGetMembershipForUserParamSchema, void, void, void>,
  respond: OrgsGetMembershipForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsSetMembershipForUserResponder = {
  with200(): ExpressRuntimeResponse<t_org_membership>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsSetMembershipForUser = (
  params: Params<
    t_OrgsSetMembershipForUserParamSchema,
    void,
    t_OrgsSetMembershipForUserRequestBody | undefined,
    void
  >,
  respond: OrgsSetMembershipForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRemoveMembershipForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsRemoveMembershipForUser = (
  params: Params<t_OrgsRemoveMembershipForUserParamSchema, void, void, void>,
  respond: OrgsRemoveMembershipForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsListForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_migration[]>
} & ExpressRuntimeResponder

export type MigrationsListForOrg = (
  params: Params<
    t_MigrationsListForOrgParamSchema,
    t_MigrationsListForOrgQuerySchema,
    void,
    void
  >,
  respond: MigrationsListForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsStartForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_migration>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type MigrationsStartForOrg = (
  params: Params<
    t_MigrationsStartForOrgParamSchema,
    void,
    t_MigrationsStartForOrgRequestBody,
    void
  >,
  respond: MigrationsStartForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsGetStatusForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_migration>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsGetStatusForOrg = (
  params: Params<
    t_MigrationsGetStatusForOrgParamSchema,
    t_MigrationsGetStatusForOrgQuerySchema,
    void,
    void
  >,
  respond: MigrationsGetStatusForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsDownloadArchiveForOrgResponder = {
  with302(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsDownloadArchiveForOrg = (
  params: Params<
    t_MigrationsDownloadArchiveForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: MigrationsDownloadArchiveForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsDeleteArchiveForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsDeleteArchiveForOrg = (
  params: Params<t_MigrationsDeleteArchiveForOrgParamSchema, void, void, void>,
  respond: MigrationsDeleteArchiveForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsUnlockRepoForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsUnlockRepoForOrg = (
  params: Params<t_MigrationsUnlockRepoForOrgParamSchema, void, void, void>,
  respond: MigrationsUnlockRepoForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsListReposForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsListReposForOrg = (
  params: Params<
    t_MigrationsListReposForOrgParamSchema,
    t_MigrationsListReposForOrgQuerySchema,
    void,
    void
  >,
  respond: MigrationsListReposForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListOrgRolesResponder = {
  with200(): ExpressRuntimeResponse<{
    roles?: t_organization_role[] | undefined
    total_count?: number | undefined
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsListOrgRoles = (
  params: Params<t_OrgsListOrgRolesParamSchema, void, void, void>,
  respond: OrgsListOrgRolesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRevokeAllOrgRolesTeamResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsRevokeAllOrgRolesTeam = (
  params: Params<t_OrgsRevokeAllOrgRolesTeamParamSchema, void, void, void>,
  respond: OrgsRevokeAllOrgRolesTeamResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsAssignTeamToOrgRoleResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsAssignTeamToOrgRole = (
  params: Params<t_OrgsAssignTeamToOrgRoleParamSchema, void, void, void>,
  respond: OrgsAssignTeamToOrgRoleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRevokeOrgRoleTeamResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsRevokeOrgRoleTeam = (
  params: Params<t_OrgsRevokeOrgRoleTeamParamSchema, void, void, void>,
  respond: OrgsRevokeOrgRoleTeamResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRevokeAllOrgRolesUserResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsRevokeAllOrgRolesUser = (
  params: Params<t_OrgsRevokeAllOrgRolesUserParamSchema, void, void, void>,
  respond: OrgsRevokeAllOrgRolesUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsAssignUserToOrgRoleResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsAssignUserToOrgRole = (
  params: Params<t_OrgsAssignUserToOrgRoleParamSchema, void, void, void>,
  respond: OrgsAssignUserToOrgRoleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRevokeOrgRoleUserResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsRevokeOrgRoleUser = (
  params: Params<t_OrgsRevokeOrgRoleUserParamSchema, void, void, void>,
  respond: OrgsRevokeOrgRoleUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetOrgRoleResponder = {
  with200(): ExpressRuntimeResponse<t_organization_role>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsGetOrgRole = (
  params: Params<t_OrgsGetOrgRoleParamSchema, void, void, void>,
  respond: OrgsGetOrgRoleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListOrgRoleTeamsResponder = {
  with200(): ExpressRuntimeResponse<t_team_role_assignment[]>
  with404(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsListOrgRoleTeams = (
  params: Params<
    t_OrgsListOrgRoleTeamsParamSchema,
    t_OrgsListOrgRoleTeamsQuerySchema,
    void,
    void
  >,
  respond: OrgsListOrgRoleTeamsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListOrgRoleUsersResponder = {
  with200(): ExpressRuntimeResponse<t_user_role_assignment[]>
  with404(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsListOrgRoleUsers = (
  params: Params<
    t_OrgsListOrgRoleUsersParamSchema,
    t_OrgsListOrgRoleUsersQuerySchema,
    void,
    void
  >,
  respond: OrgsListOrgRoleUsersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListOutsideCollaboratorsResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
} & ExpressRuntimeResponder

export type OrgsListOutsideCollaborators = (
  params: Params<
    t_OrgsListOutsideCollaboratorsParamSchema,
    t_OrgsListOutsideCollaboratorsQuerySchema,
    void,
    void
  >,
  respond: OrgsListOutsideCollaboratorsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsConvertMemberToOutsideCollaboratorResponder = {
  with202(): ExpressRuntimeResponse<EmptyObject>
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsConvertMemberToOutsideCollaborator = (
  params: Params<
    t_OrgsConvertMemberToOutsideCollaboratorParamSchema,
    void,
    t_OrgsConvertMemberToOutsideCollaboratorRequestBody | undefined,
    void
  >,
  respond: OrgsConvertMemberToOutsideCollaboratorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRemoveOutsideCollaboratorResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type OrgsRemoveOutsideCollaborator = (
  params: Params<t_OrgsRemoveOutsideCollaboratorParamSchema, void, void, void>,
  respond: OrgsRemoveOutsideCollaboratorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesListPackagesForOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_package[]>
  with400(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesListPackagesForOrganization = (
  params: Params<
    t_PackagesListPackagesForOrganizationParamSchema,
    t_PackagesListPackagesForOrganizationQuerySchema,
    void,
    void
  >,
  respond: PackagesListPackagesForOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetPackageForOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_package>
} & ExpressRuntimeResponder

export type PackagesGetPackageForOrganization = (
  params: Params<
    t_PackagesGetPackageForOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesGetPackageForOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesDeletePackageForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesDeletePackageForOrg = (
  params: Params<t_PackagesDeletePackageForOrgParamSchema, void, void, void>,
  respond: PackagesDeletePackageForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesRestorePackageForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesRestorePackageForOrg = (
  params: Params<
    t_PackagesRestorePackageForOrgParamSchema,
    t_PackagesRestorePackageForOrgQuerySchema,
    void,
    void
  >,
  respond: PackagesRestorePackageForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgResponder = {
  with200(): ExpressRuntimeResponse<t_package_version[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
    t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
    void,
    void
  >,
  respond: PackagesGetAllPackageVersionsForPackageOwnedByOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetPackageVersionForOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_package_version>
} & ExpressRuntimeResponder

export type PackagesGetPackageVersionForOrganization = (
  params: Params<
    t_PackagesGetPackageVersionForOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesGetPackageVersionForOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesDeletePackageVersionForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesDeletePackageVersionForOrg = (
  params: Params<
    t_PackagesDeletePackageVersionForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesDeletePackageVersionForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesRestorePackageVersionForOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesRestorePackageVersionForOrg = (
  params: Params<
    t_PackagesRestorePackageVersionForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesRestorePackageVersionForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListPatGrantRequestsResponder = {
  with200(): ExpressRuntimeResponse<
    t_organization_programmatic_access_grant_request[]
  >
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListPatGrantRequests = (
  params: Params<
    t_OrgsListPatGrantRequestsParamSchema,
    t_OrgsListPatGrantRequestsQuerySchema,
    void,
    void
  >,
  respond: OrgsListPatGrantRequestsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsReviewPatGrantRequestsInBulkResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsReviewPatGrantRequestsInBulk = (
  params: Params<
    t_OrgsReviewPatGrantRequestsInBulkParamSchema,
    void,
    t_OrgsReviewPatGrantRequestsInBulkRequestBody,
    void
  >,
  respond: OrgsReviewPatGrantRequestsInBulkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsReviewPatGrantRequestResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsReviewPatGrantRequest = (
  params: Params<
    t_OrgsReviewPatGrantRequestParamSchema,
    void,
    t_OrgsReviewPatGrantRequestRequestBody,
    void
  >,
  respond: OrgsReviewPatGrantRequestResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListPatGrantRequestRepositoriesResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListPatGrantRequestRepositories = (
  params: Params<
    t_OrgsListPatGrantRequestRepositoriesParamSchema,
    t_OrgsListPatGrantRequestRepositoriesQuerySchema,
    void,
    void
  >,
  respond: OrgsListPatGrantRequestRepositoriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListPatGrantsResponder = {
  with200(): ExpressRuntimeResponse<t_organization_programmatic_access_grant[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListPatGrants = (
  params: Params<
    t_OrgsListPatGrantsParamSchema,
    t_OrgsListPatGrantsQuerySchema,
    void,
    void
  >,
  respond: OrgsListPatGrantsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUpdatePatAccessesResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsUpdatePatAccesses = (
  params: Params<
    t_OrgsUpdatePatAccessesParamSchema,
    void,
    t_OrgsUpdatePatAccessesRequestBody,
    void
  >,
  respond: OrgsUpdatePatAccessesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUpdatePatAccessResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsUpdatePatAccess = (
  params: Params<
    t_OrgsUpdatePatAccessParamSchema,
    void,
    t_OrgsUpdatePatAccessRequestBody,
    void
  >,
  respond: OrgsUpdatePatAccessResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListPatGrantRepositoriesResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListPatGrantRepositories = (
  params: Params<
    t_OrgsListPatGrantRepositoriesParamSchema,
    t_OrgsListPatGrantRepositoriesQuerySchema,
    void,
    void
  >,
  respond: OrgsListPatGrantRepositoriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PrivateRegistriesListOrgPrivateRegistriesResponder = {
  with200(): ExpressRuntimeResponse<{
    configurations: t_org_private_registry_configuration[]
    total_count: number
  }>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PrivateRegistriesListOrgPrivateRegistries = (
  params: Params<
    t_PrivateRegistriesListOrgPrivateRegistriesParamSchema,
    t_PrivateRegistriesListOrgPrivateRegistriesQuerySchema,
    void,
    void
  >,
  respond: PrivateRegistriesListOrgPrivateRegistriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PrivateRegistriesCreateOrgPrivateRegistryResponder = {
  with201(): ExpressRuntimeResponse<t_org_private_registry_configuration_with_selected_repositories>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PrivateRegistriesCreateOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesCreateOrgPrivateRegistryParamSchema,
    void,
    t_PrivateRegistriesCreateOrgPrivateRegistryRequestBody,
    void
  >,
  respond: PrivateRegistriesCreateOrgPrivateRegistryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PrivateRegistriesGetOrgPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<{
    key: string
    key_id: string
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PrivateRegistriesGetOrgPublicKey = (
  params: Params<
    t_PrivateRegistriesGetOrgPublicKeyParamSchema,
    void,
    void,
    void
  >,
  respond: PrivateRegistriesGetOrgPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PrivateRegistriesGetOrgPrivateRegistryResponder = {
  with200(): ExpressRuntimeResponse<t_org_private_registry_configuration>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PrivateRegistriesGetOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesGetOrgPrivateRegistryParamSchema,
    void,
    void,
    void
  >,
  respond: PrivateRegistriesGetOrgPrivateRegistryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PrivateRegistriesUpdateOrgPrivateRegistryResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PrivateRegistriesUpdateOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesUpdateOrgPrivateRegistryParamSchema,
    void,
    t_PrivateRegistriesUpdateOrgPrivateRegistryRequestBody,
    void
  >,
  respond: PrivateRegistriesUpdateOrgPrivateRegistryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PrivateRegistriesDeleteOrgPrivateRegistryResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PrivateRegistriesDeleteOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesDeleteOrgPrivateRegistryParamSchema,
    void,
    void,
    void
  >,
  respond: PrivateRegistriesDeleteOrgPrivateRegistryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicListForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_project[]>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicListForOrg = (
  params: Params<
    t_ProjectsClassicListForOrgParamSchema,
    t_ProjectsClassicListForOrgQuerySchema,
    void,
    void
  >,
  respond: ProjectsClassicListForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicCreateForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_project>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicCreateForOrg = (
  params: Params<
    t_ProjectsClassicCreateForOrgParamSchema,
    void,
    t_ProjectsClassicCreateForOrgRequestBody,
    void
  >,
  respond: ProjectsClassicCreateForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetAllCustomPropertiesResponder = {
  with200(): ExpressRuntimeResponse<t_custom_property[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGetAllCustomProperties = (
  params: Params<t_OrgsGetAllCustomPropertiesParamSchema, void, void, void>,
  respond: OrgsGetAllCustomPropertiesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCreateOrUpdateCustomPropertiesResponder = {
  with200(): ExpressRuntimeResponse<t_custom_property[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsCreateOrUpdateCustomProperties = (
  params: Params<
    t_OrgsCreateOrUpdateCustomPropertiesParamSchema,
    void,
    t_OrgsCreateOrUpdateCustomPropertiesRequestBody,
    void
  >,
  respond: OrgsCreateOrUpdateCustomPropertiesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetCustomPropertyResponder = {
  with200(): ExpressRuntimeResponse<t_custom_property>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGetCustomProperty = (
  params: Params<t_OrgsGetCustomPropertyParamSchema, void, void, void>,
  respond: OrgsGetCustomPropertyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCreateOrUpdateCustomPropertyResponder = {
  with200(): ExpressRuntimeResponse<t_custom_property>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsCreateOrUpdateCustomProperty = (
  params: Params<
    t_OrgsCreateOrUpdateCustomPropertyParamSchema,
    void,
    t_custom_property_set_payload,
    void
  >,
  respond: OrgsCreateOrUpdateCustomPropertyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRemoveCustomPropertyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsRemoveCustomProperty = (
  params: Params<t_OrgsRemoveCustomPropertyParamSchema, void, void, void>,
  respond: OrgsRemoveCustomPropertyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListCustomPropertiesValuesForReposResponder = {
  with200(): ExpressRuntimeResponse<t_org_repo_custom_property_values[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListCustomPropertiesValuesForRepos = (
  params: Params<
    t_OrgsListCustomPropertiesValuesForReposParamSchema,
    t_OrgsListCustomPropertiesValuesForReposQuerySchema,
    void,
    void
  >,
  respond: OrgsListCustomPropertiesValuesForReposResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCreateOrUpdateCustomPropertiesValuesForReposResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsCreateOrUpdateCustomPropertiesValuesForRepos = (
  params: Params<
    t_OrgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema,
    void,
    t_OrgsCreateOrUpdateCustomPropertiesValuesForReposRequestBody,
    void
  >,
  respond: OrgsCreateOrUpdateCustomPropertiesValuesForReposResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListPublicMembersResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
} & ExpressRuntimeResponder

export type OrgsListPublicMembers = (
  params: Params<
    t_OrgsListPublicMembersParamSchema,
    t_OrgsListPublicMembersQuerySchema,
    void,
    void
  >,
  respond: OrgsListPublicMembersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsCheckPublicMembershipForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsCheckPublicMembershipForUser = (
  params: Params<
    t_OrgsCheckPublicMembershipForUserParamSchema,
    void,
    void,
    void
  >,
  respond: OrgsCheckPublicMembershipForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsSetPublicMembershipForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsSetPublicMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: OrgsSetPublicMembershipForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRemovePublicMembershipForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsRemovePublicMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: OrgsRemovePublicMembershipForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
} & ExpressRuntimeResponder

export type ReposListForOrg = (
  params: Params<
    t_ReposListForOrgParamSchema,
    t_ReposListForOrgQuerySchema,
    void,
    void
  >,
  respond: ReposListForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateInOrgResponder = {
  with201(): ExpressRuntimeResponse<t_full_repository>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateInOrg = (
  params: Params<
    t_ReposCreateInOrgParamSchema,
    void,
    t_ReposCreateInOrgRequestBody,
    void
  >,
  respond: ReposCreateInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetOrgRulesetsResponder = {
  with200(): ExpressRuntimeResponse<t_repository_ruleset[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetOrgRulesets = (
  params: Params<
    t_ReposGetOrgRulesetsParamSchema,
    t_ReposGetOrgRulesetsQuerySchema,
    void,
    void
  >,
  respond: ReposGetOrgRulesetsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateOrgRulesetResponder = {
  with201(): ExpressRuntimeResponse<t_repository_ruleset>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposCreateOrgRuleset = (
  params: Params<
    t_ReposCreateOrgRulesetParamSchema,
    void,
    t_ReposCreateOrgRulesetRequestBody,
    void
  >,
  respond: ReposCreateOrgRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetOrgRuleSuitesResponder = {
  with200(): ExpressRuntimeResponse<t_rule_suites>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetOrgRuleSuites = (
  params: Params<
    t_ReposGetOrgRuleSuitesParamSchema,
    t_ReposGetOrgRuleSuitesQuerySchema,
    void,
    void
  >,
  respond: ReposGetOrgRuleSuitesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetOrgRuleSuiteResponder = {
  with200(): ExpressRuntimeResponse<t_rule_suite>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetOrgRuleSuite = (
  params: Params<t_ReposGetOrgRuleSuiteParamSchema, void, void, void>,
  respond: ReposGetOrgRuleSuiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetOrgRulesetResponder = {
  with200(): ExpressRuntimeResponse<t_repository_ruleset>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetOrgRuleset = (
  params: Params<t_ReposGetOrgRulesetParamSchema, void, void, void>,
  respond: ReposGetOrgRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateOrgRulesetResponder = {
  with200(): ExpressRuntimeResponse<t_repository_ruleset>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposUpdateOrgRuleset = (
  params: Params<
    t_ReposUpdateOrgRulesetParamSchema,
    void,
    t_ReposUpdateOrgRulesetRequestBody | undefined,
    void
  >,
  respond: ReposUpdateOrgRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteOrgRulesetResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteOrgRuleset = (
  params: Params<t_ReposDeleteOrgRulesetParamSchema, void, void, void>,
  respond: ReposDeleteOrgRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetOrgRulesetHistoryResponder = {
  with200(): ExpressRuntimeResponse<t_ruleset_version[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGetOrgRulesetHistory = (
  params: Params<
    t_OrgsGetOrgRulesetHistoryParamSchema,
    t_OrgsGetOrgRulesetHistoryQuerySchema,
    void,
    void
  >,
  respond: OrgsGetOrgRulesetHistoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetOrgRulesetVersionResponder = {
  with200(): ExpressRuntimeResponse<t_ruleset_version_with_state>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGetOrgRulesetVersion = (
  params: Params<t_OrgsGetOrgRulesetVersionParamSchema, void, void, void>,
  respond: OrgsGetOrgRulesetVersionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningListAlertsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_organization_secret_scanning_alert[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningListAlertsForOrg = (
  params: Params<
    t_SecretScanningListAlertsForOrgParamSchema,
    t_SecretScanningListAlertsForOrgQuerySchema,
    void,
    void
  >,
  respond: SecretScanningListAlertsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesListOrgRepositoryAdvisoriesResponder = {
  with200(): ExpressRuntimeResponse<t_repository_advisory[]>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesListOrgRepositoryAdvisories = (
  params: Params<
    t_SecurityAdvisoriesListOrgRepositoryAdvisoriesParamSchema,
    t_SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema,
    void,
    void
  >,
  respond: SecurityAdvisoriesListOrgRepositoryAdvisoriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListSecurityManagerTeamsResponder = {
  with200(): ExpressRuntimeResponse<t_team_simple[]>
} & ExpressRuntimeResponder

export type OrgsListSecurityManagerTeams = (
  params: Params<t_OrgsListSecurityManagerTeamsParamSchema, void, void, void>,
  respond: OrgsListSecurityManagerTeamsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsAddSecurityManagerTeamResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsAddSecurityManagerTeam = (
  params: Params<t_OrgsAddSecurityManagerTeamParamSchema, void, void, void>,
  respond: OrgsAddSecurityManagerTeamResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsRemoveSecurityManagerTeamResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsRemoveSecurityManagerTeam = (
  params: Params<t_OrgsRemoveSecurityManagerTeamParamSchema, void, void, void>,
  respond: OrgsRemoveSecurityManagerTeamResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetGithubActionsBillingOrgResponder = {
  with200(): ExpressRuntimeResponse<t_actions_billing_usage>
} & ExpressRuntimeResponder

export type BillingGetGithubActionsBillingOrg = (
  params: Params<
    t_BillingGetGithubActionsBillingOrgParamSchema,
    void,
    void,
    void
  >,
  respond: BillingGetGithubActionsBillingOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetGithubPackagesBillingOrgResponder = {
  with200(): ExpressRuntimeResponse<t_packages_billing_usage>
} & ExpressRuntimeResponder

export type BillingGetGithubPackagesBillingOrg = (
  params: Params<
    t_BillingGetGithubPackagesBillingOrgParamSchema,
    void,
    void,
    void
  >,
  respond: BillingGetGithubPackagesBillingOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetSharedStorageBillingOrgResponder = {
  with200(): ExpressRuntimeResponse<t_combined_billing_usage>
} & ExpressRuntimeResponder

export type BillingGetSharedStorageBillingOrg = (
  params: Params<
    t_BillingGetSharedStorageBillingOrgParamSchema,
    void,
    void,
    void
  >,
  respond: BillingGetSharedStorageBillingOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type HostedComputeListNetworkConfigurationsForOrgResponder = {
  with200(): ExpressRuntimeResponse<{
    network_configurations: t_network_configuration[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type HostedComputeListNetworkConfigurationsForOrg = (
  params: Params<
    t_HostedComputeListNetworkConfigurationsForOrgParamSchema,
    t_HostedComputeListNetworkConfigurationsForOrgQuerySchema,
    void,
    void
  >,
  respond: HostedComputeListNetworkConfigurationsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type HostedComputeCreateNetworkConfigurationForOrgResponder = {
  with201(): ExpressRuntimeResponse<t_network_configuration>
} & ExpressRuntimeResponder

export type HostedComputeCreateNetworkConfigurationForOrg = (
  params: Params<
    t_HostedComputeCreateNetworkConfigurationForOrgParamSchema,
    void,
    t_HostedComputeCreateNetworkConfigurationForOrgRequestBody,
    void
  >,
  respond: HostedComputeCreateNetworkConfigurationForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type HostedComputeGetNetworkConfigurationForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_network_configuration>
} & ExpressRuntimeResponder

export type HostedComputeGetNetworkConfigurationForOrg = (
  params: Params<
    t_HostedComputeGetNetworkConfigurationForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: HostedComputeGetNetworkConfigurationForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type HostedComputeUpdateNetworkConfigurationForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_network_configuration>
} & ExpressRuntimeResponder

export type HostedComputeUpdateNetworkConfigurationForOrg = (
  params: Params<
    t_HostedComputeUpdateNetworkConfigurationForOrgParamSchema,
    void,
    t_HostedComputeUpdateNetworkConfigurationForOrgRequestBody,
    void
  >,
  respond: HostedComputeUpdateNetworkConfigurationForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type HostedComputeDeleteNetworkConfigurationFromOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type HostedComputeDeleteNetworkConfigurationFromOrg = (
  params: Params<
    t_HostedComputeDeleteNetworkConfigurationFromOrgParamSchema,
    void,
    void,
    void
  >,
  respond: HostedComputeDeleteNetworkConfigurationFromOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type HostedComputeGetNetworkSettingsForOrgResponder = {
  with200(): ExpressRuntimeResponse<t_network_settings>
} & ExpressRuntimeResponder

export type HostedComputeGetNetworkSettingsForOrg = (
  params: Params<
    t_HostedComputeGetNetworkSettingsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: HostedComputeGetNetworkSettingsForOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CopilotCopilotMetricsForTeamResponder = {
  with200(): ExpressRuntimeResponse<t_copilot_usage_metrics_day[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CopilotCopilotMetricsForTeam = (
  params: Params<
    t_CopilotCopilotMetricsForTeamParamSchema,
    t_CopilotCopilotMetricsForTeamQuerySchema,
    void,
    void
  >,
  respond: CopilotCopilotMetricsForTeamResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsList = (
  params: Params<t_TeamsListParamSchema, t_TeamsListQuerySchema, void, void>,
  respond: TeamsListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCreateResponder = {
  with201(): ExpressRuntimeResponse<t_team_full>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsCreate = (
  params: Params<
    t_TeamsCreateParamSchema,
    void,
    t_TeamsCreateRequestBody,
    void
  >,
  respond: TeamsCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetByNameResponder = {
  with200(): ExpressRuntimeResponse<t_team_full>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsGetByName = (
  params: Params<t_TeamsGetByNameParamSchema, void, void, void>,
  respond: TeamsGetByNameResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsUpdateInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_full>
  with201(): ExpressRuntimeResponse<t_team_full>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsUpdateInOrg = (
  params: Params<
    t_TeamsUpdateInOrgParamSchema,
    void,
    t_TeamsUpdateInOrgRequestBody | undefined,
    void
  >,
  respond: TeamsUpdateInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsDeleteInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsDeleteInOrg = (
  params: Params<t_TeamsDeleteInOrgParamSchema, void, void, void>,
  respond: TeamsDeleteInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListDiscussionsInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion[]>
} & ExpressRuntimeResponder

export type TeamsListDiscussionsInOrg = (
  params: Params<
    t_TeamsListDiscussionsInOrgParamSchema,
    t_TeamsListDiscussionsInOrgQuerySchema,
    void,
    void
  >,
  respond: TeamsListDiscussionsInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCreateDiscussionInOrgResponder = {
  with201(): ExpressRuntimeResponse<t_team_discussion>
} & ExpressRuntimeResponder

export type TeamsCreateDiscussionInOrg = (
  params: Params<
    t_TeamsCreateDiscussionInOrgParamSchema,
    void,
    t_TeamsCreateDiscussionInOrgRequestBody,
    void
  >,
  respond: TeamsCreateDiscussionInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetDiscussionInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion>
} & ExpressRuntimeResponder

export type TeamsGetDiscussionInOrg = (
  params: Params<t_TeamsGetDiscussionInOrgParamSchema, void, void, void>,
  respond: TeamsGetDiscussionInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsUpdateDiscussionInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion>
} & ExpressRuntimeResponder

export type TeamsUpdateDiscussionInOrg = (
  params: Params<
    t_TeamsUpdateDiscussionInOrgParamSchema,
    void,
    t_TeamsUpdateDiscussionInOrgRequestBody | undefined,
    void
  >,
  respond: TeamsUpdateDiscussionInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsDeleteDiscussionInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsDeleteDiscussionInOrg = (
  params: Params<t_TeamsDeleteDiscussionInOrgParamSchema, void, void, void>,
  respond: TeamsDeleteDiscussionInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListDiscussionCommentsInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion_comment[]>
} & ExpressRuntimeResponder

export type TeamsListDiscussionCommentsInOrg = (
  params: Params<
    t_TeamsListDiscussionCommentsInOrgParamSchema,
    t_TeamsListDiscussionCommentsInOrgQuerySchema,
    void,
    void
  >,
  respond: TeamsListDiscussionCommentsInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCreateDiscussionCommentInOrgResponder = {
  with201(): ExpressRuntimeResponse<t_team_discussion_comment>
} & ExpressRuntimeResponder

export type TeamsCreateDiscussionCommentInOrg = (
  params: Params<
    t_TeamsCreateDiscussionCommentInOrgParamSchema,
    void,
    t_TeamsCreateDiscussionCommentInOrgRequestBody,
    void
  >,
  respond: TeamsCreateDiscussionCommentInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetDiscussionCommentInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion_comment>
} & ExpressRuntimeResponder

export type TeamsGetDiscussionCommentInOrg = (
  params: Params<t_TeamsGetDiscussionCommentInOrgParamSchema, void, void, void>,
  respond: TeamsGetDiscussionCommentInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsUpdateDiscussionCommentInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion_comment>
} & ExpressRuntimeResponder

export type TeamsUpdateDiscussionCommentInOrg = (
  params: Params<
    t_TeamsUpdateDiscussionCommentInOrgParamSchema,
    void,
    t_TeamsUpdateDiscussionCommentInOrgRequestBody,
    void
  >,
  respond: TeamsUpdateDiscussionCommentInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsDeleteDiscussionCommentInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsDeleteDiscussionCommentInOrg = (
  params: Params<
    t_TeamsDeleteDiscussionCommentInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsDeleteDiscussionCommentInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForTeamDiscussionCommentInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
} & ExpressRuntimeResponder

export type ReactionsListForTeamDiscussionCommentInOrg = (
  params: Params<
    t_ReactionsListForTeamDiscussionCommentInOrgParamSchema,
    t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForTeamDiscussionCommentInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForTeamDiscussionCommentInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_reaction>
  with201(): ExpressRuntimeResponse<t_reaction>
} & ExpressRuntimeResponder

export type ReactionsCreateForTeamDiscussionCommentInOrg = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionCommentInOrgRequestBody,
    void
  >,
  respond: ReactionsCreateForTeamDiscussionCommentInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsDeleteForTeamDiscussionCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReactionsDeleteForTeamDiscussionComment = (
  params: Params<
    t_ReactionsDeleteForTeamDiscussionCommentParamSchema,
    void,
    void,
    void
  >,
  respond: ReactionsDeleteForTeamDiscussionCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForTeamDiscussionInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
} & ExpressRuntimeResponder

export type ReactionsListForTeamDiscussionInOrg = (
  params: Params<
    t_ReactionsListForTeamDiscussionInOrgParamSchema,
    t_ReactionsListForTeamDiscussionInOrgQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForTeamDiscussionInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForTeamDiscussionInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_reaction>
  with201(): ExpressRuntimeResponse<t_reaction>
} & ExpressRuntimeResponder

export type ReactionsCreateForTeamDiscussionInOrg = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionInOrgParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionInOrgRequestBody,
    void
  >,
  respond: ReactionsCreateForTeamDiscussionInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsDeleteForTeamDiscussionResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReactionsDeleteForTeamDiscussion = (
  params: Params<
    t_ReactionsDeleteForTeamDiscussionParamSchema,
    void,
    void,
    void
  >,
  respond: ReactionsDeleteForTeamDiscussionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListPendingInvitationsInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_organization_invitation[]>
} & ExpressRuntimeResponder

export type TeamsListPendingInvitationsInOrg = (
  params: Params<
    t_TeamsListPendingInvitationsInOrgParamSchema,
    t_TeamsListPendingInvitationsInOrgQuerySchema,
    void,
    void
  >,
  respond: TeamsListPendingInvitationsInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListMembersInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
} & ExpressRuntimeResponder

export type TeamsListMembersInOrg = (
  params: Params<
    t_TeamsListMembersInOrgParamSchema,
    t_TeamsListMembersInOrgQuerySchema,
    void,
    void
  >,
  respond: TeamsListMembersInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetMembershipForUserInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_membership>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsGetMembershipForUserInOrg = (
  params: Params<t_TeamsGetMembershipForUserInOrgParamSchema, void, void, void>,
  respond: TeamsGetMembershipForUserInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsAddOrUpdateMembershipForUserInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_membership>
  with403(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsAddOrUpdateMembershipForUserInOrg = (
  params: Params<
    t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateMembershipForUserInOrgRequestBody | undefined,
    void
  >,
  respond: TeamsAddOrUpdateMembershipForUserInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsRemoveMembershipForUserInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsRemoveMembershipForUserInOrg = (
  params: Params<
    t_TeamsRemoveMembershipForUserInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsRemoveMembershipForUserInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListProjectsInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_project[]>
} & ExpressRuntimeResponder

export type TeamsListProjectsInOrg = (
  params: Params<
    t_TeamsListProjectsInOrgParamSchema,
    t_TeamsListProjectsInOrgQuerySchema,
    void,
    void
  >,
  respond: TeamsListProjectsInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCheckPermissionsForProjectInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_project>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsCheckPermissionsForProjectInOrg = (
  params: Params<
    t_TeamsCheckPermissionsForProjectInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsCheckPermissionsForProjectInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsAddOrUpdateProjectPermissionsInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type TeamsAddOrUpdateProjectPermissionsInOrg = (
  params: Params<
    t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateProjectPermissionsInOrgRequestBody | undefined,
    void
  >,
  respond: TeamsAddOrUpdateProjectPermissionsInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsRemoveProjectInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsRemoveProjectInOrg = (
  params: Params<t_TeamsRemoveProjectInOrgParamSchema, void, void, void>,
  respond: TeamsRemoveProjectInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListReposInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
} & ExpressRuntimeResponder

export type TeamsListReposInOrg = (
  params: Params<
    t_TeamsListReposInOrgParamSchema,
    t_TeamsListReposInOrgQuerySchema,
    void,
    void
  >,
  respond: TeamsListReposInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCheckPermissionsForRepoInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team_repository>
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsCheckPermissionsForRepoInOrg = (
  params: Params<
    t_TeamsCheckPermissionsForRepoInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsCheckPermissionsForRepoInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsAddOrUpdateRepoPermissionsInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsAddOrUpdateRepoPermissionsInOrg = (
  params: Params<
    t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateRepoPermissionsInOrgRequestBody | undefined,
    void
  >,
  respond: TeamsAddOrUpdateRepoPermissionsInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsRemoveRepoInOrgResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsRemoveRepoInOrg = (
  params: Params<t_TeamsRemoveRepoInOrgParamSchema, void, void, void>,
  respond: TeamsRemoveRepoInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListChildInOrgResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
} & ExpressRuntimeResponder

export type TeamsListChildInOrg = (
  params: Params<
    t_TeamsListChildInOrgParamSchema,
    t_TeamsListChildInOrgQuerySchema,
    void,
    void
  >,
  respond: TeamsListChildInOrgResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type OrgsEnableOrDisableSecurityProductOnAllOrgRepos = (
  params: Params<
    t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
    void,
    t_OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestBody | undefined,
    void
  >,
  respond: OrgsEnableOrDisableSecurityProductOnAllOrgReposResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicGetCardResponder = {
  with200(): ExpressRuntimeResponse<t_project_card>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicGetCard = (
  params: Params<t_ProjectsClassicGetCardParamSchema, void, void, void>,
  respond: ProjectsClassicGetCardResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicUpdateCardResponder = {
  with200(): ExpressRuntimeResponse<t_project_card>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicUpdateCard = (
  params: Params<
    t_ProjectsClassicUpdateCardParamSchema,
    void,
    t_ProjectsClassicUpdateCardRequestBody | undefined,
    void
  >,
  respond: ProjectsClassicUpdateCardResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicDeleteCardResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    errors?: string[] | undefined
    message?: string | undefined
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicDeleteCard = (
  params: Params<t_ProjectsClassicDeleteCardParamSchema, void, void, void>,
  respond: ProjectsClassicDeleteCardResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicMoveCardResponder = {
  with201(): ExpressRuntimeResponse<EmptyObject>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    errors?:
      | {
          code?: string | undefined
          field?: string | undefined
          message?: string | undefined
          resource?: string | undefined
        }[]
      | undefined
    message?: string | undefined
  }>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    errors?:
      | {
          code?: string | undefined
          message?: string | undefined
        }[]
      | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type ProjectsClassicMoveCard = (
  params: Params<
    t_ProjectsClassicMoveCardParamSchema,
    void,
    t_ProjectsClassicMoveCardRequestBody,
    void
  >,
  respond: ProjectsClassicMoveCardResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicGetColumnResponder = {
  with200(): ExpressRuntimeResponse<t_project_column>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicGetColumn = (
  params: Params<t_ProjectsClassicGetColumnParamSchema, void, void, void>,
  respond: ProjectsClassicGetColumnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicUpdateColumnResponder = {
  with200(): ExpressRuntimeResponse<t_project_column>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicUpdateColumn = (
  params: Params<
    t_ProjectsClassicUpdateColumnParamSchema,
    void,
    t_ProjectsClassicUpdateColumnRequestBody,
    void
  >,
  respond: ProjectsClassicUpdateColumnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicDeleteColumnResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicDeleteColumn = (
  params: Params<t_ProjectsClassicDeleteColumnParamSchema, void, void, void>,
  respond: ProjectsClassicDeleteColumnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicListCardsResponder = {
  with200(): ExpressRuntimeResponse<t_project_card[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicListCards = (
  params: Params<
    t_ProjectsClassicListCardsParamSchema,
    t_ProjectsClassicListCardsQuerySchema,
    void,
    void
  >,
  respond: ProjectsClassicListCardsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicCreateCardResponder = {
  with201(): ExpressRuntimeResponse<t_project_card>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<
    t_validation_error | t_validation_error_simple
  >
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    errors?:
      | {
          code?: string | undefined
          message?: string | undefined
        }[]
      | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type ProjectsClassicCreateCard = (
  params: Params<
    t_ProjectsClassicCreateCardParamSchema,
    void,
    t_ProjectsClassicCreateCardRequestBody,
    void
  >,
  respond: ProjectsClassicCreateCardResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicMoveColumnResponder = {
  with201(): ExpressRuntimeResponse<EmptyObject>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicMoveColumn = (
  params: Params<
    t_ProjectsClassicMoveColumnParamSchema,
    void,
    t_ProjectsClassicMoveColumnRequestBody,
    void
  >,
  respond: ProjectsClassicMoveColumnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicGetResponder = {
  with200(): ExpressRuntimeResponse<t_project>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicGet = (
  params: Params<t_ProjectsClassicGetParamSchema, void, void, void>,
  respond: ProjectsClassicGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_project>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    errors?: string[] | undefined
    message?: string | undefined
  }>
  with404(): ExpressRuntimeResponse<void>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicUpdate = (
  params: Params<
    t_ProjectsClassicUpdateParamSchema,
    void,
    t_ProjectsClassicUpdateRequestBody | undefined,
    void
  >,
  respond: ProjectsClassicUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicDeleteResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    errors?: string[] | undefined
    message?: string | undefined
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicDelete = (
  params: Params<t_ProjectsClassicDeleteParamSchema, void, void, void>,
  respond: ProjectsClassicDeleteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicListCollaboratorsResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ProjectsClassicListCollaborators = (
  params: Params<
    t_ProjectsClassicListCollaboratorsParamSchema,
    t_ProjectsClassicListCollaboratorsQuerySchema,
    void,
    void
  >,
  respond: ProjectsClassicListCollaboratorsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicAddCollaboratorResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ProjectsClassicAddCollaborator = (
  params: Params<
    t_ProjectsClassicAddCollaboratorParamSchema,
    void,
    t_ProjectsClassicAddCollaboratorRequestBody | undefined,
    void
  >,
  respond: ProjectsClassicAddCollaboratorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicRemoveCollaboratorResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ProjectsClassicRemoveCollaborator = (
  params: Params<
    t_ProjectsClassicRemoveCollaboratorParamSchema,
    void,
    void,
    void
  >,
  respond: ProjectsClassicRemoveCollaboratorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicGetPermissionForUserResponder = {
  with200(): ExpressRuntimeResponse<t_project_collaborator_permission>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ProjectsClassicGetPermissionForUser = (
  params: Params<
    t_ProjectsClassicGetPermissionForUserParamSchema,
    void,
    void,
    void
  >,
  respond: ProjectsClassicGetPermissionForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicListColumnsResponder = {
  with200(): ExpressRuntimeResponse<t_project_column[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ProjectsClassicListColumns = (
  params: Params<
    t_ProjectsClassicListColumnsParamSchema,
    t_ProjectsClassicListColumnsQuerySchema,
    void,
    void
  >,
  respond: ProjectsClassicListColumnsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicCreateColumnResponder = {
  with201(): ExpressRuntimeResponse<t_project_column>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicCreateColumn = (
  params: Params<
    t_ProjectsClassicCreateColumnParamSchema,
    void,
    t_ProjectsClassicCreateColumnRequestBody,
    void
  >,
  respond: ProjectsClassicCreateColumnResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type RateLimitGetResponder = {
  with200(): ExpressRuntimeResponse<t_rate_limit_overview>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type RateLimitGet = (
  params: Params<void, void, void, void>,
  respond: RateLimitGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetResponder = {
  with200(): ExpressRuntimeResponse<t_full_repository>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGet = (
  params: Params<t_ReposGetParamSchema, void, void, void>,
  respond: ReposGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_full_repository>
  with307(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposUpdate = (
  params: Params<
    t_ReposUpdateParamSchema,
    void,
    t_ReposUpdateRequestBody | undefined,
    void
  >,
  respond: ReposUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteResponder = {
  with204(): ExpressRuntimeResponse<void>
  with307(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    message?: string | undefined
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDelete = (
  params: Params<t_ReposDeleteParamSchema, void, void, void>,
  respond: ReposDeleteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListArtifactsForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    artifacts: t_artifact[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListArtifactsForRepo = (
  params: Params<
    t_ActionsListArtifactsForRepoParamSchema,
    t_ActionsListArtifactsForRepoQuerySchema,
    void,
    void
  >,
  respond: ActionsListArtifactsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetArtifactResponder = {
  with200(): ExpressRuntimeResponse<t_artifact>
} & ExpressRuntimeResponder

export type ActionsGetArtifact = (
  params: Params<t_ActionsGetArtifactParamSchema, void, void, void>,
  respond: ActionsGetArtifactResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteArtifactResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteArtifact = (
  params: Params<t_ActionsDeleteArtifactParamSchema, void, void, void>,
  respond: ActionsDeleteArtifactResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDownloadArtifactResponder = {
  with302(): ExpressRuntimeResponse<void>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsDownloadArtifact = (
  params: Params<t_ActionsDownloadArtifactParamSchema, void, void, void>,
  respond: ActionsDownloadArtifactResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetActionsCacheUsageResponder = {
  with200(): ExpressRuntimeResponse<t_actions_cache_usage_by_repository>
} & ExpressRuntimeResponder

export type ActionsGetActionsCacheUsage = (
  params: Params<t_ActionsGetActionsCacheUsageParamSchema, void, void, void>,
  respond: ActionsGetActionsCacheUsageResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetActionsCacheListResponder = {
  with200(): ExpressRuntimeResponse<t_actions_cache_list>
} & ExpressRuntimeResponder

export type ActionsGetActionsCacheList = (
  params: Params<
    t_ActionsGetActionsCacheListParamSchema,
    t_ActionsGetActionsCacheListQuerySchema,
    void,
    void
  >,
  respond: ActionsGetActionsCacheListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteActionsCacheByKeyResponder = {
  with200(): ExpressRuntimeResponse<t_actions_cache_list>
} & ExpressRuntimeResponder

export type ActionsDeleteActionsCacheByKey = (
  params: Params<
    t_ActionsDeleteActionsCacheByKeyParamSchema,
    t_ActionsDeleteActionsCacheByKeyQuerySchema,
    void,
    void
  >,
  respond: ActionsDeleteActionsCacheByKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteActionsCacheByIdResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteActionsCacheById = (
  params: Params<t_ActionsDeleteActionsCacheByIdParamSchema, void, void, void>,
  respond: ActionsDeleteActionsCacheByIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetJobForWorkflowRunResponder = {
  with200(): ExpressRuntimeResponse<t_job>
} & ExpressRuntimeResponder

export type ActionsGetJobForWorkflowRun = (
  params: Params<t_ActionsGetJobForWorkflowRunParamSchema, void, void, void>,
  respond: ActionsGetJobForWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDownloadJobLogsForWorkflowRunResponder = {
  with302(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDownloadJobLogsForWorkflowRun = (
  params: Params<
    t_ActionsDownloadJobLogsForWorkflowRunParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDownloadJobLogsForWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsReRunJobForWorkflowRunResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsReRunJobForWorkflowRun = (
  params: Params<
    t_ActionsReRunJobForWorkflowRunParamSchema,
    void,
    t_ActionsReRunJobForWorkflowRunRequestBody | undefined,
    void
  >,
  respond: ActionsReRunJobForWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetCustomOidcSubClaimForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_oidc_custom_sub_repo>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsGetCustomOidcSubClaimForRepo = (
  params: Params<
    t_ActionsGetCustomOidcSubClaimForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetCustomOidcSubClaimForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetCustomOidcSubClaimForRepoResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsSetCustomOidcSubClaimForRepo = (
  params: Params<
    t_ActionsSetCustomOidcSubClaimForRepoParamSchema,
    void,
    t_ActionsSetCustomOidcSubClaimForRepoRequestBody,
    void
  >,
  respond: ActionsSetCustomOidcSubClaimForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRepoOrganizationSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_actions_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListRepoOrganizationSecrets = (
  params: Params<
    t_ActionsListRepoOrganizationSecretsParamSchema,
    t_ActionsListRepoOrganizationSecretsQuerySchema,
    void,
    void
  >,
  respond: ActionsListRepoOrganizationSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRepoOrganizationVariablesResponder = {
  with200(): ExpressRuntimeResponse<{
    total_count: number
    variables: t_actions_variable[]
  }>
} & ExpressRuntimeResponder

export type ActionsListRepoOrganizationVariables = (
  params: Params<
    t_ActionsListRepoOrganizationVariablesParamSchema,
    t_ActionsListRepoOrganizationVariablesQuerySchema,
    void,
    void
  >,
  respond: ActionsListRepoOrganizationVariablesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetGithubActionsPermissionsRepositoryResponder = {
  with200(): ExpressRuntimeResponse<t_actions_repository_permissions>
} & ExpressRuntimeResponder

export type ActionsGetGithubActionsPermissionsRepository = (
  params: Params<
    t_ActionsGetGithubActionsPermissionsRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetGithubActionsPermissionsRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetGithubActionsPermissionsRepositoryResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetGithubActionsPermissionsRepository = (
  params: Params<
    t_ActionsSetGithubActionsPermissionsRepositoryParamSchema,
    void,
    t_ActionsSetGithubActionsPermissionsRepositoryRequestBody,
    void
  >,
  respond: ActionsSetGithubActionsPermissionsRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetWorkflowAccessToRepositoryResponder = {
  with200(): ExpressRuntimeResponse<t_actions_workflow_access_to_repository>
} & ExpressRuntimeResponder

export type ActionsGetWorkflowAccessToRepository = (
  params: Params<
    t_ActionsGetWorkflowAccessToRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetWorkflowAccessToRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetWorkflowAccessToRepositoryResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetWorkflowAccessToRepository = (
  params: Params<
    t_ActionsSetWorkflowAccessToRepositoryParamSchema,
    void,
    t_actions_workflow_access_to_repository,
    void
  >,
  respond: ActionsSetWorkflowAccessToRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetAllowedActionsRepositoryResponder = {
  with200(): ExpressRuntimeResponse<t_selected_actions>
} & ExpressRuntimeResponder

export type ActionsGetAllowedActionsRepository = (
  params: Params<
    t_ActionsGetAllowedActionsRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetAllowedActionsRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetAllowedActionsRepositoryResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsSetAllowedActionsRepository = (
  params: Params<
    t_ActionsSetAllowedActionsRepositoryParamSchema,
    void,
    t_selected_actions | undefined,
    void
  >,
  respond: ActionsSetAllowedActionsRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponder =
  {
    with200(): ExpressRuntimeResponse<t_actions_get_default_workflow_permissions>
  } & ExpressRuntimeResponder

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepository = (
  params: Params<
    t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponder =
  {
    with204(): ExpressRuntimeResponse<void>
    with409(): ExpressRuntimeResponse<void>
  } & ExpressRuntimeResponder

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepository = (
  params: Params<
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
    void,
    t_actions_set_default_workflow_permissions,
    void
  >,
  respond: ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListSelfHostedRunnersForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    runners: t_runner[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListSelfHostedRunnersForRepo = (
  params: Params<
    t_ActionsListSelfHostedRunnersForRepoParamSchema,
    t_ActionsListSelfHostedRunnersForRepoQuerySchema,
    void,
    void
  >,
  respond: ActionsListSelfHostedRunnersForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRunnerApplicationsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_runner_application[]>
} & ExpressRuntimeResponder

export type ActionsListRunnerApplicationsForRepo = (
  params: Params<
    t_ActionsListRunnerApplicationsForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsListRunnerApplicationsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGenerateRunnerJitconfigForRepoResponder = {
  with201(): ExpressRuntimeResponse<{
    encoded_jit_config: string
    runner: t_runner
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsGenerateRunnerJitconfigForRepo = (
  params: Params<
    t_ActionsGenerateRunnerJitconfigForRepoParamSchema,
    void,
    t_ActionsGenerateRunnerJitconfigForRepoRequestBody,
    void
  >,
  respond: ActionsGenerateRunnerJitconfigForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateRegistrationTokenForRepoResponder = {
  with201(): ExpressRuntimeResponse<t_authentication_token>
} & ExpressRuntimeResponder

export type ActionsCreateRegistrationTokenForRepo = (
  params: Params<
    t_ActionsCreateRegistrationTokenForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsCreateRegistrationTokenForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateRemoveTokenForRepoResponder = {
  with201(): ExpressRuntimeResponse<t_authentication_token>
} & ExpressRuntimeResponder

export type ActionsCreateRemoveTokenForRepo = (
  params: Params<
    t_ActionsCreateRemoveTokenForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsCreateRemoveTokenForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetSelfHostedRunnerForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_runner>
} & ExpressRuntimeResponder

export type ActionsGetSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsGetSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetSelfHostedRunnerForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteSelfHostedRunnerFromRepoResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsDeleteSelfHostedRunnerFromRepo = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDeleteSelfHostedRunnerFromRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListLabelsForSelfHostedRunnerForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsListLabelsForSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsListLabelsForSelfHostedRunnerForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
    void,
    t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody,
    void
  >,
  respond: ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
    void,
    t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody,
    void
  >,
  respond: ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    labels: t_runner_label[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListWorkflowRunsForRepoResponder = {
  with200(): ExpressRuntimeResponse<{
    total_count: number
    workflow_runs: t_workflow_run[]
  }>
} & ExpressRuntimeResponder

export type ActionsListWorkflowRunsForRepo = (
  params: Params<
    t_ActionsListWorkflowRunsForRepoParamSchema,
    t_ActionsListWorkflowRunsForRepoQuerySchema,
    void,
    void
  >,
  respond: ActionsListWorkflowRunsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetWorkflowRunResponder = {
  with200(): ExpressRuntimeResponse<t_workflow_run>
} & ExpressRuntimeResponder

export type ActionsGetWorkflowRun = (
  params: Params<
    t_ActionsGetWorkflowRunParamSchema,
    t_ActionsGetWorkflowRunQuerySchema,
    void,
    void
  >,
  respond: ActionsGetWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteWorkflowRunResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteWorkflowRun = (
  params: Params<t_ActionsDeleteWorkflowRunParamSchema, void, void, void>,
  respond: ActionsDeleteWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetReviewsForRunResponder = {
  with200(): ExpressRuntimeResponse<t_environment_approvals[]>
} & ExpressRuntimeResponder

export type ActionsGetReviewsForRun = (
  params: Params<t_ActionsGetReviewsForRunParamSchema, void, void, void>,
  respond: ActionsGetReviewsForRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsApproveWorkflowRunResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsApproveWorkflowRun = (
  params: Params<t_ActionsApproveWorkflowRunParamSchema, void, void, void>,
  respond: ActionsApproveWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListWorkflowRunArtifactsResponder = {
  with200(): ExpressRuntimeResponse<{
    artifacts: t_artifact[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListWorkflowRunArtifacts = (
  params: Params<
    t_ActionsListWorkflowRunArtifactsParamSchema,
    t_ActionsListWorkflowRunArtifactsQuerySchema,
    void,
    void
  >,
  respond: ActionsListWorkflowRunArtifactsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetWorkflowRunAttemptResponder = {
  with200(): ExpressRuntimeResponse<t_workflow_run>
} & ExpressRuntimeResponder

export type ActionsGetWorkflowRunAttempt = (
  params: Params<
    t_ActionsGetWorkflowRunAttemptParamSchema,
    t_ActionsGetWorkflowRunAttemptQuerySchema,
    void,
    void
  >,
  respond: ActionsGetWorkflowRunAttemptResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListJobsForWorkflowRunAttemptResponder = {
  with200(): ExpressRuntimeResponse<{
    jobs: t_job[]
    total_count: number
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsListJobsForWorkflowRunAttempt = (
  params: Params<
    t_ActionsListJobsForWorkflowRunAttemptParamSchema,
    t_ActionsListJobsForWorkflowRunAttemptQuerySchema,
    void,
    void
  >,
  respond: ActionsListJobsForWorkflowRunAttemptResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDownloadWorkflowRunAttemptLogsResponder = {
  with302(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDownloadWorkflowRunAttemptLogs = (
  params: Params<
    t_ActionsDownloadWorkflowRunAttemptLogsParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDownloadWorkflowRunAttemptLogsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCancelWorkflowRunResponder = {
  with202(): ExpressRuntimeResponse<t_empty_object>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsCancelWorkflowRun = (
  params: Params<t_ActionsCancelWorkflowRunParamSchema, void, void, void>,
  respond: ActionsCancelWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsReviewCustomGatesForRunResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsReviewCustomGatesForRun = (
  params: Params<
    t_ActionsReviewCustomGatesForRunParamSchema,
    void,
    t_ActionsReviewCustomGatesForRunRequestBody,
    void
  >,
  respond: ActionsReviewCustomGatesForRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsForceCancelWorkflowRunResponder = {
  with202(): ExpressRuntimeResponse<t_empty_object>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsForceCancelWorkflowRun = (
  params: Params<t_ActionsForceCancelWorkflowRunParamSchema, void, void, void>,
  respond: ActionsForceCancelWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListJobsForWorkflowRunResponder = {
  with200(): ExpressRuntimeResponse<{
    jobs: t_job[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListJobsForWorkflowRun = (
  params: Params<
    t_ActionsListJobsForWorkflowRunParamSchema,
    t_ActionsListJobsForWorkflowRunQuerySchema,
    void,
    void
  >,
  respond: ActionsListJobsForWorkflowRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDownloadWorkflowRunLogsResponder = {
  with302(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDownloadWorkflowRunLogs = (
  params: Params<t_ActionsDownloadWorkflowRunLogsParamSchema, void, void, void>,
  respond: ActionsDownloadWorkflowRunLogsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteWorkflowRunLogsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActionsDeleteWorkflowRunLogs = (
  params: Params<t_ActionsDeleteWorkflowRunLogsParamSchema, void, void, void>,
  respond: ActionsDeleteWorkflowRunLogsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetPendingDeploymentsForRunResponder = {
  with200(): ExpressRuntimeResponse<t_pending_deployment[]>
} & ExpressRuntimeResponder

export type ActionsGetPendingDeploymentsForRun = (
  params: Params<
    t_ActionsGetPendingDeploymentsForRunParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsGetPendingDeploymentsForRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsReviewPendingDeploymentsForRunResponder = {
  with200(): ExpressRuntimeResponse<t_deployment[]>
} & ExpressRuntimeResponder

export type ActionsReviewPendingDeploymentsForRun = (
  params: Params<
    t_ActionsReviewPendingDeploymentsForRunParamSchema,
    void,
    t_ActionsReviewPendingDeploymentsForRunRequestBody,
    void
  >,
  respond: ActionsReviewPendingDeploymentsForRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsReRunWorkflowResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
} & ExpressRuntimeResponder

export type ActionsReRunWorkflow = (
  params: Params<
    t_ActionsReRunWorkflowParamSchema,
    void,
    t_ActionsReRunWorkflowRequestBody | undefined,
    void
  >,
  respond: ActionsReRunWorkflowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsReRunWorkflowFailedJobsResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
} & ExpressRuntimeResponder

export type ActionsReRunWorkflowFailedJobs = (
  params: Params<
    t_ActionsReRunWorkflowFailedJobsParamSchema,
    void,
    t_ActionsReRunWorkflowFailedJobsRequestBody | undefined,
    void
  >,
  respond: ActionsReRunWorkflowFailedJobsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetWorkflowRunUsageResponder = {
  with200(): ExpressRuntimeResponse<t_workflow_run_usage>
} & ExpressRuntimeResponder

export type ActionsGetWorkflowRunUsage = (
  params: Params<t_ActionsGetWorkflowRunUsageParamSchema, void, void, void>,
  respond: ActionsGetWorkflowRunUsageResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRepoSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_actions_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListRepoSecrets = (
  params: Params<
    t_ActionsListRepoSecretsParamSchema,
    t_ActionsListRepoSecretsQuerySchema,
    void,
    void
  >,
  respond: ActionsListRepoSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetRepoPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<t_actions_public_key>
} & ExpressRuntimeResponder

export type ActionsGetRepoPublicKey = (
  params: Params<t_ActionsGetRepoPublicKeyParamSchema, void, void, void>,
  respond: ActionsGetRepoPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetRepoSecretResponder = {
  with200(): ExpressRuntimeResponse<t_actions_secret>
} & ExpressRuntimeResponder

export type ActionsGetRepoSecret = (
  params: Params<t_ActionsGetRepoSecretParamSchema, void, void, void>,
  respond: ActionsGetRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateOrUpdateRepoSecretResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsCreateOrUpdateRepoSecret = (
  params: Params<
    t_ActionsCreateOrUpdateRepoSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateRepoSecretRequestBody,
    void
  >,
  respond: ActionsCreateOrUpdateRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteRepoSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteRepoSecret = (
  params: Params<t_ActionsDeleteRepoSecretParamSchema, void, void, void>,
  respond: ActionsDeleteRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRepoVariablesResponder = {
  with200(): ExpressRuntimeResponse<{
    total_count: number
    variables: t_actions_variable[]
  }>
} & ExpressRuntimeResponder

export type ActionsListRepoVariables = (
  params: Params<
    t_ActionsListRepoVariablesParamSchema,
    t_ActionsListRepoVariablesQuerySchema,
    void,
    void
  >,
  respond: ActionsListRepoVariablesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateRepoVariableResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
} & ExpressRuntimeResponder

export type ActionsCreateRepoVariable = (
  params: Params<
    t_ActionsCreateRepoVariableParamSchema,
    void,
    t_ActionsCreateRepoVariableRequestBody,
    void
  >,
  respond: ActionsCreateRepoVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetRepoVariableResponder = {
  with200(): ExpressRuntimeResponse<t_actions_variable>
} & ExpressRuntimeResponder

export type ActionsGetRepoVariable = (
  params: Params<t_ActionsGetRepoVariableParamSchema, void, void, void>,
  respond: ActionsGetRepoVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsUpdateRepoVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsUpdateRepoVariable = (
  params: Params<
    t_ActionsUpdateRepoVariableParamSchema,
    void,
    t_ActionsUpdateRepoVariableRequestBody,
    void
  >,
  respond: ActionsUpdateRepoVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteRepoVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteRepoVariable = (
  params: Params<t_ActionsDeleteRepoVariableParamSchema, void, void, void>,
  respond: ActionsDeleteRepoVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListRepoWorkflowsResponder = {
  with200(): ExpressRuntimeResponse<{
    total_count: number
    workflows: t_workflow[]
  }>
} & ExpressRuntimeResponder

export type ActionsListRepoWorkflows = (
  params: Params<
    t_ActionsListRepoWorkflowsParamSchema,
    t_ActionsListRepoWorkflowsQuerySchema,
    void,
    void
  >,
  respond: ActionsListRepoWorkflowsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetWorkflowResponder = {
  with200(): ExpressRuntimeResponse<t_workflow>
} & ExpressRuntimeResponder

export type ActionsGetWorkflow = (
  params: Params<t_ActionsGetWorkflowParamSchema, void, void, void>,
  respond: ActionsGetWorkflowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDisableWorkflowResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDisableWorkflow = (
  params: Params<t_ActionsDisableWorkflowParamSchema, void, void, void>,
  respond: ActionsDisableWorkflowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateWorkflowDispatchResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsCreateWorkflowDispatch = (
  params: Params<
    t_ActionsCreateWorkflowDispatchParamSchema,
    void,
    t_ActionsCreateWorkflowDispatchRequestBody,
    void
  >,
  respond: ActionsCreateWorkflowDispatchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsEnableWorkflowResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsEnableWorkflow = (
  params: Params<t_ActionsEnableWorkflowParamSchema, void, void, void>,
  respond: ActionsEnableWorkflowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListWorkflowRunsResponder = {
  with200(): ExpressRuntimeResponse<{
    total_count: number
    workflow_runs: t_workflow_run[]
  }>
} & ExpressRuntimeResponder

export type ActionsListWorkflowRuns = (
  params: Params<
    t_ActionsListWorkflowRunsParamSchema,
    t_ActionsListWorkflowRunsQuerySchema,
    void,
    void
  >,
  respond: ActionsListWorkflowRunsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetWorkflowUsageResponder = {
  with200(): ExpressRuntimeResponse<t_workflow_usage>
} & ExpressRuntimeResponder

export type ActionsGetWorkflowUsage = (
  params: Params<t_ActionsGetWorkflowUsageParamSchema, void, void, void>,
  respond: ActionsGetWorkflowUsageResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListActivitiesResponder = {
  with200(): ExpressRuntimeResponse<t_activity[]>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ReposListActivities = (
  params: Params<
    t_ReposListActivitiesParamSchema,
    t_ReposListActivitiesQuerySchema,
    void,
    void
  >,
  respond: ReposListActivitiesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListAssigneesResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListAssignees = (
  params: Params<
    t_IssuesListAssigneesParamSchema,
    t_IssuesListAssigneesQuerySchema,
    void,
    void
  >,
  respond: IssuesListAssigneesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesCheckUserCanBeAssignedResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesCheckUserCanBeAssigned = (
  params: Params<t_IssuesCheckUserCanBeAssignedParamSchema, void, void, void>,
  respond: IssuesCheckUserCanBeAssignedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateAttestationResponder = {
  with201(): ExpressRuntimeResponse<{
    id?: number | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateAttestation = (
  params: Params<
    t_ReposCreateAttestationParamSchema,
    void,
    t_ReposCreateAttestationRequestBody,
    void
  >,
  respond: ReposCreateAttestationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListAttestationsResponder = {
  with200(): ExpressRuntimeResponse<{
    attestations?:
      | {
          bundle?:
            | {
                dsseEnvelope?:
                  | {
                      [key: string]: unknown | undefined
                    }
                  | undefined
                mediaType?: string | undefined
                verificationMaterial?:
                  | {
                      [key: string]: unknown | undefined
                    }
                  | undefined
              }
            | undefined
          bundle_url?: string | undefined
          repository_id?: number | undefined
        }[]
      | undefined
  }>
} & ExpressRuntimeResponder

export type ReposListAttestations = (
  params: Params<
    t_ReposListAttestationsParamSchema,
    t_ReposListAttestationsQuerySchema,
    void,
    void
  >,
  respond: ReposListAttestationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListAutolinksResponder = {
  with200(): ExpressRuntimeResponse<t_autolink[]>
} & ExpressRuntimeResponder

export type ReposListAutolinks = (
  params: Params<t_ReposListAutolinksParamSchema, void, void, void>,
  respond: ReposListAutolinksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateAutolinkResponder = {
  with201(): ExpressRuntimeResponse<t_autolink>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateAutolink = (
  params: Params<
    t_ReposCreateAutolinkParamSchema,
    void,
    t_ReposCreateAutolinkRequestBody,
    void
  >,
  respond: ReposCreateAutolinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAutolinkResponder = {
  with200(): ExpressRuntimeResponse<t_autolink>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetAutolink = (
  params: Params<t_ReposGetAutolinkParamSchema, void, void, void>,
  respond: ReposGetAutolinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteAutolinkResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteAutolink = (
  params: Params<t_ReposDeleteAutolinkParamSchema, void, void, void>,
  respond: ReposDeleteAutolinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCheckAutomatedSecurityFixesResponder = {
  with200(): ExpressRuntimeResponse<t_check_automated_security_fixes>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposCheckAutomatedSecurityFixes = (
  params: Params<
    t_ReposCheckAutomatedSecurityFixesParamSchema,
    void,
    void,
    void
  >,
  respond: ReposCheckAutomatedSecurityFixesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposEnableAutomatedSecurityFixesResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposEnableAutomatedSecurityFixes = (
  params: Params<
    t_ReposEnableAutomatedSecurityFixesParamSchema,
    void,
    void,
    void
  >,
  respond: ReposEnableAutomatedSecurityFixesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDisableAutomatedSecurityFixesResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDisableAutomatedSecurityFixes = (
  params: Params<
    t_ReposDisableAutomatedSecurityFixesParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDisableAutomatedSecurityFixesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListBranchesResponder = {
  with200(): ExpressRuntimeResponse<t_short_branch[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListBranches = (
  params: Params<
    t_ReposListBranchesParamSchema,
    t_ReposListBranchesQuerySchema,
    void,
    void
  >,
  respond: ReposListBranchesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetBranchResponder = {
  with200(): ExpressRuntimeResponse<t_branch_with_protection>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetBranch = (
  params: Params<t_ReposGetBranchParamSchema, void, void, void>,
  respond: ReposGetBranchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetBranchProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_branch_protection>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetBranchProtection = (
  params: Params<t_ReposGetBranchProtectionParamSchema, void, void, void>,
  respond: ReposGetBranchProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateBranchProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_protected_branch>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ReposUpdateBranchProtection = (
  params: Params<
    t_ReposUpdateBranchProtectionParamSchema,
    void,
    t_ReposUpdateBranchProtectionRequestBody,
    void
  >,
  respond: ReposUpdateBranchProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteBranchProtectionResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteBranchProtection = (
  params: Params<t_ReposDeleteBranchProtectionParamSchema, void, void, void>,
  respond: ReposDeleteBranchProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAdminBranchProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_protected_branch_admin_enforced>
} & ExpressRuntimeResponder

export type ReposGetAdminBranchProtection = (
  params: Params<t_ReposGetAdminBranchProtectionParamSchema, void, void, void>,
  respond: ReposGetAdminBranchProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposSetAdminBranchProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_protected_branch_admin_enforced>
} & ExpressRuntimeResponder

export type ReposSetAdminBranchProtection = (
  params: Params<t_ReposSetAdminBranchProtectionParamSchema, void, void, void>,
  respond: ReposSetAdminBranchProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteAdminBranchProtectionResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteAdminBranchProtection = (
  params: Params<
    t_ReposDeleteAdminBranchProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDeleteAdminBranchProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetPullRequestReviewProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_protected_branch_pull_request_review>
} & ExpressRuntimeResponder

export type ReposGetPullRequestReviewProtection = (
  params: Params<
    t_ReposGetPullRequestReviewProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetPullRequestReviewProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdatePullRequestReviewProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_protected_branch_pull_request_review>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposUpdatePullRequestReviewProtection = (
  params: Params<
    t_ReposUpdatePullRequestReviewProtectionParamSchema,
    void,
    t_ReposUpdatePullRequestReviewProtectionRequestBody | undefined,
    void
  >,
  respond: ReposUpdatePullRequestReviewProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeletePullRequestReviewProtectionResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeletePullRequestReviewProtection = (
  params: Params<
    t_ReposDeletePullRequestReviewProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDeletePullRequestReviewProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCommitSignatureProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_protected_branch_admin_enforced>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetCommitSignatureProtection = (
  params: Params<
    t_ReposGetCommitSignatureProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetCommitSignatureProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateCommitSignatureProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_protected_branch_admin_enforced>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposCreateCommitSignatureProtection = (
  params: Params<
    t_ReposCreateCommitSignatureProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: ReposCreateCommitSignatureProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteCommitSignatureProtectionResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteCommitSignatureProtection = (
  params: Params<
    t_ReposDeleteCommitSignatureProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDeleteCommitSignatureProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetStatusChecksProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_status_check_policy>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetStatusChecksProtection = (
  params: Params<t_ReposGetStatusChecksProtectionParamSchema, void, void, void>,
  respond: ReposGetStatusChecksProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateStatusCheckProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_status_check_policy>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposUpdateStatusCheckProtection = (
  params: Params<
    t_ReposUpdateStatusCheckProtectionParamSchema,
    void,
    t_ReposUpdateStatusCheckProtectionRequestBody | undefined,
    void
  >,
  respond: ReposUpdateStatusCheckProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRemoveStatusCheckProtectionResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposRemoveStatusCheckProtection = (
  params: Params<
    t_ReposRemoveStatusCheckProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: ReposRemoveStatusCheckProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAllStatusCheckContextsResponder = {
  with200(): ExpressRuntimeResponse<string[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetAllStatusCheckContexts = (
  params: Params<t_ReposGetAllStatusCheckContextsParamSchema, void, void, void>,
  respond: ReposGetAllStatusCheckContextsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposAddStatusCheckContextsResponder = {
  with200(): ExpressRuntimeResponse<string[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposAddStatusCheckContexts = (
  params: Params<
    t_ReposAddStatusCheckContextsParamSchema,
    void,
    t_ReposAddStatusCheckContextsRequestBody | undefined,
    void
  >,
  respond: ReposAddStatusCheckContextsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposSetStatusCheckContextsResponder = {
  with200(): ExpressRuntimeResponse<string[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposSetStatusCheckContexts = (
  params: Params<
    t_ReposSetStatusCheckContextsParamSchema,
    void,
    t_ReposSetStatusCheckContextsRequestBody | undefined,
    void
  >,
  respond: ReposSetStatusCheckContextsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRemoveStatusCheckContextsResponder = {
  with200(): ExpressRuntimeResponse<string[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposRemoveStatusCheckContexts = (
  params: Params<
    t_ReposRemoveStatusCheckContextsParamSchema,
    void,
    t_ReposRemoveStatusCheckContextsRequestBody,
    void
  >,
  respond: ReposRemoveStatusCheckContextsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_branch_restriction_policy>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetAccessRestrictions = (
  params: Params<t_ReposGetAccessRestrictionsParamSchema, void, void, void>,
  respond: ReposGetAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteAccessRestrictionsResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDeleteAccessRestrictions = (
  params: Params<t_ReposDeleteAccessRestrictionsParamSchema, void, void, void>,
  respond: ReposDeleteAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAppsWithAccessToProtectedBranchResponder = {
  with200(): ExpressRuntimeResponse<t_integration[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetAppsWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetAppsWithAccessToProtectedBranchParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetAppsWithAccessToProtectedBranchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposAddAppAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_integration[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposAddAppAccessRestrictions = (
  params: Params<
    t_ReposAddAppAccessRestrictionsParamSchema,
    void,
    t_ReposAddAppAccessRestrictionsRequestBody,
    void
  >,
  respond: ReposAddAppAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposSetAppAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_integration[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposSetAppAccessRestrictions = (
  params: Params<
    t_ReposSetAppAccessRestrictionsParamSchema,
    void,
    t_ReposSetAppAccessRestrictionsRequestBody,
    void
  >,
  respond: ReposSetAppAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRemoveAppAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_integration[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposRemoveAppAccessRestrictions = (
  params: Params<
    t_ReposRemoveAppAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveAppAccessRestrictionsRequestBody,
    void
  >,
  respond: ReposRemoveAppAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetTeamsWithAccessToProtectedBranchResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetTeamsWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetTeamsWithAccessToProtectedBranchParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetTeamsWithAccessToProtectedBranchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposAddTeamAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposAddTeamAccessRestrictions = (
  params: Params<
    t_ReposAddTeamAccessRestrictionsParamSchema,
    void,
    t_ReposAddTeamAccessRestrictionsRequestBody | undefined,
    void
  >,
  respond: ReposAddTeamAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposSetTeamAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposSetTeamAccessRestrictions = (
  params: Params<
    t_ReposSetTeamAccessRestrictionsParamSchema,
    void,
    t_ReposSetTeamAccessRestrictionsRequestBody | undefined,
    void
  >,
  respond: ReposSetTeamAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRemoveTeamAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposRemoveTeamAccessRestrictions = (
  params: Params<
    t_ReposRemoveTeamAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveTeamAccessRestrictionsRequestBody,
    void
  >,
  respond: ReposRemoveTeamAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetUsersWithAccessToProtectedBranchResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetUsersWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetUsersWithAccessToProtectedBranchParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetUsersWithAccessToProtectedBranchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposAddUserAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposAddUserAccessRestrictions = (
  params: Params<
    t_ReposAddUserAccessRestrictionsParamSchema,
    void,
    t_ReposAddUserAccessRestrictionsRequestBody,
    void
  >,
  respond: ReposAddUserAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposSetUserAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposSetUserAccessRestrictions = (
  params: Params<
    t_ReposSetUserAccessRestrictionsParamSchema,
    void,
    t_ReposSetUserAccessRestrictionsRequestBody,
    void
  >,
  respond: ReposSetUserAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRemoveUserAccessRestrictionsResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposRemoveUserAccessRestrictions = (
  params: Params<
    t_ReposRemoveUserAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveUserAccessRestrictionsRequestBody,
    void
  >,
  respond: ReposRemoveUserAccessRestrictionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRenameBranchResponder = {
  with201(): ExpressRuntimeResponse<t_branch_with_protection>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposRenameBranch = (
  params: Params<
    t_ReposRenameBranchParamSchema,
    void,
    t_ReposRenameBranchRequestBody,
    void
  >,
  respond: ReposRenameBranchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksCreateResponder = {
  with201(): ExpressRuntimeResponse<t_check_run>
} & ExpressRuntimeResponder

export type ChecksCreate = (
  params: Params<
    t_ChecksCreateParamSchema,
    void,
    t_ChecksCreateRequestBody,
    void
  >,
  respond: ChecksCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksGetResponder = {
  with200(): ExpressRuntimeResponse<t_check_run>
} & ExpressRuntimeResponder

export type ChecksGet = (
  params: Params<t_ChecksGetParamSchema, void, void, void>,
  respond: ChecksGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_check_run>
} & ExpressRuntimeResponder

export type ChecksUpdate = (
  params: Params<
    t_ChecksUpdateParamSchema,
    void,
    t_ChecksUpdateRequestBody,
    void
  >,
  respond: ChecksUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksListAnnotationsResponder = {
  with200(): ExpressRuntimeResponse<t_check_annotation[]>
} & ExpressRuntimeResponder

export type ChecksListAnnotations = (
  params: Params<
    t_ChecksListAnnotationsParamSchema,
    t_ChecksListAnnotationsQuerySchema,
    void,
    void
  >,
  respond: ChecksListAnnotationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksRerequestRunResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ChecksRerequestRun = (
  params: Params<t_ChecksRerequestRunParamSchema, void, void, void>,
  respond: ChecksRerequestRunResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksCreateSuiteResponder = {
  with200(): ExpressRuntimeResponse<t_check_suite>
  with201(): ExpressRuntimeResponse<t_check_suite>
} & ExpressRuntimeResponder

export type ChecksCreateSuite = (
  params: Params<
    t_ChecksCreateSuiteParamSchema,
    void,
    t_ChecksCreateSuiteRequestBody,
    void
  >,
  respond: ChecksCreateSuiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksSetSuitesPreferencesResponder = {
  with200(): ExpressRuntimeResponse<t_check_suite_preference>
} & ExpressRuntimeResponder

export type ChecksSetSuitesPreferences = (
  params: Params<
    t_ChecksSetSuitesPreferencesParamSchema,
    void,
    t_ChecksSetSuitesPreferencesRequestBody,
    void
  >,
  respond: ChecksSetSuitesPreferencesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksGetSuiteResponder = {
  with200(): ExpressRuntimeResponse<t_check_suite>
} & ExpressRuntimeResponder

export type ChecksGetSuite = (
  params: Params<t_ChecksGetSuiteParamSchema, void, void, void>,
  respond: ChecksGetSuiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksListForSuiteResponder = {
  with200(): ExpressRuntimeResponse<{
    check_runs: t_check_run[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ChecksListForSuite = (
  params: Params<
    t_ChecksListForSuiteParamSchema,
    t_ChecksListForSuiteQuerySchema,
    void,
    void
  >,
  respond: ChecksListForSuiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksRerequestSuiteResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
} & ExpressRuntimeResponder

export type ChecksRerequestSuite = (
  params: Params<t_ChecksRerequestSuiteParamSchema, void, void, void>,
  respond: ChecksRerequestSuiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningListAlertsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_alert_items[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningListAlertsForRepo = (
  params: Params<
    t_CodeScanningListAlertsForRepoParamSchema,
    t_CodeScanningListAlertsForRepoQuerySchema,
    void,
    void
  >,
  respond: CodeScanningListAlertsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetAlertResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_alert>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetAlert = (
  params: Params<t_CodeScanningGetAlertParamSchema, void, void, void>,
  respond: CodeScanningGetAlertResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningUpdateAlertResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_alert>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningUpdateAlert = (
  params: Params<
    t_CodeScanningUpdateAlertParamSchema,
    void,
    t_CodeScanningUpdateAlertRequestBody,
    void
  >,
  respond: CodeScanningUpdateAlertResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetAutofixResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_autofix>
  with400(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetAutofix = (
  params: Params<t_CodeScanningGetAutofixParamSchema, void, void, void>,
  respond: CodeScanningGetAutofixResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningCreateAutofixResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_autofix>
  with202(): ExpressRuntimeResponse<t_code_scanning_autofix>
  with400(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningCreateAutofix = (
  params: Params<t_CodeScanningCreateAutofixParamSchema, void, void, void>,
  respond: CodeScanningCreateAutofixResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningCommitAutofixResponder = {
  with201(): ExpressRuntimeResponse<t_code_scanning_autofix_commits_response>
  with400(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningCommitAutofix = (
  params: Params<
    t_CodeScanningCommitAutofixParamSchema,
    void,
    t_code_scanning_autofix_commits | undefined,
    void
  >,
  respond: CodeScanningCommitAutofixResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningListAlertInstancesResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_alert_instance[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningListAlertInstances = (
  params: Params<
    t_CodeScanningListAlertInstancesParamSchema,
    t_CodeScanningListAlertInstancesQuerySchema,
    void,
    void
  >,
  respond: CodeScanningListAlertInstancesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningListRecentAnalysesResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_analysis[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningListRecentAnalyses = (
  params: Params<
    t_CodeScanningListRecentAnalysesParamSchema,
    t_CodeScanningListRecentAnalysesQuerySchema,
    void,
    void
  >,
  respond: CodeScanningListRecentAnalysesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetAnalysisResponder = {
  with200(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetAnalysis = (
  params: Params<t_CodeScanningGetAnalysisParamSchema, void, void, void>,
  respond: CodeScanningGetAnalysisResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningDeleteAnalysisResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_analysis_deletion>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningDeleteAnalysis = (
  params: Params<
    t_CodeScanningDeleteAnalysisParamSchema,
    t_CodeScanningDeleteAnalysisQuerySchema,
    void,
    void
  >,
  respond: CodeScanningDeleteAnalysisResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningListCodeqlDatabasesResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_codeql_database[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningListCodeqlDatabases = (
  params: Params<
    t_CodeScanningListCodeqlDatabasesParamSchema,
    void,
    void,
    void
  >,
  respond: CodeScanningListCodeqlDatabasesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetCodeqlDatabaseResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_codeql_database>
  with302(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetCodeqlDatabase = (
  params: Params<t_CodeScanningGetCodeqlDatabaseParamSchema, void, void, void>,
  respond: CodeScanningGetCodeqlDatabaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningDeleteCodeqlDatabaseResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningDeleteCodeqlDatabase = (
  params: Params<
    t_CodeScanningDeleteCodeqlDatabaseParamSchema,
    void,
    void,
    void
  >,
  respond: CodeScanningDeleteCodeqlDatabaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningCreateVariantAnalysisResponder = {
  with201(): ExpressRuntimeResponse<t_code_scanning_variant_analysis>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningCreateVariantAnalysis = (
  params: Params<
    t_CodeScanningCreateVariantAnalysisParamSchema,
    void,
    t_CodeScanningCreateVariantAnalysisRequestBody,
    void
  >,
  respond: CodeScanningCreateVariantAnalysisResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetVariantAnalysisResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_variant_analysis>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetVariantAnalysis = (
  params: Params<t_CodeScanningGetVariantAnalysisParamSchema, void, void, void>,
  respond: CodeScanningGetVariantAnalysisResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetVariantAnalysisRepoTaskResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_variant_analysis_repo_task>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetVariantAnalysisRepoTask = (
  params: Params<
    t_CodeScanningGetVariantAnalysisRepoTaskParamSchema,
    void,
    void,
    void
  >,
  respond: CodeScanningGetVariantAnalysisRepoTaskResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetDefaultSetupResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_default_setup>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetDefaultSetup = (
  params: Params<t_CodeScanningGetDefaultSetupParamSchema, void, void, void>,
  respond: CodeScanningGetDefaultSetupResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningUpdateDefaultSetupResponder = {
  with200(): ExpressRuntimeResponse<t_empty_object>
  with202(): ExpressRuntimeResponse<t_code_scanning_default_setup_update_response>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningUpdateDefaultSetup = (
  params: Params<
    t_CodeScanningUpdateDefaultSetupParamSchema,
    void,
    t_code_scanning_default_setup_update,
    void
  >,
  respond: CodeScanningUpdateDefaultSetupResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningUploadSarifResponder = {
  with202(): ExpressRuntimeResponse<t_code_scanning_sarifs_receipt>
  with400(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with413(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningUploadSarif = (
  params: Params<
    t_CodeScanningUploadSarifParamSchema,
    void,
    t_CodeScanningUploadSarifRequestBody,
    void
  >,
  respond: CodeScanningUploadSarifResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeScanningGetSarifResponder = {
  with200(): ExpressRuntimeResponse<t_code_scanning_sarifs_status>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodeScanningGetSarif = (
  params: Params<t_CodeScanningGetSarifParamSchema, void, void, void>,
  respond: CodeScanningGetSarifResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodeSecurityGetConfigurationForRepositoryResponder = {
  with200(): ExpressRuntimeResponse<t_code_security_configuration_for_repository>
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodeSecurityGetConfigurationForRepository = (
  params: Params<
    t_CodeSecurityGetConfigurationForRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: CodeSecurityGetConfigurationForRepositoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCodeownersErrorsResponder = {
  with200(): ExpressRuntimeResponse<t_codeowners_errors>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposCodeownersErrors = (
  params: Params<
    t_ReposCodeownersErrorsParamSchema,
    t_ReposCodeownersErrorsQuerySchema,
    void,
    void
  >,
  respond: ReposCodeownersErrorsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListInRepositoryForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    codespaces: t_codespace[]
    total_count: number
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesListInRepositoryForAuthenticatedUser = (
  params: Params<
    t_CodespacesListInRepositoryForAuthenticatedUserParamSchema,
    t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: CodespacesListInRepositoryForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCreateWithRepoForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_codespace>
  with202(): ExpressRuntimeResponse<t_codespace>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodespacesCreateWithRepoForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateWithRepoForAuthenticatedUserRequestBody,
    void
  >,
  respond: CodespacesCreateWithRepoForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponder =
  {
    with200(): ExpressRuntimeResponse<{
      devcontainers: {
        display_name?: string | undefined
        name?: string | undefined
        path: string
      }[]
      total_count: number
    }>
    with400(): ExpressRuntimeResponse<t_scim_error>
    with401(): ExpressRuntimeResponse<t_basic_error>
    with403(): ExpressRuntimeResponse<t_basic_error>
    with404(): ExpressRuntimeResponse<t_basic_error>
    with500(): ExpressRuntimeResponse<t_basic_error>
  } & ExpressRuntimeResponder

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser = (
  params: Params<
    t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
    t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesRepoMachinesForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    machines: t_codespace_machine[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesRepoMachinesForAuthenticatedUser = (
  params: Params<
    t_CodespacesRepoMachinesForAuthenticatedUserParamSchema,
    t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: CodespacesRepoMachinesForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesPreFlightWithRepoForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    billable_owner?: t_simple_user | undefined
    defaults?:
      | {
          devcontainer_path: string | null
          location: string
        }
      | undefined
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesPreFlightWithRepoForAuthenticatedUser = (
  params: Params<
    t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
    t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: CodespacesPreFlightWithRepoForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCheckPermissionsForDevcontainerResponder = {
  with200(): ExpressRuntimeResponse<t_codespaces_permissions_check_for_devcontainer>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodespacesCheckPermissionsForDevcontainer = (
  params: Params<
    t_CodespacesCheckPermissionsForDevcontainerParamSchema,
    t_CodespacesCheckPermissionsForDevcontainerQuerySchema,
    void,
    void
  >,
  respond: CodespacesCheckPermissionsForDevcontainerResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListRepoSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_repo_codespaces_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type CodespacesListRepoSecrets = (
  params: Params<
    t_CodespacesListRepoSecretsParamSchema,
    t_CodespacesListRepoSecretsQuerySchema,
    void,
    void
  >,
  respond: CodespacesListRepoSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetRepoPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<t_codespaces_public_key>
} & ExpressRuntimeResponder

export type CodespacesGetRepoPublicKey = (
  params: Params<t_CodespacesGetRepoPublicKeyParamSchema, void, void, void>,
  respond: CodespacesGetRepoPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetRepoSecretResponder = {
  with200(): ExpressRuntimeResponse<t_repo_codespaces_secret>
} & ExpressRuntimeResponder

export type CodespacesGetRepoSecret = (
  params: Params<t_CodespacesGetRepoSecretParamSchema, void, void, void>,
  respond: CodespacesGetRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCreateOrUpdateRepoSecretResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type CodespacesCreateOrUpdateRepoSecret = (
  params: Params<
    t_CodespacesCreateOrUpdateRepoSecretParamSchema,
    void,
    t_CodespacesCreateOrUpdateRepoSecretRequestBody,
    void
  >,
  respond: CodespacesCreateOrUpdateRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesDeleteRepoSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type CodespacesDeleteRepoSecret = (
  params: Params<t_CodespacesDeleteRepoSecretParamSchema, void, void, void>,
  respond: CodespacesDeleteRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListCollaboratorsResponder = {
  with200(): ExpressRuntimeResponse<t_collaborator[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListCollaborators = (
  params: Params<
    t_ReposListCollaboratorsParamSchema,
    t_ReposListCollaboratorsQuerySchema,
    void,
    void
  >,
  respond: ReposListCollaboratorsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCheckCollaboratorResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposCheckCollaborator = (
  params: Params<t_ReposCheckCollaboratorParamSchema, void, void, void>,
  respond: ReposCheckCollaboratorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposAddCollaboratorResponder = {
  with201(): ExpressRuntimeResponse<t_repository_invitation>
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposAddCollaborator = (
  params: Params<
    t_ReposAddCollaboratorParamSchema,
    void,
    t_ReposAddCollaboratorRequestBody | undefined,
    void
  >,
  respond: ReposAddCollaboratorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRemoveCollaboratorResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposRemoveCollaborator = (
  params: Params<t_ReposRemoveCollaboratorParamSchema, void, void, void>,
  respond: ReposRemoveCollaboratorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCollaboratorPermissionLevelResponder = {
  with200(): ExpressRuntimeResponse<t_repository_collaborator_permission>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetCollaboratorPermissionLevel = (
  params: Params<
    t_ReposGetCollaboratorPermissionLevelParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetCollaboratorPermissionLevelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListCommitCommentsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_commit_comment[]>
} & ExpressRuntimeResponder

export type ReposListCommitCommentsForRepo = (
  params: Params<
    t_ReposListCommitCommentsForRepoParamSchema,
    t_ReposListCommitCommentsForRepoQuerySchema,
    void,
    void
  >,
  respond: ReposListCommitCommentsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCommitCommentResponder = {
  with200(): ExpressRuntimeResponse<t_commit_comment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetCommitComment = (
  params: Params<t_ReposGetCommitCommentParamSchema, void, void, void>,
  respond: ReposGetCommitCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateCommitCommentResponder = {
  with200(): ExpressRuntimeResponse<t_commit_comment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposUpdateCommitComment = (
  params: Params<
    t_ReposUpdateCommitCommentParamSchema,
    void,
    t_ReposUpdateCommitCommentRequestBody,
    void
  >,
  respond: ReposUpdateCommitCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteCommitCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteCommitComment = (
  params: Params<t_ReposDeleteCommitCommentParamSchema, void, void, void>,
  respond: ReposDeleteCommitCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForCommitCommentResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReactionsListForCommitComment = (
  params: Params<
    t_ReactionsListForCommitCommentParamSchema,
    t_ReactionsListForCommitCommentQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForCommitCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForCommitCommentResponder = {
  with200(): ExpressRuntimeResponse<t_reaction>
  with201(): ExpressRuntimeResponse<t_reaction>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReactionsCreateForCommitComment = (
  params: Params<
    t_ReactionsCreateForCommitCommentParamSchema,
    void,
    t_ReactionsCreateForCommitCommentRequestBody,
    void
  >,
  respond: ReactionsCreateForCommitCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsDeleteForCommitCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReactionsDeleteForCommitComment = (
  params: Params<
    t_ReactionsDeleteForCommitCommentParamSchema,
    void,
    void,
    void
  >,
  respond: ReactionsDeleteForCommitCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListCommitsResponder = {
  with200(): ExpressRuntimeResponse<t_commit[]>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListCommits = (
  params: Params<
    t_ReposListCommitsParamSchema,
    t_ReposListCommitsQuerySchema,
    void,
    void
  >,
  respond: ReposListCommitsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListBranchesForHeadCommitResponder = {
  with200(): ExpressRuntimeResponse<t_branch_short[]>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposListBranchesForHeadCommit = (
  params: Params<t_ReposListBranchesForHeadCommitParamSchema, void, void, void>,
  respond: ReposListBranchesForHeadCommitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListCommentsForCommitResponder = {
  with200(): ExpressRuntimeResponse<t_commit_comment[]>
} & ExpressRuntimeResponder

export type ReposListCommentsForCommit = (
  params: Params<
    t_ReposListCommentsForCommitParamSchema,
    t_ReposListCommentsForCommitQuerySchema,
    void,
    void
  >,
  respond: ReposListCommentsForCommitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateCommitCommentResponder = {
  with201(): ExpressRuntimeResponse<t_commit_comment>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateCommitComment = (
  params: Params<
    t_ReposCreateCommitCommentParamSchema,
    void,
    t_ReposCreateCommitCommentRequestBody,
    void
  >,
  respond: ReposCreateCommitCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListPullRequestsAssociatedWithCommitResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_simple[]>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListPullRequestsAssociatedWithCommit = (
  params: Params<
    t_ReposListPullRequestsAssociatedWithCommitParamSchema,
    t_ReposListPullRequestsAssociatedWithCommitQuerySchema,
    void,
    void
  >,
  respond: ReposListPullRequestsAssociatedWithCommitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCommitResponder = {
  with200(): ExpressRuntimeResponse<t_commit>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type ReposGetCommit = (
  params: Params<
    t_ReposGetCommitParamSchema,
    t_ReposGetCommitQuerySchema,
    void,
    void
  >,
  respond: ReposGetCommitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksListForRefResponder = {
  with200(): ExpressRuntimeResponse<{
    check_runs: t_check_run[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ChecksListForRef = (
  params: Params<
    t_ChecksListForRefParamSchema,
    t_ChecksListForRefQuerySchema,
    void,
    void
  >,
  respond: ChecksListForRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChecksListSuitesForRefResponder = {
  with200(): ExpressRuntimeResponse<{
    check_suites: t_check_suite[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ChecksListSuitesForRef = (
  params: Params<
    t_ChecksListSuitesForRefParamSchema,
    t_ChecksListSuitesForRefQuerySchema,
    void,
    void
  >,
  respond: ChecksListSuitesForRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCombinedStatusForRefResponder = {
  with200(): ExpressRuntimeResponse<t_combined_commit_status>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetCombinedStatusForRef = (
  params: Params<
    t_ReposGetCombinedStatusForRefParamSchema,
    t_ReposGetCombinedStatusForRefQuerySchema,
    void,
    void
  >,
  respond: ReposGetCombinedStatusForRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListCommitStatusesForRefResponder = {
  with200(): ExpressRuntimeResponse<t_status[]>
  with301(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListCommitStatusesForRef = (
  params: Params<
    t_ReposListCommitStatusesForRefParamSchema,
    t_ReposListCommitStatusesForRefQuerySchema,
    void,
    void
  >,
  respond: ReposListCommitStatusesForRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCommunityProfileMetricsResponder = {
  with200(): ExpressRuntimeResponse<t_community_profile>
} & ExpressRuntimeResponder

export type ReposGetCommunityProfileMetrics = (
  params: Params<
    t_ReposGetCommunityProfileMetricsParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetCommunityProfileMetricsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCompareCommitsResponder = {
  with200(): ExpressRuntimeResponse<t_commit_comparison>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type ReposCompareCommits = (
  params: Params<
    t_ReposCompareCommitsParamSchema,
    t_ReposCompareCommitsQuerySchema,
    void,
    void
  >,
  respond: ReposCompareCommitsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetContentResponder = {
  with200(): ExpressRuntimeResponse<
    | t_content_directory
    | t_content_file
    | t_content_symlink
    | t_content_submodule
  >
  with302(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetContent = (
  params: Params<
    t_ReposGetContentParamSchema,
    t_ReposGetContentQuerySchema,
    void,
    void
  >,
  respond: ReposGetContentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateOrUpdateFileContentsResponder = {
  with200(): ExpressRuntimeResponse<t_file_commit>
  with201(): ExpressRuntimeResponse<t_file_commit>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<
    t_basic_error | t_repository_rule_violation_error
  >
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateOrUpdateFileContents = (
  params: Params<
    t_ReposCreateOrUpdateFileContentsParamSchema,
    void,
    t_ReposCreateOrUpdateFileContentsRequestBody,
    void
  >,
  respond: ReposCreateOrUpdateFileContentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteFileResponder = {
  with200(): ExpressRuntimeResponse<t_file_commit>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type ReposDeleteFile = (
  params: Params<
    t_ReposDeleteFileParamSchema,
    void,
    t_ReposDeleteFileRequestBody,
    void
  >,
  respond: ReposDeleteFileResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListContributorsResponder = {
  with200(): ExpressRuntimeResponse<t_contributor[]>
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListContributors = (
  params: Params<
    t_ReposListContributorsParamSchema,
    t_ReposListContributorsQuerySchema,
    void,
    void
  >,
  respond: ReposListContributorsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotListAlertsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_alert[]>
  with304(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type DependabotListAlertsForRepo = (
  params: Params<
    t_DependabotListAlertsForRepoParamSchema,
    t_DependabotListAlertsForRepoQuerySchema,
    void,
    void
  >,
  respond: DependabotListAlertsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotGetAlertResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_alert>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type DependabotGetAlert = (
  params: Params<t_DependabotGetAlertParamSchema, void, void, void>,
  respond: DependabotGetAlertResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotUpdateAlertResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_alert>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type DependabotUpdateAlert = (
  params: Params<
    t_DependabotUpdateAlertParamSchema,
    void,
    t_DependabotUpdateAlertRequestBody,
    void
  >,
  respond: DependabotUpdateAlertResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotListRepoSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_dependabot_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type DependabotListRepoSecrets = (
  params: Params<
    t_DependabotListRepoSecretsParamSchema,
    t_DependabotListRepoSecretsQuerySchema,
    void,
    void
  >,
  respond: DependabotListRepoSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotGetRepoPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_public_key>
} & ExpressRuntimeResponder

export type DependabotGetRepoPublicKey = (
  params: Params<t_DependabotGetRepoPublicKeyParamSchema, void, void, void>,
  respond: DependabotGetRepoPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotGetRepoSecretResponder = {
  with200(): ExpressRuntimeResponse<t_dependabot_secret>
} & ExpressRuntimeResponder

export type DependabotGetRepoSecret = (
  params: Params<t_DependabotGetRepoSecretParamSchema, void, void, void>,
  respond: DependabotGetRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotCreateOrUpdateRepoSecretResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DependabotCreateOrUpdateRepoSecret = (
  params: Params<
    t_DependabotCreateOrUpdateRepoSecretParamSchema,
    void,
    t_DependabotCreateOrUpdateRepoSecretRequestBody,
    void
  >,
  respond: DependabotCreateOrUpdateRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependabotDeleteRepoSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DependabotDeleteRepoSecret = (
  params: Params<t_DependabotDeleteRepoSecretParamSchema, void, void, void>,
  respond: DependabotDeleteRepoSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependencyGraphDiffRangeResponder = {
  with200(): ExpressRuntimeResponse<t_dependency_graph_diff>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type DependencyGraphDiffRange = (
  params: Params<
    t_DependencyGraphDiffRangeParamSchema,
    t_DependencyGraphDiffRangeQuerySchema,
    void,
    void
  >,
  respond: DependencyGraphDiffRangeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependencyGraphExportSbomResponder = {
  with200(): ExpressRuntimeResponse<t_dependency_graph_spdx_sbom>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type DependencyGraphExportSbom = (
  params: Params<t_DependencyGraphExportSbomParamSchema, void, void, void>,
  respond: DependencyGraphExportSbomResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DependencyGraphCreateRepositorySnapshotResponder = {
  with201(): ExpressRuntimeResponse<{
    created_at: string
    id: number
    message: string
    result: string
  }>
} & ExpressRuntimeResponder

export type DependencyGraphCreateRepositorySnapshot = (
  params: Params<
    t_DependencyGraphCreateRepositorySnapshotParamSchema,
    void,
    t_snapshot,
    void
  >,
  respond: DependencyGraphCreateRepositorySnapshotResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListDeploymentsResponder = {
  with200(): ExpressRuntimeResponse<t_deployment[]>
} & ExpressRuntimeResponder

export type ReposListDeployments = (
  params: Params<
    t_ReposListDeploymentsParamSchema,
    t_ReposListDeploymentsQuerySchema,
    void,
    void
  >,
  respond: ReposListDeploymentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateDeploymentResponder = {
  with201(): ExpressRuntimeResponse<t_deployment>
  with202(): ExpressRuntimeResponse<{
    message?: string | undefined
  }>
  with409(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateDeployment = (
  params: Params<
    t_ReposCreateDeploymentParamSchema,
    void,
    t_ReposCreateDeploymentRequestBody,
    void
  >,
  respond: ReposCreateDeploymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetDeploymentResponder = {
  with200(): ExpressRuntimeResponse<t_deployment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetDeployment = (
  params: Params<t_ReposGetDeploymentParamSchema, void, void, void>,
  respond: ReposGetDeploymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteDeploymentResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ReposDeleteDeployment = (
  params: Params<t_ReposDeleteDeploymentParamSchema, void, void, void>,
  respond: ReposDeleteDeploymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListDeploymentStatusesResponder = {
  with200(): ExpressRuntimeResponse<t_deployment_status[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListDeploymentStatuses = (
  params: Params<
    t_ReposListDeploymentStatusesParamSchema,
    t_ReposListDeploymentStatusesQuerySchema,
    void,
    void
  >,
  respond: ReposListDeploymentStatusesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateDeploymentStatusResponder = {
  with201(): ExpressRuntimeResponse<t_deployment_status>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateDeploymentStatus = (
  params: Params<
    t_ReposCreateDeploymentStatusParamSchema,
    void,
    t_ReposCreateDeploymentStatusRequestBody,
    void
  >,
  respond: ReposCreateDeploymentStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetDeploymentStatusResponder = {
  with200(): ExpressRuntimeResponse<t_deployment_status>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetDeploymentStatus = (
  params: Params<t_ReposGetDeploymentStatusParamSchema, void, void, void>,
  respond: ReposGetDeploymentStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateDispatchEventResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateDispatchEvent = (
  params: Params<
    t_ReposCreateDispatchEventParamSchema,
    void,
    t_ReposCreateDispatchEventRequestBody,
    void
  >,
  respond: ReposCreateDispatchEventResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAllEnvironmentsResponder = {
  with200(): ExpressRuntimeResponse<{
    environments?: t_environment[] | undefined
    total_count?: number | undefined
  }>
} & ExpressRuntimeResponder

export type ReposGetAllEnvironments = (
  params: Params<
    t_ReposGetAllEnvironmentsParamSchema,
    t_ReposGetAllEnvironmentsQuerySchema,
    void,
    void
  >,
  respond: ReposGetAllEnvironmentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetEnvironmentResponder = {
  with200(): ExpressRuntimeResponse<t_environment>
} & ExpressRuntimeResponder

export type ReposGetEnvironment = (
  params: Params<t_ReposGetEnvironmentParamSchema, void, void, void>,
  respond: ReposGetEnvironmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateOrUpdateEnvironmentResponder = {
  with200(): ExpressRuntimeResponse<t_environment>
  with422(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposCreateOrUpdateEnvironment = (
  params: Params<
    t_ReposCreateOrUpdateEnvironmentParamSchema,
    void,
    t_ReposCreateOrUpdateEnvironmentRequestBody | undefined,
    void
  >,
  respond: ReposCreateOrUpdateEnvironmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteAnEnvironmentResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDeleteAnEnvironment = (
  params: Params<t_ReposDeleteAnEnvironmentParamSchema, void, void, void>,
  respond: ReposDeleteAnEnvironmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListDeploymentBranchPoliciesResponder = {
  with200(): ExpressRuntimeResponse<{
    branch_policies: t_deployment_branch_policy[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ReposListDeploymentBranchPolicies = (
  params: Params<
    t_ReposListDeploymentBranchPoliciesParamSchema,
    t_ReposListDeploymentBranchPoliciesQuerySchema,
    void,
    void
  >,
  respond: ReposListDeploymentBranchPoliciesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateDeploymentBranchPolicyResponder = {
  with200(): ExpressRuntimeResponse<t_deployment_branch_policy>
  with303(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposCreateDeploymentBranchPolicy = (
  params: Params<
    t_ReposCreateDeploymentBranchPolicyParamSchema,
    void,
    t_deployment_branch_policy_name_pattern_with_type,
    void
  >,
  respond: ReposCreateDeploymentBranchPolicyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetDeploymentBranchPolicyResponder = {
  with200(): ExpressRuntimeResponse<t_deployment_branch_policy>
} & ExpressRuntimeResponder

export type ReposGetDeploymentBranchPolicy = (
  params: Params<t_ReposGetDeploymentBranchPolicyParamSchema, void, void, void>,
  respond: ReposGetDeploymentBranchPolicyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateDeploymentBranchPolicyResponder = {
  with200(): ExpressRuntimeResponse<t_deployment_branch_policy>
} & ExpressRuntimeResponder

export type ReposUpdateDeploymentBranchPolicy = (
  params: Params<
    t_ReposUpdateDeploymentBranchPolicyParamSchema,
    void,
    t_deployment_branch_policy_name_pattern,
    void
  >,
  respond: ReposUpdateDeploymentBranchPolicyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteDeploymentBranchPolicyResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDeleteDeploymentBranchPolicy = (
  params: Params<
    t_ReposDeleteDeploymentBranchPolicyParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDeleteDeploymentBranchPolicyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAllDeploymentProtectionRulesResponder = {
  with200(): ExpressRuntimeResponse<{
    custom_deployment_protection_rules?:
      | t_deployment_protection_rule[]
      | undefined
    total_count?: number | undefined
  }>
} & ExpressRuntimeResponder

export type ReposGetAllDeploymentProtectionRules = (
  params: Params<
    t_ReposGetAllDeploymentProtectionRulesParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetAllDeploymentProtectionRulesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateDeploymentProtectionRuleResponder = {
  with201(): ExpressRuntimeResponse<t_deployment_protection_rule>
} & ExpressRuntimeResponder

export type ReposCreateDeploymentProtectionRule = (
  params: Params<
    t_ReposCreateDeploymentProtectionRuleParamSchema,
    void,
    t_ReposCreateDeploymentProtectionRuleRequestBody,
    void
  >,
  respond: ReposCreateDeploymentProtectionRuleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListCustomDeploymentRuleIntegrationsResponder = {
  with200(): ExpressRuntimeResponse<{
    available_custom_deployment_protection_rule_integrations?:
      | t_custom_deployment_rule_app[]
      | undefined
    total_count?: number | undefined
  }>
} & ExpressRuntimeResponder

export type ReposListCustomDeploymentRuleIntegrations = (
  params: Params<
    t_ReposListCustomDeploymentRuleIntegrationsParamSchema,
    t_ReposListCustomDeploymentRuleIntegrationsQuerySchema,
    void,
    void
  >,
  respond: ReposListCustomDeploymentRuleIntegrationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCustomDeploymentProtectionRuleResponder = {
  with200(): ExpressRuntimeResponse<t_deployment_protection_rule>
} & ExpressRuntimeResponder

export type ReposGetCustomDeploymentProtectionRule = (
  params: Params<
    t_ReposGetCustomDeploymentProtectionRuleParamSchema,
    void,
    void,
    void
  >,
  respond: ReposGetCustomDeploymentProtectionRuleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDisableDeploymentProtectionRuleResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDisableDeploymentProtectionRule = (
  params: Params<
    t_ReposDisableDeploymentProtectionRuleParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDisableDeploymentProtectionRuleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListEnvironmentSecretsResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_actions_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type ActionsListEnvironmentSecrets = (
  params: Params<
    t_ActionsListEnvironmentSecretsParamSchema,
    t_ActionsListEnvironmentSecretsQuerySchema,
    void,
    void
  >,
  respond: ActionsListEnvironmentSecretsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetEnvironmentPublicKeyResponder = {
  with200(): ExpressRuntimeResponse<t_actions_public_key>
} & ExpressRuntimeResponder

export type ActionsGetEnvironmentPublicKey = (
  params: Params<t_ActionsGetEnvironmentPublicKeyParamSchema, void, void, void>,
  respond: ActionsGetEnvironmentPublicKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetEnvironmentSecretResponder = {
  with200(): ExpressRuntimeResponse<t_actions_secret>
} & ExpressRuntimeResponder

export type ActionsGetEnvironmentSecret = (
  params: Params<t_ActionsGetEnvironmentSecretParamSchema, void, void, void>,
  respond: ActionsGetEnvironmentSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateOrUpdateEnvironmentSecretResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsCreateOrUpdateEnvironmentSecret = (
  params: Params<
    t_ActionsCreateOrUpdateEnvironmentSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateEnvironmentSecretRequestBody,
    void
  >,
  respond: ActionsCreateOrUpdateEnvironmentSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteEnvironmentSecretResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteEnvironmentSecret = (
  params: Params<t_ActionsDeleteEnvironmentSecretParamSchema, void, void, void>,
  respond: ActionsDeleteEnvironmentSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsListEnvironmentVariablesResponder = {
  with200(): ExpressRuntimeResponse<{
    total_count: number
    variables: t_actions_variable[]
  }>
} & ExpressRuntimeResponder

export type ActionsListEnvironmentVariables = (
  params: Params<
    t_ActionsListEnvironmentVariablesParamSchema,
    t_ActionsListEnvironmentVariablesQuerySchema,
    void,
    void
  >,
  respond: ActionsListEnvironmentVariablesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsCreateEnvironmentVariableResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
} & ExpressRuntimeResponder

export type ActionsCreateEnvironmentVariable = (
  params: Params<
    t_ActionsCreateEnvironmentVariableParamSchema,
    void,
    t_ActionsCreateEnvironmentVariableRequestBody,
    void
  >,
  respond: ActionsCreateEnvironmentVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsGetEnvironmentVariableResponder = {
  with200(): ExpressRuntimeResponse<t_actions_variable>
} & ExpressRuntimeResponder

export type ActionsGetEnvironmentVariable = (
  params: Params<t_ActionsGetEnvironmentVariableParamSchema, void, void, void>,
  respond: ActionsGetEnvironmentVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsUpdateEnvironmentVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsUpdateEnvironmentVariable = (
  params: Params<
    t_ActionsUpdateEnvironmentVariableParamSchema,
    void,
    t_ActionsUpdateEnvironmentVariableRequestBody,
    void
  >,
  respond: ActionsUpdateEnvironmentVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActionsDeleteEnvironmentVariableResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActionsDeleteEnvironmentVariable = (
  params: Params<
    t_ActionsDeleteEnvironmentVariableParamSchema,
    void,
    void,
    void
  >,
  respond: ActionsDeleteEnvironmentVariableResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListRepoEventsResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
} & ExpressRuntimeResponder

export type ActivityListRepoEvents = (
  params: Params<
    t_ActivityListRepoEventsParamSchema,
    t_ActivityListRepoEventsQuerySchema,
    void,
    void
  >,
  respond: ActivityListRepoEventsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListForksResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with400(): ExpressRuntimeResponse<t_scim_error>
} & ExpressRuntimeResponder

export type ReposListForks = (
  params: Params<
    t_ReposListForksParamSchema,
    t_ReposListForksQuerySchema,
    void,
    void
  >,
  respond: ReposListForksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateForkResponder = {
  with202(): ExpressRuntimeResponse<t_full_repository>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateFork = (
  params: Params<
    t_ReposCreateForkParamSchema,
    void,
    t_ReposCreateForkRequestBody | undefined,
    void
  >,
  respond: ReposCreateForkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitCreateBlobResponder = {
  with201(): ExpressRuntimeResponse<t_short_blob>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<
    t_validation_error | t_repository_rule_violation_error
  >
} & ExpressRuntimeResponder

export type GitCreateBlob = (
  params: Params<
    t_GitCreateBlobParamSchema,
    void,
    t_GitCreateBlobRequestBody,
    void
  >,
  respond: GitCreateBlobResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitGetBlobResponder = {
  with200(): ExpressRuntimeResponse<t_blob>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GitGetBlob = (
  params: Params<t_GitGetBlobParamSchema, void, void, void>,
  respond: GitGetBlobResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitCreateCommitResponder = {
  with201(): ExpressRuntimeResponse<t_git_commit>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GitCreateCommit = (
  params: Params<
    t_GitCreateCommitParamSchema,
    void,
    t_GitCreateCommitRequestBody,
    void
  >,
  respond: GitCreateCommitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitGetCommitResponder = {
  with200(): ExpressRuntimeResponse<t_git_commit>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GitGetCommit = (
  params: Params<t_GitGetCommitParamSchema, void, void, void>,
  respond: GitGetCommitResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitListMatchingRefsResponder = {
  with200(): ExpressRuntimeResponse<t_git_ref[]>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GitListMatchingRefs = (
  params: Params<t_GitListMatchingRefsParamSchema, void, void, void>,
  respond: GitListMatchingRefsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitGetRefResponder = {
  with200(): ExpressRuntimeResponse<t_git_ref>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GitGetRef = (
  params: Params<t_GitGetRefParamSchema, void, void, void>,
  respond: GitGetRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitCreateRefResponder = {
  with201(): ExpressRuntimeResponse<t_git_ref>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GitCreateRef = (
  params: Params<
    t_GitCreateRefParamSchema,
    void,
    t_GitCreateRefRequestBody,
    void
  >,
  respond: GitCreateRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitUpdateRefResponder = {
  with200(): ExpressRuntimeResponse<t_git_ref>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GitUpdateRef = (
  params: Params<
    t_GitUpdateRefParamSchema,
    void,
    t_GitUpdateRefRequestBody,
    void
  >,
  respond: GitUpdateRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitDeleteRefResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type GitDeleteRef = (
  params: Params<t_GitDeleteRefParamSchema, void, void, void>,
  respond: GitDeleteRefResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitCreateTagResponder = {
  with201(): ExpressRuntimeResponse<t_git_tag>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GitCreateTag = (
  params: Params<
    t_GitCreateTagParamSchema,
    void,
    t_GitCreateTagRequestBody,
    void
  >,
  respond: GitCreateTagResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitGetTagResponder = {
  with200(): ExpressRuntimeResponse<t_git_tag>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type GitGetTag = (
  params: Params<t_GitGetTagParamSchema, void, void, void>,
  respond: GitGetTagResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitCreateTreeResponder = {
  with201(): ExpressRuntimeResponse<t_git_tree>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GitCreateTree = (
  params: Params<
    t_GitCreateTreeParamSchema,
    void,
    t_GitCreateTreeRequestBody,
    void
  >,
  respond: GitCreateTreeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GitGetTreeResponder = {
  with200(): ExpressRuntimeResponse<t_git_tree>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GitGetTree = (
  params: Params<t_GitGetTreeParamSchema, t_GitGetTreeQuerySchema, void, void>,
  respond: GitGetTreeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListWebhooksResponder = {
  with200(): ExpressRuntimeResponse<t_hook[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListWebhooks = (
  params: Params<
    t_ReposListWebhooksParamSchema,
    t_ReposListWebhooksQuerySchema,
    void,
    void
  >,
  respond: ReposListWebhooksResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateWebhookResponder = {
  with201(): ExpressRuntimeResponse<t_hook>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateWebhook = (
  params: Params<
    t_ReposCreateWebhookParamSchema,
    void,
    t_ReposCreateWebhookRequestBody | undefined,
    void
  >,
  respond: ReposCreateWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetWebhookResponder = {
  with200(): ExpressRuntimeResponse<t_hook>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetWebhook = (
  params: Params<t_ReposGetWebhookParamSchema, void, void, void>,
  respond: ReposGetWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateWebhookResponder = {
  with200(): ExpressRuntimeResponse<t_hook>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposUpdateWebhook = (
  params: Params<
    t_ReposUpdateWebhookParamSchema,
    void,
    t_ReposUpdateWebhookRequestBody,
    void
  >,
  respond: ReposUpdateWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteWebhookResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteWebhook = (
  params: Params<t_ReposDeleteWebhookParamSchema, void, void, void>,
  respond: ReposDeleteWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetWebhookConfigForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_config>
} & ExpressRuntimeResponder

export type ReposGetWebhookConfigForRepo = (
  params: Params<t_ReposGetWebhookConfigForRepoParamSchema, void, void, void>,
  respond: ReposGetWebhookConfigForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateWebhookConfigForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_webhook_config>
} & ExpressRuntimeResponder

export type ReposUpdateWebhookConfigForRepo = (
  params: Params<
    t_ReposUpdateWebhookConfigForRepoParamSchema,
    void,
    t_ReposUpdateWebhookConfigForRepoRequestBody | undefined,
    void
  >,
  respond: ReposUpdateWebhookConfigForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListWebhookDeliveriesResponder = {
  with200(): ExpressRuntimeResponse<t_hook_delivery_item[]>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposListWebhookDeliveries = (
  params: Params<
    t_ReposListWebhookDeliveriesParamSchema,
    t_ReposListWebhookDeliveriesQuerySchema,
    void,
    void
  >,
  respond: ReposListWebhookDeliveriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetWebhookDeliveryResponder = {
  with200(): ExpressRuntimeResponse<t_hook_delivery>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposGetWebhookDelivery = (
  params: Params<t_ReposGetWebhookDeliveryParamSchema, void, void, void>,
  respond: ReposGetWebhookDeliveryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRedeliverWebhookDeliveryResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposRedeliverWebhookDelivery = (
  params: Params<t_ReposRedeliverWebhookDeliveryParamSchema, void, void, void>,
  respond: ReposRedeliverWebhookDeliveryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposPingWebhookResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposPingWebhook = (
  params: Params<t_ReposPingWebhookParamSchema, void, void, void>,
  respond: ReposPingWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposTestPushWebhookResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposTestPushWebhook = (
  params: Params<t_ReposTestPushWebhookParamSchema, void, void, void>,
  respond: ReposTestPushWebhookResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsGetImportStatusResponder = {
  with200(): ExpressRuntimeResponse<t_import>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsGetImportStatus = (
  params: Params<t_MigrationsGetImportStatusParamSchema, void, void, void>,
  respond: MigrationsGetImportStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsStartImportResponder = {
  with201(): ExpressRuntimeResponse<t_import>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsStartImport = (
  params: Params<
    t_MigrationsStartImportParamSchema,
    void,
    t_MigrationsStartImportRequestBody,
    void
  >,
  respond: MigrationsStartImportResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsUpdateImportResponder = {
  with200(): ExpressRuntimeResponse<t_import>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsUpdateImport = (
  params: Params<
    t_MigrationsUpdateImportParamSchema,
    void,
    t_MigrationsUpdateImportRequestBody | undefined,
    void
  >,
  respond: MigrationsUpdateImportResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsCancelImportResponder = {
  with204(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsCancelImport = (
  params: Params<t_MigrationsCancelImportParamSchema, void, void, void>,
  respond: MigrationsCancelImportResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsGetCommitAuthorsResponder = {
  with200(): ExpressRuntimeResponse<t_porter_author[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsGetCommitAuthors = (
  params: Params<
    t_MigrationsGetCommitAuthorsParamSchema,
    t_MigrationsGetCommitAuthorsQuerySchema,
    void,
    void
  >,
  respond: MigrationsGetCommitAuthorsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsMapCommitAuthorResponder = {
  with200(): ExpressRuntimeResponse<t_porter_author>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsMapCommitAuthor = (
  params: Params<
    t_MigrationsMapCommitAuthorParamSchema,
    void,
    t_MigrationsMapCommitAuthorRequestBody | undefined,
    void
  >,
  respond: MigrationsMapCommitAuthorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsGetLargeFilesResponder = {
  with200(): ExpressRuntimeResponse<t_porter_large_file[]>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsGetLargeFiles = (
  params: Params<t_MigrationsGetLargeFilesParamSchema, void, void, void>,
  respond: MigrationsGetLargeFilesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsSetLfsPreferenceResponder = {
  with200(): ExpressRuntimeResponse<t_import>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsSetLfsPreference = (
  params: Params<
    t_MigrationsSetLfsPreferenceParamSchema,
    void,
    t_MigrationsSetLfsPreferenceRequestBody,
    void
  >,
  respond: MigrationsSetLfsPreferenceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetRepoInstallationResponder = {
  with200(): ExpressRuntimeResponse<t_installation>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsGetRepoInstallation = (
  params: Params<t_AppsGetRepoInstallationParamSchema, void, void, void>,
  respond: AppsGetRepoInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsGetRestrictionsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_interaction_limit_response | EmptyObject>
} & ExpressRuntimeResponder

export type InteractionsGetRestrictionsForRepo = (
  params: Params<
    t_InteractionsGetRestrictionsForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: InteractionsGetRestrictionsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsSetRestrictionsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_interaction_limit_response>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type InteractionsSetRestrictionsForRepo = (
  params: Params<
    t_InteractionsSetRestrictionsForRepoParamSchema,
    void,
    t_interaction_limit,
    void
  >,
  respond: InteractionsSetRestrictionsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsRemoveRestrictionsForRepoResponder = {
  with204(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type InteractionsRemoveRestrictionsForRepo = (
  params: Params<
    t_InteractionsRemoveRestrictionsForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: InteractionsRemoveRestrictionsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListInvitationsResponder = {
  with200(): ExpressRuntimeResponse<t_repository_invitation[]>
} & ExpressRuntimeResponder

export type ReposListInvitations = (
  params: Params<
    t_ReposListInvitationsParamSchema,
    t_ReposListInvitationsQuerySchema,
    void,
    void
  >,
  respond: ReposListInvitationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateInvitationResponder = {
  with200(): ExpressRuntimeResponse<t_repository_invitation>
} & ExpressRuntimeResponder

export type ReposUpdateInvitation = (
  params: Params<
    t_ReposUpdateInvitationParamSchema,
    void,
    t_ReposUpdateInvitationRequestBody | undefined,
    void
  >,
  respond: ReposUpdateInvitationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteInvitationResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDeleteInvitation = (
  params: Params<t_ReposDeleteInvitationParamSchema, void, void, void>,
  respond: ReposDeleteInvitationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_issue[]>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesListForRepo = (
  params: Params<
    t_IssuesListForRepoParamSchema,
    t_IssuesListForRepoQuerySchema,
    void,
    void
  >,
  respond: IssuesListForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesCreateResponder = {
  with201(): ExpressRuntimeResponse<t_issue>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type IssuesCreate = (
  params: Params<
    t_IssuesCreateParamSchema,
    void,
    t_IssuesCreateRequestBody,
    void
  >,
  respond: IssuesCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListCommentsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_issue_comment[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesListCommentsForRepo = (
  params: Params<
    t_IssuesListCommentsForRepoParamSchema,
    t_IssuesListCommentsForRepoQuerySchema,
    void,
    void
  >,
  respond: IssuesListCommentsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesGetCommentResponder = {
  with200(): ExpressRuntimeResponse<t_issue_comment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesGetComment = (
  params: Params<t_IssuesGetCommentParamSchema, void, void, void>,
  respond: IssuesGetCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesUpdateCommentResponder = {
  with200(): ExpressRuntimeResponse<t_issue_comment>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesUpdateComment = (
  params: Params<
    t_IssuesUpdateCommentParamSchema,
    void,
    t_IssuesUpdateCommentRequestBody,
    void
  >,
  respond: IssuesUpdateCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesDeleteCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type IssuesDeleteComment = (
  params: Params<t_IssuesDeleteCommentParamSchema, void, void, void>,
  respond: IssuesDeleteCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForIssueCommentResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReactionsListForIssueComment = (
  params: Params<
    t_ReactionsListForIssueCommentParamSchema,
    t_ReactionsListForIssueCommentQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForIssueCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForIssueCommentResponder = {
  with200(): ExpressRuntimeResponse<t_reaction>
  with201(): ExpressRuntimeResponse<t_reaction>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReactionsCreateForIssueComment = (
  params: Params<
    t_ReactionsCreateForIssueCommentParamSchema,
    void,
    t_ReactionsCreateForIssueCommentRequestBody,
    void
  >,
  respond: ReactionsCreateForIssueCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsDeleteForIssueCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReactionsDeleteForIssueComment = (
  params: Params<t_ReactionsDeleteForIssueCommentParamSchema, void, void, void>,
  respond: ReactionsDeleteForIssueCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListEventsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_issue_event[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesListEventsForRepo = (
  params: Params<
    t_IssuesListEventsForRepoParamSchema,
    t_IssuesListEventsForRepoQuerySchema,
    void,
    void
  >,
  respond: IssuesListEventsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesGetEventResponder = {
  with200(): ExpressRuntimeResponse<t_issue_event>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesGetEvent = (
  params: Params<t_IssuesGetEventParamSchema, void, void, void>,
  respond: IssuesGetEventResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesGetResponder = {
  with200(): ExpressRuntimeResponse<t_issue>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesGet = (
  params: Params<t_IssuesGetParamSchema, void, void, void>,
  respond: IssuesGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_issue>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type IssuesUpdate = (
  params: Params<
    t_IssuesUpdateParamSchema,
    void,
    t_IssuesUpdateRequestBody | undefined,
    void
  >,
  respond: IssuesUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesAddAssigneesResponder = {
  with201(): ExpressRuntimeResponse<t_issue>
} & ExpressRuntimeResponder

export type IssuesAddAssignees = (
  params: Params<
    t_IssuesAddAssigneesParamSchema,
    void,
    t_IssuesAddAssigneesRequestBody | undefined,
    void
  >,
  respond: IssuesAddAssigneesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesRemoveAssigneesResponder = {
  with200(): ExpressRuntimeResponse<t_issue>
} & ExpressRuntimeResponder

export type IssuesRemoveAssignees = (
  params: Params<
    t_IssuesRemoveAssigneesParamSchema,
    void,
    t_IssuesRemoveAssigneesRequestBody,
    void
  >,
  respond: IssuesRemoveAssigneesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesCheckUserCanBeAssignedToIssueResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesCheckUserCanBeAssignedToIssue = (
  params: Params<
    t_IssuesCheckUserCanBeAssignedToIssueParamSchema,
    void,
    void,
    void
  >,
  respond: IssuesCheckUserCanBeAssignedToIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListCommentsResponder = {
  with200(): ExpressRuntimeResponse<t_issue_comment[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListComments = (
  params: Params<
    t_IssuesListCommentsParamSchema,
    t_IssuesListCommentsQuerySchema,
    void,
    void
  >,
  respond: IssuesListCommentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesCreateCommentResponder = {
  with201(): ExpressRuntimeResponse<t_issue_comment>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesCreateComment = (
  params: Params<
    t_IssuesCreateCommentParamSchema,
    void,
    t_IssuesCreateCommentRequestBody,
    void
  >,
  respond: IssuesCreateCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListEventsResponder = {
  with200(): ExpressRuntimeResponse<t_issue_event_for_issue[]>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListEvents = (
  params: Params<
    t_IssuesListEventsParamSchema,
    t_IssuesListEventsQuerySchema,
    void,
    void
  >,
  respond: IssuesListEventsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListLabelsOnIssueResponder = {
  with200(): ExpressRuntimeResponse<t_label[]>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListLabelsOnIssue = (
  params: Params<
    t_IssuesListLabelsOnIssueParamSchema,
    t_IssuesListLabelsOnIssueQuerySchema,
    void,
    void
  >,
  respond: IssuesListLabelsOnIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesAddLabelsResponder = {
  with200(): ExpressRuntimeResponse<t_label[]>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesAddLabels = (
  params: Params<
    t_IssuesAddLabelsParamSchema,
    void,
    t_IssuesAddLabelsRequestBody | undefined,
    void
  >,
  respond: IssuesAddLabelsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesSetLabelsResponder = {
  with200(): ExpressRuntimeResponse<t_label[]>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesSetLabels = (
  params: Params<
    t_IssuesSetLabelsParamSchema,
    void,
    t_IssuesSetLabelsRequestBody | undefined,
    void
  >,
  respond: IssuesSetLabelsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesRemoveAllLabelsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesRemoveAllLabels = (
  params: Params<t_IssuesRemoveAllLabelsParamSchema, void, void, void>,
  respond: IssuesRemoveAllLabelsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesRemoveLabelResponder = {
  with200(): ExpressRuntimeResponse<t_label[]>
  with301(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesRemoveLabel = (
  params: Params<t_IssuesRemoveLabelParamSchema, void, void, void>,
  respond: IssuesRemoveLabelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesLockResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesLock = (
  params: Params<
    t_IssuesLockParamSchema,
    void,
    t_IssuesLockRequestBody | undefined,
    void
  >,
  respond: IssuesLockResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesUnlockResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesUnlock = (
  params: Params<t_IssuesUnlockParamSchema, void, void, void>,
  respond: IssuesUnlockResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForIssueResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReactionsListForIssue = (
  params: Params<
    t_ReactionsListForIssueParamSchema,
    t_ReactionsListForIssueQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForIssueResponder = {
  with200(): ExpressRuntimeResponse<t_reaction>
  with201(): ExpressRuntimeResponse<t_reaction>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReactionsCreateForIssue = (
  params: Params<
    t_ReactionsCreateForIssueParamSchema,
    void,
    t_ReactionsCreateForIssueRequestBody,
    void
  >,
  respond: ReactionsCreateForIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsDeleteForIssueResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReactionsDeleteForIssue = (
  params: Params<t_ReactionsDeleteForIssueParamSchema, void, void, void>,
  respond: ReactionsDeleteForIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesRemoveSubIssueResponder = {
  with200(): ExpressRuntimeResponse<t_issue>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesRemoveSubIssue = (
  params: Params<
    t_IssuesRemoveSubIssueParamSchema,
    void,
    t_IssuesRemoveSubIssueRequestBody,
    void
  >,
  respond: IssuesRemoveSubIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListSubIssuesResponder = {
  with200(): ExpressRuntimeResponse<t_issue[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListSubIssues = (
  params: Params<
    t_IssuesListSubIssuesParamSchema,
    t_IssuesListSubIssuesQuerySchema,
    void,
    void
  >,
  respond: IssuesListSubIssuesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesAddSubIssueResponder = {
  with201(): ExpressRuntimeResponse<t_issue>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesAddSubIssue = (
  params: Params<
    t_IssuesAddSubIssueParamSchema,
    void,
    t_IssuesAddSubIssueRequestBody,
    void
  >,
  respond: IssuesAddSubIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesReprioritizeSubIssueResponder = {
  with200(): ExpressRuntimeResponse<t_issue>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type IssuesReprioritizeSubIssue = (
  params: Params<
    t_IssuesReprioritizeSubIssueParamSchema,
    void,
    t_IssuesReprioritizeSubIssueRequestBody,
    void
  >,
  respond: IssuesReprioritizeSubIssueResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListEventsForTimelineResponder = {
  with200(): ExpressRuntimeResponse<t_timeline_issue_events[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListEventsForTimeline = (
  params: Params<
    t_IssuesListEventsForTimelineParamSchema,
    t_IssuesListEventsForTimelineQuerySchema,
    void,
    void
  >,
  respond: IssuesListEventsForTimelineResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListDeployKeysResponder = {
  with200(): ExpressRuntimeResponse<t_deploy_key[]>
} & ExpressRuntimeResponder

export type ReposListDeployKeys = (
  params: Params<
    t_ReposListDeployKeysParamSchema,
    t_ReposListDeployKeysQuerySchema,
    void,
    void
  >,
  respond: ReposListDeployKeysResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateDeployKeyResponder = {
  with201(): ExpressRuntimeResponse<t_deploy_key>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateDeployKey = (
  params: Params<
    t_ReposCreateDeployKeyParamSchema,
    void,
    t_ReposCreateDeployKeyRequestBody,
    void
  >,
  respond: ReposCreateDeployKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetDeployKeyResponder = {
  with200(): ExpressRuntimeResponse<t_deploy_key>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetDeployKey = (
  params: Params<t_ReposGetDeployKeyParamSchema, void, void, void>,
  respond: ReposGetDeployKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteDeployKeyResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDeleteDeployKey = (
  params: Params<t_ReposDeleteDeployKeyParamSchema, void, void, void>,
  respond: ReposDeleteDeployKeyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListLabelsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_label[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListLabelsForRepo = (
  params: Params<
    t_IssuesListLabelsForRepoParamSchema,
    t_IssuesListLabelsForRepoQuerySchema,
    void,
    void
  >,
  respond: IssuesListLabelsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesCreateLabelResponder = {
  with201(): ExpressRuntimeResponse<t_label>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesCreateLabel = (
  params: Params<
    t_IssuesCreateLabelParamSchema,
    void,
    t_IssuesCreateLabelRequestBody,
    void
  >,
  respond: IssuesCreateLabelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesGetLabelResponder = {
  with200(): ExpressRuntimeResponse<t_label>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesGetLabel = (
  params: Params<t_IssuesGetLabelParamSchema, void, void, void>,
  respond: IssuesGetLabelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesUpdateLabelResponder = {
  with200(): ExpressRuntimeResponse<t_label>
} & ExpressRuntimeResponder

export type IssuesUpdateLabel = (
  params: Params<
    t_IssuesUpdateLabelParamSchema,
    void,
    t_IssuesUpdateLabelRequestBody | undefined,
    void
  >,
  respond: IssuesUpdateLabelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesDeleteLabelResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type IssuesDeleteLabel = (
  params: Params<t_IssuesDeleteLabelParamSchema, void, void, void>,
  respond: IssuesDeleteLabelResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListLanguagesResponder = {
  with200(): ExpressRuntimeResponse<t_language>
} & ExpressRuntimeResponder

export type ReposListLanguages = (
  params: Params<t_ReposListLanguagesParamSchema, void, void, void>,
  respond: ReposListLanguagesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LicensesGetForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_license_content>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type LicensesGetForRepo = (
  params: Params<
    t_LicensesGetForRepoParamSchema,
    t_LicensesGetForRepoQuerySchema,
    void,
    void
  >,
  respond: LicensesGetForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposMergeUpstreamResponder = {
  with200(): ExpressRuntimeResponse<t_merged_upstream>
  with409(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposMergeUpstream = (
  params: Params<
    t_ReposMergeUpstreamParamSchema,
    void,
    t_ReposMergeUpstreamRequestBody,
    void
  >,
  respond: ReposMergeUpstreamResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposMergeResponder = {
  with201(): ExpressRuntimeResponse<t_commit>
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<void>
  with409(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposMerge = (
  params: Params<t_ReposMergeParamSchema, void, t_ReposMergeRequestBody, void>,
  respond: ReposMergeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListMilestonesResponder = {
  with200(): ExpressRuntimeResponse<t_milestone[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListMilestones = (
  params: Params<
    t_IssuesListMilestonesParamSchema,
    t_IssuesListMilestonesQuerySchema,
    void,
    void
  >,
  respond: IssuesListMilestonesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesCreateMilestoneResponder = {
  with201(): ExpressRuntimeResponse<t_milestone>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type IssuesCreateMilestone = (
  params: Params<
    t_IssuesCreateMilestoneParamSchema,
    void,
    t_IssuesCreateMilestoneRequestBody,
    void
  >,
  respond: IssuesCreateMilestoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesGetMilestoneResponder = {
  with200(): ExpressRuntimeResponse<t_milestone>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesGetMilestone = (
  params: Params<t_IssuesGetMilestoneParamSchema, void, void, void>,
  respond: IssuesGetMilestoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesUpdateMilestoneResponder = {
  with200(): ExpressRuntimeResponse<t_milestone>
} & ExpressRuntimeResponder

export type IssuesUpdateMilestone = (
  params: Params<
    t_IssuesUpdateMilestoneParamSchema,
    void,
    t_IssuesUpdateMilestoneRequestBody | undefined,
    void
  >,
  respond: IssuesUpdateMilestoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesDeleteMilestoneResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesDeleteMilestone = (
  params: Params<t_IssuesDeleteMilestoneParamSchema, void, void, void>,
  respond: IssuesDeleteMilestoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListLabelsForMilestoneResponder = {
  with200(): ExpressRuntimeResponse<t_label[]>
} & ExpressRuntimeResponder

export type IssuesListLabelsForMilestone = (
  params: Params<
    t_IssuesListLabelsForMilestoneParamSchema,
    t_IssuesListLabelsForMilestoneQuerySchema,
    void,
    void
  >,
  respond: IssuesListLabelsForMilestoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListRepoNotificationsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_thread[]>
} & ExpressRuntimeResponder

export type ActivityListRepoNotificationsForAuthenticatedUser = (
  params: Params<
    t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema,
    t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListRepoNotificationsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityMarkRepoNotificationsAsReadResponder = {
  with202(): ExpressRuntimeResponse<{
    message?: string | undefined
    url?: string | undefined
  }>
  with205(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActivityMarkRepoNotificationsAsRead = (
  params: Params<
    t_ActivityMarkRepoNotificationsAsReadParamSchema,
    void,
    t_ActivityMarkRepoNotificationsAsReadRequestBody | undefined,
    void
  >,
  respond: ActivityMarkRepoNotificationsAsReadResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetPagesResponder = {
  with200(): ExpressRuntimeResponse<t_page>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetPages = (
  params: Params<t_ReposGetPagesParamSchema, void, void, void>,
  respond: ReposGetPagesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreatePagesSiteResponder = {
  with201(): ExpressRuntimeResponse<t_page>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreatePagesSite = (
  params: Params<
    t_ReposCreatePagesSiteParamSchema,
    void,
    t_ReposCreatePagesSiteRequestBody,
    void
  >,
  respond: ReposCreatePagesSiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateInformationAboutPagesSiteResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposUpdateInformationAboutPagesSite = (
  params: Params<
    t_ReposUpdateInformationAboutPagesSiteParamSchema,
    void,
    t_ReposUpdateInformationAboutPagesSiteRequestBody,
    void
  >,
  respond: ReposUpdateInformationAboutPagesSiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeletePagesSiteResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposDeletePagesSite = (
  params: Params<t_ReposDeletePagesSiteParamSchema, void, void, void>,
  respond: ReposDeletePagesSiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListPagesBuildsResponder = {
  with200(): ExpressRuntimeResponse<t_page_build[]>
} & ExpressRuntimeResponder

export type ReposListPagesBuilds = (
  params: Params<
    t_ReposListPagesBuildsParamSchema,
    t_ReposListPagesBuildsQuerySchema,
    void,
    void
  >,
  respond: ReposListPagesBuildsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposRequestPagesBuildResponder = {
  with201(): ExpressRuntimeResponse<t_page_build_status>
} & ExpressRuntimeResponder

export type ReposRequestPagesBuild = (
  params: Params<t_ReposRequestPagesBuildParamSchema, void, void, void>,
  respond: ReposRequestPagesBuildResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetLatestPagesBuildResponder = {
  with200(): ExpressRuntimeResponse<t_page_build>
} & ExpressRuntimeResponder

export type ReposGetLatestPagesBuild = (
  params: Params<t_ReposGetLatestPagesBuildParamSchema, void, void, void>,
  respond: ReposGetLatestPagesBuildResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetPagesBuildResponder = {
  with200(): ExpressRuntimeResponse<t_page_build>
} & ExpressRuntimeResponder

export type ReposGetPagesBuild = (
  params: Params<t_ReposGetPagesBuildParamSchema, void, void, void>,
  respond: ReposGetPagesBuildResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreatePagesDeploymentResponder = {
  with200(): ExpressRuntimeResponse<t_page_deployment>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreatePagesDeployment = (
  params: Params<
    t_ReposCreatePagesDeploymentParamSchema,
    void,
    t_ReposCreatePagesDeploymentRequestBody,
    void
  >,
  respond: ReposCreatePagesDeploymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetPagesDeploymentResponder = {
  with200(): ExpressRuntimeResponse<t_pages_deployment_status>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetPagesDeployment = (
  params: Params<t_ReposGetPagesDeploymentParamSchema, void, void, void>,
  respond: ReposGetPagesDeploymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCancelPagesDeploymentResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposCancelPagesDeployment = (
  params: Params<t_ReposCancelPagesDeploymentParamSchema, void, void, void>,
  respond: ReposCancelPagesDeploymentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetPagesHealthCheckResponder = {
  with200(): ExpressRuntimeResponse<t_pages_health_check>
  with202(): ExpressRuntimeResponse<t_empty_object>
  with400(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposGetPagesHealthCheck = (
  params: Params<t_ReposGetPagesHealthCheckParamSchema, void, void, void>,
  respond: ReposGetPagesHealthCheckResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCheckPrivateVulnerabilityReportingResponder = {
  with200(): ExpressRuntimeResponse<{
    enabled: boolean
  }>
  with422(): ExpressRuntimeResponse<t_scim_error>
} & ExpressRuntimeResponder

export type ReposCheckPrivateVulnerabilityReporting = (
  params: Params<
    t_ReposCheckPrivateVulnerabilityReportingParamSchema,
    void,
    void,
    void
  >,
  respond: ReposCheckPrivateVulnerabilityReportingResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposEnablePrivateVulnerabilityReportingResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_scim_error>
} & ExpressRuntimeResponder

export type ReposEnablePrivateVulnerabilityReporting = (
  params: Params<
    t_ReposEnablePrivateVulnerabilityReportingParamSchema,
    void,
    void,
    void
  >,
  respond: ReposEnablePrivateVulnerabilityReportingResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDisablePrivateVulnerabilityReportingResponder = {
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_scim_error>
} & ExpressRuntimeResponder

export type ReposDisablePrivateVulnerabilityReporting = (
  params: Params<
    t_ReposDisablePrivateVulnerabilityReportingParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDisablePrivateVulnerabilityReportingResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicListForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_project[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicListForRepo = (
  params: Params<
    t_ProjectsClassicListForRepoParamSchema,
    t_ProjectsClassicListForRepoQuerySchema,
    void,
    void
  >,
  respond: ProjectsClassicListForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicCreateForRepoResponder = {
  with201(): ExpressRuntimeResponse<t_project>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with410(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicCreateForRepo = (
  params: Params<
    t_ProjectsClassicCreateForRepoParamSchema,
    void,
    t_ProjectsClassicCreateForRepoRequestBody,
    void
  >,
  respond: ProjectsClassicCreateForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCustomPropertiesValuesResponder = {
  with200(): ExpressRuntimeResponse<t_custom_property_value[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetCustomPropertiesValues = (
  params: Params<t_ReposGetCustomPropertiesValuesParamSchema, void, void, void>,
  respond: ReposGetCustomPropertiesValuesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateOrUpdateCustomPropertiesValuesResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateOrUpdateCustomPropertiesValues = (
  params: Params<
    t_ReposCreateOrUpdateCustomPropertiesValuesParamSchema,
    void,
    t_ReposCreateOrUpdateCustomPropertiesValuesRequestBody,
    void
  >,
  respond: ReposCreateOrUpdateCustomPropertiesValuesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_simple[]>
  with304(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PullsList = (
  params: Params<t_PullsListParamSchema, t_PullsListQuerySchema, void, void>,
  respond: PullsListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsCreateResponder = {
  with201(): ExpressRuntimeResponse<t_pull_request>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PullsCreate = (
  params: Params<
    t_PullsCreateParamSchema,
    void,
    t_PullsCreateRequestBody,
    void
  >,
  respond: PullsCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListReviewCommentsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review_comment[]>
} & ExpressRuntimeResponder

export type PullsListReviewCommentsForRepo = (
  params: Params<
    t_PullsListReviewCommentsForRepoParamSchema,
    t_PullsListReviewCommentsForRepoQuerySchema,
    void,
    void
  >,
  respond: PullsListReviewCommentsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsGetReviewCommentResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review_comment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PullsGetReviewComment = (
  params: Params<t_PullsGetReviewCommentParamSchema, void, void, void>,
  respond: PullsGetReviewCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsUpdateReviewCommentResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review_comment>
} & ExpressRuntimeResponder

export type PullsUpdateReviewComment = (
  params: Params<
    t_PullsUpdateReviewCommentParamSchema,
    void,
    t_PullsUpdateReviewCommentRequestBody,
    void
  >,
  respond: PullsUpdateReviewCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsDeleteReviewCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PullsDeleteReviewComment = (
  params: Params<t_PullsDeleteReviewCommentParamSchema, void, void, void>,
  respond: PullsDeleteReviewCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForPullRequestReviewCommentResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReactionsListForPullRequestReviewComment = (
  params: Params<
    t_ReactionsListForPullRequestReviewCommentParamSchema,
    t_ReactionsListForPullRequestReviewCommentQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForPullRequestReviewCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForPullRequestReviewCommentResponder = {
  with200(): ExpressRuntimeResponse<t_reaction>
  with201(): ExpressRuntimeResponse<t_reaction>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReactionsCreateForPullRequestReviewComment = (
  params: Params<
    t_ReactionsCreateForPullRequestReviewCommentParamSchema,
    void,
    t_ReactionsCreateForPullRequestReviewCommentRequestBody,
    void
  >,
  respond: ReactionsCreateForPullRequestReviewCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsDeleteForPullRequestCommentResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReactionsDeleteForPullRequestComment = (
  params: Params<
    t_ReactionsDeleteForPullRequestCommentParamSchema,
    void,
    void,
    void
  >,
  respond: ReactionsDeleteForPullRequestCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsGetResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with406(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type PullsGet = (
  params: Params<t_PullsGetParamSchema, void, void, void>,
  respond: PullsGetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PullsUpdate = (
  params: Params<
    t_PullsUpdateParamSchema,
    void,
    t_PullsUpdateRequestBody | undefined,
    void
  >,
  respond: PullsUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCreateWithPrForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_codespace>
  with202(): ExpressRuntimeResponse<t_codespace>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodespacesCreateWithPrForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateWithPrForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateWithPrForAuthenticatedUserRequestBody,
    void
  >,
  respond: CodespacesCreateWithPrForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListReviewCommentsResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review_comment[]>
} & ExpressRuntimeResponder

export type PullsListReviewComments = (
  params: Params<
    t_PullsListReviewCommentsParamSchema,
    t_PullsListReviewCommentsQuerySchema,
    void,
    void
  >,
  respond: PullsListReviewCommentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsCreateReviewCommentResponder = {
  with201(): ExpressRuntimeResponse<t_pull_request_review_comment>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PullsCreateReviewComment = (
  params: Params<
    t_PullsCreateReviewCommentParamSchema,
    void,
    t_PullsCreateReviewCommentRequestBody,
    void
  >,
  respond: PullsCreateReviewCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsCreateReplyForReviewCommentResponder = {
  with201(): ExpressRuntimeResponse<t_pull_request_review_comment>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PullsCreateReplyForReviewComment = (
  params: Params<
    t_PullsCreateReplyForReviewCommentParamSchema,
    void,
    t_PullsCreateReplyForReviewCommentRequestBody,
    void
  >,
  respond: PullsCreateReplyForReviewCommentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListCommitsResponder = {
  with200(): ExpressRuntimeResponse<t_commit[]>
} & ExpressRuntimeResponder

export type PullsListCommits = (
  params: Params<
    t_PullsListCommitsParamSchema,
    t_PullsListCommitsQuerySchema,
    void,
    void
  >,
  respond: PullsListCommitsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListFilesResponder = {
  with200(): ExpressRuntimeResponse<t_diff_entry[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type PullsListFiles = (
  params: Params<
    t_PullsListFilesParamSchema,
    t_PullsListFilesQuerySchema,
    void,
    void
  >,
  respond: PullsListFilesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsCheckIfMergedResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type PullsCheckIfMerged = (
  params: Params<t_PullsCheckIfMergedParamSchema, void, void, void>,
  respond: PullsCheckIfMergedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsMergeResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_merge_result>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with405(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    message?: string | undefined
  }>
  with409(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    message?: string | undefined
  }>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PullsMerge = (
  params: Params<
    t_PullsMergeParamSchema,
    void,
    t_PullsMergeRequestBody | undefined,
    void
  >,
  respond: PullsMergeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListRequestedReviewersResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review_request>
} & ExpressRuntimeResponder

export type PullsListRequestedReviewers = (
  params: Params<t_PullsListRequestedReviewersParamSchema, void, void, void>,
  respond: PullsListRequestedReviewersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsRequestReviewersResponder = {
  with201(): ExpressRuntimeResponse<t_pull_request_simple>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type PullsRequestReviewers = (
  params: Params<
    t_PullsRequestReviewersParamSchema,
    void,
    t_PullsRequestReviewersRequestBody | undefined,
    void
  >,
  respond: PullsRequestReviewersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsRemoveRequestedReviewersResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_simple>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PullsRemoveRequestedReviewers = (
  params: Params<
    t_PullsRemoveRequestedReviewersParamSchema,
    void,
    t_PullsRemoveRequestedReviewersRequestBody,
    void
  >,
  respond: PullsRemoveRequestedReviewersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListReviewsResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review[]>
} & ExpressRuntimeResponder

export type PullsListReviews = (
  params: Params<
    t_PullsListReviewsParamSchema,
    t_PullsListReviewsQuerySchema,
    void,
    void
  >,
  respond: PullsListReviewsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsCreateReviewResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type PullsCreateReview = (
  params: Params<
    t_PullsCreateReviewParamSchema,
    void,
    t_PullsCreateReviewRequestBody | undefined,
    void
  >,
  respond: PullsCreateReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsGetReviewResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PullsGetReview = (
  params: Params<t_PullsGetReviewParamSchema, void, void, void>,
  respond: PullsGetReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsUpdateReviewResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type PullsUpdateReview = (
  params: Params<
    t_PullsUpdateReviewParamSchema,
    void,
    t_PullsUpdateReviewRequestBody,
    void
  >,
  respond: PullsUpdateReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsDeletePendingReviewResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type PullsDeletePendingReview = (
  params: Params<t_PullsDeletePendingReviewParamSchema, void, void, void>,
  respond: PullsDeletePendingReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsListCommentsForReviewResponder = {
  with200(): ExpressRuntimeResponse<t_review_comment[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PullsListCommentsForReview = (
  params: Params<
    t_PullsListCommentsForReviewParamSchema,
    t_PullsListCommentsForReviewQuerySchema,
    void,
    void
  >,
  respond: PullsListCommentsForReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsDismissReviewResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type PullsDismissReview = (
  params: Params<
    t_PullsDismissReviewParamSchema,
    void,
    t_PullsDismissReviewRequestBody,
    void
  >,
  respond: PullsDismissReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsSubmitReviewResponder = {
  with200(): ExpressRuntimeResponse<t_pull_request_review>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type PullsSubmitReview = (
  params: Params<
    t_PullsSubmitReviewParamSchema,
    void,
    t_PullsSubmitReviewRequestBody,
    void
  >,
  respond: PullsSubmitReviewResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PullsUpdateBranchResponder = {
  with202(): ExpressRuntimeResponse<{
    message?: string | undefined
    url?: string | undefined
  }>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type PullsUpdateBranch = (
  params: Params<
    t_PullsUpdateBranchParamSchema,
    void,
    t_PullsUpdateBranchRequestBody | undefined,
    void
  >,
  respond: PullsUpdateBranchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetReadmeResponder = {
  with200(): ExpressRuntimeResponse<t_content_file>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposGetReadme = (
  params: Params<
    t_ReposGetReadmeParamSchema,
    t_ReposGetReadmeQuerySchema,
    void,
    void
  >,
  respond: ReposGetReadmeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetReadmeInDirectoryResponder = {
  with200(): ExpressRuntimeResponse<t_content_file>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposGetReadmeInDirectory = (
  params: Params<
    t_ReposGetReadmeInDirectoryParamSchema,
    t_ReposGetReadmeInDirectoryQuerySchema,
    void,
    void
  >,
  respond: ReposGetReadmeInDirectoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListReleasesResponder = {
  with200(): ExpressRuntimeResponse<t_release[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListReleases = (
  params: Params<
    t_ReposListReleasesParamSchema,
    t_ReposListReleasesQuerySchema,
    void,
    void
  >,
  respond: ReposListReleasesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateReleaseResponder = {
  with201(): ExpressRuntimeResponse<t_release>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateRelease = (
  params: Params<
    t_ReposCreateReleaseParamSchema,
    void,
    t_ReposCreateReleaseRequestBody,
    void
  >,
  respond: ReposCreateReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetReleaseAssetResponder = {
  with200(): ExpressRuntimeResponse<t_release_asset>
  with302(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetReleaseAsset = (
  params: Params<t_ReposGetReleaseAssetParamSchema, void, void, void>,
  respond: ReposGetReleaseAssetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateReleaseAssetResponder = {
  with200(): ExpressRuntimeResponse<t_release_asset>
} & ExpressRuntimeResponder

export type ReposUpdateReleaseAsset = (
  params: Params<
    t_ReposUpdateReleaseAssetParamSchema,
    void,
    t_ReposUpdateReleaseAssetRequestBody | undefined,
    void
  >,
  respond: ReposUpdateReleaseAssetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteReleaseAssetResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDeleteReleaseAsset = (
  params: Params<t_ReposDeleteReleaseAssetParamSchema, void, void, void>,
  respond: ReposDeleteReleaseAssetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGenerateReleaseNotesResponder = {
  with200(): ExpressRuntimeResponse<t_release_notes_content>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGenerateReleaseNotes = (
  params: Params<
    t_ReposGenerateReleaseNotesParamSchema,
    void,
    t_ReposGenerateReleaseNotesRequestBody,
    void
  >,
  respond: ReposGenerateReleaseNotesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetLatestReleaseResponder = {
  with200(): ExpressRuntimeResponse<t_release>
} & ExpressRuntimeResponder

export type ReposGetLatestRelease = (
  params: Params<t_ReposGetLatestReleaseParamSchema, void, void, void>,
  respond: ReposGetLatestReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetReleaseByTagResponder = {
  with200(): ExpressRuntimeResponse<t_release>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetReleaseByTag = (
  params: Params<t_ReposGetReleaseByTagParamSchema, void, void, void>,
  respond: ReposGetReleaseByTagResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetReleaseResponder = {
  with200(): ExpressRuntimeResponse<t_release>
  with401(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposGetRelease = (
  params: Params<t_ReposGetReleaseParamSchema, void, void, void>,
  respond: ReposGetReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateReleaseResponder = {
  with200(): ExpressRuntimeResponse<t_release>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposUpdateRelease = (
  params: Params<
    t_ReposUpdateReleaseParamSchema,
    void,
    t_ReposUpdateReleaseRequestBody | undefined,
    void
  >,
  respond: ReposUpdateReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteReleaseResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDeleteRelease = (
  params: Params<t_ReposDeleteReleaseParamSchema, void, void, void>,
  respond: ReposDeleteReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListReleaseAssetsResponder = {
  with200(): ExpressRuntimeResponse<t_release_asset[]>
} & ExpressRuntimeResponder

export type ReposListReleaseAssets = (
  params: Params<
    t_ReposListReleaseAssetsParamSchema,
    t_ReposListReleaseAssetsQuerySchema,
    void,
    void
  >,
  respond: ReposListReleaseAssetsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUploadReleaseAssetResponder = {
  with201(): ExpressRuntimeResponse<t_release_asset>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposUploadReleaseAsset = (
  params: Params<
    t_ReposUploadReleaseAssetParamSchema,
    t_ReposUploadReleaseAssetQuerySchema,
    never | undefined,
    void
  >,
  respond: ReposUploadReleaseAssetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForReleaseResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReactionsListForRelease = (
  params: Params<
    t_ReactionsListForReleaseParamSchema,
    t_ReactionsListForReleaseQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForReleaseResponder = {
  with200(): ExpressRuntimeResponse<t_reaction>
  with201(): ExpressRuntimeResponse<t_reaction>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReactionsCreateForRelease = (
  params: Params<
    t_ReactionsCreateForReleaseParamSchema,
    void,
    t_ReactionsCreateForReleaseRequestBody,
    void
  >,
  respond: ReactionsCreateForReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsDeleteForReleaseResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReactionsDeleteForRelease = (
  params: Params<t_ReactionsDeleteForReleaseParamSchema, void, void, void>,
  respond: ReactionsDeleteForReleaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetBranchRulesResponder = {
  with200(): ExpressRuntimeResponse<t_repository_rule_detailed[]>
} & ExpressRuntimeResponder

export type ReposGetBranchRules = (
  params: Params<
    t_ReposGetBranchRulesParamSchema,
    t_ReposGetBranchRulesQuerySchema,
    void,
    void
  >,
  respond: ReposGetBranchRulesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetRepoRulesetsResponder = {
  with200(): ExpressRuntimeResponse<t_repository_ruleset[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetRepoRulesets = (
  params: Params<
    t_ReposGetRepoRulesetsParamSchema,
    t_ReposGetRepoRulesetsQuerySchema,
    void,
    void
  >,
  respond: ReposGetRepoRulesetsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateRepoRulesetResponder = {
  with201(): ExpressRuntimeResponse<t_repository_ruleset>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposCreateRepoRuleset = (
  params: Params<
    t_ReposCreateRepoRulesetParamSchema,
    void,
    t_ReposCreateRepoRulesetRequestBody,
    void
  >,
  respond: ReposCreateRepoRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetRepoRuleSuitesResponder = {
  with200(): ExpressRuntimeResponse<t_rule_suites>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetRepoRuleSuites = (
  params: Params<
    t_ReposGetRepoRuleSuitesParamSchema,
    t_ReposGetRepoRuleSuitesQuerySchema,
    void,
    void
  >,
  respond: ReposGetRepoRuleSuitesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetRepoRuleSuiteResponder = {
  with200(): ExpressRuntimeResponse<t_rule_suite>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetRepoRuleSuite = (
  params: Params<t_ReposGetRepoRuleSuiteParamSchema, void, void, void>,
  respond: ReposGetRepoRuleSuiteResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetRepoRulesetResponder = {
  with200(): ExpressRuntimeResponse<t_repository_ruleset>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetRepoRuleset = (
  params: Params<
    t_ReposGetRepoRulesetParamSchema,
    t_ReposGetRepoRulesetQuerySchema,
    void,
    void
  >,
  respond: ReposGetRepoRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposUpdateRepoRulesetResponder = {
  with200(): ExpressRuntimeResponse<t_repository_ruleset>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposUpdateRepoRuleset = (
  params: Params<
    t_ReposUpdateRepoRulesetParamSchema,
    void,
    t_ReposUpdateRepoRulesetRequestBody | undefined,
    void
  >,
  respond: ReposUpdateRepoRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteRepoRulesetResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteRepoRuleset = (
  params: Params<t_ReposDeleteRepoRulesetParamSchema, void, void, void>,
  respond: ReposDeleteRepoRulesetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetRepoRulesetHistoryResponder = {
  with200(): ExpressRuntimeResponse<t_ruleset_version[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetRepoRulesetHistory = (
  params: Params<
    t_ReposGetRepoRulesetHistoryParamSchema,
    t_ReposGetRepoRulesetHistoryQuerySchema,
    void,
    void
  >,
  respond: ReposGetRepoRulesetHistoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetRepoRulesetVersionResponder = {
  with200(): ExpressRuntimeResponse<t_ruleset_version_with_state>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetRepoRulesetVersion = (
  params: Params<t_ReposGetRepoRulesetVersionParamSchema, void, void, void>,
  respond: ReposGetRepoRulesetVersionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningListAlertsForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_secret_scanning_alert[]>
  with404(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningListAlertsForRepo = (
  params: Params<
    t_SecretScanningListAlertsForRepoParamSchema,
    t_SecretScanningListAlertsForRepoQuerySchema,
    void,
    void
  >,
  respond: SecretScanningListAlertsForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningGetAlertResponder = {
  with200(): ExpressRuntimeResponse<t_secret_scanning_alert>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningGetAlert = (
  params: Params<
    t_SecretScanningGetAlertParamSchema,
    t_SecretScanningGetAlertQuerySchema,
    void,
    void
  >,
  respond: SecretScanningGetAlertResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningUpdateAlertResponder = {
  with200(): ExpressRuntimeResponse<t_secret_scanning_alert>
  with400(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningUpdateAlert = (
  params: Params<
    t_SecretScanningUpdateAlertParamSchema,
    void,
    t_SecretScanningUpdateAlertRequestBody,
    void
  >,
  respond: SecretScanningUpdateAlertResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningListLocationsForAlertResponder = {
  with200(): ExpressRuntimeResponse<t_secret_scanning_location[]>
  with404(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningListLocationsForAlert = (
  params: Params<
    t_SecretScanningListLocationsForAlertParamSchema,
    t_SecretScanningListLocationsForAlertQuerySchema,
    void,
    void
  >,
  respond: SecretScanningListLocationsForAlertResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningCreatePushProtectionBypassResponder = {
  with200(): ExpressRuntimeResponse<t_secret_scanning_push_protection_bypass>
  with403(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningCreatePushProtectionBypass = (
  params: Params<
    t_SecretScanningCreatePushProtectionBypassParamSchema,
    void,
    t_SecretScanningCreatePushProtectionBypassRequestBody,
    void
  >,
  respond: SecretScanningCreatePushProtectionBypassResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecretScanningGetScanHistoryResponder = {
  with200(): ExpressRuntimeResponse<t_secret_scanning_scan_history>
  with404(): ExpressRuntimeResponse<void>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SecretScanningGetScanHistory = (
  params: Params<t_SecretScanningGetScanHistoryParamSchema, void, void, void>,
  respond: SecretScanningGetScanHistoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesListRepositoryAdvisoriesResponder = {
  with200(): ExpressRuntimeResponse<t_repository_advisory[]>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesListRepositoryAdvisories = (
  params: Params<
    t_SecurityAdvisoriesListRepositoryAdvisoriesParamSchema,
    t_SecurityAdvisoriesListRepositoryAdvisoriesQuerySchema,
    void,
    void
  >,
  respond: SecurityAdvisoriesListRepositoryAdvisoriesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesCreateRepositoryAdvisoryResponder = {
  with201(): ExpressRuntimeResponse<t_repository_advisory>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesCreateRepositoryAdvisory = (
  params: Params<
    t_SecurityAdvisoriesCreateRepositoryAdvisoryParamSchema,
    void,
    t_repository_advisory_create,
    void
  >,
  respond: SecurityAdvisoriesCreateRepositoryAdvisoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesCreatePrivateVulnerabilityReportResponder = {
  with201(): ExpressRuntimeResponse<t_repository_advisory>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesCreatePrivateVulnerabilityReport = (
  params: Params<
    t_SecurityAdvisoriesCreatePrivateVulnerabilityReportParamSchema,
    void,
    t_private_vulnerability_report_create,
    void
  >,
  respond: SecurityAdvisoriesCreatePrivateVulnerabilityReportResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesGetRepositoryAdvisoryResponder = {
  with200(): ExpressRuntimeResponse<t_repository_advisory>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesGetRepositoryAdvisory = (
  params: Params<
    t_SecurityAdvisoriesGetRepositoryAdvisoryParamSchema,
    void,
    void,
    void
  >,
  respond: SecurityAdvisoriesGetRepositoryAdvisoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesUpdateRepositoryAdvisoryResponder = {
  with200(): ExpressRuntimeResponse<t_repository_advisory>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesUpdateRepositoryAdvisory = (
  params: Params<
    t_SecurityAdvisoriesUpdateRepositoryAdvisoryParamSchema,
    void,
    t_repository_advisory_update,
    void
  >,
  respond: SecurityAdvisoriesUpdateRepositoryAdvisoryResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesCreateRepositoryAdvisoryCveRequest = (
  params: Params<
    t_SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema,
    void,
    void,
    void
  >,
  respond: SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SecurityAdvisoriesCreateForkResponder = {
  with202(): ExpressRuntimeResponse<t_full_repository>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type SecurityAdvisoriesCreateFork = (
  params: Params<t_SecurityAdvisoriesCreateForkParamSchema, void, void, void>,
  respond: SecurityAdvisoriesCreateForkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListStargazersForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[] | t_stargazer[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ActivityListStargazersForRepo = (
  params: Params<
    t_ActivityListStargazersForRepoParamSchema,
    t_ActivityListStargazersForRepoQuerySchema,
    void,
    void
  >,
  respond: ActivityListStargazersForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCodeFrequencyStatsResponder = {
  with200(): ExpressRuntimeResponse<t_code_frequency_stat[]>
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with204(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposGetCodeFrequencyStats = (
  params: Params<t_ReposGetCodeFrequencyStatsParamSchema, void, void, void>,
  respond: ReposGetCodeFrequencyStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetCommitActivityStatsResponder = {
  with200(): ExpressRuntimeResponse<t_commit_activity[]>
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposGetCommitActivityStats = (
  params: Params<t_ReposGetCommitActivityStatsParamSchema, void, void, void>,
  respond: ReposGetCommitActivityStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetContributorsStatsResponder = {
  with200(): ExpressRuntimeResponse<t_contributor_activity[]>
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposGetContributorsStats = (
  params: Params<t_ReposGetContributorsStatsParamSchema, void, void, void>,
  respond: ReposGetContributorsStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetParticipationStatsResponder = {
  with200(): ExpressRuntimeResponse<t_participation_stats>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetParticipationStats = (
  params: Params<t_ReposGetParticipationStatsParamSchema, void, void, void>,
  respond: ReposGetParticipationStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetPunchCardStatsResponder = {
  with200(): ExpressRuntimeResponse<t_code_frequency_stat[]>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposGetPunchCardStats = (
  params: Params<t_ReposGetPunchCardStatsParamSchema, void, void, void>,
  respond: ReposGetPunchCardStatsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateCommitStatusResponder = {
  with201(): ExpressRuntimeResponse<t_status>
} & ExpressRuntimeResponder

export type ReposCreateCommitStatus = (
  params: Params<
    t_ReposCreateCommitStatusParamSchema,
    void,
    t_ReposCreateCommitStatusRequestBody,
    void
  >,
  respond: ReposCreateCommitStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListWatchersForRepoResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
} & ExpressRuntimeResponder

export type ActivityListWatchersForRepo = (
  params: Params<
    t_ActivityListWatchersForRepoParamSchema,
    t_ActivityListWatchersForRepoQuerySchema,
    void,
    void
  >,
  respond: ActivityListWatchersForRepoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityGetRepoSubscriptionResponder = {
  with200(): ExpressRuntimeResponse<t_repository_subscription>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActivityGetRepoSubscription = (
  params: Params<t_ActivityGetRepoSubscriptionParamSchema, void, void, void>,
  respond: ActivityGetRepoSubscriptionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivitySetRepoSubscriptionResponder = {
  with200(): ExpressRuntimeResponse<t_repository_subscription>
} & ExpressRuntimeResponder

export type ActivitySetRepoSubscription = (
  params: Params<
    t_ActivitySetRepoSubscriptionParamSchema,
    void,
    t_ActivitySetRepoSubscriptionRequestBody | undefined,
    void
  >,
  respond: ActivitySetRepoSubscriptionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityDeleteRepoSubscriptionResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ActivityDeleteRepoSubscription = (
  params: Params<t_ActivityDeleteRepoSubscriptionParamSchema, void, void, void>,
  respond: ActivityDeleteRepoSubscriptionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListTagsResponder = {
  with200(): ExpressRuntimeResponse<t_tag[]>
} & ExpressRuntimeResponder

export type ReposListTags = (
  params: Params<
    t_ReposListTagsParamSchema,
    t_ReposListTagsQuerySchema,
    void,
    void
  >,
  respond: ReposListTagsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListTagProtectionResponder = {
  with200(): ExpressRuntimeResponse<t_tag_protection[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListTagProtection = (
  params: Params<t_ReposListTagProtectionParamSchema, void, void, void>,
  respond: ReposListTagProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateTagProtectionResponder = {
  with201(): ExpressRuntimeResponse<t_tag_protection>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposCreateTagProtection = (
  params: Params<
    t_ReposCreateTagProtectionParamSchema,
    void,
    t_ReposCreateTagProtectionRequestBody,
    void
  >,
  respond: ReposCreateTagProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeleteTagProtectionResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeleteTagProtection = (
  params: Params<t_ReposDeleteTagProtectionParamSchema, void, void, void>,
  respond: ReposDeleteTagProtectionResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDownloadTarballArchiveResponder = {
  with302(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDownloadTarballArchive = (
  params: Params<t_ReposDownloadTarballArchiveParamSchema, void, void, void>,
  respond: ReposDownloadTarballArchiveResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListTeamsResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListTeams = (
  params: Params<
    t_ReposListTeamsParamSchema,
    t_ReposListTeamsQuerySchema,
    void,
    void
  >,
  respond: ReposListTeamsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetAllTopicsResponder = {
  with200(): ExpressRuntimeResponse<t_topic>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetAllTopics = (
  params: Params<
    t_ReposGetAllTopicsParamSchema,
    t_ReposGetAllTopicsQuerySchema,
    void,
    void
  >,
  respond: ReposGetAllTopicsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposReplaceAllTopicsResponder = {
  with200(): ExpressRuntimeResponse<t_topic>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ReposReplaceAllTopics = (
  params: Params<
    t_ReposReplaceAllTopicsParamSchema,
    void,
    t_ReposReplaceAllTopicsRequestBody,
    void
  >,
  respond: ReposReplaceAllTopicsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetClonesResponder = {
  with200(): ExpressRuntimeResponse<t_clone_traffic>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetClones = (
  params: Params<
    t_ReposGetClonesParamSchema,
    t_ReposGetClonesQuerySchema,
    void,
    void
  >,
  respond: ReposGetClonesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetTopPathsResponder = {
  with200(): ExpressRuntimeResponse<t_content_traffic[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetTopPaths = (
  params: Params<t_ReposGetTopPathsParamSchema, void, void, void>,
  respond: ReposGetTopPathsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetTopReferrersResponder = {
  with200(): ExpressRuntimeResponse<t_referrer_traffic[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetTopReferrers = (
  params: Params<t_ReposGetTopReferrersParamSchema, void, void, void>,
  respond: ReposGetTopReferrersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposGetViewsResponder = {
  with200(): ExpressRuntimeResponse<t_view_traffic>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposGetViews = (
  params: Params<
    t_ReposGetViewsParamSchema,
    t_ReposGetViewsQuerySchema,
    void,
    void
  >,
  respond: ReposGetViewsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposTransferResponder = {
  with202(): ExpressRuntimeResponse<t_minimal_repository>
} & ExpressRuntimeResponder

export type ReposTransfer = (
  params: Params<
    t_ReposTransferParamSchema,
    void,
    t_ReposTransferRequestBody,
    void
  >,
  respond: ReposTransferResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCheckVulnerabilityAlertsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposCheckVulnerabilityAlerts = (
  params: Params<t_ReposCheckVulnerabilityAlertsParamSchema, void, void, void>,
  respond: ReposCheckVulnerabilityAlertsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposEnableVulnerabilityAlertsResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposEnableVulnerabilityAlerts = (
  params: Params<t_ReposEnableVulnerabilityAlertsParamSchema, void, void, void>,
  respond: ReposEnableVulnerabilityAlertsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDisableVulnerabilityAlertsResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDisableVulnerabilityAlerts = (
  params: Params<
    t_ReposDisableVulnerabilityAlertsParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDisableVulnerabilityAlertsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDownloadZipballArchiveResponder = {
  with302(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type ReposDownloadZipballArchive = (
  params: Params<t_ReposDownloadZipballArchiveParamSchema, void, void, void>,
  respond: ReposDownloadZipballArchiveResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateUsingTemplateResponder = {
  with201(): ExpressRuntimeResponse<t_full_repository>
} & ExpressRuntimeResponder

export type ReposCreateUsingTemplate = (
  params: Params<
    t_ReposCreateUsingTemplateParamSchema,
    void,
    t_ReposCreateUsingTemplateRequestBody,
    void
  >,
  respond: ReposCreateUsingTemplateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListPublicResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with304(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposListPublic = (
  params: Params<void, t_ReposListPublicQuerySchema, void, void>,
  respond: ReposListPublicResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchCodeResponder = {
  with200(): ExpressRuntimeResponse<{
    incomplete_results: boolean
    items: t_code_search_result_item[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SearchCode = (
  params: Params<void, t_SearchCodeQuerySchema, void, void>,
  respond: SearchCodeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchCommitsResponder = {
  with200(): ExpressRuntimeResponse<{
    incomplete_results: boolean
    items: t_commit_search_result_item[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type SearchCommits = (
  params: Params<void, t_SearchCommitsQuerySchema, void, void>,
  respond: SearchCommitsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchIssuesAndPullRequestsResponder = {
  with200(): ExpressRuntimeResponse<{
    incomplete_results: boolean
    items: t_issue_search_result_item[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SearchIssuesAndPullRequests = (
  params: Params<void, t_SearchIssuesAndPullRequestsQuerySchema, void, void>,
  respond: SearchIssuesAndPullRequestsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchLabelsResponder = {
  with200(): ExpressRuntimeResponse<{
    incomplete_results: boolean
    items: t_label_search_result_item[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type SearchLabels = (
  params: Params<void, t_SearchLabelsQuerySchema, void, void>,
  respond: SearchLabelsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchReposResponder = {
  with200(): ExpressRuntimeResponse<{
    incomplete_results: boolean
    items: t_repo_search_result_item[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SearchRepos = (
  params: Params<void, t_SearchReposQuerySchema, void, void>,
  respond: SearchReposResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchTopicsResponder = {
  with200(): ExpressRuntimeResponse<{
    incomplete_results: boolean
    items: t_topic_search_result_item[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type SearchTopics = (
  params: Params<void, t_SearchTopicsQuerySchema, void, void>,
  respond: SearchTopicsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchUsersResponder = {
  with200(): ExpressRuntimeResponse<{
    incomplete_results: boolean
    items: t_user_search_result_item[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type SearchUsers = (
  params: Params<void, t_SearchUsersQuerySchema, void, void>,
  respond: SearchUsersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_full>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsGetLegacy = (
  params: Params<t_TeamsGetLegacyParamSchema, void, void, void>,
  respond: TeamsGetLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsUpdateLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_full>
  with201(): ExpressRuntimeResponse<t_team_full>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsUpdateLegacy = (
  params: Params<
    t_TeamsUpdateLegacyParamSchema,
    void,
    t_TeamsUpdateLegacyRequestBody,
    void
  >,
  respond: TeamsUpdateLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsDeleteLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsDeleteLegacy = (
  params: Params<t_TeamsDeleteLegacyParamSchema, void, void, void>,
  respond: TeamsDeleteLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListDiscussionsLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion[]>
} & ExpressRuntimeResponder

export type TeamsListDiscussionsLegacy = (
  params: Params<
    t_TeamsListDiscussionsLegacyParamSchema,
    t_TeamsListDiscussionsLegacyQuerySchema,
    void,
    void
  >,
  respond: TeamsListDiscussionsLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCreateDiscussionLegacyResponder = {
  with201(): ExpressRuntimeResponse<t_team_discussion>
} & ExpressRuntimeResponder

export type TeamsCreateDiscussionLegacy = (
  params: Params<
    t_TeamsCreateDiscussionLegacyParamSchema,
    void,
    t_TeamsCreateDiscussionLegacyRequestBody,
    void
  >,
  respond: TeamsCreateDiscussionLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetDiscussionLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion>
} & ExpressRuntimeResponder

export type TeamsGetDiscussionLegacy = (
  params: Params<t_TeamsGetDiscussionLegacyParamSchema, void, void, void>,
  respond: TeamsGetDiscussionLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsUpdateDiscussionLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion>
} & ExpressRuntimeResponder

export type TeamsUpdateDiscussionLegacy = (
  params: Params<
    t_TeamsUpdateDiscussionLegacyParamSchema,
    void,
    t_TeamsUpdateDiscussionLegacyRequestBody | undefined,
    void
  >,
  respond: TeamsUpdateDiscussionLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsDeleteDiscussionLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsDeleteDiscussionLegacy = (
  params: Params<t_TeamsDeleteDiscussionLegacyParamSchema, void, void, void>,
  respond: TeamsDeleteDiscussionLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListDiscussionCommentsLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion_comment[]>
} & ExpressRuntimeResponder

export type TeamsListDiscussionCommentsLegacy = (
  params: Params<
    t_TeamsListDiscussionCommentsLegacyParamSchema,
    t_TeamsListDiscussionCommentsLegacyQuerySchema,
    void,
    void
  >,
  respond: TeamsListDiscussionCommentsLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCreateDiscussionCommentLegacyResponder = {
  with201(): ExpressRuntimeResponse<t_team_discussion_comment>
} & ExpressRuntimeResponder

export type TeamsCreateDiscussionCommentLegacy = (
  params: Params<
    t_TeamsCreateDiscussionCommentLegacyParamSchema,
    void,
    t_TeamsCreateDiscussionCommentLegacyRequestBody,
    void
  >,
  respond: TeamsCreateDiscussionCommentLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetDiscussionCommentLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion_comment>
} & ExpressRuntimeResponder

export type TeamsGetDiscussionCommentLegacy = (
  params: Params<
    t_TeamsGetDiscussionCommentLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsGetDiscussionCommentLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsUpdateDiscussionCommentLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_discussion_comment>
} & ExpressRuntimeResponder

export type TeamsUpdateDiscussionCommentLegacy = (
  params: Params<
    t_TeamsUpdateDiscussionCommentLegacyParamSchema,
    void,
    t_TeamsUpdateDiscussionCommentLegacyRequestBody,
    void
  >,
  respond: TeamsUpdateDiscussionCommentLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsDeleteDiscussionCommentLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsDeleteDiscussionCommentLegacy = (
  params: Params<
    t_TeamsDeleteDiscussionCommentLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsDeleteDiscussionCommentLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForTeamDiscussionCommentLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
} & ExpressRuntimeResponder

export type ReactionsListForTeamDiscussionCommentLegacy = (
  params: Params<
    t_ReactionsListForTeamDiscussionCommentLegacyParamSchema,
    t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForTeamDiscussionCommentLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForTeamDiscussionCommentLegacyResponder = {
  with201(): ExpressRuntimeResponse<t_reaction>
} & ExpressRuntimeResponder

export type ReactionsCreateForTeamDiscussionCommentLegacy = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionCommentLegacyRequestBody,
    void
  >,
  respond: ReactionsCreateForTeamDiscussionCommentLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsListForTeamDiscussionLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_reaction[]>
} & ExpressRuntimeResponder

export type ReactionsListForTeamDiscussionLegacy = (
  params: Params<
    t_ReactionsListForTeamDiscussionLegacyParamSchema,
    t_ReactionsListForTeamDiscussionLegacyQuerySchema,
    void,
    void
  >,
  respond: ReactionsListForTeamDiscussionLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReactionsCreateForTeamDiscussionLegacyResponder = {
  with201(): ExpressRuntimeResponse<t_reaction>
} & ExpressRuntimeResponder

export type ReactionsCreateForTeamDiscussionLegacy = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionLegacyParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionLegacyRequestBody,
    void
  >,
  respond: ReactionsCreateForTeamDiscussionLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListPendingInvitationsLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_organization_invitation[]>
} & ExpressRuntimeResponder

export type TeamsListPendingInvitationsLegacy = (
  params: Params<
    t_TeamsListPendingInvitationsLegacyParamSchema,
    t_TeamsListPendingInvitationsLegacyQuerySchema,
    void,
    void
  >,
  respond: TeamsListPendingInvitationsLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListMembersLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsListMembersLegacy = (
  params: Params<
    t_TeamsListMembersLegacyParamSchema,
    t_TeamsListMembersLegacyQuerySchema,
    void,
    void
  >,
  respond: TeamsListMembersLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetMemberLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsGetMemberLegacy = (
  params: Params<t_TeamsGetMemberLegacyParamSchema, void, void, void>,
  respond: TeamsGetMemberLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsAddMemberLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<void>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsAddMemberLegacy = (
  params: Params<t_TeamsAddMemberLegacyParamSchema, void, void, void>,
  respond: TeamsAddMemberLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsRemoveMemberLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsRemoveMemberLegacy = (
  params: Params<t_TeamsRemoveMemberLegacyParamSchema, void, void, void>,
  respond: TeamsRemoveMemberLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsGetMembershipForUserLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_membership>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsGetMembershipForUserLegacy = (
  params: Params<
    t_TeamsGetMembershipForUserLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsGetMembershipForUserLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsAddOrUpdateMembershipForUserLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_membership>
  with403(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsAddOrUpdateMembershipForUserLegacy = (
  params: Params<
    t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateMembershipForUserLegacyRequestBody | undefined,
    void
  >,
  respond: TeamsAddOrUpdateMembershipForUserLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsRemoveMembershipForUserLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsRemoveMembershipForUserLegacy = (
  params: Params<
    t_TeamsRemoveMembershipForUserLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsRemoveMembershipForUserLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListProjectsLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_project[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsListProjectsLegacy = (
  params: Params<
    t_TeamsListProjectsLegacyParamSchema,
    t_TeamsListProjectsLegacyQuerySchema,
    void,
    void
  >,
  respond: TeamsListProjectsLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCheckPermissionsForProjectLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_project>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsCheckPermissionsForProjectLegacy = (
  params: Params<
    t_TeamsCheckPermissionsForProjectLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsCheckPermissionsForProjectLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsAddOrUpdateProjectPermissionsLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<{
    documentation_url?: string | undefined
    message?: string | undefined
  }>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsAddOrUpdateProjectPermissionsLegacy = (
  params: Params<
    t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateProjectPermissionsLegacyRequestBody | undefined,
    void
  >,
  respond: TeamsAddOrUpdateProjectPermissionsLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsRemoveProjectLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsRemoveProjectLegacy = (
  params: Params<t_TeamsRemoveProjectLegacyParamSchema, void, void, void>,
  respond: TeamsRemoveProjectLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListReposLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsListReposLegacy = (
  params: Params<
    t_TeamsListReposLegacyParamSchema,
    t_TeamsListReposLegacyQuerySchema,
    void,
    void
  >,
  respond: TeamsListReposLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsCheckPermissionsForRepoLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team_repository>
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsCheckPermissionsForRepoLegacy = (
  params: Params<
    t_TeamsCheckPermissionsForRepoLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: TeamsCheckPermissionsForRepoLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsAddOrUpdateRepoPermissionsLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsAddOrUpdateRepoPermissionsLegacy = (
  params: Params<
    t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateRepoPermissionsLegacyRequestBody | undefined,
    void
  >,
  respond: TeamsAddOrUpdateRepoPermissionsLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsRemoveRepoLegacyResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type TeamsRemoveRepoLegacy = (
  params: Params<t_TeamsRemoveRepoLegacyParamSchema, void, void, void>,
  respond: TeamsRemoveRepoLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListChildLegacyResponder = {
  with200(): ExpressRuntimeResponse<t_team[]>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type TeamsListChildLegacy = (
  params: Params<
    t_TeamsListChildLegacyParamSchema,
    t_TeamsListChildLegacyQuerySchema,
    void,
    void
  >,
  respond: TeamsListChildLegacyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersGetAuthenticatedResponder = {
  with200(): ExpressRuntimeResponse<t_private_user | t_public_user>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersGetAuthenticated = (
  params: Params<void, void, void, void>,
  respond: UsersGetAuthenticatedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersUpdateAuthenticatedResponder = {
  with200(): ExpressRuntimeResponse<t_private_user>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersUpdateAuthenticated = (
  params: Params<
    void,
    void,
    t_UsersUpdateAuthenticatedRequestBody | undefined,
    void
  >,
  respond: UsersUpdateAuthenticatedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListBlockedByAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListBlockedByAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListBlockedByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListBlockedByAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersCheckBlockedResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersCheckBlocked = (
  params: Params<t_UsersCheckBlockedParamSchema, void, void, void>,
  respond: UsersCheckBlockedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersBlockResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersBlock = (
  params: Params<t_UsersBlockParamSchema, void, void, void>,
  respond: UsersBlockResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersUnblockResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersUnblock = (
  params: Params<t_UsersUnblockParamSchema, void, void, void>,
  respond: UsersUnblockResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    codespaces: t_codespace[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesListForAuthenticatedUser = (
  params: Params<
    void,
    t_CodespacesListForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: CodespacesListForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCreateForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_codespace>
  with202(): ExpressRuntimeResponse<t_codespace>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type CodespacesCreateForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_CodespacesCreateForAuthenticatedUserRequestBody,
    void
  >,
  respond: CodespacesCreateForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListSecretsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    secrets: t_codespaces_secret[]
    total_count: number
  }>
} & ExpressRuntimeResponder

export type CodespacesListSecretsForAuthenticatedUser = (
  params: Params<
    void,
    t_CodespacesListSecretsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: CodespacesListSecretsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetPublicKeyForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_codespaces_user_public_key>
} & ExpressRuntimeResponder

export type CodespacesGetPublicKeyForAuthenticatedUser = (
  params: Params<void, void, void, void>,
  respond: CodespacesGetPublicKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetSecretForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_codespaces_secret>
} & ExpressRuntimeResponder

export type CodespacesGetSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesGetSecretForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody,
    void
  >,
  respond: CodespacesCreateOrUpdateSecretForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesDeleteSecretForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type CodespacesDeleteSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesDeleteSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesDeleteSecretForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesListRepositoriesForSecretForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_minimal_repository[]
    total_count: number
  }>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesListRepositoriesForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesListRepositoriesForSecretForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
    void,
    t_CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody,
    void
  >,
  respond: CodespacesSetRepositoriesForSecretForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesAddRepositoryForSecretForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesAddRepositoryForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesAddRepositoryForSecretForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_codespace>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesGetForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesGetForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesUpdateForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_codespace>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesUpdateForAuthenticatedUser = (
  params: Params<
    t_CodespacesUpdateForAuthenticatedUserParamSchema,
    void,
    t_CodespacesUpdateForAuthenticatedUserRequestBody | undefined,
    void
  >,
  respond: CodespacesUpdateForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesDeleteForAuthenticatedUserResponder = {
  with202(): ExpressRuntimeResponse<{
    [key: string]: unknown | undefined
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesDeleteForAuthenticatedUser = (
  params: Params<
    t_CodespacesDeleteForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesDeleteForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesExportForAuthenticatedUserResponder = {
  with202(): ExpressRuntimeResponse<t_codespace_export_details>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesExportForAuthenticatedUser = (
  params: Params<
    t_CodespacesExportForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesExportForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesGetExportDetailsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_codespace_export_details>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesGetExportDetailsForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesGetExportDetailsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesCodespaceMachinesForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    machines: t_codespace_machine[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesCodespaceMachinesForAuthenticatedUser = (
  params: Params<
    t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesCodespaceMachinesForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesPublishForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_codespace_with_full_repository>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type CodespacesPublishForAuthenticatedUser = (
  params: Params<
    t_CodespacesPublishForAuthenticatedUserParamSchema,
    void,
    t_CodespacesPublishForAuthenticatedUserRequestBody,
    void
  >,
  respond: CodespacesPublishForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesStartForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_codespace>
  with304(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with402(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesStartForAuthenticatedUser = (
  params: Params<
    t_CodespacesStartForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesStartForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CodespacesStopForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_codespace>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type CodespacesStopForAuthenticatedUser = (
  params: Params<
    t_CodespacesStopForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: CodespacesStopForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponder =
  {
    with200(): ExpressRuntimeResponse<t_package[]>
  } & ExpressRuntimeResponder

export type PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser =
  (
    params: Params<void, void, void, void>,
    respond: PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponder,
    req: Request,
    res: Response,
    next: NextFunction,
  ) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_email[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody,
    void
  >,
  respond: UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListEmailsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_email[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListEmailsForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListEmailsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListEmailsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersAddEmailForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_email[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersAddEmailForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersAddEmailForAuthenticatedUserRequestBody | undefined,
    void
  >,
  respond: UsersAddEmailForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeleteEmailForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersDeleteEmailForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersDeleteEmailForAuthenticatedUserRequestBody,
    void
  >,
  respond: UsersDeleteEmailForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListFollowersForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListFollowersForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListFollowersForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListFollowersForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListFollowedByAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListFollowedByAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListFollowedByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListFollowedByAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersCheckPersonIsFollowedByAuthenticatedResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersCheckPersonIsFollowedByAuthenticated = (
  params: Params<
    t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema,
    void,
    void,
    void
  >,
  respond: UsersCheckPersonIsFollowedByAuthenticatedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersFollowResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersFollow = (
  params: Params<t_UsersFollowParamSchema, void, void, void>,
  respond: UsersFollowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersUnfollowResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersUnfollow = (
  params: Params<t_UsersUnfollowParamSchema, void, void, void>,
  respond: UsersUnfollowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListGpgKeysForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_gpg_key[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListGpgKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListGpgKeysForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListGpgKeysForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersCreateGpgKeyForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_gpg_key>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersCreateGpgKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreateGpgKeyForAuthenticatedUserRequestBody,
    void
  >,
  respond: UsersCreateGpgKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersGetGpgKeyForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_gpg_key>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersGetGpgKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetGpgKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: UsersGetGpgKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeleteGpgKeyForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersDeleteGpgKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: UsersDeleteGpgKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListInstallationsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    installations: t_installation[]
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListInstallationsForAuthenticatedUser = (
  params: Params<
    void,
    t_AppsListInstallationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: AppsListInstallationsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListInstallationReposForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<{
    repositories: t_repository[]
    repository_selection?: string | undefined
    total_count: number
  }>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListInstallationReposForAuthenticatedUser = (
  params: Params<
    t_AppsListInstallationReposForAuthenticatedUserParamSchema,
    t_AppsListInstallationReposForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: AppsListInstallationReposForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsAddRepoToInstallationForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsAddRepoToInstallationForAuthenticatedUser = (
  params: Params<
    t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: AppsAddRepoToInstallationForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsRemoveRepoFromInstallationForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type AppsRemoveRepoFromInstallationForAuthenticatedUser = (
  params: Params<
    t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: AppsRemoveRepoFromInstallationForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsGetRestrictionsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_interaction_limit_response | EmptyObject>
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type InteractionsGetRestrictionsForAuthenticatedUser = (
  params: Params<void, void, void, void>,
  respond: InteractionsGetRestrictionsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsSetRestrictionsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_interaction_limit_response>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type InteractionsSetRestrictionsForAuthenticatedUser = (
  params: Params<void, void, t_interaction_limit, void>,
  respond: InteractionsSetRestrictionsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type InteractionsRemoveRestrictionsForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type InteractionsRemoveRestrictionsForAuthenticatedUser = (
  params: Params<void, void, void, void>,
  respond: InteractionsRemoveRestrictionsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IssuesListForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_issue[]>
  with304(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type IssuesListForAuthenticatedUser = (
  params: Params<void, t_IssuesListForAuthenticatedUserQuerySchema, void, void>,
  respond: IssuesListForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListPublicSshKeysForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_key[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListPublicSshKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListPublicSshKeysForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersCreatePublicSshKeyForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_key>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersCreatePublicSshKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreatePublicSshKeyForAuthenticatedUserRequestBody,
    void
  >,
  respond: UsersCreatePublicSshKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersGetPublicSshKeyForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_key>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersGetPublicSshKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: UsersGetPublicSshKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeletePublicSshKeyForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersDeletePublicSshKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: UsersDeletePublicSshKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListSubscriptionsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_user_marketplace_purchase[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListSubscriptionsForAuthenticatedUser = (
  params: Params<
    void,
    t_AppsListSubscriptionsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: AppsListSubscriptionsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsListSubscriptionsForAuthenticatedUserStubbedResponder = {
  with200(): ExpressRuntimeResponse<t_user_marketplace_purchase[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type AppsListSubscriptionsForAuthenticatedUserStubbed = (
  params: Params<
    void,
    t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
    void,
    void
  >,
  respond: AppsListSubscriptionsForAuthenticatedUserStubbedResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListMembershipsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_org_membership[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsListMembershipsForAuthenticatedUser = (
  params: Params<
    void,
    t_OrgsListMembershipsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: OrgsListMembershipsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsGetMembershipForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_org_membership>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsGetMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsGetMembershipForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: OrgsGetMembershipForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsUpdateMembershipForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_org_membership>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type OrgsUpdateMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsUpdateMembershipForAuthenticatedUserParamSchema,
    void,
    t_OrgsUpdateMembershipForAuthenticatedUserRequestBody,
    void
  >,
  respond: OrgsUpdateMembershipForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsListForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_migration[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsListForAuthenticatedUser = (
  params: Params<
    void,
    t_MigrationsListForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: MigrationsListForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsStartForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_migration>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type MigrationsStartForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_MigrationsStartForAuthenticatedUserRequestBody,
    void
  >,
  respond: MigrationsStartForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsGetStatusForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_migration>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsGetStatusForAuthenticatedUser = (
  params: Params<
    t_MigrationsGetStatusForAuthenticatedUserParamSchema,
    t_MigrationsGetStatusForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: MigrationsGetStatusForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsGetArchiveForAuthenticatedUserResponder = {
  with302(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsGetArchiveForAuthenticatedUser = (
  params: Params<
    t_MigrationsGetArchiveForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: MigrationsGetArchiveForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsDeleteArchiveForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsDeleteArchiveForAuthenticatedUser = (
  params: Params<
    t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: MigrationsDeleteArchiveForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsUnlockRepoForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsUnlockRepoForAuthenticatedUser = (
  params: Params<
    t_MigrationsUnlockRepoForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: MigrationsUnlockRepoForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MigrationsListReposForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MigrationsListReposForAuthenticatedUser = (
  params: Params<
    t_MigrationsListReposForAuthenticatedUserParamSchema,
    t_MigrationsListReposForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: MigrationsListReposForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_organization_simple[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type OrgsListForAuthenticatedUser = (
  params: Params<void, t_OrgsListForAuthenticatedUserQuerySchema, void, void>,
  respond: OrgsListForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesListPackagesForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_package[]>
  with400(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type PackagesListPackagesForAuthenticatedUser = (
  params: Params<
    void,
    t_PackagesListPackagesForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: PackagesListPackagesForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetPackageForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_package>
} & ExpressRuntimeResponder

export type PackagesGetPackageForAuthenticatedUser = (
  params: Params<
    t_PackagesGetPackageForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesGetPackageForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesDeletePackageForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesDeletePackageForAuthenticatedUser = (
  params: Params<
    t_PackagesDeletePackageForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesDeletePackageForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesRestorePackageForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesRestorePackageForAuthenticatedUser = (
  params: Params<
    t_PackagesRestorePackageForAuthenticatedUserParamSchema,
    t_PackagesRestorePackageForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: PackagesRestorePackageForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponder =
  {
    with200(): ExpressRuntimeResponse<t_package_version[]>
    with401(): ExpressRuntimeResponse<t_basic_error>
    with403(): ExpressRuntimeResponse<t_basic_error>
    with404(): ExpressRuntimeResponse<t_basic_error>
  } & ExpressRuntimeResponder

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
    t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetPackageVersionForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_package_version>
} & ExpressRuntimeResponder

export type PackagesGetPackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesGetPackageVersionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesGetPackageVersionForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesDeletePackageVersionForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesDeletePackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesDeletePackageVersionForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesRestorePackageVersionForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesRestorePackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesRestorePackageVersionForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicCreateForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_project>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error_simple>
} & ExpressRuntimeResponder

export type ProjectsClassicCreateForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_ProjectsClassicCreateForAuthenticatedUserRequestBody,
    void
  >,
  respond: ProjectsClassicCreateForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListPublicEmailsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_email[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListPublicEmailsForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListPublicEmailsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListPublicEmailsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_repository[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposListForAuthenticatedUser = (
  params: Params<void, t_ReposListForAuthenticatedUserQuerySchema, void, void>,
  respond: ReposListForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposCreateForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_full_repository>
  with304(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ReposCreateForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_ReposCreateForAuthenticatedUserRequestBody,
    void
  >,
  respond: ReposCreateForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListInvitationsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_repository_invitation[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposListInvitationsForAuthenticatedUser = (
  params: Params<
    void,
    t_ReposListInvitationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: ReposListInvitationsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposAcceptInvitationForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposAcceptInvitationForAuthenticatedUser = (
  params: Params<
    t_ReposAcceptInvitationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: ReposAcceptInvitationForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposDeclineInvitationForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with409(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ReposDeclineInvitationForAuthenticatedUser = (
  params: Params<
    t_ReposDeclineInvitationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: ReposDeclineInvitationForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListSocialAccountsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_social_account[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListSocialAccountsForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListSocialAccountsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListSocialAccountsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersAddSocialAccountForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_social_account[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersAddSocialAccountForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersAddSocialAccountForAuthenticatedUserRequestBody,
    void
  >,
  respond: UsersAddSocialAccountForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeleteSocialAccountForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersDeleteSocialAccountForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersDeleteSocialAccountForAuthenticatedUserRequestBody,
    void
  >,
  respond: UsersDeleteSocialAccountForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListSshSigningKeysForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_ssh_signing_key[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListSshSigningKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: UsersListSshSigningKeysForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersCreateSshSigningKeyForAuthenticatedUserResponder = {
  with201(): ExpressRuntimeResponse<t_ssh_signing_key>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersCreateSshSigningKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreateSshSigningKeyForAuthenticatedUserRequestBody,
    void
  >,
  respond: UsersCreateSshSigningKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersGetSshSigningKeyForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_ssh_signing_key>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersGetSshSigningKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: UsersGetSshSigningKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeleteSshSigningKeyForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersDeleteSshSigningKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: UsersDeleteSshSigningKeyForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListReposStarredByAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_starred_repository[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityListReposStarredByAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListReposStarredByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListReposStarredByAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityCheckRepoIsStarredByAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityCheckRepoIsStarredByAuthenticatedUser = (
  params: Params<
    t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: ActivityCheckRepoIsStarredByAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityStarRepoForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityStarRepoForAuthenticatedUser = (
  params: Params<
    t_ActivityStarRepoForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: ActivityStarRepoForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityUnstarRepoForAuthenticatedUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityUnstarRepoForAuthenticatedUser = (
  params: Params<
    t_ActivityUnstarRepoForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: ActivityUnstarRepoForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListWatchedReposForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
  with304(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type ActivityListWatchedReposForAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListWatchedReposForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListWatchedReposForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TeamsListForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_team_full[]>
  with304(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type TeamsListForAuthenticatedUser = (
  params: Params<void, t_TeamsListForAuthenticatedUserQuerySchema, void, void>,
  respond: TeamsListForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersGetByIdResponder = {
  with200(): ExpressRuntimeResponse<t_private_user | t_public_user>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersGetById = (
  params: Params<t_UsersGetByIdParamSchema, void, void, void>,
  respond: UsersGetByIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
  with304(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type UsersList = (
  params: Params<void, t_UsersListQuerySchema, void, void>,
  respond: UsersListResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersGetByUsernameResponder = {
  with200(): ExpressRuntimeResponse<t_private_user | t_public_user>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersGetByUsername = (
  params: Params<t_UsersGetByUsernameParamSchema, void, void, void>,
  respond: UsersGetByUsernameResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListAttestationsBulkResponder = {
  with200(): ExpressRuntimeResponse<{
    attestations_subject_digests?:
      | {
          [key: string]:
            | (
                | {
                    bundle?:
                      | {
                          dsseEnvelope?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                          mediaType?: string | undefined
                          verificationMaterial?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                        }
                      | undefined
                    bundle_url?: string | undefined
                    repository_id?: number | undefined
                  }[]
                | null
              )
            | undefined
        }
      | undefined
    page_info?:
      | {
          has_next?: boolean | undefined
          has_previous?: boolean | undefined
          next?: string | undefined
          previous?: string | undefined
        }
      | undefined
  }>
} & ExpressRuntimeResponder

export type UsersListAttestationsBulk = (
  params: Params<
    t_UsersListAttestationsBulkParamSchema,
    t_UsersListAttestationsBulkQuerySchema,
    t_UsersListAttestationsBulkRequestBody,
    void
  >,
  respond: UsersListAttestationsBulkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeleteAttestationsBulkResponder = {
  with200(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersDeleteAttestationsBulk = (
  params: Params<
    t_UsersDeleteAttestationsBulkParamSchema,
    void,
    t_UsersDeleteAttestationsBulkRequestBody,
    void
  >,
  respond: UsersDeleteAttestationsBulkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeleteAttestationsBySubjectDigestResponder = {
  with200(): ExpressRuntimeResponse<void>
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersDeleteAttestationsBySubjectDigest = (
  params: Params<
    t_UsersDeleteAttestationsBySubjectDigestParamSchema,
    void,
    void,
    void
  >,
  respond: UsersDeleteAttestationsBySubjectDigestResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersDeleteAttestationsByIdResponder = {
  with200(): ExpressRuntimeResponse<void>
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersDeleteAttestationsById = (
  params: Params<t_UsersDeleteAttestationsByIdParamSchema, void, void, void>,
  respond: UsersDeleteAttestationsByIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListAttestationsResponder = {
  with200(): ExpressRuntimeResponse<{
    attestations?:
      | {
          bundle?:
            | {
                dsseEnvelope?:
                  | {
                      [key: string]: unknown | undefined
                    }
                  | undefined
                mediaType?: string | undefined
                verificationMaterial?:
                  | {
                      [key: string]: unknown | undefined
                    }
                  | undefined
              }
            | undefined
          bundle_url?: string | undefined
          repository_id?: number | undefined
        }[]
      | undefined
  }>
  with201(): ExpressRuntimeResponse<t_empty_object>
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type UsersListAttestations = (
  params: Params<
    t_UsersListAttestationsParamSchema,
    t_UsersListAttestationsQuerySchema,
    void,
    void
  >,
  respond: UsersListAttestationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesListDockerMigrationConflictingPackagesForUserResponder = {
  with200(): ExpressRuntimeResponse<t_package[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesListDockerMigrationConflictingPackagesForUser = (
  params: Params<
    t_PackagesListDockerMigrationConflictingPackagesForUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesListDockerMigrationConflictingPackagesForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListEventsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
} & ExpressRuntimeResponder

export type ActivityListEventsForAuthenticatedUser = (
  params: Params<
    t_ActivityListEventsForAuthenticatedUserParamSchema,
    t_ActivityListEventsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListEventsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListOrgEventsForAuthenticatedUserResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
} & ExpressRuntimeResponder

export type ActivityListOrgEventsForAuthenticatedUser = (
  params: Params<
    t_ActivityListOrgEventsForAuthenticatedUserParamSchema,
    t_ActivityListOrgEventsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListOrgEventsForAuthenticatedUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListPublicEventsForUserResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
} & ExpressRuntimeResponder

export type ActivityListPublicEventsForUser = (
  params: Params<
    t_ActivityListPublicEventsForUserParamSchema,
    t_ActivityListPublicEventsForUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListPublicEventsForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListFollowersForUserResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
} & ExpressRuntimeResponder

export type UsersListFollowersForUser = (
  params: Params<
    t_UsersListFollowersForUserParamSchema,
    t_UsersListFollowersForUserQuerySchema,
    void,
    void
  >,
  respond: UsersListFollowersForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListFollowingForUserResponder = {
  with200(): ExpressRuntimeResponse<t_simple_user[]>
} & ExpressRuntimeResponder

export type UsersListFollowingForUser = (
  params: Params<
    t_UsersListFollowingForUserParamSchema,
    t_UsersListFollowingForUserQuerySchema,
    void,
    void
  >,
  respond: UsersListFollowingForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersCheckFollowingForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with404(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type UsersCheckFollowingForUser = (
  params: Params<t_UsersCheckFollowingForUserParamSchema, void, void, void>,
  respond: UsersCheckFollowingForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GistsListForUserResponder = {
  with200(): ExpressRuntimeResponse<t_base_gist[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type GistsListForUser = (
  params: Params<
    t_GistsListForUserParamSchema,
    t_GistsListForUserQuerySchema,
    void,
    void
  >,
  respond: GistsListForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListGpgKeysForUserResponder = {
  with200(): ExpressRuntimeResponse<t_gpg_key[]>
} & ExpressRuntimeResponder

export type UsersListGpgKeysForUser = (
  params: Params<
    t_UsersListGpgKeysForUserParamSchema,
    t_UsersListGpgKeysForUserQuerySchema,
    void,
    void
  >,
  respond: UsersListGpgKeysForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersGetContextForUserResponder = {
  with200(): ExpressRuntimeResponse<t_hovercard>
  with404(): ExpressRuntimeResponse<t_basic_error>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type UsersGetContextForUser = (
  params: Params<
    t_UsersGetContextForUserParamSchema,
    t_UsersGetContextForUserQuerySchema,
    void,
    void
  >,
  respond: UsersGetContextForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AppsGetUserInstallationResponder = {
  with200(): ExpressRuntimeResponse<t_installation>
} & ExpressRuntimeResponder

export type AppsGetUserInstallation = (
  params: Params<t_AppsGetUserInstallationParamSchema, void, void, void>,
  respond: AppsGetUserInstallationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListPublicKeysForUserResponder = {
  with200(): ExpressRuntimeResponse<t_key_simple[]>
} & ExpressRuntimeResponder

export type UsersListPublicKeysForUser = (
  params: Params<
    t_UsersListPublicKeysForUserParamSchema,
    t_UsersListPublicKeysForUserQuerySchema,
    void,
    void
  >,
  respond: UsersListPublicKeysForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OrgsListForUserResponder = {
  with200(): ExpressRuntimeResponse<t_organization_simple[]>
} & ExpressRuntimeResponder

export type OrgsListForUser = (
  params: Params<
    t_OrgsListForUserParamSchema,
    t_OrgsListForUserQuerySchema,
    void,
    void
  >,
  respond: OrgsListForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesListPackagesForUserResponder = {
  with200(): ExpressRuntimeResponse<t_package[]>
  with400(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesListPackagesForUser = (
  params: Params<
    t_PackagesListPackagesForUserParamSchema,
    t_PackagesListPackagesForUserQuerySchema,
    void,
    void
  >,
  respond: PackagesListPackagesForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetPackageForUserResponder = {
  with200(): ExpressRuntimeResponse<t_package>
} & ExpressRuntimeResponder

export type PackagesGetPackageForUser = (
  params: Params<t_PackagesGetPackageForUserParamSchema, void, void, void>,
  respond: PackagesGetPackageForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesDeletePackageForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesDeletePackageForUser = (
  params: Params<t_PackagesDeletePackageForUserParamSchema, void, void, void>,
  respond: PackagesDeletePackageForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesRestorePackageForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesRestorePackageForUser = (
  params: Params<
    t_PackagesRestorePackageForUserParamSchema,
    t_PackagesRestorePackageForUserQuerySchema,
    void,
    void
  >,
  respond: PackagesRestorePackageForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetAllPackageVersionsForPackageOwnedByUserResponder = {
  with200(): ExpressRuntimeResponse<t_package_version[]>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesGetAllPackageVersionsForPackageOwnedByUser = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesGetAllPackageVersionsForPackageOwnedByUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesGetPackageVersionForUserResponder = {
  with200(): ExpressRuntimeResponse<t_package_version>
} & ExpressRuntimeResponder

export type PackagesGetPackageVersionForUser = (
  params: Params<
    t_PackagesGetPackageVersionForUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesGetPackageVersionForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesDeletePackageVersionForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesDeletePackageVersionForUser = (
  params: Params<
    t_PackagesDeletePackageVersionForUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesDeletePackageVersionForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PackagesRestorePackageVersionForUserResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_basic_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type PackagesRestorePackageVersionForUser = (
  params: Params<
    t_PackagesRestorePackageVersionForUserParamSchema,
    void,
    void,
    void
  >,
  respond: PackagesRestorePackageVersionForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ProjectsClassicListForUserResponder = {
  with200(): ExpressRuntimeResponse<t_project[]>
  with422(): ExpressRuntimeResponse<t_validation_error>
} & ExpressRuntimeResponder

export type ProjectsClassicListForUser = (
  params: Params<
    t_ProjectsClassicListForUserParamSchema,
    t_ProjectsClassicListForUserQuerySchema,
    void,
    void
  >,
  respond: ProjectsClassicListForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListReceivedEventsForUserResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
} & ExpressRuntimeResponder

export type ActivityListReceivedEventsForUser = (
  params: Params<
    t_ActivityListReceivedEventsForUserParamSchema,
    t_ActivityListReceivedEventsForUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListReceivedEventsForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListReceivedPublicEventsForUserResponder = {
  with200(): ExpressRuntimeResponse<t_event[]>
} & ExpressRuntimeResponder

export type ActivityListReceivedPublicEventsForUser = (
  params: Params<
    t_ActivityListReceivedPublicEventsForUserParamSchema,
    t_ActivityListReceivedPublicEventsForUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListReceivedPublicEventsForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReposListForUserResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
} & ExpressRuntimeResponder

export type ReposListForUser = (
  params: Params<
    t_ReposListForUserParamSchema,
    t_ReposListForUserQuerySchema,
    void,
    void
  >,
  respond: ReposListForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetGithubActionsBillingUserResponder = {
  with200(): ExpressRuntimeResponse<t_actions_billing_usage>
} & ExpressRuntimeResponder

export type BillingGetGithubActionsBillingUser = (
  params: Params<
    t_BillingGetGithubActionsBillingUserParamSchema,
    void,
    void,
    void
  >,
  respond: BillingGetGithubActionsBillingUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetGithubPackagesBillingUserResponder = {
  with200(): ExpressRuntimeResponse<t_packages_billing_usage>
} & ExpressRuntimeResponder

export type BillingGetGithubPackagesBillingUser = (
  params: Params<
    t_BillingGetGithubPackagesBillingUserParamSchema,
    void,
    void,
    void
  >,
  respond: BillingGetGithubPackagesBillingUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetSharedStorageBillingUserResponder = {
  with200(): ExpressRuntimeResponse<t_combined_billing_usage>
} & ExpressRuntimeResponder

export type BillingGetSharedStorageBillingUser = (
  params: Params<
    t_BillingGetSharedStorageBillingUserParamSchema,
    void,
    void,
    void
  >,
  respond: BillingGetSharedStorageBillingUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BillingGetGithubBillingUsageReportUserResponder = {
  with200(): ExpressRuntimeResponse<t_billing_usage_report_user>
  with400(): ExpressRuntimeResponse<t_scim_error>
  with403(): ExpressRuntimeResponse<t_basic_error>
  with500(): ExpressRuntimeResponse<t_basic_error>
  with503(): ExpressRuntimeResponse<{
    code?: string | undefined
    documentation_url?: string | undefined
    message?: string | undefined
  }>
} & ExpressRuntimeResponder

export type BillingGetGithubBillingUsageReportUser = (
  params: Params<
    t_BillingGetGithubBillingUsageReportUserParamSchema,
    t_BillingGetGithubBillingUsageReportUserQuerySchema,
    void,
    void
  >,
  respond: BillingGetGithubBillingUsageReportUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListSocialAccountsForUserResponder = {
  with200(): ExpressRuntimeResponse<t_social_account[]>
} & ExpressRuntimeResponder

export type UsersListSocialAccountsForUser = (
  params: Params<
    t_UsersListSocialAccountsForUserParamSchema,
    t_UsersListSocialAccountsForUserQuerySchema,
    void,
    void
  >,
  respond: UsersListSocialAccountsForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UsersListSshSigningKeysForUserResponder = {
  with200(): ExpressRuntimeResponse<t_ssh_signing_key[]>
} & ExpressRuntimeResponder

export type UsersListSshSigningKeysForUser = (
  params: Params<
    t_UsersListSshSigningKeysForUserParamSchema,
    t_UsersListSshSigningKeysForUserQuerySchema,
    void,
    void
  >,
  respond: UsersListSshSigningKeysForUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListReposStarredByUserResponder = {
  with200(): ExpressRuntimeResponse<t_starred_repository[] | t_repository[]>
} & ExpressRuntimeResponder

export type ActivityListReposStarredByUser = (
  params: Params<
    t_ActivityListReposStarredByUserParamSchema,
    t_ActivityListReposStarredByUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListReposStarredByUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ActivityListReposWatchedByUserResponder = {
  with200(): ExpressRuntimeResponse<t_minimal_repository[]>
} & ExpressRuntimeResponder

export type ActivityListReposWatchedByUser = (
  params: Params<
    t_ActivityListReposWatchedByUserParamSchema,
    t_ActivityListReposWatchedByUserQuerySchema,
    void,
    void
  >,
  respond: ActivityListReposWatchedByUserResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MetaGetAllVersionsResponder = {
  with200(): ExpressRuntimeResponse<string[]>
  with404(): ExpressRuntimeResponse<t_basic_error>
} & ExpressRuntimeResponder

export type MetaGetAllVersions = (
  params: Params<void, void, void, void>,
  respond: MetaGetAllVersionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type MetaGetZenResponder = {
  with200(): ExpressRuntimeResponse<string>
} & ExpressRuntimeResponder

export type MetaGetZen = (
  params: Params<void, void, void, void>,
  respond: MetaGetZenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  metaRoot: MetaRoot
  securityAdvisoriesListGlobalAdvisories: SecurityAdvisoriesListGlobalAdvisories
  securityAdvisoriesGetGlobalAdvisory: SecurityAdvisoriesGetGlobalAdvisory
  appsGetAuthenticated: AppsGetAuthenticated
  appsCreateFromManifest: AppsCreateFromManifest
  appsGetWebhookConfigForApp: AppsGetWebhookConfigForApp
  appsUpdateWebhookConfigForApp: AppsUpdateWebhookConfigForApp
  appsListWebhookDeliveries: AppsListWebhookDeliveries
  appsGetWebhookDelivery: AppsGetWebhookDelivery
  appsRedeliverWebhookDelivery: AppsRedeliverWebhookDelivery
  appsListInstallationRequestsForAuthenticatedApp: AppsListInstallationRequestsForAuthenticatedApp
  appsListInstallations: AppsListInstallations
  appsGetInstallation: AppsGetInstallation
  appsDeleteInstallation: AppsDeleteInstallation
  appsCreateInstallationAccessToken: AppsCreateInstallationAccessToken
  appsSuspendInstallation: AppsSuspendInstallation
  appsUnsuspendInstallation: AppsUnsuspendInstallation
  appsDeleteAuthorization: AppsDeleteAuthorization
  appsCheckToken: AppsCheckToken
  appsResetToken: AppsResetToken
  appsDeleteToken: AppsDeleteToken
  appsScopeToken: AppsScopeToken
  appsGetBySlug: AppsGetBySlug
  classroomGetAnAssignment: ClassroomGetAnAssignment
  classroomListAcceptedAssignmentsForAnAssignment: ClassroomListAcceptedAssignmentsForAnAssignment
  classroomGetAssignmentGrades: ClassroomGetAssignmentGrades
  classroomListClassrooms: ClassroomListClassrooms
  classroomGetAClassroom: ClassroomGetAClassroom
  classroomListAssignmentsForAClassroom: ClassroomListAssignmentsForAClassroom
  codesOfConductGetAllCodesOfConduct: CodesOfConductGetAllCodesOfConduct
  codesOfConductGetConductCode: CodesOfConductGetConductCode
  credentialsRevoke: CredentialsRevoke
  emojisGet: EmojisGet
  codeSecurityGetConfigurationsForEnterprise: CodeSecurityGetConfigurationsForEnterprise
  codeSecurityCreateConfigurationForEnterprise: CodeSecurityCreateConfigurationForEnterprise
  codeSecurityGetDefaultConfigurationsForEnterprise: CodeSecurityGetDefaultConfigurationsForEnterprise
  codeSecurityGetSingleConfigurationForEnterprise: CodeSecurityGetSingleConfigurationForEnterprise
  codeSecurityUpdateEnterpriseConfiguration: CodeSecurityUpdateEnterpriseConfiguration
  codeSecurityDeleteConfigurationForEnterprise: CodeSecurityDeleteConfigurationForEnterprise
  codeSecurityAttachEnterpriseConfiguration: CodeSecurityAttachEnterpriseConfiguration
  codeSecuritySetConfigurationAsDefaultForEnterprise: CodeSecuritySetConfigurationAsDefaultForEnterprise
  codeSecurityGetRepositoriesForEnterpriseConfiguration: CodeSecurityGetRepositoriesForEnterpriseConfiguration
  dependabotListAlertsForEnterprise: DependabotListAlertsForEnterprise
  secretScanningListAlertsForEnterprise: SecretScanningListAlertsForEnterprise
  activityListPublicEvents: ActivityListPublicEvents
  activityGetFeeds: ActivityGetFeeds
  gistsList: GistsList
  gistsCreate: GistsCreate
  gistsListPublic: GistsListPublic
  gistsListStarred: GistsListStarred
  gistsGet: GistsGet
  gistsUpdate: GistsUpdate
  gistsDelete: GistsDelete
  gistsListComments: GistsListComments
  gistsCreateComment: GistsCreateComment
  gistsGetComment: GistsGetComment
  gistsUpdateComment: GistsUpdateComment
  gistsDeleteComment: GistsDeleteComment
  gistsListCommits: GistsListCommits
  gistsListForks: GistsListForks
  gistsFork: GistsFork
  gistsCheckIsStarred: GistsCheckIsStarred
  gistsStar: GistsStar
  gistsUnstar: GistsUnstar
  gistsGetRevision: GistsGetRevision
  gitignoreGetAllTemplates: GitignoreGetAllTemplates
  gitignoreGetTemplate: GitignoreGetTemplate
  appsListReposAccessibleToInstallation: AppsListReposAccessibleToInstallation
  appsRevokeInstallationAccessToken: AppsRevokeInstallationAccessToken
  issuesList: IssuesList
  licensesGetAllCommonlyUsed: LicensesGetAllCommonlyUsed
  licensesGet: LicensesGet
  markdownRender: MarkdownRender
  markdownRenderRaw: MarkdownRenderRaw
  appsGetSubscriptionPlanForAccount: AppsGetSubscriptionPlanForAccount
  appsListPlans: AppsListPlans
  appsListAccountsForPlan: AppsListAccountsForPlan
  appsGetSubscriptionPlanForAccountStubbed: AppsGetSubscriptionPlanForAccountStubbed
  appsListPlansStubbed: AppsListPlansStubbed
  appsListAccountsForPlanStubbed: AppsListAccountsForPlanStubbed
  metaGet: MetaGet
  activityListPublicEventsForRepoNetwork: ActivityListPublicEventsForRepoNetwork
  activityListNotificationsForAuthenticatedUser: ActivityListNotificationsForAuthenticatedUser
  activityMarkNotificationsAsRead: ActivityMarkNotificationsAsRead
  activityGetThread: ActivityGetThread
  activityMarkThreadAsRead: ActivityMarkThreadAsRead
  activityMarkThreadAsDone: ActivityMarkThreadAsDone
  activityGetThreadSubscriptionForAuthenticatedUser: ActivityGetThreadSubscriptionForAuthenticatedUser
  activitySetThreadSubscription: ActivitySetThreadSubscription
  activityDeleteThreadSubscription: ActivityDeleteThreadSubscription
  metaGetOctocat: MetaGetOctocat
  orgsList: OrgsList
  dependabotRepositoryAccessForOrg: DependabotRepositoryAccessForOrg
  dependabotUpdateRepositoryAccessForOrg: DependabotUpdateRepositoryAccessForOrg
  dependabotSetRepositoryAccessDefaultLevel: DependabotSetRepositoryAccessDefaultLevel
  billingGetGithubBillingUsageReportOrg: BillingGetGithubBillingUsageReportOrg
  orgsGet: OrgsGet
  orgsUpdate: OrgsUpdate
  orgsDelete: OrgsDelete
  actionsGetActionsCacheUsageForOrg: ActionsGetActionsCacheUsageForOrg
  actionsGetActionsCacheUsageByRepoForOrg: ActionsGetActionsCacheUsageByRepoForOrg
  actionsListHostedRunnersForOrg: ActionsListHostedRunnersForOrg
  actionsCreateHostedRunnerForOrg: ActionsCreateHostedRunnerForOrg
  actionsGetHostedRunnersGithubOwnedImagesForOrg: ActionsGetHostedRunnersGithubOwnedImagesForOrg
  actionsGetHostedRunnersPartnerImagesForOrg: ActionsGetHostedRunnersPartnerImagesForOrg
  actionsGetHostedRunnersLimitsForOrg: ActionsGetHostedRunnersLimitsForOrg
  actionsGetHostedRunnersMachineSpecsForOrg: ActionsGetHostedRunnersMachineSpecsForOrg
  actionsGetHostedRunnersPlatformsForOrg: ActionsGetHostedRunnersPlatformsForOrg
  actionsGetHostedRunnerForOrg: ActionsGetHostedRunnerForOrg
  actionsUpdateHostedRunnerForOrg: ActionsUpdateHostedRunnerForOrg
  actionsDeleteHostedRunnerForOrg: ActionsDeleteHostedRunnerForOrg
  oidcGetOidcCustomSubTemplateForOrg: OidcGetOidcCustomSubTemplateForOrg
  oidcUpdateOidcCustomSubTemplateForOrg: OidcUpdateOidcCustomSubTemplateForOrg
  actionsGetGithubActionsPermissionsOrganization: ActionsGetGithubActionsPermissionsOrganization
  actionsSetGithubActionsPermissionsOrganization: ActionsSetGithubActionsPermissionsOrganization
  actionsListSelectedRepositoriesEnabledGithubActionsOrganization: ActionsListSelectedRepositoriesEnabledGithubActionsOrganization
  actionsSetSelectedRepositoriesEnabledGithubActionsOrganization: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization
  actionsEnableSelectedRepositoryGithubActionsOrganization: ActionsEnableSelectedRepositoryGithubActionsOrganization
  actionsDisableSelectedRepositoryGithubActionsOrganization: ActionsDisableSelectedRepositoryGithubActionsOrganization
  actionsGetAllowedActionsOrganization: ActionsGetAllowedActionsOrganization
  actionsSetAllowedActionsOrganization: ActionsSetAllowedActionsOrganization
  actionsGetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization
  actionsSetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization
  actionsListSelfHostedRunnerGroupsForOrg: ActionsListSelfHostedRunnerGroupsForOrg
  actionsCreateSelfHostedRunnerGroupForOrg: ActionsCreateSelfHostedRunnerGroupForOrg
  actionsGetSelfHostedRunnerGroupForOrg: ActionsGetSelfHostedRunnerGroupForOrg
  actionsUpdateSelfHostedRunnerGroupForOrg: ActionsUpdateSelfHostedRunnerGroupForOrg
  actionsDeleteSelfHostedRunnerGroupFromOrg: ActionsDeleteSelfHostedRunnerGroupFromOrg
  actionsListGithubHostedRunnersInGroupForOrg: ActionsListGithubHostedRunnersInGroupForOrg
  actionsListRepoAccessToSelfHostedRunnerGroupInOrg: ActionsListRepoAccessToSelfHostedRunnerGroupInOrg
  actionsSetRepoAccessToSelfHostedRunnerGroupInOrg: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg
  actionsAddRepoAccessToSelfHostedRunnerGroupInOrg: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg
  actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
  actionsListSelfHostedRunnersInGroupForOrg: ActionsListSelfHostedRunnersInGroupForOrg
  actionsSetSelfHostedRunnersInGroupForOrg: ActionsSetSelfHostedRunnersInGroupForOrg
  actionsAddSelfHostedRunnerToGroupForOrg: ActionsAddSelfHostedRunnerToGroupForOrg
  actionsRemoveSelfHostedRunnerFromGroupForOrg: ActionsRemoveSelfHostedRunnerFromGroupForOrg
  actionsListSelfHostedRunnersForOrg: ActionsListSelfHostedRunnersForOrg
  actionsListRunnerApplicationsForOrg: ActionsListRunnerApplicationsForOrg
  actionsGenerateRunnerJitconfigForOrg: ActionsGenerateRunnerJitconfigForOrg
  actionsCreateRegistrationTokenForOrg: ActionsCreateRegistrationTokenForOrg
  actionsCreateRemoveTokenForOrg: ActionsCreateRemoveTokenForOrg
  actionsGetSelfHostedRunnerForOrg: ActionsGetSelfHostedRunnerForOrg
  actionsDeleteSelfHostedRunnerFromOrg: ActionsDeleteSelfHostedRunnerFromOrg
  actionsListLabelsForSelfHostedRunnerForOrg: ActionsListLabelsForSelfHostedRunnerForOrg
  actionsAddCustomLabelsToSelfHostedRunnerForOrg: ActionsAddCustomLabelsToSelfHostedRunnerForOrg
  actionsSetCustomLabelsForSelfHostedRunnerForOrg: ActionsSetCustomLabelsForSelfHostedRunnerForOrg
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg
  actionsRemoveCustomLabelFromSelfHostedRunnerForOrg: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg
  actionsListOrgSecrets: ActionsListOrgSecrets
  actionsGetOrgPublicKey: ActionsGetOrgPublicKey
  actionsGetOrgSecret: ActionsGetOrgSecret
  actionsCreateOrUpdateOrgSecret: ActionsCreateOrUpdateOrgSecret
  actionsDeleteOrgSecret: ActionsDeleteOrgSecret
  actionsListSelectedReposForOrgSecret: ActionsListSelectedReposForOrgSecret
  actionsSetSelectedReposForOrgSecret: ActionsSetSelectedReposForOrgSecret
  actionsAddSelectedRepoToOrgSecret: ActionsAddSelectedRepoToOrgSecret
  actionsRemoveSelectedRepoFromOrgSecret: ActionsRemoveSelectedRepoFromOrgSecret
  actionsListOrgVariables: ActionsListOrgVariables
  actionsCreateOrgVariable: ActionsCreateOrgVariable
  actionsGetOrgVariable: ActionsGetOrgVariable
  actionsUpdateOrgVariable: ActionsUpdateOrgVariable
  actionsDeleteOrgVariable: ActionsDeleteOrgVariable
  actionsListSelectedReposForOrgVariable: ActionsListSelectedReposForOrgVariable
  actionsSetSelectedReposForOrgVariable: ActionsSetSelectedReposForOrgVariable
  actionsAddSelectedRepoToOrgVariable: ActionsAddSelectedRepoToOrgVariable
  actionsRemoveSelectedRepoFromOrgVariable: ActionsRemoveSelectedRepoFromOrgVariable
  orgsListAttestationsBulk: OrgsListAttestationsBulk
  orgsDeleteAttestationsBulk: OrgsDeleteAttestationsBulk
  orgsDeleteAttestationsBySubjectDigest: OrgsDeleteAttestationsBySubjectDigest
  orgsDeleteAttestationsById: OrgsDeleteAttestationsById
  orgsListAttestations: OrgsListAttestations
  orgsListBlockedUsers: OrgsListBlockedUsers
  orgsCheckBlockedUser: OrgsCheckBlockedUser
  orgsBlockUser: OrgsBlockUser
  orgsUnblockUser: OrgsUnblockUser
  campaignsListOrgCampaigns: CampaignsListOrgCampaigns
  campaignsCreateCampaign: CampaignsCreateCampaign
  campaignsGetCampaignSummary: CampaignsGetCampaignSummary
  campaignsUpdateCampaign: CampaignsUpdateCampaign
  campaignsDeleteCampaign: CampaignsDeleteCampaign
  codeScanningListAlertsForOrg: CodeScanningListAlertsForOrg
  codeSecurityGetConfigurationsForOrg: CodeSecurityGetConfigurationsForOrg
  codeSecurityCreateConfiguration: CodeSecurityCreateConfiguration
  codeSecurityGetDefaultConfigurations: CodeSecurityGetDefaultConfigurations
  codeSecurityDetachConfiguration: CodeSecurityDetachConfiguration
  codeSecurityGetConfiguration: CodeSecurityGetConfiguration
  codeSecurityUpdateConfiguration: CodeSecurityUpdateConfiguration
  codeSecurityDeleteConfiguration: CodeSecurityDeleteConfiguration
  codeSecurityAttachConfiguration: CodeSecurityAttachConfiguration
  codeSecuritySetConfigurationAsDefault: CodeSecuritySetConfigurationAsDefault
  codeSecurityGetRepositoriesForConfiguration: CodeSecurityGetRepositoriesForConfiguration
  codespacesListInOrganization: CodespacesListInOrganization
  codespacesSetCodespacesAccess: CodespacesSetCodespacesAccess
  codespacesSetCodespacesAccessUsers: CodespacesSetCodespacesAccessUsers
  codespacesDeleteCodespacesAccessUsers: CodespacesDeleteCodespacesAccessUsers
  codespacesListOrgSecrets: CodespacesListOrgSecrets
  codespacesGetOrgPublicKey: CodespacesGetOrgPublicKey
  codespacesGetOrgSecret: CodespacesGetOrgSecret
  codespacesCreateOrUpdateOrgSecret: CodespacesCreateOrUpdateOrgSecret
  codespacesDeleteOrgSecret: CodespacesDeleteOrgSecret
  codespacesListSelectedReposForOrgSecret: CodespacesListSelectedReposForOrgSecret
  codespacesSetSelectedReposForOrgSecret: CodespacesSetSelectedReposForOrgSecret
  codespacesAddSelectedRepoToOrgSecret: CodespacesAddSelectedRepoToOrgSecret
  codespacesRemoveSelectedRepoFromOrgSecret: CodespacesRemoveSelectedRepoFromOrgSecret
  copilotGetCopilotOrganizationDetails: CopilotGetCopilotOrganizationDetails
  copilotListCopilotSeats: CopilotListCopilotSeats
  copilotAddCopilotSeatsForTeams: CopilotAddCopilotSeatsForTeams
  copilotCancelCopilotSeatAssignmentForTeams: CopilotCancelCopilotSeatAssignmentForTeams
  copilotAddCopilotSeatsForUsers: CopilotAddCopilotSeatsForUsers
  copilotCancelCopilotSeatAssignmentForUsers: CopilotCancelCopilotSeatAssignmentForUsers
  copilotCopilotMetricsForOrganization: CopilotCopilotMetricsForOrganization
  dependabotListAlertsForOrg: DependabotListAlertsForOrg
  dependabotListOrgSecrets: DependabotListOrgSecrets
  dependabotGetOrgPublicKey: DependabotGetOrgPublicKey
  dependabotGetOrgSecret: DependabotGetOrgSecret
  dependabotCreateOrUpdateOrgSecret: DependabotCreateOrUpdateOrgSecret
  dependabotDeleteOrgSecret: DependabotDeleteOrgSecret
  dependabotListSelectedReposForOrgSecret: DependabotListSelectedReposForOrgSecret
  dependabotSetSelectedReposForOrgSecret: DependabotSetSelectedReposForOrgSecret
  dependabotAddSelectedRepoToOrgSecret: DependabotAddSelectedRepoToOrgSecret
  dependabotRemoveSelectedRepoFromOrgSecret: DependabotRemoveSelectedRepoFromOrgSecret
  packagesListDockerMigrationConflictingPackagesForOrganization: PackagesListDockerMigrationConflictingPackagesForOrganization
  activityListPublicOrgEvents: ActivityListPublicOrgEvents
  orgsListFailedInvitations: OrgsListFailedInvitations
  orgsListWebhooks: OrgsListWebhooks
  orgsCreateWebhook: OrgsCreateWebhook
  orgsGetWebhook: OrgsGetWebhook
  orgsUpdateWebhook: OrgsUpdateWebhook
  orgsDeleteWebhook: OrgsDeleteWebhook
  orgsGetWebhookConfigForOrg: OrgsGetWebhookConfigForOrg
  orgsUpdateWebhookConfigForOrg: OrgsUpdateWebhookConfigForOrg
  orgsListWebhookDeliveries: OrgsListWebhookDeliveries
  orgsGetWebhookDelivery: OrgsGetWebhookDelivery
  orgsRedeliverWebhookDelivery: OrgsRedeliverWebhookDelivery
  orgsPingWebhook: OrgsPingWebhook
  apiInsightsGetRouteStatsByActor: ApiInsightsGetRouteStatsByActor
  apiInsightsGetSubjectStats: ApiInsightsGetSubjectStats
  apiInsightsGetSummaryStats: ApiInsightsGetSummaryStats
  apiInsightsGetSummaryStatsByUser: ApiInsightsGetSummaryStatsByUser
  apiInsightsGetSummaryStatsByActor: ApiInsightsGetSummaryStatsByActor
  apiInsightsGetTimeStats: ApiInsightsGetTimeStats
  apiInsightsGetTimeStatsByUser: ApiInsightsGetTimeStatsByUser
  apiInsightsGetTimeStatsByActor: ApiInsightsGetTimeStatsByActor
  apiInsightsGetUserStats: ApiInsightsGetUserStats
  appsGetOrgInstallation: AppsGetOrgInstallation
  orgsListAppInstallations: OrgsListAppInstallations
  interactionsGetRestrictionsForOrg: InteractionsGetRestrictionsForOrg
  interactionsSetRestrictionsForOrg: InteractionsSetRestrictionsForOrg
  interactionsRemoveRestrictionsForOrg: InteractionsRemoveRestrictionsForOrg
  orgsListPendingInvitations: OrgsListPendingInvitations
  orgsCreateInvitation: OrgsCreateInvitation
  orgsCancelInvitation: OrgsCancelInvitation
  orgsListInvitationTeams: OrgsListInvitationTeams
  orgsListIssueTypes: OrgsListIssueTypes
  orgsCreateIssueType: OrgsCreateIssueType
  orgsUpdateIssueType: OrgsUpdateIssueType
  orgsDeleteIssueType: OrgsDeleteIssueType
  issuesListForOrg: IssuesListForOrg
  orgsListMembers: OrgsListMembers
  orgsCheckMembershipForUser: OrgsCheckMembershipForUser
  orgsRemoveMember: OrgsRemoveMember
  codespacesGetCodespacesForUserInOrg: CodespacesGetCodespacesForUserInOrg
  codespacesDeleteFromOrganization: CodespacesDeleteFromOrganization
  codespacesStopInOrganization: CodespacesStopInOrganization
  copilotGetCopilotSeatDetailsForUser: CopilotGetCopilotSeatDetailsForUser
  orgsGetMembershipForUser: OrgsGetMembershipForUser
  orgsSetMembershipForUser: OrgsSetMembershipForUser
  orgsRemoveMembershipForUser: OrgsRemoveMembershipForUser
  migrationsListForOrg: MigrationsListForOrg
  migrationsStartForOrg: MigrationsStartForOrg
  migrationsGetStatusForOrg: MigrationsGetStatusForOrg
  migrationsDownloadArchiveForOrg: MigrationsDownloadArchiveForOrg
  migrationsDeleteArchiveForOrg: MigrationsDeleteArchiveForOrg
  migrationsUnlockRepoForOrg: MigrationsUnlockRepoForOrg
  migrationsListReposForOrg: MigrationsListReposForOrg
  orgsListOrgRoles: OrgsListOrgRoles
  orgsRevokeAllOrgRolesTeam: OrgsRevokeAllOrgRolesTeam
  orgsAssignTeamToOrgRole: OrgsAssignTeamToOrgRole
  orgsRevokeOrgRoleTeam: OrgsRevokeOrgRoleTeam
  orgsRevokeAllOrgRolesUser: OrgsRevokeAllOrgRolesUser
  orgsAssignUserToOrgRole: OrgsAssignUserToOrgRole
  orgsRevokeOrgRoleUser: OrgsRevokeOrgRoleUser
  orgsGetOrgRole: OrgsGetOrgRole
  orgsListOrgRoleTeams: OrgsListOrgRoleTeams
  orgsListOrgRoleUsers: OrgsListOrgRoleUsers
  orgsListOutsideCollaborators: OrgsListOutsideCollaborators
  orgsConvertMemberToOutsideCollaborator: OrgsConvertMemberToOutsideCollaborator
  orgsRemoveOutsideCollaborator: OrgsRemoveOutsideCollaborator
  packagesListPackagesForOrganization: PackagesListPackagesForOrganization
  packagesGetPackageForOrganization: PackagesGetPackageForOrganization
  packagesDeletePackageForOrg: PackagesDeletePackageForOrg
  packagesRestorePackageForOrg: PackagesRestorePackageForOrg
  packagesGetAllPackageVersionsForPackageOwnedByOrg: PackagesGetAllPackageVersionsForPackageOwnedByOrg
  packagesGetPackageVersionForOrganization: PackagesGetPackageVersionForOrganization
  packagesDeletePackageVersionForOrg: PackagesDeletePackageVersionForOrg
  packagesRestorePackageVersionForOrg: PackagesRestorePackageVersionForOrg
  orgsListPatGrantRequests: OrgsListPatGrantRequests
  orgsReviewPatGrantRequestsInBulk: OrgsReviewPatGrantRequestsInBulk
  orgsReviewPatGrantRequest: OrgsReviewPatGrantRequest
  orgsListPatGrantRequestRepositories: OrgsListPatGrantRequestRepositories
  orgsListPatGrants: OrgsListPatGrants
  orgsUpdatePatAccesses: OrgsUpdatePatAccesses
  orgsUpdatePatAccess: OrgsUpdatePatAccess
  orgsListPatGrantRepositories: OrgsListPatGrantRepositories
  privateRegistriesListOrgPrivateRegistries: PrivateRegistriesListOrgPrivateRegistries
  privateRegistriesCreateOrgPrivateRegistry: PrivateRegistriesCreateOrgPrivateRegistry
  privateRegistriesGetOrgPublicKey: PrivateRegistriesGetOrgPublicKey
  privateRegistriesGetOrgPrivateRegistry: PrivateRegistriesGetOrgPrivateRegistry
  privateRegistriesUpdateOrgPrivateRegistry: PrivateRegistriesUpdateOrgPrivateRegistry
  privateRegistriesDeleteOrgPrivateRegistry: PrivateRegistriesDeleteOrgPrivateRegistry
  projectsClassicListForOrg: ProjectsClassicListForOrg
  projectsClassicCreateForOrg: ProjectsClassicCreateForOrg
  orgsGetAllCustomProperties: OrgsGetAllCustomProperties
  orgsCreateOrUpdateCustomProperties: OrgsCreateOrUpdateCustomProperties
  orgsGetCustomProperty: OrgsGetCustomProperty
  orgsCreateOrUpdateCustomProperty: OrgsCreateOrUpdateCustomProperty
  orgsRemoveCustomProperty: OrgsRemoveCustomProperty
  orgsListCustomPropertiesValuesForRepos: OrgsListCustomPropertiesValuesForRepos
  orgsCreateOrUpdateCustomPropertiesValuesForRepos: OrgsCreateOrUpdateCustomPropertiesValuesForRepos
  orgsListPublicMembers: OrgsListPublicMembers
  orgsCheckPublicMembershipForUser: OrgsCheckPublicMembershipForUser
  orgsSetPublicMembershipForAuthenticatedUser: OrgsSetPublicMembershipForAuthenticatedUser
  orgsRemovePublicMembershipForAuthenticatedUser: OrgsRemovePublicMembershipForAuthenticatedUser
  reposListForOrg: ReposListForOrg
  reposCreateInOrg: ReposCreateInOrg
  reposGetOrgRulesets: ReposGetOrgRulesets
  reposCreateOrgRuleset: ReposCreateOrgRuleset
  reposGetOrgRuleSuites: ReposGetOrgRuleSuites
  reposGetOrgRuleSuite: ReposGetOrgRuleSuite
  reposGetOrgRuleset: ReposGetOrgRuleset
  reposUpdateOrgRuleset: ReposUpdateOrgRuleset
  reposDeleteOrgRuleset: ReposDeleteOrgRuleset
  orgsGetOrgRulesetHistory: OrgsGetOrgRulesetHistory
  orgsGetOrgRulesetVersion: OrgsGetOrgRulesetVersion
  secretScanningListAlertsForOrg: SecretScanningListAlertsForOrg
  securityAdvisoriesListOrgRepositoryAdvisories: SecurityAdvisoriesListOrgRepositoryAdvisories
  orgsListSecurityManagerTeams: OrgsListSecurityManagerTeams
  orgsAddSecurityManagerTeam: OrgsAddSecurityManagerTeam
  orgsRemoveSecurityManagerTeam: OrgsRemoveSecurityManagerTeam
  billingGetGithubActionsBillingOrg: BillingGetGithubActionsBillingOrg
  billingGetGithubPackagesBillingOrg: BillingGetGithubPackagesBillingOrg
  billingGetSharedStorageBillingOrg: BillingGetSharedStorageBillingOrg
  hostedComputeListNetworkConfigurationsForOrg: HostedComputeListNetworkConfigurationsForOrg
  hostedComputeCreateNetworkConfigurationForOrg: HostedComputeCreateNetworkConfigurationForOrg
  hostedComputeGetNetworkConfigurationForOrg: HostedComputeGetNetworkConfigurationForOrg
  hostedComputeUpdateNetworkConfigurationForOrg: HostedComputeUpdateNetworkConfigurationForOrg
  hostedComputeDeleteNetworkConfigurationFromOrg: HostedComputeDeleteNetworkConfigurationFromOrg
  hostedComputeGetNetworkSettingsForOrg: HostedComputeGetNetworkSettingsForOrg
  copilotCopilotMetricsForTeam: CopilotCopilotMetricsForTeam
  teamsList: TeamsList
  teamsCreate: TeamsCreate
  teamsGetByName: TeamsGetByName
  teamsUpdateInOrg: TeamsUpdateInOrg
  teamsDeleteInOrg: TeamsDeleteInOrg
  teamsListDiscussionsInOrg: TeamsListDiscussionsInOrg
  teamsCreateDiscussionInOrg: TeamsCreateDiscussionInOrg
  teamsGetDiscussionInOrg: TeamsGetDiscussionInOrg
  teamsUpdateDiscussionInOrg: TeamsUpdateDiscussionInOrg
  teamsDeleteDiscussionInOrg: TeamsDeleteDiscussionInOrg
  teamsListDiscussionCommentsInOrg: TeamsListDiscussionCommentsInOrg
  teamsCreateDiscussionCommentInOrg: TeamsCreateDiscussionCommentInOrg
  teamsGetDiscussionCommentInOrg: TeamsGetDiscussionCommentInOrg
  teamsUpdateDiscussionCommentInOrg: TeamsUpdateDiscussionCommentInOrg
  teamsDeleteDiscussionCommentInOrg: TeamsDeleteDiscussionCommentInOrg
  reactionsListForTeamDiscussionCommentInOrg: ReactionsListForTeamDiscussionCommentInOrg
  reactionsCreateForTeamDiscussionCommentInOrg: ReactionsCreateForTeamDiscussionCommentInOrg
  reactionsDeleteForTeamDiscussionComment: ReactionsDeleteForTeamDiscussionComment
  reactionsListForTeamDiscussionInOrg: ReactionsListForTeamDiscussionInOrg
  reactionsCreateForTeamDiscussionInOrg: ReactionsCreateForTeamDiscussionInOrg
  reactionsDeleteForTeamDiscussion: ReactionsDeleteForTeamDiscussion
  teamsListPendingInvitationsInOrg: TeamsListPendingInvitationsInOrg
  teamsListMembersInOrg: TeamsListMembersInOrg
  teamsGetMembershipForUserInOrg: TeamsGetMembershipForUserInOrg
  teamsAddOrUpdateMembershipForUserInOrg: TeamsAddOrUpdateMembershipForUserInOrg
  teamsRemoveMembershipForUserInOrg: TeamsRemoveMembershipForUserInOrg
  teamsListProjectsInOrg: TeamsListProjectsInOrg
  teamsCheckPermissionsForProjectInOrg: TeamsCheckPermissionsForProjectInOrg
  teamsAddOrUpdateProjectPermissionsInOrg: TeamsAddOrUpdateProjectPermissionsInOrg
  teamsRemoveProjectInOrg: TeamsRemoveProjectInOrg
  teamsListReposInOrg: TeamsListReposInOrg
  teamsCheckPermissionsForRepoInOrg: TeamsCheckPermissionsForRepoInOrg
  teamsAddOrUpdateRepoPermissionsInOrg: TeamsAddOrUpdateRepoPermissionsInOrg
  teamsRemoveRepoInOrg: TeamsRemoveRepoInOrg
  teamsListChildInOrg: TeamsListChildInOrg
  orgsEnableOrDisableSecurityProductOnAllOrgRepos: OrgsEnableOrDisableSecurityProductOnAllOrgRepos
  projectsClassicGetCard: ProjectsClassicGetCard
  projectsClassicUpdateCard: ProjectsClassicUpdateCard
  projectsClassicDeleteCard: ProjectsClassicDeleteCard
  projectsClassicMoveCard: ProjectsClassicMoveCard
  projectsClassicGetColumn: ProjectsClassicGetColumn
  projectsClassicUpdateColumn: ProjectsClassicUpdateColumn
  projectsClassicDeleteColumn: ProjectsClassicDeleteColumn
  projectsClassicListCards: ProjectsClassicListCards
  projectsClassicCreateCard: ProjectsClassicCreateCard
  projectsClassicMoveColumn: ProjectsClassicMoveColumn
  projectsClassicGet: ProjectsClassicGet
  projectsClassicUpdate: ProjectsClassicUpdate
  projectsClassicDelete: ProjectsClassicDelete
  projectsClassicListCollaborators: ProjectsClassicListCollaborators
  projectsClassicAddCollaborator: ProjectsClassicAddCollaborator
  projectsClassicRemoveCollaborator: ProjectsClassicRemoveCollaborator
  projectsClassicGetPermissionForUser: ProjectsClassicGetPermissionForUser
  projectsClassicListColumns: ProjectsClassicListColumns
  projectsClassicCreateColumn: ProjectsClassicCreateColumn
  rateLimitGet: RateLimitGet
  reposGet: ReposGet
  reposUpdate: ReposUpdate
  reposDelete: ReposDelete
  actionsListArtifactsForRepo: ActionsListArtifactsForRepo
  actionsGetArtifact: ActionsGetArtifact
  actionsDeleteArtifact: ActionsDeleteArtifact
  actionsDownloadArtifact: ActionsDownloadArtifact
  actionsGetActionsCacheUsage: ActionsGetActionsCacheUsage
  actionsGetActionsCacheList: ActionsGetActionsCacheList
  actionsDeleteActionsCacheByKey: ActionsDeleteActionsCacheByKey
  actionsDeleteActionsCacheById: ActionsDeleteActionsCacheById
  actionsGetJobForWorkflowRun: ActionsGetJobForWorkflowRun
  actionsDownloadJobLogsForWorkflowRun: ActionsDownloadJobLogsForWorkflowRun
  actionsReRunJobForWorkflowRun: ActionsReRunJobForWorkflowRun
  actionsGetCustomOidcSubClaimForRepo: ActionsGetCustomOidcSubClaimForRepo
  actionsSetCustomOidcSubClaimForRepo: ActionsSetCustomOidcSubClaimForRepo
  actionsListRepoOrganizationSecrets: ActionsListRepoOrganizationSecrets
  actionsListRepoOrganizationVariables: ActionsListRepoOrganizationVariables
  actionsGetGithubActionsPermissionsRepository: ActionsGetGithubActionsPermissionsRepository
  actionsSetGithubActionsPermissionsRepository: ActionsSetGithubActionsPermissionsRepository
  actionsGetWorkflowAccessToRepository: ActionsGetWorkflowAccessToRepository
  actionsSetWorkflowAccessToRepository: ActionsSetWorkflowAccessToRepository
  actionsGetAllowedActionsRepository: ActionsGetAllowedActionsRepository
  actionsSetAllowedActionsRepository: ActionsSetAllowedActionsRepository
  actionsGetGithubActionsDefaultWorkflowPermissionsRepository: ActionsGetGithubActionsDefaultWorkflowPermissionsRepository
  actionsSetGithubActionsDefaultWorkflowPermissionsRepository: ActionsSetGithubActionsDefaultWorkflowPermissionsRepository
  actionsListSelfHostedRunnersForRepo: ActionsListSelfHostedRunnersForRepo
  actionsListRunnerApplicationsForRepo: ActionsListRunnerApplicationsForRepo
  actionsGenerateRunnerJitconfigForRepo: ActionsGenerateRunnerJitconfigForRepo
  actionsCreateRegistrationTokenForRepo: ActionsCreateRegistrationTokenForRepo
  actionsCreateRemoveTokenForRepo: ActionsCreateRemoveTokenForRepo
  actionsGetSelfHostedRunnerForRepo: ActionsGetSelfHostedRunnerForRepo
  actionsDeleteSelfHostedRunnerFromRepo: ActionsDeleteSelfHostedRunnerFromRepo
  actionsListLabelsForSelfHostedRunnerForRepo: ActionsListLabelsForSelfHostedRunnerForRepo
  actionsAddCustomLabelsToSelfHostedRunnerForRepo: ActionsAddCustomLabelsToSelfHostedRunnerForRepo
  actionsSetCustomLabelsForSelfHostedRunnerForRepo: ActionsSetCustomLabelsForSelfHostedRunnerForRepo
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo
  actionsRemoveCustomLabelFromSelfHostedRunnerForRepo: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo
  actionsListWorkflowRunsForRepo: ActionsListWorkflowRunsForRepo
  actionsGetWorkflowRun: ActionsGetWorkflowRun
  actionsDeleteWorkflowRun: ActionsDeleteWorkflowRun
  actionsGetReviewsForRun: ActionsGetReviewsForRun
  actionsApproveWorkflowRun: ActionsApproveWorkflowRun
  actionsListWorkflowRunArtifacts: ActionsListWorkflowRunArtifacts
  actionsGetWorkflowRunAttempt: ActionsGetWorkflowRunAttempt
  actionsListJobsForWorkflowRunAttempt: ActionsListJobsForWorkflowRunAttempt
  actionsDownloadWorkflowRunAttemptLogs: ActionsDownloadWorkflowRunAttemptLogs
  actionsCancelWorkflowRun: ActionsCancelWorkflowRun
  actionsReviewCustomGatesForRun: ActionsReviewCustomGatesForRun
  actionsForceCancelWorkflowRun: ActionsForceCancelWorkflowRun
  actionsListJobsForWorkflowRun: ActionsListJobsForWorkflowRun
  actionsDownloadWorkflowRunLogs: ActionsDownloadWorkflowRunLogs
  actionsDeleteWorkflowRunLogs: ActionsDeleteWorkflowRunLogs
  actionsGetPendingDeploymentsForRun: ActionsGetPendingDeploymentsForRun
  actionsReviewPendingDeploymentsForRun: ActionsReviewPendingDeploymentsForRun
  actionsReRunWorkflow: ActionsReRunWorkflow
  actionsReRunWorkflowFailedJobs: ActionsReRunWorkflowFailedJobs
  actionsGetWorkflowRunUsage: ActionsGetWorkflowRunUsage
  actionsListRepoSecrets: ActionsListRepoSecrets
  actionsGetRepoPublicKey: ActionsGetRepoPublicKey
  actionsGetRepoSecret: ActionsGetRepoSecret
  actionsCreateOrUpdateRepoSecret: ActionsCreateOrUpdateRepoSecret
  actionsDeleteRepoSecret: ActionsDeleteRepoSecret
  actionsListRepoVariables: ActionsListRepoVariables
  actionsCreateRepoVariable: ActionsCreateRepoVariable
  actionsGetRepoVariable: ActionsGetRepoVariable
  actionsUpdateRepoVariable: ActionsUpdateRepoVariable
  actionsDeleteRepoVariable: ActionsDeleteRepoVariable
  actionsListRepoWorkflows: ActionsListRepoWorkflows
  actionsGetWorkflow: ActionsGetWorkflow
  actionsDisableWorkflow: ActionsDisableWorkflow
  actionsCreateWorkflowDispatch: ActionsCreateWorkflowDispatch
  actionsEnableWorkflow: ActionsEnableWorkflow
  actionsListWorkflowRuns: ActionsListWorkflowRuns
  actionsGetWorkflowUsage: ActionsGetWorkflowUsage
  reposListActivities: ReposListActivities
  issuesListAssignees: IssuesListAssignees
  issuesCheckUserCanBeAssigned: IssuesCheckUserCanBeAssigned
  reposCreateAttestation: ReposCreateAttestation
  reposListAttestations: ReposListAttestations
  reposListAutolinks: ReposListAutolinks
  reposCreateAutolink: ReposCreateAutolink
  reposGetAutolink: ReposGetAutolink
  reposDeleteAutolink: ReposDeleteAutolink
  reposCheckAutomatedSecurityFixes: ReposCheckAutomatedSecurityFixes
  reposEnableAutomatedSecurityFixes: ReposEnableAutomatedSecurityFixes
  reposDisableAutomatedSecurityFixes: ReposDisableAutomatedSecurityFixes
  reposListBranches: ReposListBranches
  reposGetBranch: ReposGetBranch
  reposGetBranchProtection: ReposGetBranchProtection
  reposUpdateBranchProtection: ReposUpdateBranchProtection
  reposDeleteBranchProtection: ReposDeleteBranchProtection
  reposGetAdminBranchProtection: ReposGetAdminBranchProtection
  reposSetAdminBranchProtection: ReposSetAdminBranchProtection
  reposDeleteAdminBranchProtection: ReposDeleteAdminBranchProtection
  reposGetPullRequestReviewProtection: ReposGetPullRequestReviewProtection
  reposUpdatePullRequestReviewProtection: ReposUpdatePullRequestReviewProtection
  reposDeletePullRequestReviewProtection: ReposDeletePullRequestReviewProtection
  reposGetCommitSignatureProtection: ReposGetCommitSignatureProtection
  reposCreateCommitSignatureProtection: ReposCreateCommitSignatureProtection
  reposDeleteCommitSignatureProtection: ReposDeleteCommitSignatureProtection
  reposGetStatusChecksProtection: ReposGetStatusChecksProtection
  reposUpdateStatusCheckProtection: ReposUpdateStatusCheckProtection
  reposRemoveStatusCheckProtection: ReposRemoveStatusCheckProtection
  reposGetAllStatusCheckContexts: ReposGetAllStatusCheckContexts
  reposAddStatusCheckContexts: ReposAddStatusCheckContexts
  reposSetStatusCheckContexts: ReposSetStatusCheckContexts
  reposRemoveStatusCheckContexts: ReposRemoveStatusCheckContexts
  reposGetAccessRestrictions: ReposGetAccessRestrictions
  reposDeleteAccessRestrictions: ReposDeleteAccessRestrictions
  reposGetAppsWithAccessToProtectedBranch: ReposGetAppsWithAccessToProtectedBranch
  reposAddAppAccessRestrictions: ReposAddAppAccessRestrictions
  reposSetAppAccessRestrictions: ReposSetAppAccessRestrictions
  reposRemoveAppAccessRestrictions: ReposRemoveAppAccessRestrictions
  reposGetTeamsWithAccessToProtectedBranch: ReposGetTeamsWithAccessToProtectedBranch
  reposAddTeamAccessRestrictions: ReposAddTeamAccessRestrictions
  reposSetTeamAccessRestrictions: ReposSetTeamAccessRestrictions
  reposRemoveTeamAccessRestrictions: ReposRemoveTeamAccessRestrictions
  reposGetUsersWithAccessToProtectedBranch: ReposGetUsersWithAccessToProtectedBranch
  reposAddUserAccessRestrictions: ReposAddUserAccessRestrictions
  reposSetUserAccessRestrictions: ReposSetUserAccessRestrictions
  reposRemoveUserAccessRestrictions: ReposRemoveUserAccessRestrictions
  reposRenameBranch: ReposRenameBranch
  checksCreate: ChecksCreate
  checksGet: ChecksGet
  checksUpdate: ChecksUpdate
  checksListAnnotations: ChecksListAnnotations
  checksRerequestRun: ChecksRerequestRun
  checksCreateSuite: ChecksCreateSuite
  checksSetSuitesPreferences: ChecksSetSuitesPreferences
  checksGetSuite: ChecksGetSuite
  checksListForSuite: ChecksListForSuite
  checksRerequestSuite: ChecksRerequestSuite
  codeScanningListAlertsForRepo: CodeScanningListAlertsForRepo
  codeScanningGetAlert: CodeScanningGetAlert
  codeScanningUpdateAlert: CodeScanningUpdateAlert
  codeScanningGetAutofix: CodeScanningGetAutofix
  codeScanningCreateAutofix: CodeScanningCreateAutofix
  codeScanningCommitAutofix: CodeScanningCommitAutofix
  codeScanningListAlertInstances: CodeScanningListAlertInstances
  codeScanningListRecentAnalyses: CodeScanningListRecentAnalyses
  codeScanningGetAnalysis: CodeScanningGetAnalysis
  codeScanningDeleteAnalysis: CodeScanningDeleteAnalysis
  codeScanningListCodeqlDatabases: CodeScanningListCodeqlDatabases
  codeScanningGetCodeqlDatabase: CodeScanningGetCodeqlDatabase
  codeScanningDeleteCodeqlDatabase: CodeScanningDeleteCodeqlDatabase
  codeScanningCreateVariantAnalysis: CodeScanningCreateVariantAnalysis
  codeScanningGetVariantAnalysis: CodeScanningGetVariantAnalysis
  codeScanningGetVariantAnalysisRepoTask: CodeScanningGetVariantAnalysisRepoTask
  codeScanningGetDefaultSetup: CodeScanningGetDefaultSetup
  codeScanningUpdateDefaultSetup: CodeScanningUpdateDefaultSetup
  codeScanningUploadSarif: CodeScanningUploadSarif
  codeScanningGetSarif: CodeScanningGetSarif
  codeSecurityGetConfigurationForRepository: CodeSecurityGetConfigurationForRepository
  reposCodeownersErrors: ReposCodeownersErrors
  codespacesListInRepositoryForAuthenticatedUser: CodespacesListInRepositoryForAuthenticatedUser
  codespacesCreateWithRepoForAuthenticatedUser: CodespacesCreateWithRepoForAuthenticatedUser
  codespacesListDevcontainersInRepositoryForAuthenticatedUser: CodespacesListDevcontainersInRepositoryForAuthenticatedUser
  codespacesRepoMachinesForAuthenticatedUser: CodespacesRepoMachinesForAuthenticatedUser
  codespacesPreFlightWithRepoForAuthenticatedUser: CodespacesPreFlightWithRepoForAuthenticatedUser
  codespacesCheckPermissionsForDevcontainer: CodespacesCheckPermissionsForDevcontainer
  codespacesListRepoSecrets: CodespacesListRepoSecrets
  codespacesGetRepoPublicKey: CodespacesGetRepoPublicKey
  codespacesGetRepoSecret: CodespacesGetRepoSecret
  codespacesCreateOrUpdateRepoSecret: CodespacesCreateOrUpdateRepoSecret
  codespacesDeleteRepoSecret: CodespacesDeleteRepoSecret
  reposListCollaborators: ReposListCollaborators
  reposCheckCollaborator: ReposCheckCollaborator
  reposAddCollaborator: ReposAddCollaborator
  reposRemoveCollaborator: ReposRemoveCollaborator
  reposGetCollaboratorPermissionLevel: ReposGetCollaboratorPermissionLevel
  reposListCommitCommentsForRepo: ReposListCommitCommentsForRepo
  reposGetCommitComment: ReposGetCommitComment
  reposUpdateCommitComment: ReposUpdateCommitComment
  reposDeleteCommitComment: ReposDeleteCommitComment
  reactionsListForCommitComment: ReactionsListForCommitComment
  reactionsCreateForCommitComment: ReactionsCreateForCommitComment
  reactionsDeleteForCommitComment: ReactionsDeleteForCommitComment
  reposListCommits: ReposListCommits
  reposListBranchesForHeadCommit: ReposListBranchesForHeadCommit
  reposListCommentsForCommit: ReposListCommentsForCommit
  reposCreateCommitComment: ReposCreateCommitComment
  reposListPullRequestsAssociatedWithCommit: ReposListPullRequestsAssociatedWithCommit
  reposGetCommit: ReposGetCommit
  checksListForRef: ChecksListForRef
  checksListSuitesForRef: ChecksListSuitesForRef
  reposGetCombinedStatusForRef: ReposGetCombinedStatusForRef
  reposListCommitStatusesForRef: ReposListCommitStatusesForRef
  reposGetCommunityProfileMetrics: ReposGetCommunityProfileMetrics
  reposCompareCommits: ReposCompareCommits
  reposGetContent: ReposGetContent
  reposCreateOrUpdateFileContents: ReposCreateOrUpdateFileContents
  reposDeleteFile: ReposDeleteFile
  reposListContributors: ReposListContributors
  dependabotListAlertsForRepo: DependabotListAlertsForRepo
  dependabotGetAlert: DependabotGetAlert
  dependabotUpdateAlert: DependabotUpdateAlert
  dependabotListRepoSecrets: DependabotListRepoSecrets
  dependabotGetRepoPublicKey: DependabotGetRepoPublicKey
  dependabotGetRepoSecret: DependabotGetRepoSecret
  dependabotCreateOrUpdateRepoSecret: DependabotCreateOrUpdateRepoSecret
  dependabotDeleteRepoSecret: DependabotDeleteRepoSecret
  dependencyGraphDiffRange: DependencyGraphDiffRange
  dependencyGraphExportSbom: DependencyGraphExportSbom
  dependencyGraphCreateRepositorySnapshot: DependencyGraphCreateRepositorySnapshot
  reposListDeployments: ReposListDeployments
  reposCreateDeployment: ReposCreateDeployment
  reposGetDeployment: ReposGetDeployment
  reposDeleteDeployment: ReposDeleteDeployment
  reposListDeploymentStatuses: ReposListDeploymentStatuses
  reposCreateDeploymentStatus: ReposCreateDeploymentStatus
  reposGetDeploymentStatus: ReposGetDeploymentStatus
  reposCreateDispatchEvent: ReposCreateDispatchEvent
  reposGetAllEnvironments: ReposGetAllEnvironments
  reposGetEnvironment: ReposGetEnvironment
  reposCreateOrUpdateEnvironment: ReposCreateOrUpdateEnvironment
  reposDeleteAnEnvironment: ReposDeleteAnEnvironment
  reposListDeploymentBranchPolicies: ReposListDeploymentBranchPolicies
  reposCreateDeploymentBranchPolicy: ReposCreateDeploymentBranchPolicy
  reposGetDeploymentBranchPolicy: ReposGetDeploymentBranchPolicy
  reposUpdateDeploymentBranchPolicy: ReposUpdateDeploymentBranchPolicy
  reposDeleteDeploymentBranchPolicy: ReposDeleteDeploymentBranchPolicy
  reposGetAllDeploymentProtectionRules: ReposGetAllDeploymentProtectionRules
  reposCreateDeploymentProtectionRule: ReposCreateDeploymentProtectionRule
  reposListCustomDeploymentRuleIntegrations: ReposListCustomDeploymentRuleIntegrations
  reposGetCustomDeploymentProtectionRule: ReposGetCustomDeploymentProtectionRule
  reposDisableDeploymentProtectionRule: ReposDisableDeploymentProtectionRule
  actionsListEnvironmentSecrets: ActionsListEnvironmentSecrets
  actionsGetEnvironmentPublicKey: ActionsGetEnvironmentPublicKey
  actionsGetEnvironmentSecret: ActionsGetEnvironmentSecret
  actionsCreateOrUpdateEnvironmentSecret: ActionsCreateOrUpdateEnvironmentSecret
  actionsDeleteEnvironmentSecret: ActionsDeleteEnvironmentSecret
  actionsListEnvironmentVariables: ActionsListEnvironmentVariables
  actionsCreateEnvironmentVariable: ActionsCreateEnvironmentVariable
  actionsGetEnvironmentVariable: ActionsGetEnvironmentVariable
  actionsUpdateEnvironmentVariable: ActionsUpdateEnvironmentVariable
  actionsDeleteEnvironmentVariable: ActionsDeleteEnvironmentVariable
  activityListRepoEvents: ActivityListRepoEvents
  reposListForks: ReposListForks
  reposCreateFork: ReposCreateFork
  gitCreateBlob: GitCreateBlob
  gitGetBlob: GitGetBlob
  gitCreateCommit: GitCreateCommit
  gitGetCommit: GitGetCommit
  gitListMatchingRefs: GitListMatchingRefs
  gitGetRef: GitGetRef
  gitCreateRef: GitCreateRef
  gitUpdateRef: GitUpdateRef
  gitDeleteRef: GitDeleteRef
  gitCreateTag: GitCreateTag
  gitGetTag: GitGetTag
  gitCreateTree: GitCreateTree
  gitGetTree: GitGetTree
  reposListWebhooks: ReposListWebhooks
  reposCreateWebhook: ReposCreateWebhook
  reposGetWebhook: ReposGetWebhook
  reposUpdateWebhook: ReposUpdateWebhook
  reposDeleteWebhook: ReposDeleteWebhook
  reposGetWebhookConfigForRepo: ReposGetWebhookConfigForRepo
  reposUpdateWebhookConfigForRepo: ReposUpdateWebhookConfigForRepo
  reposListWebhookDeliveries: ReposListWebhookDeliveries
  reposGetWebhookDelivery: ReposGetWebhookDelivery
  reposRedeliverWebhookDelivery: ReposRedeliverWebhookDelivery
  reposPingWebhook: ReposPingWebhook
  reposTestPushWebhook: ReposTestPushWebhook
  migrationsGetImportStatus: MigrationsGetImportStatus
  migrationsStartImport: MigrationsStartImport
  migrationsUpdateImport: MigrationsUpdateImport
  migrationsCancelImport: MigrationsCancelImport
  migrationsGetCommitAuthors: MigrationsGetCommitAuthors
  migrationsMapCommitAuthor: MigrationsMapCommitAuthor
  migrationsGetLargeFiles: MigrationsGetLargeFiles
  migrationsSetLfsPreference: MigrationsSetLfsPreference
  appsGetRepoInstallation: AppsGetRepoInstallation
  interactionsGetRestrictionsForRepo: InteractionsGetRestrictionsForRepo
  interactionsSetRestrictionsForRepo: InteractionsSetRestrictionsForRepo
  interactionsRemoveRestrictionsForRepo: InteractionsRemoveRestrictionsForRepo
  reposListInvitations: ReposListInvitations
  reposUpdateInvitation: ReposUpdateInvitation
  reposDeleteInvitation: ReposDeleteInvitation
  issuesListForRepo: IssuesListForRepo
  issuesCreate: IssuesCreate
  issuesListCommentsForRepo: IssuesListCommentsForRepo
  issuesGetComment: IssuesGetComment
  issuesUpdateComment: IssuesUpdateComment
  issuesDeleteComment: IssuesDeleteComment
  reactionsListForIssueComment: ReactionsListForIssueComment
  reactionsCreateForIssueComment: ReactionsCreateForIssueComment
  reactionsDeleteForIssueComment: ReactionsDeleteForIssueComment
  issuesListEventsForRepo: IssuesListEventsForRepo
  issuesGetEvent: IssuesGetEvent
  issuesGet: IssuesGet
  issuesUpdate: IssuesUpdate
  issuesAddAssignees: IssuesAddAssignees
  issuesRemoveAssignees: IssuesRemoveAssignees
  issuesCheckUserCanBeAssignedToIssue: IssuesCheckUserCanBeAssignedToIssue
  issuesListComments: IssuesListComments
  issuesCreateComment: IssuesCreateComment
  issuesListEvents: IssuesListEvents
  issuesListLabelsOnIssue: IssuesListLabelsOnIssue
  issuesAddLabels: IssuesAddLabels
  issuesSetLabels: IssuesSetLabels
  issuesRemoveAllLabels: IssuesRemoveAllLabels
  issuesRemoveLabel: IssuesRemoveLabel
  issuesLock: IssuesLock
  issuesUnlock: IssuesUnlock
  reactionsListForIssue: ReactionsListForIssue
  reactionsCreateForIssue: ReactionsCreateForIssue
  reactionsDeleteForIssue: ReactionsDeleteForIssue
  issuesRemoveSubIssue: IssuesRemoveSubIssue
  issuesListSubIssues: IssuesListSubIssues
  issuesAddSubIssue: IssuesAddSubIssue
  issuesReprioritizeSubIssue: IssuesReprioritizeSubIssue
  issuesListEventsForTimeline: IssuesListEventsForTimeline
  reposListDeployKeys: ReposListDeployKeys
  reposCreateDeployKey: ReposCreateDeployKey
  reposGetDeployKey: ReposGetDeployKey
  reposDeleteDeployKey: ReposDeleteDeployKey
  issuesListLabelsForRepo: IssuesListLabelsForRepo
  issuesCreateLabel: IssuesCreateLabel
  issuesGetLabel: IssuesGetLabel
  issuesUpdateLabel: IssuesUpdateLabel
  issuesDeleteLabel: IssuesDeleteLabel
  reposListLanguages: ReposListLanguages
  licensesGetForRepo: LicensesGetForRepo
  reposMergeUpstream: ReposMergeUpstream
  reposMerge: ReposMerge
  issuesListMilestones: IssuesListMilestones
  issuesCreateMilestone: IssuesCreateMilestone
  issuesGetMilestone: IssuesGetMilestone
  issuesUpdateMilestone: IssuesUpdateMilestone
  issuesDeleteMilestone: IssuesDeleteMilestone
  issuesListLabelsForMilestone: IssuesListLabelsForMilestone
  activityListRepoNotificationsForAuthenticatedUser: ActivityListRepoNotificationsForAuthenticatedUser
  activityMarkRepoNotificationsAsRead: ActivityMarkRepoNotificationsAsRead
  reposGetPages: ReposGetPages
  reposCreatePagesSite: ReposCreatePagesSite
  reposUpdateInformationAboutPagesSite: ReposUpdateInformationAboutPagesSite
  reposDeletePagesSite: ReposDeletePagesSite
  reposListPagesBuilds: ReposListPagesBuilds
  reposRequestPagesBuild: ReposRequestPagesBuild
  reposGetLatestPagesBuild: ReposGetLatestPagesBuild
  reposGetPagesBuild: ReposGetPagesBuild
  reposCreatePagesDeployment: ReposCreatePagesDeployment
  reposGetPagesDeployment: ReposGetPagesDeployment
  reposCancelPagesDeployment: ReposCancelPagesDeployment
  reposGetPagesHealthCheck: ReposGetPagesHealthCheck
  reposCheckPrivateVulnerabilityReporting: ReposCheckPrivateVulnerabilityReporting
  reposEnablePrivateVulnerabilityReporting: ReposEnablePrivateVulnerabilityReporting
  reposDisablePrivateVulnerabilityReporting: ReposDisablePrivateVulnerabilityReporting
  projectsClassicListForRepo: ProjectsClassicListForRepo
  projectsClassicCreateForRepo: ProjectsClassicCreateForRepo
  reposGetCustomPropertiesValues: ReposGetCustomPropertiesValues
  reposCreateOrUpdateCustomPropertiesValues: ReposCreateOrUpdateCustomPropertiesValues
  pullsList: PullsList
  pullsCreate: PullsCreate
  pullsListReviewCommentsForRepo: PullsListReviewCommentsForRepo
  pullsGetReviewComment: PullsGetReviewComment
  pullsUpdateReviewComment: PullsUpdateReviewComment
  pullsDeleteReviewComment: PullsDeleteReviewComment
  reactionsListForPullRequestReviewComment: ReactionsListForPullRequestReviewComment
  reactionsCreateForPullRequestReviewComment: ReactionsCreateForPullRequestReviewComment
  reactionsDeleteForPullRequestComment: ReactionsDeleteForPullRequestComment
  pullsGet: PullsGet
  pullsUpdate: PullsUpdate
  codespacesCreateWithPrForAuthenticatedUser: CodespacesCreateWithPrForAuthenticatedUser
  pullsListReviewComments: PullsListReviewComments
  pullsCreateReviewComment: PullsCreateReviewComment
  pullsCreateReplyForReviewComment: PullsCreateReplyForReviewComment
  pullsListCommits: PullsListCommits
  pullsListFiles: PullsListFiles
  pullsCheckIfMerged: PullsCheckIfMerged
  pullsMerge: PullsMerge
  pullsListRequestedReviewers: PullsListRequestedReviewers
  pullsRequestReviewers: PullsRequestReviewers
  pullsRemoveRequestedReviewers: PullsRemoveRequestedReviewers
  pullsListReviews: PullsListReviews
  pullsCreateReview: PullsCreateReview
  pullsGetReview: PullsGetReview
  pullsUpdateReview: PullsUpdateReview
  pullsDeletePendingReview: PullsDeletePendingReview
  pullsListCommentsForReview: PullsListCommentsForReview
  pullsDismissReview: PullsDismissReview
  pullsSubmitReview: PullsSubmitReview
  pullsUpdateBranch: PullsUpdateBranch
  reposGetReadme: ReposGetReadme
  reposGetReadmeInDirectory: ReposGetReadmeInDirectory
  reposListReleases: ReposListReleases
  reposCreateRelease: ReposCreateRelease
  reposGetReleaseAsset: ReposGetReleaseAsset
  reposUpdateReleaseAsset: ReposUpdateReleaseAsset
  reposDeleteReleaseAsset: ReposDeleteReleaseAsset
  reposGenerateReleaseNotes: ReposGenerateReleaseNotes
  reposGetLatestRelease: ReposGetLatestRelease
  reposGetReleaseByTag: ReposGetReleaseByTag
  reposGetRelease: ReposGetRelease
  reposUpdateRelease: ReposUpdateRelease
  reposDeleteRelease: ReposDeleteRelease
  reposListReleaseAssets: ReposListReleaseAssets
  reposUploadReleaseAsset: ReposUploadReleaseAsset
  reactionsListForRelease: ReactionsListForRelease
  reactionsCreateForRelease: ReactionsCreateForRelease
  reactionsDeleteForRelease: ReactionsDeleteForRelease
  reposGetBranchRules: ReposGetBranchRules
  reposGetRepoRulesets: ReposGetRepoRulesets
  reposCreateRepoRuleset: ReposCreateRepoRuleset
  reposGetRepoRuleSuites: ReposGetRepoRuleSuites
  reposGetRepoRuleSuite: ReposGetRepoRuleSuite
  reposGetRepoRuleset: ReposGetRepoRuleset
  reposUpdateRepoRuleset: ReposUpdateRepoRuleset
  reposDeleteRepoRuleset: ReposDeleteRepoRuleset
  reposGetRepoRulesetHistory: ReposGetRepoRulesetHistory
  reposGetRepoRulesetVersion: ReposGetRepoRulesetVersion
  secretScanningListAlertsForRepo: SecretScanningListAlertsForRepo
  secretScanningGetAlert: SecretScanningGetAlert
  secretScanningUpdateAlert: SecretScanningUpdateAlert
  secretScanningListLocationsForAlert: SecretScanningListLocationsForAlert
  secretScanningCreatePushProtectionBypass: SecretScanningCreatePushProtectionBypass
  secretScanningGetScanHistory: SecretScanningGetScanHistory
  securityAdvisoriesListRepositoryAdvisories: SecurityAdvisoriesListRepositoryAdvisories
  securityAdvisoriesCreateRepositoryAdvisory: SecurityAdvisoriesCreateRepositoryAdvisory
  securityAdvisoriesCreatePrivateVulnerabilityReport: SecurityAdvisoriesCreatePrivateVulnerabilityReport
  securityAdvisoriesGetRepositoryAdvisory: SecurityAdvisoriesGetRepositoryAdvisory
  securityAdvisoriesUpdateRepositoryAdvisory: SecurityAdvisoriesUpdateRepositoryAdvisory
  securityAdvisoriesCreateRepositoryAdvisoryCveRequest: SecurityAdvisoriesCreateRepositoryAdvisoryCveRequest
  securityAdvisoriesCreateFork: SecurityAdvisoriesCreateFork
  activityListStargazersForRepo: ActivityListStargazersForRepo
  reposGetCodeFrequencyStats: ReposGetCodeFrequencyStats
  reposGetCommitActivityStats: ReposGetCommitActivityStats
  reposGetContributorsStats: ReposGetContributorsStats
  reposGetParticipationStats: ReposGetParticipationStats
  reposGetPunchCardStats: ReposGetPunchCardStats
  reposCreateCommitStatus: ReposCreateCommitStatus
  activityListWatchersForRepo: ActivityListWatchersForRepo
  activityGetRepoSubscription: ActivityGetRepoSubscription
  activitySetRepoSubscription: ActivitySetRepoSubscription
  activityDeleteRepoSubscription: ActivityDeleteRepoSubscription
  reposListTags: ReposListTags
  reposListTagProtection: ReposListTagProtection
  reposCreateTagProtection: ReposCreateTagProtection
  reposDeleteTagProtection: ReposDeleteTagProtection
  reposDownloadTarballArchive: ReposDownloadTarballArchive
  reposListTeams: ReposListTeams
  reposGetAllTopics: ReposGetAllTopics
  reposReplaceAllTopics: ReposReplaceAllTopics
  reposGetClones: ReposGetClones
  reposGetTopPaths: ReposGetTopPaths
  reposGetTopReferrers: ReposGetTopReferrers
  reposGetViews: ReposGetViews
  reposTransfer: ReposTransfer
  reposCheckVulnerabilityAlerts: ReposCheckVulnerabilityAlerts
  reposEnableVulnerabilityAlerts: ReposEnableVulnerabilityAlerts
  reposDisableVulnerabilityAlerts: ReposDisableVulnerabilityAlerts
  reposDownloadZipballArchive: ReposDownloadZipballArchive
  reposCreateUsingTemplate: ReposCreateUsingTemplate
  reposListPublic: ReposListPublic
  searchCode: SearchCode
  searchCommits: SearchCommits
  searchIssuesAndPullRequests: SearchIssuesAndPullRequests
  searchLabels: SearchLabels
  searchRepos: SearchRepos
  searchTopics: SearchTopics
  searchUsers: SearchUsers
  teamsGetLegacy: TeamsGetLegacy
  teamsUpdateLegacy: TeamsUpdateLegacy
  teamsDeleteLegacy: TeamsDeleteLegacy
  teamsListDiscussionsLegacy: TeamsListDiscussionsLegacy
  teamsCreateDiscussionLegacy: TeamsCreateDiscussionLegacy
  teamsGetDiscussionLegacy: TeamsGetDiscussionLegacy
  teamsUpdateDiscussionLegacy: TeamsUpdateDiscussionLegacy
  teamsDeleteDiscussionLegacy: TeamsDeleteDiscussionLegacy
  teamsListDiscussionCommentsLegacy: TeamsListDiscussionCommentsLegacy
  teamsCreateDiscussionCommentLegacy: TeamsCreateDiscussionCommentLegacy
  teamsGetDiscussionCommentLegacy: TeamsGetDiscussionCommentLegacy
  teamsUpdateDiscussionCommentLegacy: TeamsUpdateDiscussionCommentLegacy
  teamsDeleteDiscussionCommentLegacy: TeamsDeleteDiscussionCommentLegacy
  reactionsListForTeamDiscussionCommentLegacy: ReactionsListForTeamDiscussionCommentLegacy
  reactionsCreateForTeamDiscussionCommentLegacy: ReactionsCreateForTeamDiscussionCommentLegacy
  reactionsListForTeamDiscussionLegacy: ReactionsListForTeamDiscussionLegacy
  reactionsCreateForTeamDiscussionLegacy: ReactionsCreateForTeamDiscussionLegacy
  teamsListPendingInvitationsLegacy: TeamsListPendingInvitationsLegacy
  teamsListMembersLegacy: TeamsListMembersLegacy
  teamsGetMemberLegacy: TeamsGetMemberLegacy
  teamsAddMemberLegacy: TeamsAddMemberLegacy
  teamsRemoveMemberLegacy: TeamsRemoveMemberLegacy
  teamsGetMembershipForUserLegacy: TeamsGetMembershipForUserLegacy
  teamsAddOrUpdateMembershipForUserLegacy: TeamsAddOrUpdateMembershipForUserLegacy
  teamsRemoveMembershipForUserLegacy: TeamsRemoveMembershipForUserLegacy
  teamsListProjectsLegacy: TeamsListProjectsLegacy
  teamsCheckPermissionsForProjectLegacy: TeamsCheckPermissionsForProjectLegacy
  teamsAddOrUpdateProjectPermissionsLegacy: TeamsAddOrUpdateProjectPermissionsLegacy
  teamsRemoveProjectLegacy: TeamsRemoveProjectLegacy
  teamsListReposLegacy: TeamsListReposLegacy
  teamsCheckPermissionsForRepoLegacy: TeamsCheckPermissionsForRepoLegacy
  teamsAddOrUpdateRepoPermissionsLegacy: TeamsAddOrUpdateRepoPermissionsLegacy
  teamsRemoveRepoLegacy: TeamsRemoveRepoLegacy
  teamsListChildLegacy: TeamsListChildLegacy
  usersGetAuthenticated: UsersGetAuthenticated
  usersUpdateAuthenticated: UsersUpdateAuthenticated
  usersListBlockedByAuthenticatedUser: UsersListBlockedByAuthenticatedUser
  usersCheckBlocked: UsersCheckBlocked
  usersBlock: UsersBlock
  usersUnblock: UsersUnblock
  codespacesListForAuthenticatedUser: CodespacesListForAuthenticatedUser
  codespacesCreateForAuthenticatedUser: CodespacesCreateForAuthenticatedUser
  codespacesListSecretsForAuthenticatedUser: CodespacesListSecretsForAuthenticatedUser
  codespacesGetPublicKeyForAuthenticatedUser: CodespacesGetPublicKeyForAuthenticatedUser
  codespacesGetSecretForAuthenticatedUser: CodespacesGetSecretForAuthenticatedUser
  codespacesCreateOrUpdateSecretForAuthenticatedUser: CodespacesCreateOrUpdateSecretForAuthenticatedUser
  codespacesDeleteSecretForAuthenticatedUser: CodespacesDeleteSecretForAuthenticatedUser
  codespacesListRepositoriesForSecretForAuthenticatedUser: CodespacesListRepositoriesForSecretForAuthenticatedUser
  codespacesSetRepositoriesForSecretForAuthenticatedUser: CodespacesSetRepositoriesForSecretForAuthenticatedUser
  codespacesAddRepositoryForSecretForAuthenticatedUser: CodespacesAddRepositoryForSecretForAuthenticatedUser
  codespacesRemoveRepositoryForSecretForAuthenticatedUser: CodespacesRemoveRepositoryForSecretForAuthenticatedUser
  codespacesGetForAuthenticatedUser: CodespacesGetForAuthenticatedUser
  codespacesUpdateForAuthenticatedUser: CodespacesUpdateForAuthenticatedUser
  codespacesDeleteForAuthenticatedUser: CodespacesDeleteForAuthenticatedUser
  codespacesExportForAuthenticatedUser: CodespacesExportForAuthenticatedUser
  codespacesGetExportDetailsForAuthenticatedUser: CodespacesGetExportDetailsForAuthenticatedUser
  codespacesCodespaceMachinesForAuthenticatedUser: CodespacesCodespaceMachinesForAuthenticatedUser
  codespacesPublishForAuthenticatedUser: CodespacesPublishForAuthenticatedUser
  codespacesStartForAuthenticatedUser: CodespacesStartForAuthenticatedUser
  codespacesStopForAuthenticatedUser: CodespacesStopForAuthenticatedUser
  packagesListDockerMigrationConflictingPackagesForAuthenticatedUser: PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser
  usersSetPrimaryEmailVisibilityForAuthenticatedUser: UsersSetPrimaryEmailVisibilityForAuthenticatedUser
  usersListEmailsForAuthenticatedUser: UsersListEmailsForAuthenticatedUser
  usersAddEmailForAuthenticatedUser: UsersAddEmailForAuthenticatedUser
  usersDeleteEmailForAuthenticatedUser: UsersDeleteEmailForAuthenticatedUser
  usersListFollowersForAuthenticatedUser: UsersListFollowersForAuthenticatedUser
  usersListFollowedByAuthenticatedUser: UsersListFollowedByAuthenticatedUser
  usersCheckPersonIsFollowedByAuthenticated: UsersCheckPersonIsFollowedByAuthenticated
  usersFollow: UsersFollow
  usersUnfollow: UsersUnfollow
  usersListGpgKeysForAuthenticatedUser: UsersListGpgKeysForAuthenticatedUser
  usersCreateGpgKeyForAuthenticatedUser: UsersCreateGpgKeyForAuthenticatedUser
  usersGetGpgKeyForAuthenticatedUser: UsersGetGpgKeyForAuthenticatedUser
  usersDeleteGpgKeyForAuthenticatedUser: UsersDeleteGpgKeyForAuthenticatedUser
  appsListInstallationsForAuthenticatedUser: AppsListInstallationsForAuthenticatedUser
  appsListInstallationReposForAuthenticatedUser: AppsListInstallationReposForAuthenticatedUser
  appsAddRepoToInstallationForAuthenticatedUser: AppsAddRepoToInstallationForAuthenticatedUser
  appsRemoveRepoFromInstallationForAuthenticatedUser: AppsRemoveRepoFromInstallationForAuthenticatedUser
  interactionsGetRestrictionsForAuthenticatedUser: InteractionsGetRestrictionsForAuthenticatedUser
  interactionsSetRestrictionsForAuthenticatedUser: InteractionsSetRestrictionsForAuthenticatedUser
  interactionsRemoveRestrictionsForAuthenticatedUser: InteractionsRemoveRestrictionsForAuthenticatedUser
  issuesListForAuthenticatedUser: IssuesListForAuthenticatedUser
  usersListPublicSshKeysForAuthenticatedUser: UsersListPublicSshKeysForAuthenticatedUser
  usersCreatePublicSshKeyForAuthenticatedUser: UsersCreatePublicSshKeyForAuthenticatedUser
  usersGetPublicSshKeyForAuthenticatedUser: UsersGetPublicSshKeyForAuthenticatedUser
  usersDeletePublicSshKeyForAuthenticatedUser: UsersDeletePublicSshKeyForAuthenticatedUser
  appsListSubscriptionsForAuthenticatedUser: AppsListSubscriptionsForAuthenticatedUser
  appsListSubscriptionsForAuthenticatedUserStubbed: AppsListSubscriptionsForAuthenticatedUserStubbed
  orgsListMembershipsForAuthenticatedUser: OrgsListMembershipsForAuthenticatedUser
  orgsGetMembershipForAuthenticatedUser: OrgsGetMembershipForAuthenticatedUser
  orgsUpdateMembershipForAuthenticatedUser: OrgsUpdateMembershipForAuthenticatedUser
  migrationsListForAuthenticatedUser: MigrationsListForAuthenticatedUser
  migrationsStartForAuthenticatedUser: MigrationsStartForAuthenticatedUser
  migrationsGetStatusForAuthenticatedUser: MigrationsGetStatusForAuthenticatedUser
  migrationsGetArchiveForAuthenticatedUser: MigrationsGetArchiveForAuthenticatedUser
  migrationsDeleteArchiveForAuthenticatedUser: MigrationsDeleteArchiveForAuthenticatedUser
  migrationsUnlockRepoForAuthenticatedUser: MigrationsUnlockRepoForAuthenticatedUser
  migrationsListReposForAuthenticatedUser: MigrationsListReposForAuthenticatedUser
  orgsListForAuthenticatedUser: OrgsListForAuthenticatedUser
  packagesListPackagesForAuthenticatedUser: PackagesListPackagesForAuthenticatedUser
  packagesGetPackageForAuthenticatedUser: PackagesGetPackageForAuthenticatedUser
  packagesDeletePackageForAuthenticatedUser: PackagesDeletePackageForAuthenticatedUser
  packagesRestorePackageForAuthenticatedUser: PackagesRestorePackageForAuthenticatedUser
  packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser
  packagesGetPackageVersionForAuthenticatedUser: PackagesGetPackageVersionForAuthenticatedUser
  packagesDeletePackageVersionForAuthenticatedUser: PackagesDeletePackageVersionForAuthenticatedUser
  packagesRestorePackageVersionForAuthenticatedUser: PackagesRestorePackageVersionForAuthenticatedUser
  projectsClassicCreateForAuthenticatedUser: ProjectsClassicCreateForAuthenticatedUser
  usersListPublicEmailsForAuthenticatedUser: UsersListPublicEmailsForAuthenticatedUser
  reposListForAuthenticatedUser: ReposListForAuthenticatedUser
  reposCreateForAuthenticatedUser: ReposCreateForAuthenticatedUser
  reposListInvitationsForAuthenticatedUser: ReposListInvitationsForAuthenticatedUser
  reposAcceptInvitationForAuthenticatedUser: ReposAcceptInvitationForAuthenticatedUser
  reposDeclineInvitationForAuthenticatedUser: ReposDeclineInvitationForAuthenticatedUser
  usersListSocialAccountsForAuthenticatedUser: UsersListSocialAccountsForAuthenticatedUser
  usersAddSocialAccountForAuthenticatedUser: UsersAddSocialAccountForAuthenticatedUser
  usersDeleteSocialAccountForAuthenticatedUser: UsersDeleteSocialAccountForAuthenticatedUser
  usersListSshSigningKeysForAuthenticatedUser: UsersListSshSigningKeysForAuthenticatedUser
  usersCreateSshSigningKeyForAuthenticatedUser: UsersCreateSshSigningKeyForAuthenticatedUser
  usersGetSshSigningKeyForAuthenticatedUser: UsersGetSshSigningKeyForAuthenticatedUser
  usersDeleteSshSigningKeyForAuthenticatedUser: UsersDeleteSshSigningKeyForAuthenticatedUser
  activityListReposStarredByAuthenticatedUser: ActivityListReposStarredByAuthenticatedUser
  activityCheckRepoIsStarredByAuthenticatedUser: ActivityCheckRepoIsStarredByAuthenticatedUser
  activityStarRepoForAuthenticatedUser: ActivityStarRepoForAuthenticatedUser
  activityUnstarRepoForAuthenticatedUser: ActivityUnstarRepoForAuthenticatedUser
  activityListWatchedReposForAuthenticatedUser: ActivityListWatchedReposForAuthenticatedUser
  teamsListForAuthenticatedUser: TeamsListForAuthenticatedUser
  usersGetById: UsersGetById
  usersList: UsersList
  usersGetByUsername: UsersGetByUsername
  usersListAttestationsBulk: UsersListAttestationsBulk
  usersDeleteAttestationsBulk: UsersDeleteAttestationsBulk
  usersDeleteAttestationsBySubjectDigest: UsersDeleteAttestationsBySubjectDigest
  usersDeleteAttestationsById: UsersDeleteAttestationsById
  usersListAttestations: UsersListAttestations
  packagesListDockerMigrationConflictingPackagesForUser: PackagesListDockerMigrationConflictingPackagesForUser
  activityListEventsForAuthenticatedUser: ActivityListEventsForAuthenticatedUser
  activityListOrgEventsForAuthenticatedUser: ActivityListOrgEventsForAuthenticatedUser
  activityListPublicEventsForUser: ActivityListPublicEventsForUser
  usersListFollowersForUser: UsersListFollowersForUser
  usersListFollowingForUser: UsersListFollowingForUser
  usersCheckFollowingForUser: UsersCheckFollowingForUser
  gistsListForUser: GistsListForUser
  usersListGpgKeysForUser: UsersListGpgKeysForUser
  usersGetContextForUser: UsersGetContextForUser
  appsGetUserInstallation: AppsGetUserInstallation
  usersListPublicKeysForUser: UsersListPublicKeysForUser
  orgsListForUser: OrgsListForUser
  packagesListPackagesForUser: PackagesListPackagesForUser
  packagesGetPackageForUser: PackagesGetPackageForUser
  packagesDeletePackageForUser: PackagesDeletePackageForUser
  packagesRestorePackageForUser: PackagesRestorePackageForUser
  packagesGetAllPackageVersionsForPackageOwnedByUser: PackagesGetAllPackageVersionsForPackageOwnedByUser
  packagesGetPackageVersionForUser: PackagesGetPackageVersionForUser
  packagesDeletePackageVersionForUser: PackagesDeletePackageVersionForUser
  packagesRestorePackageVersionForUser: PackagesRestorePackageVersionForUser
  projectsClassicListForUser: ProjectsClassicListForUser
  activityListReceivedEventsForUser: ActivityListReceivedEventsForUser
  activityListReceivedPublicEventsForUser: ActivityListReceivedPublicEventsForUser
  reposListForUser: ReposListForUser
  billingGetGithubActionsBillingUser: BillingGetGithubActionsBillingUser
  billingGetGithubPackagesBillingUser: BillingGetGithubPackagesBillingUser
  billingGetSharedStorageBillingUser: BillingGetSharedStorageBillingUser
  billingGetGithubBillingUsageReportUser: BillingGetGithubBillingUsageReportUser
  usersListSocialAccountsForUser: UsersListSocialAccountsForUser
  usersListSshSigningKeysForUser: UsersListSshSigningKeysForUser
  activityListReposStarredByUser: ActivityListReposStarredByUser
  activityListReposWatchedByUser: ActivityListReposWatchedByUser
  metaGetAllVersions: MetaGetAllVersions
  metaGetZen: MetaGetZen
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const metaRootResponseBodyValidator = responseValidationFactory(
    [["200", s_root]],
    undefined,
  )

  // metaRoot
  router.get(`/`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_root>(200)
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status)
        },
      }

      await implementation
        .metaRoot(input, responder, req, res, next)
        .catch(handleImplementationError)
        .then(handleResponse(res, metaRootResponseBodyValidator))
    } catch (error) {
      next(error)
    }
  })

  const securityAdvisoriesListGlobalAdvisoriesQuerySchema = z.object({
    ghsa_id: z.string().optional(),
    type: z
      .enum(["reviewed", "malware", "unreviewed"])
      .optional()
      .default("reviewed"),
    cve_id: z.string().optional(),
    ecosystem: s_security_advisory_ecosystems.optional(),
    severity: z
      .enum(["unknown", "low", "medium", "high", "critical"])
      .optional(),
    cwes: z.union([z.string(), z.array(z.string())]).optional(),
    is_withdrawn: PermissiveBoolean.optional(),
    affects: z.union([z.string(), z.array(z.string()).max(1000)]).optional(),
    published: z.string().optional(),
    updated: z.string().optional(),
    modified: z.string().optional(),
    epss_percentage: z.string().optional(),
    epss_percentile: z.string().optional(),
    before: z.string().optional(),
    after: z.string().optional(),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().min(1).max(100).optional().default(30),
    sort: z
      .enum(["updated", "published", "epss_percentage", "epss_percentile"])
      .optional()
      .default("published"),
  })

  const securityAdvisoriesListGlobalAdvisoriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_global_advisory)],
        ["422", s_validation_error_simple],
        ["429", s_basic_error],
      ],
      undefined,
    )

  // securityAdvisoriesListGlobalAdvisories
  router.get(
    `/advisories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            securityAdvisoriesListGlobalAdvisoriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_global_advisory[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          with429() {
            return new ExpressRuntimeResponse<t_basic_error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesListGlobalAdvisories(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesListGlobalAdvisoriesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesGetGlobalAdvisoryParamSchema = z.object({
    ghsa_id: z.string(),
  })

  const securityAdvisoriesGetGlobalAdvisoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_global_advisory],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // securityAdvisoriesGetGlobalAdvisory
  router.get(
    `/advisories/:ghsa_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesGetGlobalAdvisoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_global_advisory>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesGetGlobalAdvisory(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesGetGlobalAdvisoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetAuthenticatedResponseBodyValidator = responseValidationFactory(
    [["200", s_integration]],
    undefined,
  )

  // appsGetAuthenticated
  router.get(
    `/app`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_integration>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetAuthenticated(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsGetAuthenticatedResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsCreateFromManifestParamSchema = z.object({code: z.string()})

  const appsCreateFromManifestResponseBodyValidator = responseValidationFactory(
    [
      [
        "201",
        z.intersection(
          s_integration,
          z.intersection(
            z.object({
              client_id: z.string(),
              client_secret: z.string(),
              webhook_secret: z.string().nullable(),
              pem: z.string(),
            }),
            z.record(z.string(), z.unknown()),
          ),
        ),
      ],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // appsCreateFromManifest
  router.post(
    `/app-manifests/:code/conversions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsCreateFromManifestParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<
              t_integration & {
                client_id: string
                client_secret: string
                pem: string
                webhook_secret: string | null
                [key: string]: unknown | undefined
              }
            >(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsCreateFromManifest(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsCreateFromManifestResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetWebhookConfigForAppResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_config]], undefined)

  // appsGetWebhookConfigForApp
  router.get(
    `/app/hook/config`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_config>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetWebhookConfigForApp(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsGetWebhookConfigForAppResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsUpdateWebhookConfigForAppResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_config]], undefined)

  // appsUpdateWebhookConfigForApp
  router.patch(
    `/app/hook/config`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_AppsUpdateWebhookConfigForAppRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_config>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsUpdateWebhookConfigForApp(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsUpdateWebhookConfigForAppResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    cursor: z.string().optional(),
  })

  const appsListWebhookDeliveriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_hook_delivery_item)],
        ["400", s_scim_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // appsListWebhookDeliveries
  router.get(
    `/app/hook/deliveries`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListWebhookDeliveriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook_delivery_item[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListWebhookDeliveries(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsListWebhookDeliveriesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetWebhookDeliveryParamSchema = z.object({
    delivery_id: z.coerce.number(),
  })

  const appsGetWebhookDeliveryResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_hook_delivery],
      ["400", s_scim_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // appsGetWebhookDelivery
  router.get(
    `/app/hook/deliveries/:delivery_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetWebhookDeliveryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook_delivery>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetWebhookDelivery(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsGetWebhookDeliveryResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsRedeliverWebhookDeliveryParamSchema = z.object({
    delivery_id: z.coerce.number(),
  })

  const appsRedeliverWebhookDeliveryResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["400", s_scim_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // appsRedeliverWebhookDelivery
  router.post(
    `/app/hook/deliveries/:delivery_id/attempts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsRedeliverWebhookDeliveryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsRedeliverWebhookDelivery(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsRedeliverWebhookDeliveryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListInstallationRequestsForAuthenticatedAppQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListInstallationRequestsForAuthenticatedAppResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_integration_installation_request)],
        ["304", z.undefined()],
        ["401", s_basic_error],
      ],
      undefined,
    )

  // appsListInstallationRequestsForAuthenticatedApp
  router.get(
    `/app/installation-requests`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListInstallationRequestsForAuthenticatedAppQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_integration_installation_request[]
            >(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListInstallationRequestsForAuthenticatedApp(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsListInstallationRequestsForAuthenticatedAppResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListInstallationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    since: z.iso.datetime({offset: true}).optional(),
    outdated: z.string().optional(),
  })

  const appsListInstallationsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_installation)]],
    undefined,
  )

  // appsListInstallations
  router.get(
    `/app/installations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListInstallationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_installation[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListInstallations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsListInstallationsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsGetInstallationResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_installation],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // appsGetInstallation
  router.get(
    `/app/installations/:installation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetInstallationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_installation>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetInstallation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsGetInstallationResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsDeleteInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsDeleteInstallationResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // appsDeleteInstallation
  router.delete(
    `/app/installations/:installation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsDeleteInstallationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsDeleteInstallation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsDeleteInstallationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsCreateInstallationAccessTokenParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsCreateInstallationAccessTokenResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_installation_token],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // appsCreateInstallationAccessToken
  router.post(
    `/app/installations/:installation_id/access_tokens`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsCreateInstallationAccessTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_AppsCreateInstallationAccessTokenRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_installation_token>(201)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsCreateInstallationAccessToken(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsCreateInstallationAccessTokenResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsSuspendInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsSuspendInstallationResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // appsSuspendInstallation
  router.put(
    `/app/installations/:installation_id/suspended`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsSuspendInstallationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsSuspendInstallation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsSuspendInstallationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsUnsuspendInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsUnsuspendInstallationResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // appsUnsuspendInstallation
  router.delete(
    `/app/installations/:installation_id/suspended`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsUnsuspendInstallationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsUnsuspendInstallation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsUnsuspendInstallationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsDeleteAuthorizationParamSchema = z.object({client_id: z.string()})

  const appsDeleteAuthorizationResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // appsDeleteAuthorization
  router.delete(
    `/applications/:client_id/grant`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsDeleteAuthorizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_AppsDeleteAuthorizationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsDeleteAuthorization(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsDeleteAuthorizationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsCheckTokenParamSchema = z.object({client_id: z.string()})

  const appsCheckTokenResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_authorization],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // appsCheckToken
  router.post(
    `/applications/:client_id/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsCheckTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_AppsCheckTokenRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_authorization>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsCheckToken(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsCheckTokenResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsResetTokenParamSchema = z.object({client_id: z.string()})

  const appsResetTokenResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_authorization],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // appsResetToken
  router.patch(
    `/applications/:client_id/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsResetTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_AppsResetTokenRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_authorization>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsResetToken(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsResetTokenResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsDeleteTokenParamSchema = z.object({client_id: z.string()})

  const appsDeleteTokenResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // appsDeleteToken
  router.delete(
    `/applications/:client_id/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsDeleteTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_AppsDeleteTokenRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsDeleteToken(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsDeleteTokenResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsScopeTokenParamSchema = z.object({client_id: z.string()})

  const appsScopeTokenResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_authorization],
      ["401", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // appsScopeToken
  router.post(
    `/applications/:client_id/token/scoped`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsScopeTokenParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_AppsScopeTokenRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_authorization>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsScopeToken(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsScopeTokenResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetBySlugParamSchema = z.object({app_slug: z.string()})

  const appsGetBySlugResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_integration],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // appsGetBySlug
  router.get(
    `/apps/:app_slug`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetBySlugParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_integration>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetBySlug(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsGetBySlugResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const classroomGetAnAssignmentParamSchema = z.object({
    assignment_id: z.coerce.number(),
  })

  const classroomGetAnAssignmentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_classroom_assignment],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // classroomGetAnAssignment
  router.get(
    `/assignments/:assignment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            classroomGetAnAssignmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_classroom_assignment>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .classroomGetAnAssignment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, classroomGetAnAssignmentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const classroomListAcceptedAssignmentsForAnAssignmentParamSchema = z.object({
    assignment_id: z.coerce.number(),
  })

  const classroomListAcceptedAssignmentsForAnAssignmentQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const classroomListAcceptedAssignmentsForAnAssignmentResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_classroom_accepted_assignment)]],
      undefined,
    )

  // classroomListAcceptedAssignmentsForAnAssignment
  router.get(
    `/assignments/:assignment_id/accepted_assignments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            classroomListAcceptedAssignmentsForAnAssignmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            classroomListAcceptedAssignmentsForAnAssignmentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_classroom_accepted_assignment[]
            >(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .classroomListAcceptedAssignmentsForAnAssignment(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              classroomListAcceptedAssignmentsForAnAssignmentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const classroomGetAssignmentGradesParamSchema = z.object({
    assignment_id: z.coerce.number(),
  })

  const classroomGetAssignmentGradesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_classroom_assignment_grade)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // classroomGetAssignmentGrades
  router.get(
    `/assignments/:assignment_id/grades`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            classroomGetAssignmentGradesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_classroom_assignment_grade[]>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .classroomGetAssignmentGrades(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              classroomGetAssignmentGradesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const classroomListClassroomsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const classroomListClassroomsResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_simple_classroom)]], undefined)

  // classroomListClassrooms
  router.get(
    `/classrooms`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            classroomListClassroomsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_classroom[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .classroomListClassrooms(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, classroomListClassroomsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const classroomGetAClassroomParamSchema = z.object({
    classroom_id: z.coerce.number(),
  })

  const classroomGetAClassroomResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_classroom],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // classroomGetAClassroom
  router.get(
    `/classrooms/:classroom_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            classroomGetAClassroomParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_classroom>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .classroomGetAClassroom(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, classroomGetAClassroomResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const classroomListAssignmentsForAClassroomParamSchema = z.object({
    classroom_id: z.coerce.number(),
  })

  const classroomListAssignmentsForAClassroomQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const classroomListAssignmentsForAClassroomResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_simple_classroom_assignment)]],
      undefined,
    )

  // classroomListAssignmentsForAClassroom
  router.get(
    `/classrooms/:classroom_id/assignments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            classroomListAssignmentsForAClassroomParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            classroomListAssignmentsForAClassroomQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_classroom_assignment[]>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .classroomListAssignmentsForAClassroom(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              classroomListAssignmentsForAClassroomResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codesOfConductGetAllCodesOfConductResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_of_conduct)],
        ["304", z.undefined()],
      ],
      undefined,
    )

  // codesOfConductGetAllCodesOfConduct
  router.get(
    `/codes_of_conduct`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_of_conduct[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codesOfConductGetAllCodesOfConduct(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codesOfConductGetAllCodesOfConductResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codesOfConductGetConductCodeParamSchema = z.object({key: z.string()})

  const codesOfConductGetConductCodeResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_of_conduct],
        ["304", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codesOfConductGetConductCode
  router.get(
    `/codes_of_conduct/:key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codesOfConductGetConductCodeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_of_conduct>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codesOfConductGetConductCode(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codesOfConductGetConductCodeResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const credentialsRevokeResponseBodyValidator = responseValidationFactory(
    [
      ["202", z.record(z.string(), z.unknown())],
      ["422", s_validation_error_simple],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // credentialsRevoke
  router.post(
    `/credentials/revoke`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_CredentialsRevokeRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .credentialsRevoke(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, credentialsRevokeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const emojisGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.record(z.string(), z.string())],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // emojisGet
  router.get(
    `/emojis`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              [key: string]: string | undefined
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .emojisGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, emojisGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetConfigurationsForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const codeSecurityGetConfigurationsForEnterpriseQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
  })

  const codeSecurityGetConfigurationsForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_security_configuration)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetConfigurationsForEnterprise
  router.get(
    `/enterprises/:enterprise/code-security/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetConfigurationsForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeSecurityGetConfigurationsForEnterpriseQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_configuration[]>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetConfigurationsForEnterprise(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetConfigurationsForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityCreateConfigurationForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const codeSecurityCreateConfigurationForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_code_security_configuration],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityCreateConfigurationForEnterprise
  router.post(
    `/enterprises/:enterprise/code-security/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityCreateConfigurationForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecurityCreateConfigurationForEnterpriseRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_code_security_configuration>(
              201,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityCreateConfigurationForEnterprise(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityCreateConfigurationForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetDefaultConfigurationsForEnterpriseParamSchema = z.object(
    {enterprise: z.string()},
  )

  const codeSecurityGetDefaultConfigurationsForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [["200", s_code_security_default_configurations]],
      undefined,
    )

  // codeSecurityGetDefaultConfigurationsForEnterprise
  router.get(
    `/enterprises/:enterprise/code-security/configurations/defaults`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetDefaultConfigurationsForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_default_configurations>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetDefaultConfigurationsForEnterprise(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetDefaultConfigurationsForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetSingleConfigurationForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityGetSingleConfigurationForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_security_configuration],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetSingleConfigurationForEnterprise
  router.get(
    `/enterprises/:enterprise/code-security/configurations/:configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetSingleConfigurationForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_configuration>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetSingleConfigurationForEnterprise(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetSingleConfigurationForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityUpdateEnterpriseConfigurationParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityUpdateEnterpriseConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_security_configuration],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityUpdateEnterpriseConfiguration
  router.patch(
    `/enterprises/:enterprise/code-security/configurations/:configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityUpdateEnterpriseConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecurityUpdateEnterpriseConfigurationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_configuration>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityUpdateEnterpriseConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityUpdateEnterpriseConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityDeleteConfigurationForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityDeleteConfigurationForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityDeleteConfigurationForEnterprise
  router.delete(
    `/enterprises/:enterprise/code-security/configurations/:configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityDeleteConfigurationForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityDeleteConfigurationForEnterprise(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityDeleteConfigurationForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityAttachEnterpriseConfigurationParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityAttachEnterpriseConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityAttachEnterpriseConfiguration
  router.post(
    `/enterprises/:enterprise/code-security/configurations/:configuration_id/attach`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityAttachEnterpriseConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecurityAttachEnterpriseConfigurationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityAttachEnterpriseConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityAttachEnterpriseConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema =
    z.object({enterprise: z.string(), configuration_id: z.coerce.number()})

  const codeSecuritySetConfigurationAsDefaultForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            default_for_new_repos: z
              .enum(["all", "none", "private_and_internal", "public"])
              .optional(),
            configuration: s_code_security_configuration.optional(),
          }),
        ],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecuritySetConfigurationAsDefaultForEnterprise
  router.put(
    `/enterprises/:enterprise/code-security/configurations/:configuration_id/defaults`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecuritySetConfigurationAsDefaultForEnterpriseRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              configuration?: t_code_security_configuration | undefined
              default_for_new_repos?:
                | ("all" | "none" | "private_and_internal" | "public")
                | undefined
            }>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecuritySetConfigurationAsDefaultForEnterprise(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecuritySetConfigurationAsDefaultForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema =
    z.object({enterprise: z.string(), configuration_id: z.coerce.number()})

  const codeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema =
    z.object({
      per_page: z.coerce.number().optional().default(30),
      before: z.string().optional(),
      after: z.string().optional(),
      status: z.string().optional().default("all"),
    })

  const codeSecurityGetRepositoriesForEnterpriseConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_security_configuration_repositories)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetRepositoriesForEnterpriseConfiguration
  router.get(
    `/enterprises/:enterprise/code-security/configurations/:configuration_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_code_security_configuration_repositories[]
            >(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetRepositoriesForEnterpriseConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetRepositoriesForEnterpriseConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotListAlertsForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const dependabotListAlertsForEnterpriseQuerySchema = z.object({
    state: z.string().optional(),
    severity: z.string().optional(),
    ecosystem: z.string().optional(),
    package: z.string().optional(),
    epss_percentage: z.string().optional(),
    has: z.union([z.string(), z.array(z.enum(["patch"]))]).optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z
      .enum(["created", "updated", "epss_percentage"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    before: z.string().optional(),
    after: z.string().optional(),
    first: z.coerce.number().min(1).max(100).optional().default(30),
    last: z.coerce.number().min(1).max(100).optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  const dependabotListAlertsForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_dependabot_alert_with_repository)],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // dependabotListAlertsForEnterprise
  router.get(
    `/enterprises/:enterprise/dependabot/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotListAlertsForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependabotListAlertsForEnterpriseQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_dependabot_alert_with_repository[]
            >(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotListAlertsForEnterprise(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotListAlertsForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningListAlertsForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const secretScanningListAlertsForEnterpriseQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.string().optional(),
    resolution: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    validity: z.string().optional(),
    is_publicly_leaked: PermissiveBoolean.optional().default(false),
    is_multi_repo: PermissiveBoolean.optional().default(false),
    hide_secret: PermissiveBoolean.optional().default(false),
  })

  const secretScanningListAlertsForEnterpriseResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_organization_secret_scanning_alert)],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // secretScanningListAlertsForEnterprise
  router.get(
    `/enterprises/:enterprise/secret-scanning/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningListAlertsForEnterpriseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            secretScanningListAlertsForEnterpriseQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_organization_secret_scanning_alert[]
            >(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningListAlertsForEnterprise(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              secretScanningListAlertsForEnterpriseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListPublicEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListPublicEventsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_event)],
        ["304", z.undefined()],
        ["403", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // activityListPublicEvents
  router.get(
    `/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            activityListPublicEventsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListPublicEvents(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, activityListPublicEventsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityGetFeedsResponseBodyValidator = responseValidationFactory(
    [["200", s_feed]],
    undefined,
  )

  // activityGetFeeds
  router.get(
    `/feeds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_feed>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityGetFeeds(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, activityGetFeedsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsListQuerySchema = z.object({
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const gistsListResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_base_gist)],
      ["304", z.undefined()],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // gistsList
  router.get(
    `/gists`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            gistsListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_base_gist[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsList(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsListResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsCreateResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_gist_simple],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gistsCreate
  router.post(
    `/gists`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_GistsCreateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_gist_simple>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsCreate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsCreateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsListPublicQuerySchema = z.object({
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const gistsListPublicResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_base_gist)],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gistsListPublic
  router.get(
    `/gists/public`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            gistsListPublicQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_base_gist[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsListPublic(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsListPublicResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsListStarredQuerySchema = z.object({
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const gistsListStarredResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_base_gist)],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // gistsListStarred
  router.get(
    `/gists/starred`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            gistsListStarredQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_base_gist[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsListStarred(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsListStarredResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsGetParamSchema = z.object({gist_id: z.string()})

  const gistsGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_gist_simple],
      ["304", z.undefined()],
      [
        "403",
        z.object({
          block: z
            .object({
              reason: z.string().optional(),
              created_at: z.string().optional(),
              html_url: z.string().nullable().optional(),
            })
            .optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsGet
  router.get(
    `/gists/:gist_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_simple>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              block?:
                | {
                    created_at?: string | undefined
                    html_url?: (string | null) | undefined
                    reason?: string | undefined
                  }
                | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsUpdateParamSchema = z.object({gist_id: z.string()})

  const gistsUpdateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_gist_simple],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gistsUpdate
  router.patch(
    `/gists/:gist_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsUpdateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GistsUpdateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_simple>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsUpdate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsUpdateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsDeleteParamSchema = z.object({gist_id: z.string()})

  const gistsDeleteResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsDelete
  router.delete(
    `/gists/:gist_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsDeleteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsDelete(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsDeleteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsListCommentsParamSchema = z.object({gist_id: z.string()})

  const gistsListCommentsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const gistsListCommentsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_gist_comment)],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsListComments
  router.get(
    `/gists/:gist_id/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsListCommentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            gistsListCommentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_comment[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsListComments(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsListCommentsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsCreateCommentParamSchema = z.object({gist_id: z.string()})

  const gistsCreateCommentResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_gist_comment],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsCreateComment
  router.post(
    `/gists/:gist_id/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsCreateCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GistsCreateCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_gist_comment>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsCreateComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsCreateCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsGetCommentParamSchema = z.object({
    gist_id: z.string(),
    comment_id: z.coerce.number(),
  })

  const gistsGetCommentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_gist_comment],
      ["304", z.undefined()],
      [
        "403",
        z.object({
          block: z
            .object({
              reason: z.string().optional(),
              created_at: z.string().optional(),
              html_url: z.string().nullable().optional(),
            })
            .optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsGetComment
  router.get(
    `/gists/:gist_id/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsGetCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_comment>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              block?:
                | {
                    created_at?: string | undefined
                    html_url?: (string | null) | undefined
                    reason?: string | undefined
                  }
                | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsGetComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsGetCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsUpdateCommentParamSchema = z.object({
    gist_id: z.string(),
    comment_id: z.coerce.number(),
  })

  const gistsUpdateCommentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_gist_comment],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsUpdateComment
  router.patch(
    `/gists/:gist_id/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsUpdateCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GistsUpdateCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_comment>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsUpdateComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsUpdateCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsDeleteCommentParamSchema = z.object({
    gist_id: z.string(),
    comment_id: z.coerce.number(),
  })

  const gistsDeleteCommentResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsDeleteComment
  router.delete(
    `/gists/:gist_id/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsDeleteCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsDeleteComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsDeleteCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsListCommitsParamSchema = z.object({gist_id: z.string()})

  const gistsListCommitsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const gistsListCommitsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_gist_commit)],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsListCommits
  router.get(
    `/gists/:gist_id/commits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsListCommitsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            gistsListCommitsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_commit[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsListCommits(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsListCommitsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsListForksParamSchema = z.object({gist_id: z.string()})

  const gistsListForksQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const gistsListForksResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_gist_simple)],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsListForks
  router.get(
    `/gists/:gist_id/forks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsListForksParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            gistsListForksQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_simple[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsListForks(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsListForksResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsForkParamSchema = z.object({gist_id: z.string()})

  const gistsForkResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_base_gist],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gistsFork
  router.post(
    `/gists/:gist_id/forks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsForkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_base_gist>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsFork(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsForkResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsCheckIsStarredParamSchema = z.object({gist_id: z.string()})

  const gistsCheckIsStarredResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", z.object({})],
    ],
    undefined,
  )

  // gistsCheckIsStarred
  router.get(
    `/gists/:gist_id/star`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsCheckIsStarredParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<EmptyObject>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsCheckIsStarred(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsCheckIsStarredResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsStarParamSchema = z.object({gist_id: z.string()})

  const gistsStarResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsStar
  router.put(
    `/gists/:gist_id/star`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsStarParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsStar(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsStarResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsUnstarParamSchema = z.object({gist_id: z.string()})

  const gistsUnstarResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // gistsUnstar
  router.delete(
    `/gists/:gist_id/star`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsUnstarParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsUnstar(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsUnstarResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsGetRevisionParamSchema = z.object({
    gist_id: z.string(),
    sha: z.string(),
  })

  const gistsGetRevisionResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_gist_simple],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gistsGetRevision
  router.get(
    `/gists/:gist_id/:sha`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsGetRevisionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gist_simple>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsGetRevision(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsGetRevisionResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitignoreGetAllTemplatesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(z.string())],
        ["304", z.undefined()],
      ],
      undefined,
    )

  // gitignoreGetAllTemplates
  router.get(
    `/gitignore/templates`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitignoreGetAllTemplates(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, gitignoreGetAllTemplatesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const gitignoreGetTemplateParamSchema = z.object({name: z.string()})

  const gitignoreGetTemplateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_gitignore_template],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // gitignoreGetTemplate
  router.get(
    `/gitignore/templates/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitignoreGetTemplateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gitignore_template>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitignoreGetTemplate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitignoreGetTemplateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListReposAccessibleToInstallationQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListReposAccessibleToInstallationResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_repository),
            repository_selection: z.string().optional(),
          }),
        ],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // appsListReposAccessibleToInstallation
  router.get(
    `/installation/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListReposAccessibleToInstallationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_repository[]
              repository_selection?: string | undefined
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListReposAccessibleToInstallation(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsListReposAccessibleToInstallationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsRevokeInstallationAccessTokenResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // appsRevokeInstallationAccessToken
  router.delete(
    `/installation/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsRevokeInstallationAccessToken(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsRevokeInstallationAccessTokenResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional()
      .default("assigned"),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    labels: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.iso.datetime({offset: true}).optional(),
    collab: PermissiveBoolean.optional(),
    orgs: PermissiveBoolean.optional(),
    owned: PermissiveBoolean.optional(),
    pulls: PermissiveBoolean.optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_issue)],
      ["304", z.undefined()],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesList
  router.get(
    `/issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            issuesListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesList(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const licensesGetAllCommonlyUsedQuerySchema = z.object({
    featured: PermissiveBoolean.optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const licensesGetAllCommonlyUsedResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_license_simple)],
        ["304", z.undefined()],
      ],
      undefined,
    )

  // licensesGetAllCommonlyUsed
  router.get(
    `/licenses`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            licensesGetAllCommonlyUsedQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_license_simple[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .licensesGetAllCommonlyUsed(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              licensesGetAllCommonlyUsedResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const licensesGetParamSchema = z.object({license: z.string()})

  const licensesGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_license],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // licensesGet
  router.get(
    `/licenses/:license`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            licensesGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_license>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .licensesGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, licensesGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const markdownRenderResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.string()],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // markdownRender
  router.post(
    `/markdown`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_MarkdownRenderRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .markdownRender(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, markdownRenderResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const markdownRenderRawResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.string()],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // markdownRenderRaw
  router.post(
    `/markdown/raw`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            z.string().optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .markdownRenderRaw(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, markdownRenderRawResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetSubscriptionPlanForAccountParamSchema = z.object({
    account_id: z.coerce.number(),
  })

  const appsGetSubscriptionPlanForAccountResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_marketplace_purchase],
        ["401", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // appsGetSubscriptionPlanForAccount
  router.get(
    `/marketplace_listing/accounts/:account_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetSubscriptionPlanForAccountParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_marketplace_purchase>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetSubscriptionPlanForAccount(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsGetSubscriptionPlanForAccountResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListPlansQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListPlansResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_marketplace_listing_plan)],
      ["401", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // appsListPlans
  router.get(
    `/marketplace_listing/plans`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListPlansQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_marketplace_listing_plan[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListPlans(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsListPlansResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListAccountsForPlanParamSchema = z.object({
    plan_id: z.coerce.number(),
  })

  const appsListAccountsForPlanQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListAccountsForPlanResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_marketplace_purchase)],
        ["401", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // appsListAccountsForPlan
  router.get(
    `/marketplace_listing/plans/:plan_id/accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsListAccountsForPlanParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            appsListAccountsForPlanQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_marketplace_purchase[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListAccountsForPlan(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsListAccountsForPlanResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetSubscriptionPlanForAccountStubbedParamSchema = z.object({
    account_id: z.coerce.number(),
  })

  const appsGetSubscriptionPlanForAccountStubbedResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_marketplace_purchase],
        ["401", s_basic_error],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // appsGetSubscriptionPlanForAccountStubbed
  router.get(
    `/marketplace_listing/stubbed/accounts/:account_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetSubscriptionPlanForAccountStubbedParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_marketplace_purchase>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetSubscriptionPlanForAccountStubbed(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsGetSubscriptionPlanForAccountStubbedResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListPlansStubbedQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListPlansStubbedResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_marketplace_listing_plan)],
      ["401", s_basic_error],
    ],
    undefined,
  )

  // appsListPlansStubbed
  router.get(
    `/marketplace_listing/stubbed/plans`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListPlansStubbedQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_marketplace_listing_plan[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListPlansStubbed(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, appsListPlansStubbedResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListAccountsForPlanStubbedParamSchema = z.object({
    plan_id: z.coerce.number(),
  })

  const appsListAccountsForPlanStubbedQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListAccountsForPlanStubbedResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_marketplace_purchase)],
        ["401", s_basic_error],
      ],
      undefined,
    )

  // appsListAccountsForPlanStubbed
  router.get(
    `/marketplace_listing/stubbed/plans/:plan_id/accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsListAccountsForPlanStubbedParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            appsListAccountsForPlanStubbedQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_marketplace_purchase[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListAccountsForPlanStubbed(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsListAccountsForPlanStubbedResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const metaGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_api_overview],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // metaGet
  router.get(
    `/meta`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_overview>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .metaGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, metaGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListPublicEventsForRepoNetworkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListPublicEventsForRepoNetworkQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListPublicEventsForRepoNetworkResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_event)],
        ["301", s_basic_error],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // activityListPublicEventsForRepoNetwork
  router.get(
    `/networks/:owner/:repo/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListPublicEventsForRepoNetworkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListPublicEventsForRepoNetworkQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListPublicEventsForRepoNetwork(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListPublicEventsForRepoNetworkResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListNotificationsForAuthenticatedUserQuerySchema = z.object({
    all: PermissiveBoolean.optional().default(false),
    participating: PermissiveBoolean.optional().default(false),
    since: z.iso.datetime({offset: true}).optional(),
    before: z.iso.datetime({offset: true}).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(50),
  })

  const activityListNotificationsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_thread)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // activityListNotificationsForAuthenticatedUser
  router.get(
    `/notifications`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            activityListNotificationsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_thread[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListNotificationsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListNotificationsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityMarkNotificationsAsReadResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.object({message: z.string().optional()})],
        ["205", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // activityMarkNotificationsAsRead
  router.put(
    `/notifications`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_ActivityMarkNotificationsAsReadRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              message?: string | undefined
            }>(202)
          },
          with205() {
            return new ExpressRuntimeResponse<void>(205)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityMarkNotificationsAsRead(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityMarkNotificationsAsReadResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityGetThreadParamSchema = z.object({thread_id: z.coerce.number()})

  const activityGetThreadResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_thread],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // activityGetThread
  router.get(
    `/notifications/threads/:thread_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityGetThreadParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_thread>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityGetThread(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, activityGetThreadResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const activityMarkThreadAsReadParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  const activityMarkThreadAsReadResponseBodyValidator =
    responseValidationFactory(
      [
        ["205", z.undefined()],
        ["304", z.undefined()],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // activityMarkThreadAsRead
  router.patch(
    `/notifications/threads/:thread_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityMarkThreadAsReadParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with205() {
            return new ExpressRuntimeResponse<void>(205)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityMarkThreadAsRead(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, activityMarkThreadAsReadResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityMarkThreadAsDoneParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  const activityMarkThreadAsDoneResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // activityMarkThreadAsDone
  router.delete(
    `/notifications/threads/:thread_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityMarkThreadAsDoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityMarkThreadAsDone(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, activityMarkThreadAsDoneResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityGetThreadSubscriptionForAuthenticatedUserParamSchema = z.object(
    {thread_id: z.coerce.number()},
  )

  const activityGetThreadSubscriptionForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_thread_subscription],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // activityGetThreadSubscriptionForAuthenticatedUser
  router.get(
    `/notifications/threads/:thread_id/subscription`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityGetThreadSubscriptionForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_thread_subscription>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityGetThreadSubscriptionForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityGetThreadSubscriptionForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activitySetThreadSubscriptionParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  const activitySetThreadSubscriptionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_thread_subscription],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // activitySetThreadSubscription
  router.put(
    `/notifications/threads/:thread_id/subscription`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activitySetThreadSubscriptionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActivitySetThreadSubscriptionRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_thread_subscription>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activitySetThreadSubscription(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activitySetThreadSubscriptionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityDeleteThreadSubscriptionParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  const activityDeleteThreadSubscriptionResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // activityDeleteThreadSubscription
  router.delete(
    `/notifications/threads/:thread_id/subscription`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityDeleteThreadSubscriptionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityDeleteThreadSubscription(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityDeleteThreadSubscriptionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const metaGetOctocatQuerySchema = z.object({s: z.string().optional()})

  const metaGetOctocatResponseBodyValidator = responseValidationFactory(
    [["200", z.string()]],
    undefined,
  )

  // metaGetOctocat
  router.get(
    `/octocat`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            metaGetOctocatQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .metaGetOctocat(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, metaGetOctocatResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListQuerySchema = z.object({
    since: z.coerce.number().optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  const orgsListResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_organization_simple)],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // orgsList
  router.get(
    `/organizations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            orgsListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_simple[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsList(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotRepositoryAccessForOrgParamSchema = z.object({
    org: z.string(),
  })

  const dependabotRepositoryAccessForOrgQuerySchema = z.object({
    page: z.coerce.number().min(1).optional().default(1),
    per_page: z.coerce.number().min(1).max(100).optional().default(30),
  })

  const dependabotRepositoryAccessForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_dependabot_repository_access_details],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // dependabotRepositoryAccessForOrg
  router.get(
    `/organizations/:org/dependabot/repository-access`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotRepositoryAccessForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependabotRepositoryAccessForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependabot_repository_access_details>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotRepositoryAccessForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotRepositoryAccessForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotUpdateRepositoryAccessForOrgParamSchema = z.object({
    org: z.string(),
  })

  const dependabotUpdateRepositoryAccessForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // dependabotUpdateRepositoryAccessForOrg
  router.patch(
    `/organizations/:org/dependabot/repository-access`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotUpdateRepositoryAccessForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_DependabotUpdateRepositoryAccessForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotUpdateRepositoryAccessForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotUpdateRepositoryAccessForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotSetRepositoryAccessDefaultLevelParamSchema = z.object({
    org: z.string(),
  })

  const dependabotSetRepositoryAccessDefaultLevelResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // dependabotSetRepositoryAccessDefaultLevel
  router.put(
    `/organizations/:org/dependabot/repository-access/default-level`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotSetRepositoryAccessDefaultLevelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_DependabotSetRepositoryAccessDefaultLevelRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotSetRepositoryAccessDefaultLevel(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotSetRepositoryAccessDefaultLevelResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetGithubBillingUsageReportOrgParamSchema = z.object({
    org: z.string(),
  })

  const billingGetGithubBillingUsageReportOrgQuerySchema = z.object({
    year: z.coerce.number().optional(),
    month: z.coerce.number().optional(),
    day: z.coerce.number().optional(),
    hour: z.coerce.number().optional(),
  })

  const billingGetGithubBillingUsageReportOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_billing_usage_report],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["500", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // billingGetGithubBillingUsageReportOrg
  router.get(
    `/organizations/:org/settings/billing/usage`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetGithubBillingUsageReportOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            billingGetGithubBillingUsageReportOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_usage_report>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetGithubBillingUsageReportOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetGithubBillingUsageReportOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetParamSchema = z.object({org: z.string()})

  const orgsGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_organization_full],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsGet
  router.get(
    `/orgs/:org`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_full>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUpdateParamSchema = z.object({org: z.string()})

  const orgsUpdateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_organization_full],
      ["409", s_basic_error],
      ["422", z.union([s_validation_error, s_validation_error_simple])],
    ],
    undefined,
  )

  // orgsUpdate
  router.patch(
    `/orgs/:org`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUpdateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsUpdateRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_full>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<
              t_validation_error | t_validation_error_simple
            >(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUpdate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsUpdateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsDeleteParamSchema = z.object({org: z.string()})

  const orgsDeleteResponseBodyValidator = responseValidationFactory(
    [
      ["202", z.record(z.string(), z.unknown())],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsDelete
  router.delete(
    `/orgs/:org`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsDeleteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsDelete(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsDeleteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetActionsCacheUsageForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetActionsCacheUsageForOrgResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_cache_usage_org_enterprise]],
      undefined,
    )

  // actionsGetActionsCacheUsageForOrg
  router.get(
    `/orgs/:org/actions/cache/usage`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetActionsCacheUsageForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_cache_usage_org_enterprise>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetActionsCacheUsageForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetActionsCacheUsageForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetActionsCacheUsageByRepoForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetActionsCacheUsageByRepoForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsGetActionsCacheUsageByRepoForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repository_cache_usages: z.array(
              s_actions_cache_usage_by_repository,
            ),
          }),
        ],
      ],
      undefined,
    )

  // actionsGetActionsCacheUsageByRepoForOrg
  router.get(
    `/orgs/:org/actions/cache/usage-by-repository`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetActionsCacheUsageByRepoForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsGetActionsCacheUsageByRepoForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repository_cache_usages: t_actions_cache_usage_by_repository[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetActionsCacheUsageByRepoForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetActionsCacheUsageByRepoForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListHostedRunnersForOrgParamSchema = z.object({org: z.string()})

  const actionsListHostedRunnersForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListHostedRunnersForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            runners: z.array(s_actions_hosted_runner),
          }),
        ],
      ],
      undefined,
    )

  // actionsListHostedRunnersForOrg
  router.get(
    `/orgs/:org/actions/hosted-runners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListHostedRunnersForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListHostedRunnersForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              runners: t_actions_hosted_runner[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListHostedRunnersForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListHostedRunnersForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateHostedRunnerForOrgParamSchema = z.object({org: z.string()})

  const actionsCreateHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory([["201", s_actions_hosted_runner]], undefined)

  // actionsCreateHostedRunnerForOrg
  router.post(
    `/orgs/:org/actions/hosted-runners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateHostedRunnerForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_actions_hosted_runner>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateHostedRunnerForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetHostedRunnersGithubOwnedImagesForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            images: z.array(s_actions_hosted_runner_image),
          }),
        ],
      ],
      undefined,
    )

  // actionsGetHostedRunnersGithubOwnedImagesForOrg
  router.get(
    `/orgs/:org/actions/hosted-runners/images/github-owned`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              images: t_actions_hosted_runner_image[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetHostedRunnersGithubOwnedImagesForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetHostedRunnersGithubOwnedImagesForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetHostedRunnersPartnerImagesForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetHostedRunnersPartnerImagesForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            images: z.array(s_actions_hosted_runner_image),
          }),
        ],
      ],
      undefined,
    )

  // actionsGetHostedRunnersPartnerImagesForOrg
  router.get(
    `/orgs/:org/actions/hosted-runners/images/partner`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetHostedRunnersPartnerImagesForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              images: t_actions_hosted_runner_image[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetHostedRunnersPartnerImagesForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetHostedRunnersPartnerImagesForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetHostedRunnersLimitsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetHostedRunnersLimitsForOrgResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_hosted_runner_limits]],
      undefined,
    )

  // actionsGetHostedRunnersLimitsForOrg
  router.get(
    `/orgs/:org/actions/hosted-runners/limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetHostedRunnersLimitsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_hosted_runner_limits>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetHostedRunnersLimitsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetHostedRunnersLimitsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetHostedRunnersMachineSpecsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetHostedRunnersMachineSpecsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            machine_specs: z.array(s_actions_hosted_runner_machine_spec),
          }),
        ],
      ],
      undefined,
    )

  // actionsGetHostedRunnersMachineSpecsForOrg
  router.get(
    `/orgs/:org/actions/hosted-runners/machine-sizes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetHostedRunnersMachineSpecsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              machine_specs: t_actions_hosted_runner_machine_spec[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetHostedRunnersMachineSpecsForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetHostedRunnersMachineSpecsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetHostedRunnersPlatformsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetHostedRunnersPlatformsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            platforms: z.array(z.string()),
          }),
        ],
      ],
      undefined,
    )

  // actionsGetHostedRunnersPlatformsForOrg
  router.get(
    `/orgs/:org/actions/hosted-runners/platforms`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetHostedRunnersPlatformsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              platforms: string[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetHostedRunnersPlatformsForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetHostedRunnersPlatformsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    hosted_runner_id: z.coerce.number(),
  })

  const actionsGetHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_actions_hosted_runner]], undefined)

  // actionsGetHostedRunnerForOrg
  router.get(
    `/orgs/:org/actions/hosted-runners/:hosted_runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_hosted_runner>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetHostedRunnerForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsUpdateHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    hosted_runner_id: z.coerce.number(),
  })

  const actionsUpdateHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_actions_hosted_runner]], undefined)

  // actionsUpdateHostedRunnerForOrg
  router.patch(
    `/orgs/:org/actions/hosted-runners/:hosted_runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsUpdateHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsUpdateHostedRunnerForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_hosted_runner>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsUpdateHostedRunnerForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsUpdateHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    hosted_runner_id: z.coerce.number(),
  })

  const actionsDeleteHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory([["202", s_actions_hosted_runner]], undefined)

  // actionsDeleteHostedRunnerForOrg
  router.delete(
    `/orgs/:org/actions/hosted-runners/:hosted_runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_actions_hosted_runner>(202)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteHostedRunnerForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const oidcGetOidcCustomSubTemplateForOrgParamSchema = z.object({
    org: z.string(),
  })

  const oidcGetOidcCustomSubTemplateForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_oidc_custom_sub]], undefined)

  // oidcGetOidcCustomSubTemplateForOrg
  router.get(
    `/orgs/:org/actions/oidc/customization/sub`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            oidcGetOidcCustomSubTemplateForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_oidc_custom_sub>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .oidcGetOidcCustomSubTemplateForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              oidcGetOidcCustomSubTemplateForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const oidcUpdateOidcCustomSubTemplateForOrgParamSchema = z.object({
    org: z.string(),
  })

  const oidcUpdateOidcCustomSubTemplateForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // oidcUpdateOidcCustomSubTemplateForOrg
  router.put(
    `/orgs/:org/actions/oidc/customization/sub`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            oidcUpdateOidcCustomSubTemplateForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_oidc_custom_sub,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .oidcUpdateOidcCustomSubTemplateForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              oidcUpdateOidcCustomSubTemplateForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetGithubActionsPermissionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetGithubActionsPermissionsOrganizationResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_organization_permissions]],
      undefined,
    )

  // actionsGetGithubActionsPermissionsOrganization
  router.get(
    `/orgs/:org/actions/permissions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetGithubActionsPermissionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_organization_permissions>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetGithubActionsPermissionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetGithubActionsPermissionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetGithubActionsPermissionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const actionsSetGithubActionsPermissionsOrganizationResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetGithubActionsPermissionsOrganization
  router.put(
    `/orgs/:org/actions/permissions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetGithubActionsPermissionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetGithubActionsPermissionsOrganizationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetGithubActionsPermissionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetGithubActionsPermissionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema =
    z.object({org: z.string()})

  const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema =
    z.object({
      per_page: z.coerce.number().optional().default(30),
      page: z.coerce.number().optional().default(1),
    })

  const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_repository),
          }),
        ],
      ],
      undefined,
    )

  // actionsListSelectedRepositoriesEnabledGithubActionsOrganization
  router.get(
    `/orgs/:org/actions/permissions/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_repository[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema =
    z.object({org: z.string()})

  const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetSelectedRepositoriesEnabledGithubActionsOrganization
  router.put(
    `/orgs/:org/actions/permissions/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema =
    z.object({org: z.string(), repository_id: z.coerce.number()})

  const actionsEnableSelectedRepositoryGithubActionsOrganizationResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsEnableSelectedRepositoryGithubActionsOrganization
  router.put(
    `/orgs/:org/actions/permissions/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsEnableSelectedRepositoryGithubActionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsEnableSelectedRepositoryGithubActionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema =
    z.object({org: z.string(), repository_id: z.coerce.number()})

  const actionsDisableSelectedRepositoryGithubActionsOrganizationResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDisableSelectedRepositoryGithubActionsOrganization
  router.delete(
    `/orgs/:org/actions/permissions/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDisableSelectedRepositoryGithubActionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDisableSelectedRepositoryGithubActionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetAllowedActionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetAllowedActionsOrganizationResponseBodyValidator =
    responseValidationFactory([["200", s_selected_actions]], undefined)

  // actionsGetAllowedActionsOrganization
  router.get(
    `/orgs/:org/actions/permissions/selected-actions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetAllowedActionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_selected_actions>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetAllowedActionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetAllowedActionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetAllowedActionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const actionsSetAllowedActionsOrganizationResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetAllowedActionsOrganization
  router.put(
    `/orgs/:org/actions/permissions/selected-actions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetAllowedActionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_selected_actions.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetAllowedActionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetAllowedActionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema =
    z.object({org: z.string()})

  const actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_get_default_workflow_permissions]],
      undefined,
    )

  // actionsGetGithubActionsDefaultWorkflowPermissionsOrganization
  router.get(
    `/orgs/:org/actions/permissions/workflow`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_get_default_workflow_permissions>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema =
    z.object({org: z.string()})

  const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetGithubActionsDefaultWorkflowPermissionsOrganization
  router.put(
    `/orgs/:org/actions/permissions/workflow`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_actions_set_default_workflow_permissions.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListSelfHostedRunnerGroupsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsListSelfHostedRunnerGroupsForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    visible_to_repository: z.string().optional(),
  })

  const actionsListSelfHostedRunnerGroupsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            runner_groups: z.array(s_runner_groups_org),
          }),
        ],
      ],
      undefined,
    )

  // actionsListSelfHostedRunnerGroupsForOrg
  router.get(
    `/orgs/:org/actions/runner-groups`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListSelfHostedRunnerGroupsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListSelfHostedRunnerGroupsForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              runner_groups: t_runner_groups_org[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListSelfHostedRunnerGroupsForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListSelfHostedRunnerGroupsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsCreateSelfHostedRunnerGroupForOrgResponseBodyValidator =
    responseValidationFactory([["201", s_runner_groups_org]], undefined)

  // actionsCreateSelfHostedRunnerGroupForOrg
  router.post(
    `/orgs/:org/actions/runner-groups`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateSelfHostedRunnerGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateSelfHostedRunnerGroupForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_runner_groups_org>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateSelfHostedRunnerGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateSelfHostedRunnerGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsGetSelfHostedRunnerGroupForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_runner_groups_org]], undefined)

  // actionsGetSelfHostedRunnerGroupForOrg
  router.get(
    `/orgs/:org/actions/runner-groups/:runner_group_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetSelfHostedRunnerGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_runner_groups_org>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetSelfHostedRunnerGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetSelfHostedRunnerGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsUpdateSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsUpdateSelfHostedRunnerGroupForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_runner_groups_org]], undefined)

  // actionsUpdateSelfHostedRunnerGroupForOrg
  router.patch(
    `/orgs/:org/actions/runner-groups/:runner_group_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_runner_groups_org>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsUpdateSelfHostedRunnerGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsUpdateSelfHostedRunnerGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteSelfHostedRunnerGroupFromOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsDeleteSelfHostedRunnerGroupFromOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteSelfHostedRunnerGroupFromOrg
  router.delete(
    `/orgs/:org/actions/runner-groups/:runner_group_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteSelfHostedRunnerGroupFromOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteSelfHostedRunnerGroupFromOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListGithubHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsListGithubHostedRunnersInGroupForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListGithubHostedRunnersInGroupForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            runners: z.array(s_actions_hosted_runner),
          }),
        ],
      ],
      undefined,
    )

  // actionsListGithubHostedRunnersInGroupForOrg
  router.get(
    `/orgs/:org/actions/runner-groups/:runner_group_id/hosted-runners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListGithubHostedRunnersInGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListGithubHostedRunnersInGroupForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              runners: t_actions_hosted_runner[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListGithubHostedRunnersInGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListGithubHostedRunnersInGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object(
    {org: z.string(), runner_group_id: z.coerce.number()},
  )

  const actionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema = z.object(
    {
      page: z.coerce.number().optional().default(1),
      per_page: z.coerce.number().optional().default(30),
    },
  )

  const actionsListRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_minimal_repository),
          }),
        ],
      ],
      undefined,
    )

  // actionsListRepoAccessToSelfHostedRunnerGroupInOrg
  router.get(
    `/orgs/:org/actions/runner-groups/:runner_group_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_minimal_repository[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetRepoAccessToSelfHostedRunnerGroupInOrg
  router.put(
    `/orgs/:org/actions/runner-groups/:runner_group_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
    repository_id: z.coerce.number(),
  })

  const actionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsAddRepoAccessToSelfHostedRunnerGroupInOrg
  router.put(
    `/orgs/:org/actions/runner-groups/:runner_group_id/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsAddRepoAccessToSelfHostedRunnerGroupInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema =
    z.object({
      org: z.string(),
      runner_group_id: z.coerce.number(),
      repository_id: z.coerce.number(),
    })

  const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
  router.delete(
    `/orgs/:org/actions/runner-groups/:runner_group_id/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListSelfHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsListSelfHostedRunnersInGroupForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListSelfHostedRunnersInGroupForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            runners: z.array(s_runner),
          }),
        ],
      ],
      undefined,
    )

  // actionsListSelfHostedRunnersInGroupForOrg
  router.get(
    `/orgs/:org/actions/runner-groups/:runner_group_id/runners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListSelfHostedRunnersInGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListSelfHostedRunnersInGroupForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              runners: t_runner[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListSelfHostedRunnersInGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListSelfHostedRunnersInGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetSelfHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsSetSelfHostedRunnersInGroupForOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetSelfHostedRunnersInGroupForOrg
  router.put(
    `/orgs/:org/actions/runner-groups/:runner_group_id/runners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetSelfHostedRunnersInGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetSelfHostedRunnersInGroupForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetSelfHostedRunnersInGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetSelfHostedRunnersInGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsAddSelfHostedRunnerToGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
    runner_id: z.coerce.number(),
  })

  const actionsAddSelfHostedRunnerToGroupForOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsAddSelfHostedRunnerToGroupForOrg
  router.put(
    `/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsAddSelfHostedRunnerToGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsAddSelfHostedRunnerToGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsAddSelfHostedRunnerToGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
    runner_id: z.coerce.number(),
  })

  const actionsRemoveSelfHostedRunnerFromGroupForOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsRemoveSelfHostedRunnerFromGroupForOrg
  router.delete(
    `/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveSelfHostedRunnerFromGroupForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveSelfHostedRunnerFromGroupForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListSelfHostedRunnersForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsListSelfHostedRunnersForOrgQuerySchema = z.object({
    name: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListSelfHostedRunnersForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            runners: z.array(s_runner),
          }),
        ],
      ],
      undefined,
    )

  // actionsListSelfHostedRunnersForOrg
  router.get(
    `/orgs/:org/actions/runners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListSelfHostedRunnersForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListSelfHostedRunnersForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              runners: t_runner[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListSelfHostedRunnersForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListSelfHostedRunnersForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRunnerApplicationsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsListRunnerApplicationsForOrgResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_runner_application)]],
      undefined,
    )

  // actionsListRunnerApplicationsForOrg
  router.get(
    `/orgs/:org/actions/runners/downloads`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRunnerApplicationsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_runner_application[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRunnerApplicationsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListRunnerApplicationsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGenerateRunnerJitconfigForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGenerateRunnerJitconfigForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.object({runner: s_runner, encoded_jit_config: z.string()})],
        ["404", s_basic_error],
        ["409", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsGenerateRunnerJitconfigForOrg
  router.post(
    `/orgs/:org/actions/runners/generate-jitconfig`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGenerateRunnerJitconfigForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsGenerateRunnerJitconfigForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<{
              encoded_jit_config: string
              runner: t_runner
            }>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGenerateRunnerJitconfigForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGenerateRunnerJitconfigForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateRegistrationTokenForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsCreateRegistrationTokenForOrgResponseBodyValidator =
    responseValidationFactory([["201", s_authentication_token]], undefined)

  // actionsCreateRegistrationTokenForOrg
  router.post(
    `/orgs/:org/actions/runners/registration-token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateRegistrationTokenForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_authentication_token>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateRegistrationTokenForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateRegistrationTokenForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateRemoveTokenForOrgParamSchema = z.object({org: z.string()})

  const actionsCreateRemoveTokenForOrgResponseBodyValidator =
    responseValidationFactory([["201", s_authentication_token]], undefined)

  // actionsCreateRemoveTokenForOrg
  router.post(
    `/orgs/:org/actions/runners/remove-token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateRemoveTokenForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_authentication_token>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateRemoveTokenForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateRemoveTokenForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsGetSelfHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_runner]], undefined)

  // actionsGetSelfHostedRunnerForOrg
  router.get(
    `/orgs/:org/actions/runners/:runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetSelfHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_runner>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetSelfHostedRunnerForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetSelfHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteSelfHostedRunnerFromOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsDeleteSelfHostedRunnerFromOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsDeleteSelfHostedRunnerFromOrg
  router.delete(
    `/orgs/:org/actions/runners/:runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteSelfHostedRunnerFromOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteSelfHostedRunnerFromOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteSelfHostedRunnerFromOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListLabelsForSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsListLabelsForSelfHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // actionsListLabelsForSelfHostedRunnerForOrg
  router.get(
    `/orgs/:org/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListLabelsForSelfHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListLabelsForSelfHostedRunnerForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListLabelsForSelfHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsAddCustomLabelsToSelfHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsAddCustomLabelsToSelfHostedRunnerForOrg
  router.post(
    `/orgs/:org/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsAddCustomLabelsToSelfHostedRunnerForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsAddCustomLabelsToSelfHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsSetCustomLabelsForSelfHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsSetCustomLabelsForSelfHostedRunnerForOrg
  router.put(
    `/orgs/:org/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetCustomLabelsForSelfHostedRunnerForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetCustomLabelsForSelfHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema =
    z.object({org: z.string(), runner_id: z.coerce.number()})

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg
  router.delete(
    `/orgs/:org/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema =
    z.object({org: z.string(), runner_id: z.coerce.number(), name: z.string()})

  const actionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsRemoveCustomLabelFromSelfHostedRunnerForOrg
  router.delete(
    `/orgs/:org/actions/runners/:runner_id/labels/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListOrgSecretsParamSchema = z.object({org: z.string()})

  const actionsListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListOrgSecretsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          secrets: z.array(s_organization_actions_secret),
        }),
      ],
    ],
    undefined,
  )

  // actionsListOrgSecrets
  router.get(
    `/orgs/:org/actions/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListOrgSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListOrgSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_organization_actions_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListOrgSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsListOrgSecretsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetOrgPublicKeyParamSchema = z.object({org: z.string()})

  const actionsGetOrgPublicKeyResponseBodyValidator = responseValidationFactory(
    [["200", s_actions_public_key]],
    undefined,
  )

  // actionsGetOrgPublicKey
  router.get(
    `/orgs/:org/actions/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetOrgPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetOrgPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsGetOrgPublicKeyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsGetOrgSecretResponseBodyValidator = responseValidationFactory(
    [["200", s_organization_actions_secret]],
    undefined,
  )

  // actionsGetOrgSecret
  router.get(
    `/orgs/:org/actions/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_actions_secret>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsGetOrgSecretResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsCreateOrUpdateOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // actionsCreateOrUpdateOrgSecret
  router.put(
    `/orgs/:org/actions/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateOrUpdateOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateOrUpdateOrgSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateOrUpdateOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateOrUpdateOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsDeleteOrgSecretResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // actionsDeleteOrgSecret
  router.delete(
    `/orgs/:org/actions/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsDeleteOrgSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const actionsListSelectedReposForOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_minimal_repository),
          }),
        ],
      ],
      undefined,
    )

  // actionsListSelectedReposForOrgSecret
  router.get(
    `/orgs/:org/actions/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListSelectedReposForOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListSelectedReposForOrgSecretQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_minimal_repository[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListSelectedReposForOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListSelectedReposForOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsSetSelectedReposForOrgSecretResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetSelectedReposForOrgSecret
  router.put(
    `/orgs/:org/actions/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetSelectedReposForOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetSelectedReposForOrgSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetSelectedReposForOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetSelectedReposForOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  const actionsAddSelectedRepoToOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // actionsAddSelectedRepoToOrgSecret
  router.put(
    `/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsAddSelectedRepoToOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsAddSelectedRepoToOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsAddSelectedRepoToOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  const actionsRemoveSelectedRepoFromOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // actionsRemoveSelectedRepoFromOrgSecret
  router.delete(
    `/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveSelectedRepoFromOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveSelectedRepoFromOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveSelectedRepoFromOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListOrgVariablesParamSchema = z.object({org: z.string()})

  const actionsListOrgVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListOrgVariablesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            variables: z.array(s_organization_actions_variable),
          }),
        ],
      ],
      undefined,
    )

  // actionsListOrgVariables
  router.get(
    `/orgs/:org/actions/variables`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListOrgVariablesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListOrgVariablesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              total_count: number
              variables: t_organization_actions_variable[]
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListOrgVariables(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsListOrgVariablesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateOrgVariableParamSchema = z.object({org: z.string()})

  const actionsCreateOrgVariableResponseBodyValidator =
    responseValidationFactory([["201", s_empty_object]], undefined)

  // actionsCreateOrgVariable
  router.post(
    `/orgs/:org/actions/variables`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateOrgVariableRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateOrgVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsCreateOrgVariableResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsGetOrgVariableResponseBodyValidator = responseValidationFactory(
    [["200", s_organization_actions_variable]],
    undefined,
  )

  // actionsGetOrgVariable
  router.get(
    `/orgs/:org/actions/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_actions_variable>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetOrgVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsGetOrgVariableResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsUpdateOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsUpdateOrgVariableResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsUpdateOrgVariable
  router.patch(
    `/orgs/:org/actions/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsUpdateOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsUpdateOrgVariableRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsUpdateOrgVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsUpdateOrgVariableResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsDeleteOrgVariableResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteOrgVariable
  router.delete(
    `/orgs/:org/actions/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteOrgVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsDeleteOrgVariableResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListSelectedReposForOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsListSelectedReposForOrgVariableQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const actionsListSelectedReposForOrgVariableResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_minimal_repository),
          }),
        ],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // actionsListSelectedReposForOrgVariable
  router.get(
    `/orgs/:org/actions/variables/:name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListSelectedReposForOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListSelectedReposForOrgVariableQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_minimal_repository[]
              total_count: number
            }>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListSelectedReposForOrgVariable(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListSelectedReposForOrgVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetSelectedReposForOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsSetSelectedReposForOrgVariableResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // actionsSetSelectedReposForOrgVariable
  router.put(
    `/orgs/:org/actions/variables/:name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetSelectedReposForOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetSelectedReposForOrgVariableRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetSelectedReposForOrgVariable(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetSelectedReposForOrgVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsAddSelectedRepoToOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
    repository_id: z.coerce.number(),
  })

  const actionsAddSelectedRepoToOrgVariableResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // actionsAddSelectedRepoToOrgVariable
  router.put(
    `/orgs/:org/actions/variables/:name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsAddSelectedRepoToOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsAddSelectedRepoToOrgVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsAddSelectedRepoToOrgVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveSelectedRepoFromOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
    repository_id: z.coerce.number(),
  })

  const actionsRemoveSelectedRepoFromOrgVariableResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // actionsRemoveSelectedRepoFromOrgVariable
  router.delete(
    `/orgs/:org/actions/variables/:name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveSelectedRepoFromOrgVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveSelectedRepoFromOrgVariable(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveSelectedRepoFromOrgVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListAttestationsBulkParamSchema = z.object({org: z.string()})

  const orgsListAttestationsBulkQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
  })

  const orgsListAttestationsBulkResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            attestations_subject_digests: z
              .record(
                z.string(),
                z
                  .array(
                    z.object({
                      bundle: z
                        .object({
                          mediaType: z.string().optional(),
                          verificationMaterial: z
                            .record(z.string(), z.unknown())
                            .optional(),
                          dsseEnvelope: z
                            .record(z.string(), z.unknown())
                            .optional(),
                        })
                        .optional(),
                      repository_id: z.coerce.number().optional(),
                      bundle_url: z.string().optional(),
                    }),
                  )
                  .nullable(),
              )
              .optional(),
            page_info: z
              .object({
                has_next: PermissiveBoolean.optional(),
                has_previous: PermissiveBoolean.optional(),
                next: z.string().optional(),
                previous: z.string().optional(),
              })
              .optional(),
          }),
        ],
      ],
      undefined,
    )

  // orgsListAttestationsBulk
  router.post(
    `/orgs/:org/attestations/bulk-list`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListAttestationsBulkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListAttestationsBulkQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            s_OrgsListAttestationsBulkRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              attestations_subject_digests?:
                | {
                    [key: string]:
                      | (
                          | {
                              bundle?:
                                | {
                                    dsseEnvelope?:
                                      | {
                                          [key: string]: unknown | undefined
                                        }
                                      | undefined
                                    mediaType?: string | undefined
                                    verificationMaterial?:
                                      | {
                                          [key: string]: unknown | undefined
                                        }
                                      | undefined
                                  }
                                | undefined
                              bundle_url?: string | undefined
                              repository_id?: number | undefined
                            }[]
                          | null
                        )
                      | undefined
                  }
                | undefined
              page_info?:
                | {
                    has_next?: boolean | undefined
                    has_previous?: boolean | undefined
                    next?: string | undefined
                    previous?: string | undefined
                  }
                | undefined
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListAttestationsBulk(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsListAttestationsBulkResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsDeleteAttestationsBulkParamSchema = z.object({org: z.string()})

  const orgsDeleteAttestationsBulkResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsDeleteAttestationsBulk
  router.post(
    `/orgs/:org/attestations/delete-request`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsDeleteAttestationsBulkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsDeleteAttestationsBulkRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsDeleteAttestationsBulk(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsDeleteAttestationsBulkResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsDeleteAttestationsBySubjectDigestParamSchema = z.object({
    org: z.string(),
    subject_digest: z.string(),
  })

  const orgsDeleteAttestationsBySubjectDigestResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsDeleteAttestationsBySubjectDigest
  router.delete(
    `/orgs/:org/attestations/digest/:subject_digest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsDeleteAttestationsBySubjectDigestParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsDeleteAttestationsBySubjectDigest(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsDeleteAttestationsBySubjectDigestResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsDeleteAttestationsByIdParamSchema = z.object({
    org: z.string(),
    attestation_id: z.coerce.number(),
  })

  const orgsDeleteAttestationsByIdResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsDeleteAttestationsById
  router.delete(
    `/orgs/:org/attestations/:attestation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsDeleteAttestationsByIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsDeleteAttestationsById(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsDeleteAttestationsByIdResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListAttestationsParamSchema = z.object({
    org: z.string(),
    subject_digest: z.string(),
  })

  const orgsListAttestationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    predicate_type: z.string().optional(),
  })

  const orgsListAttestationsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          attestations: z
            .array(
              z.object({
                bundle: z
                  .object({
                    mediaType: z.string().optional(),
                    verificationMaterial: z
                      .record(z.string(), z.unknown())
                      .optional(),
                    dsseEnvelope: z.record(z.string(), z.unknown()).optional(),
                  })
                  .optional(),
                repository_id: z.coerce.number().optional(),
                bundle_url: z.string().optional(),
              }),
            )
            .optional(),
        }),
      ],
    ],
    undefined,
  )

  // orgsListAttestations
  router.get(
    `/orgs/:org/attestations/:subject_digest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListAttestationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListAttestationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              attestations?:
                | {
                    bundle?:
                      | {
                          dsseEnvelope?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                          mediaType?: string | undefined
                          verificationMaterial?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                        }
                      | undefined
                    bundle_url?: string | undefined
                    repository_id?: number | undefined
                  }[]
                | undefined
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListAttestations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListAttestationsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListBlockedUsersParamSchema = z.object({org: z.string()})

  const orgsListBlockedUsersQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListBlockedUsersResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_simple_user)]],
    undefined,
  )

  // orgsListBlockedUsers
  router.get(
    `/orgs/:org/blocks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListBlockedUsersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListBlockedUsersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListBlockedUsers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListBlockedUsersResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCheckBlockedUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsCheckBlockedUserResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsCheckBlockedUser
  router.get(
    `/orgs/:org/blocks/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCheckBlockedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCheckBlockedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsCheckBlockedUserResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsBlockUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsBlockUserResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsBlockUser
  router.put(
    `/orgs/:org/blocks/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsBlockUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsBlockUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsBlockUserResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUnblockUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsUnblockUserResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // orgsUnblockUser
  router.delete(
    `/orgs/:org/blocks/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUnblockUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUnblockUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsUnblockUserResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const campaignsListOrgCampaignsParamSchema = z.object({org: z.string()})

  const campaignsListOrgCampaignsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    state: s_campaign_state.optional(),
    sort: z
      .enum(["created", "updated", "ends_at", "published"])
      .optional()
      .default("created"),
  })

  const campaignsListOrgCampaignsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_campaign_summary)],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // campaignsListOrgCampaigns
  router.get(
    `/orgs/:org/campaigns`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            campaignsListOrgCampaignsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            campaignsListOrgCampaignsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_campaign_summary[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .campaignsListOrgCampaigns(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, campaignsListOrgCampaignsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const campaignsCreateCampaignParamSchema = z.object({org: z.string()})

  const campaignsCreateCampaignResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_campaign_summary],
        ["400", s_basic_error],
        ["404", s_basic_error],
        ["422", s_basic_error],
        ["429", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // campaignsCreateCampaign
  router.post(
    `/orgs/:org/campaigns`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            campaignsCreateCampaignParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CampaignsCreateCampaignRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_campaign_summary>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_basic_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with429() {
            return new ExpressRuntimeResponse<void>(429)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .campaignsCreateCampaign(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, campaignsCreateCampaignResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const campaignsGetCampaignSummaryParamSchema = z.object({
    org: z.string(),
    campaign_number: z.coerce.number(),
  })

  const campaignsGetCampaignSummaryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_campaign_summary],
        ["404", s_basic_error],
        ["422", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // campaignsGetCampaignSummary
  router.get(
    `/orgs/:org/campaigns/:campaign_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            campaignsGetCampaignSummaryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_campaign_summary>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .campaignsGetCampaignSummary(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              campaignsGetCampaignSummaryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const campaignsUpdateCampaignParamSchema = z.object({
    org: z.string(),
    campaign_number: z.coerce.number(),
  })

  const campaignsUpdateCampaignResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_campaign_summary],
        ["400", s_basic_error],
        ["404", s_basic_error],
        ["422", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // campaignsUpdateCampaign
  router.patch(
    `/orgs/:org/campaigns/:campaign_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            campaignsUpdateCampaignParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CampaignsUpdateCampaignRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_campaign_summary>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_basic_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .campaignsUpdateCampaign(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, campaignsUpdateCampaignResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const campaignsDeleteCampaignParamSchema = z.object({
    org: z.string(),
    campaign_number: z.coerce.number(),
  })

  const campaignsDeleteCampaignResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // campaignsDeleteCampaign
  router.delete(
    `/orgs/:org/campaigns/:campaign_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            campaignsDeleteCampaignParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .campaignsDeleteCampaign(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, campaignsDeleteCampaignResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningListAlertsForOrgParamSchema = z.object({org: z.string()})

  const codeScanningListAlertsForOrgQuerySchema = z.object({
    tool_name: s_code_scanning_analysis_tool_name.optional(),
    tool_guid: s_code_scanning_analysis_tool_guid.optional(),
    before: z.string().optional(),
    after: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    state: s_code_scanning_alert_state_query.optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    severity: s_code_scanning_alert_severity.optional(),
  })

  const codeScanningListAlertsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_scanning_organization_alert_items)],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningListAlertsForOrg
  router.get(
    `/orgs/:org/code-scanning/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningListAlertsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeScanningListAlertsForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_code_scanning_organization_alert_items[]
            >(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningListAlertsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningListAlertsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetConfigurationsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const codeSecurityGetConfigurationsForOrgQuerySchema = z.object({
    target_type: z.enum(["global", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
  })

  const codeSecurityGetConfigurationsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_security_configuration)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetConfigurationsForOrg
  router.get(
    `/orgs/:org/code-security/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetConfigurationsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeSecurityGetConfigurationsForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_configuration[]>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetConfigurationsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetConfigurationsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityCreateConfigurationParamSchema = z.object({org: z.string()})

  const codeSecurityCreateConfigurationResponseBodyValidator =
    responseValidationFactory(
      [["201", s_code_security_configuration]],
      undefined,
    )

  // codeSecurityCreateConfiguration
  router.post(
    `/orgs/:org/code-security/configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityCreateConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecurityCreateConfigurationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_code_security_configuration>(
              201,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityCreateConfiguration(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityCreateConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetDefaultConfigurationsParamSchema = z.object({
    org: z.string(),
  })

  const codeSecurityGetDefaultConfigurationsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_security_default_configurations],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetDefaultConfigurations
  router.get(
    `/orgs/:org/code-security/configurations/defaults`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetDefaultConfigurationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_default_configurations>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetDefaultConfigurations(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetDefaultConfigurationsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityDetachConfigurationParamSchema = z.object({org: z.string()})

  const codeSecurityDetachConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityDetachConfiguration
  router.delete(
    `/orgs/:org/code-security/configurations/detach`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityDetachConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecurityDetachConfigurationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityDetachConfiguration(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityDetachConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityGetConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_security_configuration],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetConfiguration
  router.get(
    `/orgs/:org/code-security/configurations/:configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_configuration>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetConfiguration(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityUpdateConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityUpdateConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_security_configuration],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // codeSecurityUpdateConfiguration
  router.patch(
    `/orgs/:org/code-security/configurations/:configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityUpdateConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecurityUpdateConfigurationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_configuration>(
              200,
            )
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityUpdateConfiguration(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityUpdateConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityDeleteConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityDeleteConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityDeleteConfiguration
  router.delete(
    `/orgs/:org/code-security/configurations/:configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityDeleteConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityDeleteConfiguration(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityDeleteConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityAttachConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityAttachConfigurationResponseBodyValidator =
    responseValidationFactory(
      [["202", z.record(z.string(), z.unknown())]],
      undefined,
    )

  // codeSecurityAttachConfiguration
  router.post(
    `/orgs/:org/code-security/configurations/:configuration_id/attach`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityAttachConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecurityAttachConfigurationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityAttachConfiguration(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityAttachConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecuritySetConfigurationAsDefaultParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecuritySetConfigurationAsDefaultResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            default_for_new_repos: z
              .enum(["all", "none", "private_and_internal", "public"])
              .optional(),
            configuration: s_code_security_configuration.optional(),
          }),
        ],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecuritySetConfigurationAsDefault
  router.put(
    `/orgs/:org/code-security/configurations/:configuration_id/defaults`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecuritySetConfigurationAsDefaultParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeSecuritySetConfigurationAsDefaultRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              configuration?: t_code_security_configuration | undefined
              default_for_new_repos?:
                | ("all" | "none" | "private_and_internal" | "public")
                | undefined
            }>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecuritySetConfigurationAsDefault(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecuritySetConfigurationAsDefaultResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetRepositoriesForConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityGetRepositoriesForConfigurationQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    status: z.string().optional().default("all"),
  })

  const codeSecurityGetRepositoriesForConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_security_configuration_repositories)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetRepositoriesForConfiguration
  router.get(
    `/orgs/:org/code-security/configurations/:configuration_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetRepositoriesForConfigurationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeSecurityGetRepositoriesForConfigurationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_code_security_configuration_repositories[]
            >(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetRepositoriesForConfiguration(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetRepositoriesForConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListInOrganizationParamSchema = z.object({org: z.string()})

  const codespacesListInOrganizationQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const codespacesListInOrganizationResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            codespaces: z.array(s_codespace),
          }),
        ],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesListInOrganization
  router.get(
    `/orgs/:org/codespaces`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesListInOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesListInOrganizationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              codespaces: t_codespace[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListInOrganization(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesListInOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesSetCodespacesAccessParamSchema = z.object({org: z.string()})

  const codespacesSetCodespacesAccessResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["400", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesSetCodespacesAccess
  router.put(
    `/orgs/:org/codespaces/access`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesSetCodespacesAccessParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesSetCodespacesAccessRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesSetCodespacesAccess(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesSetCodespacesAccessResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesSetCodespacesAccessUsersParamSchema = z.object({
    org: z.string(),
  })

  const codespacesSetCodespacesAccessUsersResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["400", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesSetCodespacesAccessUsers
  router.post(
    `/orgs/:org/codespaces/access/selected_users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesSetCodespacesAccessUsersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesSetCodespacesAccessUsersRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesSetCodespacesAccessUsers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesSetCodespacesAccessUsersResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesDeleteCodespacesAccessUsersParamSchema = z.object({
    org: z.string(),
  })

  const codespacesDeleteCodespacesAccessUsersResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["400", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesDeleteCodespacesAccessUsers
  router.delete(
    `/orgs/:org/codespaces/access/selected_users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesDeleteCodespacesAccessUsersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesDeleteCodespacesAccessUsersRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesDeleteCodespacesAccessUsers(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesDeleteCodespacesAccessUsersResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListOrgSecretsParamSchema = z.object({org: z.string()})

  const codespacesListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const codespacesListOrgSecretsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            secrets: z.array(s_codespaces_org_secret),
          }),
        ],
      ],
      undefined,
    )

  // codespacesListOrgSecrets
  router.get(
    `/orgs/:org/codespaces/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesListOrgSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesListOrgSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_codespaces_org_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListOrgSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codespacesListOrgSecretsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetOrgPublicKeyParamSchema = z.object({org: z.string()})

  const codespacesGetOrgPublicKeyResponseBodyValidator =
    responseValidationFactory([["200", s_codespaces_public_key]], undefined)

  // codespacesGetOrgPublicKey
  router.get(
    `/orgs/:org/codespaces/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetOrgPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespaces_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetOrgPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codespacesGetOrgPublicKeyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesGetOrgSecretResponseBodyValidator = responseValidationFactory(
    [["200", s_codespaces_org_secret]],
    undefined,
  )

  // codespacesGetOrgSecret
  router.get(
    `/orgs/:org/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespaces_org_secret>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codespacesGetOrgSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesCreateOrUpdateOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // codespacesCreateOrUpdateOrgSecret
  router.put(
    `/orgs/:org/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesCreateOrUpdateOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesCreateOrUpdateOrgSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCreateOrUpdateOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCreateOrUpdateOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesDeleteOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesDeleteOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codespacesDeleteOrgSecret
  router.delete(
    `/orgs/:org/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesDeleteOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesDeleteOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codespacesDeleteOrgSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const codespacesListSelectedReposForOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_minimal_repository),
          }),
        ],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codespacesListSelectedReposForOrgSecret
  router.get(
    `/orgs/:org/codespaces/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesListSelectedReposForOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesListSelectedReposForOrgSecretQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_minimal_repository[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListSelectedReposForOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesListSelectedReposForOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesSetSelectedReposForOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // codespacesSetSelectedReposForOrgSecret
  router.put(
    `/orgs/:org/codespaces/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesSetSelectedReposForOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesSetSelectedReposForOrgSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesSetSelectedReposForOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesSetSelectedReposForOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  const codespacesAddSelectedRepoToOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["409", z.undefined()],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // codespacesAddSelectedRepoToOrgSecret
  router.put(
    `/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesAddSelectedRepoToOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesAddSelectedRepoToOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesAddSelectedRepoToOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  const codespacesRemoveSelectedRepoFromOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["409", z.undefined()],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // codespacesRemoveSelectedRepoFromOrgSecret
  router.delete(
    `/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesRemoveSelectedRepoFromOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesRemoveSelectedRepoFromOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesRemoveSelectedRepoFromOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotGetCopilotOrganizationDetailsParamSchema = z.object({
    org: z.string(),
  })

  const copilotGetCopilotOrganizationDetailsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_copilot_organization_details],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotGetCopilotOrganizationDetails
  router.get(
    `/orgs/:org/copilot/billing`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotGetCopilotOrganizationDetailsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_copilot_organization_details>(
              200,
            )
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotGetCopilotOrganizationDetails(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotGetCopilotOrganizationDetailsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotListCopilotSeatsParamSchema = z.object({org: z.string()})

  const copilotListCopilotSeatsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(50),
  })

  const copilotListCopilotSeatsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_seats: z.coerce.number().optional(),
            seats: z.array(s_copilot_seat_details).optional(),
          }),
        ],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotListCopilotSeats
  router.get(
    `/orgs/:org/copilot/billing/seats`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotListCopilotSeatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            copilotListCopilotSeatsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              seats?: t_copilot_seat_details[] | undefined
              total_seats?: number | undefined
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotListCopilotSeats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, copilotListCopilotSeatsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotAddCopilotSeatsForTeamsParamSchema = z.object({org: z.string()})

  const copilotAddCopilotSeatsForTeamsResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.object({seats_created: z.coerce.number()})],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotAddCopilotSeatsForTeams
  router.post(
    `/orgs/:org/copilot/billing/selected_teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotAddCopilotSeatsForTeamsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CopilotAddCopilotSeatsForTeamsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<{
              seats_created: number
            }>(201)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotAddCopilotSeatsForTeams(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotAddCopilotSeatsForTeamsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotCancelCopilotSeatAssignmentForTeamsParamSchema = z.object({
    org: z.string(),
  })

  const copilotCancelCopilotSeatAssignmentForTeamsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.object({seats_cancelled: z.coerce.number()})],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotCancelCopilotSeatAssignmentForTeams
  router.delete(
    `/orgs/:org/copilot/billing/selected_teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotCancelCopilotSeatAssignmentForTeamsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CopilotCancelCopilotSeatAssignmentForTeamsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              seats_cancelled: number
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotCancelCopilotSeatAssignmentForTeams(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotCancelCopilotSeatAssignmentForTeamsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotAddCopilotSeatsForUsersParamSchema = z.object({org: z.string()})

  const copilotAddCopilotSeatsForUsersResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.object({seats_created: z.coerce.number()})],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotAddCopilotSeatsForUsers
  router.post(
    `/orgs/:org/copilot/billing/selected_users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotAddCopilotSeatsForUsersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CopilotAddCopilotSeatsForUsersRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<{
              seats_created: number
            }>(201)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotAddCopilotSeatsForUsers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotAddCopilotSeatsForUsersResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotCancelCopilotSeatAssignmentForUsersParamSchema = z.object({
    org: z.string(),
  })

  const copilotCancelCopilotSeatAssignmentForUsersResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.object({seats_cancelled: z.coerce.number()})],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotCancelCopilotSeatAssignmentForUsers
  router.delete(
    `/orgs/:org/copilot/billing/selected_users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotCancelCopilotSeatAssignmentForUsersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CopilotCancelCopilotSeatAssignmentForUsersRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              seats_cancelled: number
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotCancelCopilotSeatAssignmentForUsers(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotCancelCopilotSeatAssignmentForUsersResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotCopilotMetricsForOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const copilotCopilotMetricsForOrganizationQuerySchema = z.object({
    since: z.string().optional(),
    until: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(28),
  })

  const copilotCopilotMetricsForOrganizationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_copilot_usage_metrics_day)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotCopilotMetricsForOrganization
  router.get(
    `/orgs/:org/copilot/metrics`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotCopilotMetricsForOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            copilotCopilotMetricsForOrganizationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_copilot_usage_metrics_day[]>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotCopilotMetricsForOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotCopilotMetricsForOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotListAlertsForOrgParamSchema = z.object({org: z.string()})

  const dependabotListAlertsForOrgQuerySchema = z.object({
    state: z.string().optional(),
    severity: z.string().optional(),
    ecosystem: z.string().optional(),
    package: z.string().optional(),
    epss_percentage: z.string().optional(),
    has: z.union([z.string(), z.array(z.enum(["patch"]))]).optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z
      .enum(["created", "updated", "epss_percentage"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    before: z.string().optional(),
    after: z.string().optional(),
    first: z.coerce.number().min(1).max(100).optional().default(30),
    last: z.coerce.number().min(1).max(100).optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  const dependabotListAlertsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_dependabot_alert_with_repository)],
        ["304", z.undefined()],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // dependabotListAlertsForOrg
  router.get(
    `/orgs/:org/dependabot/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotListAlertsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependabotListAlertsForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_dependabot_alert_with_repository[]
            >(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotListAlertsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotListAlertsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotListOrgSecretsParamSchema = z.object({org: z.string()})

  const dependabotListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const dependabotListOrgSecretsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            secrets: z.array(s_organization_dependabot_secret),
          }),
        ],
      ],
      undefined,
    )

  // dependabotListOrgSecrets
  router.get(
    `/orgs/:org/dependabot/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotListOrgSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependabotListOrgSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_organization_dependabot_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotListOrgSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependabotListOrgSecretsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotGetOrgPublicKeyParamSchema = z.object({org: z.string()})

  const dependabotGetOrgPublicKeyResponseBodyValidator =
    responseValidationFactory([["200", s_dependabot_public_key]], undefined)

  // dependabotGetOrgPublicKey
  router.get(
    `/orgs/:org/dependabot/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotGetOrgPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependabot_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotGetOrgPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependabotGetOrgPublicKeyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotGetOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotGetOrgSecretResponseBodyValidator = responseValidationFactory(
    [["200", s_organization_dependabot_secret]],
    undefined,
  )

  // dependabotGetOrgSecret
  router.get(
    `/orgs/:org/dependabot/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotGetOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_dependabot_secret>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotGetOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependabotGetOrgSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotCreateOrUpdateOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // dependabotCreateOrUpdateOrgSecret
  router.put(
    `/orgs/:org/dependabot/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotCreateOrUpdateOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_DependabotCreateOrUpdateOrgSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotCreateOrUpdateOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotCreateOrUpdateOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotDeleteOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotDeleteOrgSecretResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // dependabotDeleteOrgSecret
  router.delete(
    `/orgs/:org/dependabot/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotDeleteOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotDeleteOrgSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependabotDeleteOrgSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const dependabotListSelectedReposForOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_minimal_repository),
          }),
        ],
      ],
      undefined,
    )

  // dependabotListSelectedReposForOrgSecret
  router.get(
    `/orgs/:org/dependabot/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotListSelectedReposForOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependabotListSelectedReposForOrgSecretQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_minimal_repository[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotListSelectedReposForOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotListSelectedReposForOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotSetSelectedReposForOrgSecretResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // dependabotSetSelectedReposForOrgSecret
  router.put(
    `/orgs/:org/dependabot/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotSetSelectedReposForOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_DependabotSetSelectedReposForOrgSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotSetSelectedReposForOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotSetSelectedReposForOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  const dependabotAddSelectedRepoToOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // dependabotAddSelectedRepoToOrgSecret
  router.put(
    `/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotAddSelectedRepoToOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotAddSelectedRepoToOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotAddSelectedRepoToOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  const dependabotRemoveSelectedRepoFromOrgSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // dependabotRemoveSelectedRepoFromOrgSecret
  router.delete(
    `/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotRemoveSelectedRepoFromOrgSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotRemoveSelectedRepoFromOrgSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotRemoveSelectedRepoFromOrgSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesListDockerMigrationConflictingPackagesForOrganizationParamSchema =
    z.object({org: z.string()})

  const packagesListDockerMigrationConflictingPackagesForOrganizationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package)],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // packagesListDockerMigrationConflictingPackagesForOrganization
  router.get(
    `/orgs/:org/docker/conflicts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesListDockerMigrationConflictingPackagesForOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesListDockerMigrationConflictingPackagesForOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesListDockerMigrationConflictingPackagesForOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListPublicOrgEventsParamSchema = z.object({org: z.string()})

  const activityListPublicOrgEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListPublicOrgEventsResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_event)]], undefined)

  // activityListPublicOrgEvents
  router.get(
    `/orgs/:org/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListPublicOrgEventsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListPublicOrgEventsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListPublicOrgEvents(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListPublicOrgEventsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListFailedInvitationsParamSchema = z.object({org: z.string()})

  const orgsListFailedInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListFailedInvitationsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_organization_invitation)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsListFailedInvitations
  router.get(
    `/orgs/:org/failed_invitations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListFailedInvitationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListFailedInvitationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_invitation[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListFailedInvitations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsListFailedInvitationsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListWebhooksParamSchema = z.object({org: z.string()})

  const orgsListWebhooksQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListWebhooksResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_org_hook)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsListWebhooks
  router.get(
    `/orgs/:org/hooks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListWebhooksParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListWebhooksQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_hook[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListWebhooks(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListWebhooksResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCreateWebhookParamSchema = z.object({org: z.string()})

  const orgsCreateWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_org_hook],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsCreateWebhook
  router.post(
    `/orgs/:org/hooks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCreateWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsCreateWebhookRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_org_hook>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCreateWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsCreateWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsGetWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_org_hook],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsGetWebhook
  router.get(
    `/orgs/:org/hooks/:hook_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_hook>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsGetWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUpdateWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsUpdateWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_org_hook],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsUpdateWebhook
  router.patch(
    `/orgs/:org/hooks/:hook_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUpdateWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsUpdateWebhookRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_hook>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUpdateWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsUpdateWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsDeleteWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsDeleteWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsDeleteWebhook
  router.delete(
    `/orgs/:org/hooks/:hook_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsDeleteWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsDeleteWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsDeleteWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetWebhookConfigForOrgParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsGetWebhookConfigForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_config]], undefined)

  // orgsGetWebhookConfigForOrg
  router.get(
    `/orgs/:org/hooks/:hook_id/config`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetWebhookConfigForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_config>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetWebhookConfigForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsGetWebhookConfigForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUpdateWebhookConfigForOrgParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsUpdateWebhookConfigForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_config]], undefined)

  // orgsUpdateWebhookConfigForOrg
  router.patch(
    `/orgs/:org/hooks/:hook_id/config`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUpdateWebhookConfigForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsUpdateWebhookConfigForOrgRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_config>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUpdateWebhookConfigForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsUpdateWebhookConfigForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListWebhookDeliveriesParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    cursor: z.string().optional(),
  })

  const orgsListWebhookDeliveriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_hook_delivery_item)],
        ["400", s_scim_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // orgsListWebhookDeliveries
  router.get(
    `/orgs/:org/hooks/:hook_id/deliveries`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListWebhookDeliveriesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListWebhookDeliveriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook_delivery_item[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListWebhookDeliveries(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsListWebhookDeliveriesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetWebhookDeliveryParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  const orgsGetWebhookDeliveryResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_hook_delivery],
      ["400", s_scim_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsGetWebhookDelivery
  router.get(
    `/orgs/:org/hooks/:hook_id/deliveries/:delivery_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetWebhookDeliveryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook_delivery>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetWebhookDelivery(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsGetWebhookDeliveryResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRedeliverWebhookDeliveryParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  const orgsRedeliverWebhookDeliveryResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["400", s_scim_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // orgsRedeliverWebhookDelivery
  router.post(
    `/orgs/:org/hooks/:hook_id/deliveries/:delivery_id/attempts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRedeliverWebhookDeliveryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRedeliverWebhookDelivery(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsRedeliverWebhookDeliveryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsPingWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsPingWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsPingWebhook
  router.post(
    `/orgs/:org/hooks/:hook_id/pings`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsPingWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsPingWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsPingWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetRouteStatsByActorParamSchema = z.object({
    org: z.string(),
    actor_type: z.enum([
      "installation",
      "classic_pat",
      "fine_grained_pat",
      "oauth_app",
      "github_app_user_to_server",
    ]),
    actor_id: z.coerce.number(),
  })

  const apiInsightsGetRouteStatsByActorQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z
            .enum([
              "last_rate_limited_timestamp",
              "last_request_timestamp",
              "rate_limited_request_count",
              "http_method",
              "api_route",
              "total_request_count",
            ])
            .default("total_request_count"),
        ),
      )
      .optional(),
    api_route_substring: z.string().optional(),
  })

  const apiInsightsGetRouteStatsByActorResponseBodyValidator =
    responseValidationFactory([["200", s_api_insights_route_stats]], undefined)

  // apiInsightsGetRouteStatsByActor
  router.get(
    `/orgs/:org/insights/api/route-stats/:actor_type/:actor_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetRouteStatsByActorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetRouteStatsByActorQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_route_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetRouteStatsByActor(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              apiInsightsGetRouteStatsByActorResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetSubjectStatsParamSchema = z.object({org: z.string()})

  const apiInsightsGetSubjectStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z
            .enum([
              "last_rate_limited_timestamp",
              "last_request_timestamp",
              "rate_limited_request_count",
              "subject_name",
              "total_request_count",
            ])
            .default("total_request_count"),
        ),
      )
      .optional(),
    subject_name_substring: z.string().optional(),
  })

  const apiInsightsGetSubjectStatsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_api_insights_subject_stats]],
      undefined,
    )

  // apiInsightsGetSubjectStats
  router.get(
    `/orgs/:org/insights/api/subject-stats`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetSubjectStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetSubjectStatsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_subject_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetSubjectStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              apiInsightsGetSubjectStatsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetSummaryStatsParamSchema = z.object({org: z.string()})

  const apiInsightsGetSummaryStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
  })

  const apiInsightsGetSummaryStatsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_api_insights_summary_stats]],
      undefined,
    )

  // apiInsightsGetSummaryStats
  router.get(
    `/orgs/:org/insights/api/summary-stats`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetSummaryStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetSummaryStatsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_summary_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetSummaryStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              apiInsightsGetSummaryStatsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetSummaryStatsByUserParamSchema = z.object({
    org: z.string(),
    user_id: z.string(),
  })

  const apiInsightsGetSummaryStatsByUserQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
  })

  const apiInsightsGetSummaryStatsByUserResponseBodyValidator =
    responseValidationFactory(
      [["200", s_api_insights_summary_stats]],
      undefined,
    )

  // apiInsightsGetSummaryStatsByUser
  router.get(
    `/orgs/:org/insights/api/summary-stats/users/:user_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetSummaryStatsByUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetSummaryStatsByUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_summary_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetSummaryStatsByUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              apiInsightsGetSummaryStatsByUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetSummaryStatsByActorParamSchema = z.object({
    org: z.string(),
    actor_type: z.enum([
      "installation",
      "classic_pat",
      "fine_grained_pat",
      "oauth_app",
      "github_app_user_to_server",
    ]),
    actor_id: z.coerce.number(),
  })

  const apiInsightsGetSummaryStatsByActorQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
  })

  const apiInsightsGetSummaryStatsByActorResponseBodyValidator =
    responseValidationFactory(
      [["200", s_api_insights_summary_stats]],
      undefined,
    )

  // apiInsightsGetSummaryStatsByActor
  router.get(
    `/orgs/:org/insights/api/summary-stats/:actor_type/:actor_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetSummaryStatsByActorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetSummaryStatsByActorQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_summary_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetSummaryStatsByActor(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              apiInsightsGetSummaryStatsByActorResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetTimeStatsParamSchema = z.object({org: z.string()})

  const apiInsightsGetTimeStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    timestamp_increment: z.string(),
  })

  const apiInsightsGetTimeStatsResponseBodyValidator =
    responseValidationFactory([["200", s_api_insights_time_stats]], undefined)

  // apiInsightsGetTimeStats
  router.get(
    `/orgs/:org/insights/api/time-stats`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetTimeStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetTimeStatsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_time_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetTimeStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, apiInsightsGetTimeStatsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetTimeStatsByUserParamSchema = z.object({
    org: z.string(),
    user_id: z.string(),
  })

  const apiInsightsGetTimeStatsByUserQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    timestamp_increment: z.string(),
  })

  const apiInsightsGetTimeStatsByUserResponseBodyValidator =
    responseValidationFactory([["200", s_api_insights_time_stats]], undefined)

  // apiInsightsGetTimeStatsByUser
  router.get(
    `/orgs/:org/insights/api/time-stats/users/:user_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetTimeStatsByUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetTimeStatsByUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_time_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetTimeStatsByUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              apiInsightsGetTimeStatsByUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetTimeStatsByActorParamSchema = z.object({
    org: z.string(),
    actor_type: z.enum([
      "installation",
      "classic_pat",
      "fine_grained_pat",
      "oauth_app",
      "github_app_user_to_server",
    ]),
    actor_id: z.coerce.number(),
  })

  const apiInsightsGetTimeStatsByActorQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    timestamp_increment: z.string(),
  })

  const apiInsightsGetTimeStatsByActorResponseBodyValidator =
    responseValidationFactory([["200", s_api_insights_time_stats]], undefined)

  // apiInsightsGetTimeStatsByActor
  router.get(
    `/orgs/:org/insights/api/time-stats/:actor_type/:actor_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetTimeStatsByActorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetTimeStatsByActorQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_time_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetTimeStatsByActor(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              apiInsightsGetTimeStatsByActorResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const apiInsightsGetUserStatsParamSchema = z.object({
    org: z.string(),
    user_id: z.string(),
  })

  const apiInsightsGetUserStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z
            .enum([
              "last_rate_limited_timestamp",
              "last_request_timestamp",
              "rate_limited_request_count",
              "subject_name",
              "total_request_count",
            ])
            .default("total_request_count"),
        ),
      )
      .optional(),
    actor_name_substring: z.string().optional(),
  })

  const apiInsightsGetUserStatsResponseBodyValidator =
    responseValidationFactory([["200", s_api_insights_user_stats]], undefined)

  // apiInsightsGetUserStats
  router.get(
    `/orgs/:org/insights/api/user-stats/:user_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            apiInsightsGetUserStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            apiInsightsGetUserStatsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_api_insights_user_stats>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .apiInsightsGetUserStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, apiInsightsGetUserStatsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetOrgInstallationParamSchema = z.object({org: z.string()})

  const appsGetOrgInstallationResponseBodyValidator = responseValidationFactory(
    [["200", s_installation]],
    undefined,
  )

  // appsGetOrgInstallation
  router.get(
    `/orgs/:org/installation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetOrgInstallationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_installation>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetOrgInstallation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsGetOrgInstallationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListAppInstallationsParamSchema = z.object({org: z.string()})

  const orgsListAppInstallationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListAppInstallationsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            installations: z.array(s_installation),
          }),
        ],
      ],
      undefined,
    )

  // orgsListAppInstallations
  router.get(
    `/orgs/:org/installations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListAppInstallationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListAppInstallationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              installations: t_installation[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListAppInstallations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsListAppInstallationsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsGetRestrictionsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const interactionsGetRestrictionsForOrgResponseBodyValidator =
    responseValidationFactory(
      [["200", z.union([s_interaction_limit_response, z.object({})])]],
      undefined,
    )

  // interactionsGetRestrictionsForOrg
  router.get(
    `/orgs/:org/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            interactionsGetRestrictionsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_interaction_limit_response | EmptyObject
            >(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsGetRestrictionsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsGetRestrictionsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsSetRestrictionsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const interactionsSetRestrictionsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_interaction_limit_response],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // interactionsSetRestrictionsForOrg
  router.put(
    `/orgs/:org/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            interactionsSetRestrictionsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_interaction_limit,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_interaction_limit_response>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsSetRestrictionsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsSetRestrictionsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsRemoveRestrictionsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const interactionsRemoveRestrictionsForOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // interactionsRemoveRestrictionsForOrg
  router.delete(
    `/orgs/:org/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            interactionsRemoveRestrictionsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsRemoveRestrictionsForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsRemoveRestrictionsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListPendingInvitationsParamSchema = z.object({org: z.string()})

  const orgsListPendingInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    role: z
      .enum([
        "all",
        "admin",
        "direct_member",
        "billing_manager",
        "hiring_manager",
      ])
      .optional()
      .default("all"),
    invitation_source: z
      .enum(["all", "member", "scim"])
      .optional()
      .default("all"),
  })

  const orgsListPendingInvitationsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_organization_invitation)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsListPendingInvitations
  router.get(
    `/orgs/:org/invitations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListPendingInvitationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListPendingInvitationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_invitation[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListPendingInvitations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListPendingInvitationsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCreateInvitationParamSchema = z.object({org: z.string()})

  const orgsCreateInvitationResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_organization_invitation],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsCreateInvitation
  router.post(
    `/orgs/:org/invitations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCreateInvitationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsCreateInvitationRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_organization_invitation>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCreateInvitation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsCreateInvitationResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCancelInvitationParamSchema = z.object({
    org: z.string(),
    invitation_id: z.coerce.number(),
  })

  const orgsCancelInvitationResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsCancelInvitation
  router.delete(
    `/orgs/:org/invitations/:invitation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCancelInvitationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCancelInvitation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsCancelInvitationResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListInvitationTeamsParamSchema = z.object({
    org: z.string(),
    invitation_id: z.coerce.number(),
  })

  const orgsListInvitationTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListInvitationTeamsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_team)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsListInvitationTeams
  router.get(
    `/orgs/:org/invitations/:invitation_id/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListInvitationTeamsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListInvitationTeamsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListInvitationTeams(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsListInvitationTeamsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListIssueTypesParamSchema = z.object({org: z.string()})

  const orgsListIssueTypesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_issue_type)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsListIssueTypes
  router.get(
    `/orgs/:org/issue-types`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListIssueTypesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_type[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListIssueTypes(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListIssueTypesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCreateIssueTypeParamSchema = z.object({org: z.string()})

  const orgsCreateIssueTypeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue_type],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // orgsCreateIssueType
  router.post(
    `/orgs/:org/issue-types`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCreateIssueTypeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_organization_create_issue_type,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_type>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCreateIssueType(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsCreateIssueTypeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUpdateIssueTypeParamSchema = z.object({
    org: z.string(),
    issue_type_id: z.coerce.number(),
  })

  const orgsUpdateIssueTypeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue_type],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // orgsUpdateIssueType
  router.put(
    `/orgs/:org/issue-types/:issue_type_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUpdateIssueTypeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_organization_update_issue_type,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_type>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUpdateIssueType(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsUpdateIssueTypeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsDeleteIssueTypeParamSchema = z.object({
    org: z.string(),
    issue_type_id: z.coerce.number(),
  })

  const orgsDeleteIssueTypeResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // orgsDeleteIssueType
  router.delete(
    `/orgs/:org/issue-types/:issue_type_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsDeleteIssueTypeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsDeleteIssueType(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsDeleteIssueTypeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListForOrgParamSchema = z.object({org: z.string()})

  const issuesListForOrgQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional()
      .default("assigned"),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    labels: z.string().optional(),
    type: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListForOrgResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_issue)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesListForOrg
  router.get(
    `/orgs/:org/issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListForOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListMembersParamSchema = z.object({org: z.string()})

  const orgsListMembersQuerySchema = z.object({
    filter: z
      .enum(["2fa_disabled", "2fa_insecure", "all"])
      .optional()
      .default("all"),
    role: z.enum(["all", "admin", "member"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListMembersResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_simple_user)],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsListMembers
  router.get(
    `/orgs/:org/members`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListMembersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListMembersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListMembers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListMembersResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCheckMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsCheckMembershipForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["302", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // orgsCheckMembershipForUser
  router.get(
    `/orgs/:org/members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCheckMembershipForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCheckMembershipForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsCheckMembershipForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRemoveMemberParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsRemoveMemberResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // orgsRemoveMember
  router.delete(
    `/orgs/:org/members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRemoveMemberParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRemoveMember(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsRemoveMemberResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetCodespacesForUserInOrgParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const codespacesGetCodespacesForUserInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const codespacesGetCodespacesForUserInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            codespaces: z.array(s_codespace),
          }),
        ],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesGetCodespacesForUserInOrg
  router.get(
    `/orgs/:org/members/:username/codespaces`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetCodespacesForUserInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesGetCodespacesForUserInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              codespaces: t_codespace[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetCodespacesForUserInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesGetCodespacesForUserInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesDeleteFromOrganizationParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    codespace_name: z.string(),
  })

  const codespacesDeleteFromOrganizationResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesDeleteFromOrganization
  router.delete(
    `/orgs/:org/members/:username/codespaces/:codespace_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesDeleteFromOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesDeleteFromOrganization(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesDeleteFromOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesStopInOrganizationParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    codespace_name: z.string(),
  })

  const codespacesStopInOrganizationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_codespace],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesStopInOrganization
  router.post(
    `/orgs/:org/members/:username/codespaces/:codespace_name/stop`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesStopInOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespace>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesStopInOrganization(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesStopInOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotGetCopilotSeatDetailsForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const copilotGetCopilotSeatDetailsForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_copilot_seat_details],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotGetCopilotSeatDetailsForUser
  router.get(
    `/orgs/:org/members/:username/copilot`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotGetCopilotSeatDetailsForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_copilot_seat_details>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotGetCopilotSeatDetailsForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotGetCopilotSeatDetailsForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsGetMembershipForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_org_membership],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsGetMembershipForUser
  router.get(
    `/orgs/:org/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetMembershipForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_membership>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetMembershipForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsGetMembershipForUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsSetMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsSetMembershipForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_org_membership],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // orgsSetMembershipForUser
  router.put(
    `/orgs/:org/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsSetMembershipForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsSetMembershipForUserRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_membership>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsSetMembershipForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsSetMembershipForUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRemoveMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsRemoveMembershipForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsRemoveMembershipForUser
  router.delete(
    `/orgs/:org/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRemoveMembershipForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRemoveMembershipForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsRemoveMembershipForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsListForOrgParamSchema = z.object({org: z.string()})

  const migrationsListForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    exclude: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.enum(["repositories"])),
      )
      .optional(),
  })

  const migrationsListForOrgResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_migration)]],
    undefined,
  )

  // migrationsListForOrg
  router.get(
    `/orgs/:org/migrations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsListForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            migrationsListForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_migration[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsListForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, migrationsListForOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsStartForOrgParamSchema = z.object({org: z.string()})

  const migrationsStartForOrgResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_migration],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // migrationsStartForOrg
  router.post(
    `/orgs/:org/migrations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsStartForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_MigrationsStartForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_migration>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsStartForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, migrationsStartForOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsGetStatusForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsGetStatusForOrgQuerySchema = z.object({
    exclude: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.enum(["repositories"])),
      )
      .optional(),
  })

  const migrationsGetStatusForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_migration],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsGetStatusForOrg
  router.get(
    `/orgs/:org/migrations/:migration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsGetStatusForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            migrationsGetStatusForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_migration>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsGetStatusForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, migrationsGetStatusForOrgResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsDownloadArchiveForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsDownloadArchiveForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["302", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsDownloadArchiveForOrg
  router.get(
    `/orgs/:org/migrations/:migration_id/archive`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsDownloadArchiveForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsDownloadArchiveForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsDownloadArchiveForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsDeleteArchiveForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsDeleteArchiveForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsDeleteArchiveForOrg
  router.delete(
    `/orgs/:org/migrations/:migration_id/archive`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsDeleteArchiveForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsDeleteArchiveForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsDeleteArchiveForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsUnlockRepoForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
    repo_name: z.string(),
  })

  const migrationsUnlockRepoForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsUnlockRepoForOrg
  router.delete(
    `/orgs/:org/migrations/:migration_id/repos/:repo_name/lock`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsUnlockRepoForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsUnlockRepoForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsUnlockRepoForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsListReposForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsListReposForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const migrationsListReposForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_minimal_repository)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsListReposForOrg
  router.get(
    `/orgs/:org/migrations/:migration_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsListReposForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            migrationsListReposForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsListReposForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, migrationsListReposForOrgResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListOrgRolesParamSchema = z.object({org: z.string()})

  const orgsListOrgRolesResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number().optional(),
          roles: z.array(s_organization_role).optional(),
        }),
      ],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsListOrgRoles
  router.get(
    `/orgs/:org/organization-roles`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListOrgRolesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              roles?: t_organization_role[] | undefined
              total_count?: number | undefined
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListOrgRoles(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListOrgRolesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRevokeAllOrgRolesTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const orgsRevokeAllOrgRolesTeamResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // orgsRevokeAllOrgRolesTeam
  router.delete(
    `/orgs/:org/organization-roles/teams/:team_slug`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRevokeAllOrgRolesTeamParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRevokeAllOrgRolesTeam(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsRevokeAllOrgRolesTeamResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsAssignTeamToOrgRoleParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsAssignTeamToOrgRoleResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", z.undefined()],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // orgsAssignTeamToOrgRole
  router.put(
    `/orgs/:org/organization-roles/teams/:team_slug/:role_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsAssignTeamToOrgRoleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsAssignTeamToOrgRole(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsAssignTeamToOrgRoleResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRevokeOrgRoleTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsRevokeOrgRoleTeamResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // orgsRevokeOrgRoleTeam
  router.delete(
    `/orgs/:org/organization-roles/teams/:team_slug/:role_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRevokeOrgRoleTeamParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRevokeOrgRoleTeam(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsRevokeOrgRoleTeamResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRevokeAllOrgRolesUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsRevokeAllOrgRolesUserResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // orgsRevokeAllOrgRolesUser
  router.delete(
    `/orgs/:org/organization-roles/users/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRevokeAllOrgRolesUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRevokeAllOrgRolesUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsRevokeAllOrgRolesUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsAssignUserToOrgRoleParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsAssignUserToOrgRoleResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", z.undefined()],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // orgsAssignUserToOrgRole
  router.put(
    `/orgs/:org/organization-roles/users/:username/:role_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsAssignUserToOrgRoleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsAssignUserToOrgRole(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsAssignUserToOrgRoleResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRevokeOrgRoleUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsRevokeOrgRoleUserResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // orgsRevokeOrgRoleUser
  router.delete(
    `/orgs/:org/organization-roles/users/:username/:role_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRevokeOrgRoleUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRevokeOrgRoleUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsRevokeOrgRoleUserResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetOrgRoleParamSchema = z.object({
    org: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsGetOrgRoleResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_organization_role],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // orgsGetOrgRole
  router.get(
    `/orgs/:org/organization-roles/:role_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetOrgRoleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_role>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetOrgRole(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsGetOrgRoleResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListOrgRoleTeamsParamSchema = z.object({
    org: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsListOrgRoleTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListOrgRoleTeamsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_team_role_assignment)],
      ["404", z.undefined()],
      ["422", z.undefined()],
    ],
    undefined,
  )

  // orgsListOrgRoleTeams
  router.get(
    `/orgs/:org/organization-roles/:role_id/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListOrgRoleTeamsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListOrgRoleTeamsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_role_assignment[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListOrgRoleTeams(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListOrgRoleTeamsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListOrgRoleUsersParamSchema = z.object({
    org: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsListOrgRoleUsersQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListOrgRoleUsersResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_user_role_assignment)],
      ["404", z.undefined()],
      ["422", z.undefined()],
    ],
    undefined,
  )

  // orgsListOrgRoleUsers
  router.get(
    `/orgs/:org/organization-roles/:role_id/users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListOrgRoleUsersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListOrgRoleUsersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_user_role_assignment[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListOrgRoleUsers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListOrgRoleUsersResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListOutsideCollaboratorsParamSchema = z.object({org: z.string()})

  const orgsListOutsideCollaboratorsQuerySchema = z.object({
    filter: z
      .enum(["2fa_disabled", "2fa_insecure", "all"])
      .optional()
      .default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListOutsideCollaboratorsResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_simple_user)]], undefined)

  // orgsListOutsideCollaborators
  router.get(
    `/orgs/:org/outside_collaborators`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListOutsideCollaboratorsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListOutsideCollaboratorsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListOutsideCollaborators(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListOutsideCollaboratorsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsConvertMemberToOutsideCollaboratorParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsConvertMemberToOutsideCollaboratorResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.object({})],
        ["204", z.undefined()],
        ["403", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsConvertMemberToOutsideCollaborator
  router.put(
    `/orgs/:org/outside_collaborators/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsConvertMemberToOutsideCollaboratorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsConvertMemberToOutsideCollaboratorRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<EmptyObject>(202)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsConvertMemberToOutsideCollaborator(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsConvertMemberToOutsideCollaboratorResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRemoveOutsideCollaboratorParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsRemoveOutsideCollaboratorResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        [
          "422",
          z.object({
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // orgsRemoveOutsideCollaborator
  router.delete(
    `/orgs/:org/outside_collaborators/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRemoveOutsideCollaboratorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              message?: string | undefined
            }>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRemoveOutsideCollaborator(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsRemoveOutsideCollaboratorResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesListPackagesForOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const packagesListPackagesForOrganizationQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const packagesListPackagesForOrganizationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package)],
        ["400", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // packagesListPackagesForOrganization
  router.get(
    `/orgs/:org/packages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesListPackagesForOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            packagesListPackagesForOrganizationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesListPackagesForOrganization(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesListPackagesForOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetPackageForOrganizationParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
  })

  const packagesGetPackageForOrganizationResponseBodyValidator =
    responseValidationFactory([["200", s_package]], undefined)

  // packagesGetPackageForOrganization
  router.get(
    `/orgs/:org/packages/:package_type/:package_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetPackageForOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetPackageForOrganization(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetPackageForOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesDeletePackageForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
  })

  const packagesDeletePackageForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesDeletePackageForOrg
  router.delete(
    `/orgs/:org/packages/:package_type/:package_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesDeletePackageForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesDeletePackageForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesDeletePackageForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesRestorePackageForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
  })

  const packagesRestorePackageForOrgQuerySchema = z.object({
    token: z.string().optional(),
  })

  const packagesRestorePackageForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesRestorePackageForOrg
  router.post(
    `/orgs/:org/packages/:package_type/:package_name/restore`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesRestorePackageForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            packagesRestorePackageForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesRestorePackageForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesRestorePackageForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema = z.object(
    {
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
      org: z.string(),
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema = z.object(
    {
      page: z.coerce.number().optional().default(1),
      per_page: z.coerce.number().optional().default(30),
      state: z.enum(["active", "deleted"]).optional().default("active"),
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package_version)],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesGetAllPackageVersionsForPackageOwnedByOrg
  router.get(
    `/orgs/:org/packages/:package_type/:package_name/versions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            packagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package_version[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetAllPackageVersionsForPackageOwnedByOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetAllPackageVersionsForPackageOwnedByOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetPackageVersionForOrganizationParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
    package_version_id: z.coerce.number(),
  })

  const packagesGetPackageVersionForOrganizationResponseBodyValidator =
    responseValidationFactory([["200", s_package_version]], undefined)

  // packagesGetPackageVersionForOrganization
  router.get(
    `/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetPackageVersionForOrganizationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package_version>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetPackageVersionForOrganization(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetPackageVersionForOrganizationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesDeletePackageVersionForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
    package_version_id: z.coerce.number(),
  })

  const packagesDeletePackageVersionForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesDeletePackageVersionForOrg
  router.delete(
    `/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesDeletePackageVersionForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesDeletePackageVersionForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesDeletePackageVersionForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesRestorePackageVersionForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
    package_version_id: z.coerce.number(),
  })

  const packagesRestorePackageVersionForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesRestorePackageVersionForOrg
  router.post(
    `/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id/restore`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesRestorePackageVersionForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesRestorePackageVersionForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesRestorePackageVersionForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListPatGrantRequestsParamSchema = z.object({org: z.string()})

  const orgsListPatGrantRequestsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    sort: z.enum(["created_at"]).optional().default("created_at"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    owner: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(10),
      )
      .optional(),
    repository: z.string().optional(),
    permission: z.string().optional(),
    last_used_before: z.iso.datetime({offset: true}).optional(),
    last_used_after: z.iso.datetime({offset: true}).optional(),
    token_id: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(50),
      )
      .optional(),
  })

  const orgsListPatGrantRequestsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_organization_programmatic_access_grant_request)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // orgsListPatGrantRequests
  router.get(
    `/orgs/:org/personal-access-token-requests`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListPatGrantRequestsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListPatGrantRequestsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_organization_programmatic_access_grant_request[]
            >(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListPatGrantRequests(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsListPatGrantRequestsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsReviewPatGrantRequestsInBulkParamSchema = z.object({
    org: z.string(),
  })

  const orgsReviewPatGrantRequestsInBulkResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // orgsReviewPatGrantRequestsInBulk
  router.post(
    `/orgs/:org/personal-access-token-requests`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsReviewPatGrantRequestsInBulkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsReviewPatGrantRequestsInBulkRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsReviewPatGrantRequestsInBulk(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsReviewPatGrantRequestsInBulkResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsReviewPatGrantRequestParamSchema = z.object({
    org: z.string(),
    pat_request_id: z.coerce.number(),
  })

  const orgsReviewPatGrantRequestResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // orgsReviewPatGrantRequest
  router.post(
    `/orgs/:org/personal-access-token-requests/:pat_request_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsReviewPatGrantRequestParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsReviewPatGrantRequestRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsReviewPatGrantRequest(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsReviewPatGrantRequestResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListPatGrantRequestRepositoriesParamSchema = z.object({
    org: z.string(),
    pat_request_id: z.coerce.number(),
  })

  const orgsListPatGrantRequestRepositoriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListPatGrantRequestRepositoriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_minimal_repository)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // orgsListPatGrantRequestRepositories
  router.get(
    `/orgs/:org/personal-access-token-requests/:pat_request_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListPatGrantRequestRepositoriesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListPatGrantRequestRepositoriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListPatGrantRequestRepositories(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListPatGrantRequestRepositoriesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListPatGrantsParamSchema = z.object({org: z.string()})

  const orgsListPatGrantsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    sort: z.enum(["created_at"]).optional().default("created_at"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    owner: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(10),
      )
      .optional(),
    repository: z.string().optional(),
    permission: z.string().optional(),
    last_used_before: z.iso.datetime({offset: true}).optional(),
    last_used_after: z.iso.datetime({offset: true}).optional(),
    token_id: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(50),
      )
      .optional(),
  })

  const orgsListPatGrantsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_organization_programmatic_access_grant)],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // orgsListPatGrants
  router.get(
    `/orgs/:org/personal-access-tokens`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListPatGrantsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListPatGrantsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_organization_programmatic_access_grant[]
            >(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListPatGrants(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListPatGrantsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUpdatePatAccessesParamSchema = z.object({org: z.string()})

  const orgsUpdatePatAccessesResponseBodyValidator = responseValidationFactory(
    [
      ["202", z.record(z.string(), z.unknown())],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // orgsUpdatePatAccesses
  router.post(
    `/orgs/:org/personal-access-tokens`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUpdatePatAccessesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsUpdatePatAccessesRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUpdatePatAccesses(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsUpdatePatAccessesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUpdatePatAccessParamSchema = z.object({
    org: z.string(),
    pat_id: z.coerce.number(),
  })

  const orgsUpdatePatAccessResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // orgsUpdatePatAccess
  router.post(
    `/orgs/:org/personal-access-tokens/:pat_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUpdatePatAccessParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsUpdatePatAccessRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUpdatePatAccess(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsUpdatePatAccessResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListPatGrantRepositoriesParamSchema = z.object({
    org: z.string(),
    pat_id: z.coerce.number(),
  })

  const orgsListPatGrantRepositoriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListPatGrantRepositoriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_minimal_repository)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // orgsListPatGrantRepositories
  router.get(
    `/orgs/:org/personal-access-tokens/:pat_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListPatGrantRepositoriesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListPatGrantRepositoriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListPatGrantRepositories(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListPatGrantRepositoriesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const privateRegistriesListOrgPrivateRegistriesParamSchema = z.object({
    org: z.string(),
  })

  const privateRegistriesListOrgPrivateRegistriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const privateRegistriesListOrgPrivateRegistriesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            configurations: z.array(s_org_private_registry_configuration),
          }),
        ],
        ["400", s_scim_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // privateRegistriesListOrgPrivateRegistries
  router.get(
    `/orgs/:org/private-registries`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            privateRegistriesListOrgPrivateRegistriesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            privateRegistriesListOrgPrivateRegistriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              configurations: t_org_private_registry_configuration[]
              total_count: number
            }>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .privateRegistriesListOrgPrivateRegistries(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              privateRegistriesListOrgPrivateRegistriesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const privateRegistriesCreateOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
  })

  const privateRegistriesCreateOrgPrivateRegistryResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "201",
          s_org_private_registry_configuration_with_selected_repositories,
        ],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // privateRegistriesCreateOrgPrivateRegistry
  router.post(
    `/orgs/:org/private-registries`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            privateRegistriesCreateOrgPrivateRegistryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PrivateRegistriesCreateOrgPrivateRegistryRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_org_private_registry_configuration_with_selected_repositories>(
              201,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .privateRegistriesCreateOrgPrivateRegistry(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              privateRegistriesCreateOrgPrivateRegistryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const privateRegistriesGetOrgPublicKeyParamSchema = z.object({
    org: z.string(),
  })

  const privateRegistriesGetOrgPublicKeyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.object({key_id: z.string(), key: z.string()})],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // privateRegistriesGetOrgPublicKey
  router.get(
    `/orgs/:org/private-registries/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            privateRegistriesGetOrgPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              key: string
              key_id: string
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .privateRegistriesGetOrgPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              privateRegistriesGetOrgPublicKeyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const privateRegistriesGetOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const privateRegistriesGetOrgPrivateRegistryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_org_private_registry_configuration],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // privateRegistriesGetOrgPrivateRegistry
  router.get(
    `/orgs/:org/private-registries/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            privateRegistriesGetOrgPrivateRegistryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_private_registry_configuration>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .privateRegistriesGetOrgPrivateRegistry(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              privateRegistriesGetOrgPrivateRegistryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const privateRegistriesUpdateOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const privateRegistriesUpdateOrgPrivateRegistryResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // privateRegistriesUpdateOrgPrivateRegistry
  router.patch(
    `/orgs/:org/private-registries/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            privateRegistriesUpdateOrgPrivateRegistryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PrivateRegistriesUpdateOrgPrivateRegistryRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .privateRegistriesUpdateOrgPrivateRegistry(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              privateRegistriesUpdateOrgPrivateRegistryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const privateRegistriesDeleteOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const privateRegistriesDeleteOrgPrivateRegistryResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["400", s_scim_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // privateRegistriesDeleteOrgPrivateRegistry
  router.delete(
    `/orgs/:org/private-registries/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            privateRegistriesDeleteOrgPrivateRegistryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .privateRegistriesDeleteOrgPrivateRegistry(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              privateRegistriesDeleteOrgPrivateRegistryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicListForOrgParamSchema = z.object({org: z.string()})

  const projectsClassicListForOrgQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const projectsClassicListForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_project)],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicListForOrg
  router.get(
    `/orgs/:org/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicListForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            projectsClassicListForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicListForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicListForOrgResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicCreateForOrgParamSchema = z.object({org: z.string()})

  const projectsClassicCreateForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_project],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["410", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicCreateForOrg
  router.post(
    `/orgs/:org/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicCreateForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicCreateForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_project>(201)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicCreateForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicCreateForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetAllCustomPropertiesParamSchema = z.object({org: z.string()})

  const orgsGetAllCustomPropertiesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_custom_property)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsGetAllCustomProperties
  router.get(
    `/orgs/:org/properties/schema`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetAllCustomPropertiesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_custom_property[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetAllCustomProperties(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsGetAllCustomPropertiesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCreateOrUpdateCustomPropertiesParamSchema = z.object({
    org: z.string(),
  })

  const orgsCreateOrUpdateCustomPropertiesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_custom_property)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsCreateOrUpdateCustomProperties
  router.patch(
    `/orgs/:org/properties/schema`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCreateOrUpdateCustomPropertiesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsCreateOrUpdateCustomPropertiesRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_custom_property[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCreateOrUpdateCustomProperties(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsCreateOrUpdateCustomPropertiesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetCustomPropertyParamSchema = z.object({
    org: z.string(),
    custom_property_name: z.string(),
  })

  const orgsGetCustomPropertyResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_custom_property],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // orgsGetCustomProperty
  router.get(
    `/orgs/:org/properties/schema/:custom_property_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetCustomPropertyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_custom_property>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetCustomProperty(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsGetCustomPropertyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCreateOrUpdateCustomPropertyParamSchema = z.object({
    org: z.string(),
    custom_property_name: z.string(),
  })

  const orgsCreateOrUpdateCustomPropertyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_custom_property],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsCreateOrUpdateCustomProperty
  router.put(
    `/orgs/:org/properties/schema/:custom_property_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCreateOrUpdateCustomPropertyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_custom_property_set_payload,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_custom_property>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCreateOrUpdateCustomProperty(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsCreateOrUpdateCustomPropertyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRemoveCustomPropertyParamSchema = z.object({
    org: z.string(),
    custom_property_name: z.string(),
  })

  const orgsRemoveCustomPropertyResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsRemoveCustomProperty
  router.delete(
    `/orgs/:org/properties/schema/:custom_property_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRemoveCustomPropertyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRemoveCustomProperty(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsRemoveCustomPropertyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListCustomPropertiesValuesForReposParamSchema = z.object({
    org: z.string(),
  })

  const orgsListCustomPropertiesValuesForReposQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    repository_query: z.string().optional(),
  })

  const orgsListCustomPropertiesValuesForReposResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_org_repo_custom_property_values)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsListCustomPropertiesValuesForRepos
  router.get(
    `/orgs/:org/properties/values`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListCustomPropertiesValuesForReposParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListCustomPropertiesValuesForReposQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_org_repo_custom_property_values[]
            >(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListCustomPropertiesValuesForRepos(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListCustomPropertiesValuesForReposResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema = z.object({
    org: z.string(),
  })

  const orgsCreateOrUpdateCustomPropertiesValuesForReposResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // orgsCreateOrUpdateCustomPropertiesValuesForRepos
  router.patch(
    `/orgs/:org/properties/values`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsCreateOrUpdateCustomPropertiesValuesForReposRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCreateOrUpdateCustomPropertiesValuesForRepos(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsCreateOrUpdateCustomPropertiesValuesForReposResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListPublicMembersParamSchema = z.object({org: z.string()})

  const orgsListPublicMembersQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListPublicMembersResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_simple_user)]],
    undefined,
  )

  // orgsListPublicMembers
  router.get(
    `/orgs/:org/public_members`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListPublicMembersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListPublicMembersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListPublicMembers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListPublicMembersResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsCheckPublicMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsCheckPublicMembershipForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // orgsCheckPublicMembershipForUser
  router.get(
    `/orgs/:org/public_members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsCheckPublicMembershipForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsCheckPublicMembershipForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsCheckPublicMembershipForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsSetPublicMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsSetPublicMembershipForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // orgsSetPublicMembershipForAuthenticatedUser
  router.put(
    `/orgs/:org/public_members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsSetPublicMembershipForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsSetPublicMembershipForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsSetPublicMembershipForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRemovePublicMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsRemovePublicMembershipForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // orgsRemovePublicMembershipForAuthenticatedUser
  router.delete(
    `/orgs/:org/public_members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRemovePublicMembershipForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRemovePublicMembershipForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsRemovePublicMembershipForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListForOrgParamSchema = z.object({org: z.string()})

  const reposListForOrgQuerySchema = z.object({
    type: z
      .enum(["all", "public", "private", "forks", "sources", "member"])
      .optional()
      .default("all"),
    sort: z
      .enum(["created", "updated", "pushed", "full_name"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListForOrgResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_minimal_repository)]],
    undefined,
  )

  // reposListForOrg
  router.get(
    `/orgs/:org/repos`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListForOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateInOrgParamSchema = z.object({org: z.string()})

  const reposCreateInOrgResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_full_repository],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateInOrg
  router.post(
    `/orgs/:org/repos`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateInOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_full_repository>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateInOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetOrgRulesetsParamSchema = z.object({org: z.string()})

  const reposGetOrgRulesetsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    targets: z.string().optional(),
  })

  const reposGetOrgRulesetsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_repository_ruleset)],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetOrgRulesets
  router.get(
    `/orgs/:org/rulesets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetOrgRulesetsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetOrgRulesetsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_ruleset[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetOrgRulesets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetOrgRulesetsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateOrgRulesetParamSchema = z.object({org: z.string()})

  const reposCreateOrgRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_repository_ruleset],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposCreateOrgRuleset
  router.post(
    `/orgs/:org/rulesets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateOrgRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateOrgRulesetRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_repository_ruleset>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateOrgRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateOrgRulesetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetOrgRuleSuitesParamSchema = z.object({org: z.string()})

  const reposGetOrgRuleSuitesQuerySchema = z.object({
    ref: z.string().optional(),
    repository_name: z.string().optional(),
    time_period: z
      .enum(["hour", "day", "week", "month"])
      .optional()
      .default("day"),
    actor_name: z.string().optional(),
    rule_suite_result: z
      .enum(["pass", "fail", "bypass", "all"])
      .optional()
      .default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposGetOrgRuleSuitesResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_rule_suites],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetOrgRuleSuites
  router.get(
    `/orgs/:org/rulesets/rule-suites`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetOrgRuleSuitesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetOrgRuleSuitesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_rule_suites>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetOrgRuleSuites(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetOrgRuleSuitesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetOrgRuleSuiteParamSchema = z.object({
    org: z.string(),
    rule_suite_id: z.coerce.number(),
  })

  const reposGetOrgRuleSuiteResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_rule_suite],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetOrgRuleSuite
  router.get(
    `/orgs/:org/rulesets/rule-suites/:rule_suite_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetOrgRuleSuiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_rule_suite>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetOrgRuleSuite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetOrgRuleSuiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetOrgRulesetParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposGetOrgRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_repository_ruleset],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetOrgRuleset
  router.get(
    `/orgs/:org/rulesets/:ruleset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetOrgRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_ruleset>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetOrgRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetOrgRulesetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateOrgRulesetParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposUpdateOrgRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_repository_ruleset],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposUpdateOrgRuleset
  router.put(
    `/orgs/:org/rulesets/:ruleset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateOrgRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateOrgRulesetRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_ruleset>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateOrgRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposUpdateOrgRulesetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteOrgRulesetParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposDeleteOrgRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposDeleteOrgRuleset
  router.delete(
    `/orgs/:org/rulesets/:ruleset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteOrgRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteOrgRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteOrgRulesetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetOrgRulesetHistoryParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const orgsGetOrgRulesetHistoryQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsGetOrgRulesetHistoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_ruleset_version)],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // orgsGetOrgRulesetHistory
  router.get(
    `/orgs/:org/rulesets/:ruleset_id/history`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetOrgRulesetHistoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsGetOrgRulesetHistoryQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ruleset_version[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetOrgRulesetHistory(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsGetOrgRulesetHistoryResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetOrgRulesetVersionParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
    version_id: z.coerce.number(),
  })

  const orgsGetOrgRulesetVersionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_ruleset_version_with_state],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // orgsGetOrgRulesetVersion
  router.get(
    `/orgs/:org/rulesets/:ruleset_id/history/:version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetOrgRulesetVersionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ruleset_version_with_state>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetOrgRulesetVersion(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, orgsGetOrgRulesetVersionResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningListAlertsForOrgParamSchema = z.object({org: z.string()})

  const secretScanningListAlertsForOrgQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.string().optional(),
    resolution: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    validity: z.string().optional(),
    is_publicly_leaked: PermissiveBoolean.optional().default(false),
    is_multi_repo: PermissiveBoolean.optional().default(false),
    hide_secret: PermissiveBoolean.optional().default(false),
  })

  const secretScanningListAlertsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_organization_secret_scanning_alert)],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // secretScanningListAlertsForOrg
  router.get(
    `/orgs/:org/secret-scanning/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningListAlertsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            secretScanningListAlertsForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_organization_secret_scanning_alert[]
            >(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningListAlertsForOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              secretScanningListAlertsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesListOrgRepositoryAdvisoriesParamSchema = z.object({
    org: z.string(),
  })

  const securityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .enum(["created", "updated", "published"])
      .optional()
      .default("created"),
    before: z.string().optional(),
    after: z.string().optional(),
    per_page: z.coerce.number().min(1).max(100).optional().default(30),
    state: z.enum(["triage", "draft", "published", "closed"]).optional(),
  })

  const securityAdvisoriesListOrgRepositoryAdvisoriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_repository_advisory)],
        ["400", s_scim_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // securityAdvisoriesListOrgRepositoryAdvisories
  router.get(
    `/orgs/:org/security-advisories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesListOrgRepositoryAdvisoriesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            securityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_advisory[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesListOrgRepositoryAdvisories(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesListOrgRepositoryAdvisoriesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListSecurityManagerTeamsParamSchema = z.object({org: z.string()})

  const orgsListSecurityManagerTeamsResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_team_simple)]], undefined)

  // orgsListSecurityManagerTeams
  router.get(
    `/orgs/:org/security-managers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListSecurityManagerTeamsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_simple[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListSecurityManagerTeams(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListSecurityManagerTeamsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsAddSecurityManagerTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const orgsAddSecurityManagerTeamResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // orgsAddSecurityManagerTeam
  router.put(
    `/orgs/:org/security-managers/teams/:team_slug`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsAddSecurityManagerTeamParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsAddSecurityManagerTeam(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsAddSecurityManagerTeamResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsRemoveSecurityManagerTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const orgsRemoveSecurityManagerTeamResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // orgsRemoveSecurityManagerTeam
  router.delete(
    `/orgs/:org/security-managers/teams/:team_slug`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsRemoveSecurityManagerTeamParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsRemoveSecurityManagerTeam(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsRemoveSecurityManagerTeamResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetGithubActionsBillingOrgParamSchema = z.object({
    org: z.string(),
  })

  const billingGetGithubActionsBillingOrgResponseBodyValidator =
    responseValidationFactory([["200", s_actions_billing_usage]], undefined)

  // billingGetGithubActionsBillingOrg
  router.get(
    `/orgs/:org/settings/billing/actions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetGithubActionsBillingOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_billing_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetGithubActionsBillingOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetGithubActionsBillingOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetGithubPackagesBillingOrgParamSchema = z.object({
    org: z.string(),
  })

  const billingGetGithubPackagesBillingOrgResponseBodyValidator =
    responseValidationFactory([["200", s_packages_billing_usage]], undefined)

  // billingGetGithubPackagesBillingOrg
  router.get(
    `/orgs/:org/settings/billing/packages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetGithubPackagesBillingOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_packages_billing_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetGithubPackagesBillingOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetGithubPackagesBillingOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetSharedStorageBillingOrgParamSchema = z.object({
    org: z.string(),
  })

  const billingGetSharedStorageBillingOrgResponseBodyValidator =
    responseValidationFactory([["200", s_combined_billing_usage]], undefined)

  // billingGetSharedStorageBillingOrg
  router.get(
    `/orgs/:org/settings/billing/shared-storage`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetSharedStorageBillingOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_combined_billing_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetSharedStorageBillingOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetSharedStorageBillingOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const hostedComputeListNetworkConfigurationsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const hostedComputeListNetworkConfigurationsForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const hostedComputeListNetworkConfigurationsForOrgResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            network_configurations: z.array(s_network_configuration),
          }),
        ],
      ],
      undefined,
    )

  // hostedComputeListNetworkConfigurationsForOrg
  router.get(
    `/orgs/:org/settings/network-configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            hostedComputeListNetworkConfigurationsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            hostedComputeListNetworkConfigurationsForOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              network_configurations: t_network_configuration[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .hostedComputeListNetworkConfigurationsForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              hostedComputeListNetworkConfigurationsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const hostedComputeCreateNetworkConfigurationForOrgParamSchema = z.object({
    org: z.string(),
  })

  const hostedComputeCreateNetworkConfigurationForOrgResponseBodyValidator =
    responseValidationFactory([["201", s_network_configuration]], undefined)

  // hostedComputeCreateNetworkConfigurationForOrg
  router.post(
    `/orgs/:org/settings/network-configurations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            hostedComputeCreateNetworkConfigurationForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_HostedComputeCreateNetworkConfigurationForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_network_configuration>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .hostedComputeCreateNetworkConfigurationForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              hostedComputeCreateNetworkConfigurationForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const hostedComputeGetNetworkConfigurationForOrgParamSchema = z.object({
    org: z.string(),
    network_configuration_id: z.string(),
  })

  const hostedComputeGetNetworkConfigurationForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_network_configuration]], undefined)

  // hostedComputeGetNetworkConfigurationForOrg
  router.get(
    `/orgs/:org/settings/network-configurations/:network_configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            hostedComputeGetNetworkConfigurationForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_network_configuration>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .hostedComputeGetNetworkConfigurationForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              hostedComputeGetNetworkConfigurationForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const hostedComputeUpdateNetworkConfigurationForOrgParamSchema = z.object({
    org: z.string(),
    network_configuration_id: z.string(),
  })

  const hostedComputeUpdateNetworkConfigurationForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_network_configuration]], undefined)

  // hostedComputeUpdateNetworkConfigurationForOrg
  router.patch(
    `/orgs/:org/settings/network-configurations/:network_configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            hostedComputeUpdateNetworkConfigurationForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_HostedComputeUpdateNetworkConfigurationForOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_network_configuration>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .hostedComputeUpdateNetworkConfigurationForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              hostedComputeUpdateNetworkConfigurationForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const hostedComputeDeleteNetworkConfigurationFromOrgParamSchema = z.object({
    org: z.string(),
    network_configuration_id: z.string(),
  })

  const hostedComputeDeleteNetworkConfigurationFromOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // hostedComputeDeleteNetworkConfigurationFromOrg
  router.delete(
    `/orgs/:org/settings/network-configurations/:network_configuration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            hostedComputeDeleteNetworkConfigurationFromOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .hostedComputeDeleteNetworkConfigurationFromOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              hostedComputeDeleteNetworkConfigurationFromOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const hostedComputeGetNetworkSettingsForOrgParamSchema = z.object({
    org: z.string(),
    network_settings_id: z.string(),
  })

  const hostedComputeGetNetworkSettingsForOrgResponseBodyValidator =
    responseValidationFactory([["200", s_network_settings]], undefined)

  // hostedComputeGetNetworkSettingsForOrg
  router.get(
    `/orgs/:org/settings/network-settings/:network_settings_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            hostedComputeGetNetworkSettingsForOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_network_settings>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .hostedComputeGetNetworkSettingsForOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              hostedComputeGetNetworkSettingsForOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const copilotCopilotMetricsForTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const copilotCopilotMetricsForTeamQuerySchema = z.object({
    since: z.string().optional(),
    until: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(28),
  })

  const copilotCopilotMetricsForTeamResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_copilot_usage_metrics_day)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // copilotCopilotMetricsForTeam
  router.get(
    `/orgs/:org/team/:team_slug/copilot/metrics`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            copilotCopilotMetricsForTeamParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            copilotCopilotMetricsForTeamQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_copilot_usage_metrics_day[]>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .copilotCopilotMetricsForTeam(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              copilotCopilotMetricsForTeamResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListParamSchema = z.object({org: z.string()})

  const teamsListQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_team)],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // teamsList
  router.get(
    `/orgs/:org/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsList(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsListResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCreateParamSchema = z.object({org: z.string()})

  const teamsCreateResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_team_full],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // teamsCreate
  router.post(
    `/orgs/:org/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCreateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsCreateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_team_full>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCreate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsCreateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetByNameParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsGetByNameResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_team_full],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // teamsGetByName
  router.get(
    `/orgs/:org/teams/:team_slug`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetByNameParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_full>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetByName(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsGetByNameResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsUpdateInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsUpdateInOrgResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_team_full],
      ["201", s_team_full],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // teamsUpdateInOrg
  router.patch(
    `/orgs/:org/teams/:team_slug`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsUpdateInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsUpdateInOrgRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_full>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_team_full>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsUpdateInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsUpdateInOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsDeleteInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsDeleteInOrgResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // teamsDeleteInOrg
  router.delete(
    `/orgs/:org/teams/:team_slug`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsDeleteInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsDeleteInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsDeleteInOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListDiscussionsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListDiscussionsInOrgQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    pinned: z.string().optional(),
  })

  const teamsListDiscussionsInOrgResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_team_discussion)]], undefined)

  // teamsListDiscussionsInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/discussions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListDiscussionsInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListDiscussionsInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListDiscussionsInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsListDiscussionsInOrgResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCreateDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsCreateDiscussionInOrgResponseBodyValidator =
    responseValidationFactory([["201", s_team_discussion]], undefined)

  // teamsCreateDiscussionInOrg
  router.post(
    `/orgs/:org/teams/:team_slug/discussions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCreateDiscussionInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsCreateDiscussionInOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_team_discussion>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCreateDiscussionInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCreateDiscussionInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsGetDiscussionInOrgResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion]], undefined)

  // teamsGetDiscussionInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetDiscussionInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetDiscussionInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsGetDiscussionInOrgResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsUpdateDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionInOrgResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion]], undefined)

  // teamsUpdateDiscussionInOrg
  router.patch(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsUpdateDiscussionInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsUpdateDiscussionInOrgRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsUpdateDiscussionInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsUpdateDiscussionInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsDeleteDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsDeleteDiscussionInOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // teamsDeleteDiscussionInOrg
  router.delete(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsDeleteDiscussionInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsDeleteDiscussionInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsDeleteDiscussionInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListDiscussionCommentsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsListDiscussionCommentsInOrgQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListDiscussionCommentsInOrgResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_team_discussion_comment)]],
      undefined,
    )

  // teamsListDiscussionCommentsInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListDiscussionCommentsInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListDiscussionCommentsInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion_comment[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListDiscussionCommentsInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsListDiscussionCommentsInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCreateDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsCreateDiscussionCommentInOrgResponseBodyValidator =
    responseValidationFactory([["201", s_team_discussion_comment]], undefined)

  // teamsCreateDiscussionCommentInOrg
  router.post(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCreateDiscussionCommentInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsCreateDiscussionCommentInOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_team_discussion_comment>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCreateDiscussionCommentInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCreateDiscussionCommentInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsGetDiscussionCommentInOrgResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion_comment]], undefined)

  // teamsGetDiscussionCommentInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetDiscussionCommentInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion_comment>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetDiscussionCommentInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsGetDiscussionCommentInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsUpdateDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionCommentInOrgResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion_comment]], undefined)

  // teamsUpdateDiscussionCommentInOrg
  router.patch(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsUpdateDiscussionCommentInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsUpdateDiscussionCommentInOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion_comment>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsUpdateDiscussionCommentInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsUpdateDiscussionCommentInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsDeleteDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsDeleteDiscussionCommentInOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // teamsDeleteDiscussionCommentInOrg
  router.delete(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsDeleteDiscussionCommentInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsDeleteDiscussionCommentInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsDeleteDiscussionCommentInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForTeamDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionCommentInOrgQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForTeamDiscussionCommentInOrgResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_reaction)]], undefined)

  // reactionsListForTeamDiscussionCommentInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForTeamDiscussionCommentInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForTeamDiscussionCommentInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForTeamDiscussionCommentInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsListForTeamDiscussionCommentInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForTeamDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionCommentInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_reaction],
        ["201", s_reaction],
      ],
      undefined,
    )

  // reactionsCreateForTeamDiscussionCommentInOrg
  router.post(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForTeamDiscussionCommentInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForTeamDiscussionCommentInOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForTeamDiscussionCommentInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsCreateForTeamDiscussionCommentInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsDeleteForTeamDiscussionCommentParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  const reactionsDeleteForTeamDiscussionCommentResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reactionsDeleteForTeamDiscussionComment
  router.delete(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsDeleteForTeamDiscussionCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsDeleteForTeamDiscussionComment(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsDeleteForTeamDiscussionCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForTeamDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionInOrgQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForTeamDiscussionInOrgResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_reaction)]], undefined)

  // reactionsListForTeamDiscussionInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForTeamDiscussionInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForTeamDiscussionInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForTeamDiscussionInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsListForTeamDiscussionInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForTeamDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_reaction],
        ["201", s_reaction],
      ],
      undefined,
    )

  // reactionsCreateForTeamDiscussionInOrg
  router.post(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForTeamDiscussionInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForTeamDiscussionInOrgRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForTeamDiscussionInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsCreateForTeamDiscussionInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsDeleteForTeamDiscussionParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  const reactionsDeleteForTeamDiscussionResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reactionsDeleteForTeamDiscussion
  router.delete(
    `/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions/:reaction_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsDeleteForTeamDiscussionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsDeleteForTeamDiscussion(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsDeleteForTeamDiscussionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListPendingInvitationsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListPendingInvitationsInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListPendingInvitationsInOrgResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_organization_invitation)]],
      undefined,
    )

  // teamsListPendingInvitationsInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/invitations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListPendingInvitationsInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListPendingInvitationsInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_invitation[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListPendingInvitationsInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsListPendingInvitationsInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListMembersInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListMembersInOrgQuerySchema = z.object({
    role: z.enum(["member", "maintainer", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListMembersInOrgResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_simple_user)]],
    undefined,
  )

  // teamsListMembersInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/members`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListMembersInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListMembersInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListMembersInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsListMembersInOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetMembershipForUserInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    username: z.string(),
  })

  const teamsGetMembershipForUserInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_membership],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // teamsGetMembershipForUserInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetMembershipForUserInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_membership>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetMembershipForUserInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsGetMembershipForUserInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsAddOrUpdateMembershipForUserInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    username: z.string(),
  })

  const teamsAddOrUpdateMembershipForUserInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_membership],
        ["403", z.undefined()],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // teamsAddOrUpdateMembershipForUserInOrg
  router.put(
    `/orgs/:org/teams/:team_slug/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsAddOrUpdateMembershipForUserInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsAddOrUpdateMembershipForUserInOrgRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_membership>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsAddOrUpdateMembershipForUserInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsAddOrUpdateMembershipForUserInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsRemoveMembershipForUserInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    username: z.string(),
  })

  const teamsRemoveMembershipForUserInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", z.undefined()],
      ],
      undefined,
    )

  // teamsRemoveMembershipForUserInOrg
  router.delete(
    `/orgs/:org/teams/:team_slug/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsRemoveMembershipForUserInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsRemoveMembershipForUserInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsRemoveMembershipForUserInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListProjectsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListProjectsInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListProjectsInOrgResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_team_project)]],
    undefined,
  )

  // teamsListProjectsInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListProjectsInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListProjectsInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_project[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListProjectsInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsListProjectsInOrgResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCheckPermissionsForProjectInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    project_id: z.coerce.number(),
  })

  const teamsCheckPermissionsForProjectInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_project],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // teamsCheckPermissionsForProjectInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCheckPermissionsForProjectInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_project>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCheckPermissionsForProjectInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCheckPermissionsForProjectInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsAddOrUpdateProjectPermissionsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    project_id: z.coerce.number(),
  })

  const teamsAddOrUpdateProjectPermissionsInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        [
          "403",
          z.object({
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // teamsAddOrUpdateProjectPermissionsInOrg
  router.put(
    `/orgs/:org/teams/:team_slug/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsAddOrUpdateProjectPermissionsInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsAddOrUpdateProjectPermissionsInOrgRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              message?: string | undefined
            }>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsAddOrUpdateProjectPermissionsInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsAddOrUpdateProjectPermissionsInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsRemoveProjectInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    project_id: z.coerce.number(),
  })

  const teamsRemoveProjectInOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // teamsRemoveProjectInOrg
  router.delete(
    `/orgs/:org/teams/:team_slug/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsRemoveProjectInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsRemoveProjectInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsRemoveProjectInOrgResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListReposInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListReposInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListReposInOrgResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_minimal_repository)]],
    undefined,
  )

  // teamsListReposInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/repos`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListReposInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListReposInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListReposInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsListReposInOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCheckPermissionsForRepoInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsCheckPermissionsForRepoInOrgResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_repository],
        ["204", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // teamsCheckPermissionsForRepoInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCheckPermissionsForRepoInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_repository>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCheckPermissionsForRepoInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCheckPermissionsForRepoInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsAddOrUpdateRepoPermissionsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsAddOrUpdateRepoPermissionsInOrgResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // teamsAddOrUpdateRepoPermissionsInOrg
  router.put(
    `/orgs/:org/teams/:team_slug/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsAddOrUpdateRepoPermissionsInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsAddOrUpdateRepoPermissionsInOrgRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsAddOrUpdateRepoPermissionsInOrg(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsAddOrUpdateRepoPermissionsInOrgResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsRemoveRepoInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsRemoveRepoInOrgResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // teamsRemoveRepoInOrg
  router.delete(
    `/orgs/:org/teams/:team_slug/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsRemoveRepoInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsRemoveRepoInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsRemoveRepoInOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListChildInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListChildInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListChildInOrgResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_team)]],
    undefined,
  )

  // teamsListChildInOrg
  router.get(
    `/orgs/:org/teams/:team_slug/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListChildInOrgParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListChildInOrgQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListChildInOrg(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsListChildInOrgResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema = z.object({
    org: z.string(),
    security_product: z.enum([
      "dependency_graph",
      "dependabot_alerts",
      "dependabot_security_updates",
      "advanced_security",
      "code_scanning_default_setup",
      "secret_scanning",
      "secret_scanning_push_protection",
    ]),
    enablement: z.enum(["enable_all", "disable_all"]),
  })

  const orgsEnableOrDisableSecurityProductOnAllOrgReposResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // orgsEnableOrDisableSecurityProductOnAllOrgRepos
  router.post(
    `/orgs/:org/:security_product/:enablement`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsEnableOrDisableSecurityProductOnAllOrgRepos(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsEnableOrDisableSecurityProductOnAllOrgReposResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicGetCardParamSchema = z.object({
    card_id: z.coerce.number(),
  })

  const projectsClassicGetCardResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_project_card],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // projectsClassicGetCard
  router.get(
    `/projects/columns/cards/:card_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicGetCardParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project_card>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicGetCard(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicGetCardResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicUpdateCardParamSchema = z.object({
    card_id: z.coerce.number(),
  })

  const projectsClassicUpdateCardResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_project_card],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicUpdateCard
  router.patch(
    `/projects/columns/cards/:card_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicUpdateCardParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicUpdateCardRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project_card>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicUpdateCard(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicUpdateCardResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicDeleteCardParamSchema = z.object({
    card_id: z.coerce.number(),
  })

  const projectsClassicDeleteCardResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        [
          "403",
          z.object({
            message: z.string().optional(),
            documentation_url: z.string().optional(),
            errors: z.array(z.string()).optional(),
          }),
        ],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // projectsClassicDeleteCard
  router.delete(
    `/projects/columns/cards/:card_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicDeleteCardParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              errors?: string[] | undefined
              message?: string | undefined
            }>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicDeleteCard(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicDeleteCardResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicMoveCardParamSchema = z.object({
    card_id: z.coerce.number(),
  })

  const projectsClassicMoveCardResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.object({})],
        ["304", z.undefined()],
        ["401", s_basic_error],
        [
          "403",
          z.object({
            message: z.string().optional(),
            documentation_url: z.string().optional(),
            errors: z
              .array(
                z.object({
                  code: z.string().optional(),
                  message: z.string().optional(),
                  resource: z.string().optional(),
                  field: z.string().optional(),
                }),
              )
              .optional(),
          }),
        ],
        ["422", s_validation_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
            errors: z
              .array(
                z.object({
                  code: z.string().optional(),
                  message: z.string().optional(),
                }),
              )
              .optional(),
          }),
        ],
      ],
      undefined,
    )

  // projectsClassicMoveCard
  router.post(
    `/projects/columns/cards/:card_id/moves`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicMoveCardParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicMoveCardRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<EmptyObject>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              errors?:
                | {
                    code?: string | undefined
                    field?: string | undefined
                    message?: string | undefined
                    resource?: string | undefined
                  }[]
                | undefined
              message?: string | undefined
            }>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              errors?:
                | {
                    code?: string | undefined
                    message?: string | undefined
                  }[]
                | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicMoveCard(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicMoveCardResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicGetColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsClassicGetColumnResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_project_column],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // projectsClassicGetColumn
  router.get(
    `/projects/columns/:column_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicGetColumnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project_column>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicGetColumn(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicGetColumnResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicUpdateColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsClassicUpdateColumnResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_project_column],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // projectsClassicUpdateColumn
  router.patch(
    `/projects/columns/:column_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicUpdateColumnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicUpdateColumnRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project_column>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicUpdateColumn(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicUpdateColumnResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicDeleteColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsClassicDeleteColumnResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // projectsClassicDeleteColumn
  router.delete(
    `/projects/columns/:column_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicDeleteColumnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicDeleteColumn(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicDeleteColumnResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicListCardsParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsClassicListCardsQuerySchema = z.object({
    archived_state: z
      .enum(["all", "archived", "not_archived"])
      .optional()
      .default("not_archived"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const projectsClassicListCardsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_project_card)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // projectsClassicListCards
  router.get(
    `/projects/columns/:column_id/cards`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicListCardsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            projectsClassicListCardsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project_card[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicListCards(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicListCardsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicCreateCardParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsClassicCreateCardResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_project_card],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", z.union([s_validation_error, s_validation_error_simple])],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
            errors: z
              .array(
                z.object({
                  code: z.string().optional(),
                  message: z.string().optional(),
                }),
              )
              .optional(),
          }),
        ],
      ],
      undefined,
    )

  // projectsClassicCreateCard
  router.post(
    `/projects/columns/:column_id/cards`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicCreateCardParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicCreateCardRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_project_card>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<
              t_validation_error | t_validation_error_simple
            >(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              errors?:
                | {
                    code?: string | undefined
                    message?: string | undefined
                  }[]
                | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicCreateCard(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicCreateCardResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicMoveColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsClassicMoveColumnResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.object({})],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicMoveColumn
  router.post(
    `/projects/columns/:column_id/moves`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicMoveColumnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicMoveColumnRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<EmptyObject>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicMoveColumn(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, projectsClassicMoveColumnResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicGetParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsClassicGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_project],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // projectsClassicGet
  router.get(
    `/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, projectsClassicGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicUpdateParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsClassicUpdateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_project],
      ["304", z.undefined()],
      ["401", s_basic_error],
      [
        "403",
        z.object({
          message: z.string().optional(),
          documentation_url: z.string().optional(),
          errors: z.array(z.string()).optional(),
        }),
      ],
      ["404", z.undefined()],
      ["410", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // projectsClassicUpdate
  router.patch(
    `/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicUpdateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicUpdateRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              errors?: string[] | undefined
              message?: string | undefined
            }>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicUpdate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, projectsClassicUpdateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicDeleteParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsClassicDeleteResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["401", s_basic_error],
      [
        "403",
        z.object({
          message: z.string().optional(),
          documentation_url: z.string().optional(),
          errors: z.array(z.string()).optional(),
        }),
      ],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // projectsClassicDelete
  router.delete(
    `/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicDeleteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              errors?: string[] | undefined
              message?: string | undefined
            }>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicDelete(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, projectsClassicDeleteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicListCollaboratorsParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsClassicListCollaboratorsQuerySchema = z.object({
    affiliation: z.enum(["outside", "direct", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const projectsClassicListCollaboratorsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // projectsClassicListCollaborators
  router.get(
    `/projects/:project_id/collaborators`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicListCollaboratorsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            projectsClassicListCollaboratorsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicListCollaborators(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicListCollaboratorsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicAddCollaboratorParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.string(),
  })

  const projectsClassicAddCollaboratorResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // projectsClassicAddCollaborator
  router.put(
    `/projects/:project_id/collaborators/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicAddCollaboratorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicAddCollaboratorRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicAddCollaborator(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicAddCollaboratorResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicRemoveCollaboratorParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.string(),
  })

  const projectsClassicRemoveCollaboratorResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // projectsClassicRemoveCollaborator
  router.delete(
    `/projects/:project_id/collaborators/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicRemoveCollaboratorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicRemoveCollaborator(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicRemoveCollaboratorResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicGetPermissionForUserParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.string(),
  })

  const projectsClassicGetPermissionForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_project_collaborator_permission],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // projectsClassicGetPermissionForUser
  router.get(
    `/projects/:project_id/collaborators/:username/permission`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicGetPermissionForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project_collaborator_permission>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicGetPermissionForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicGetPermissionForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicListColumnsParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsClassicListColumnsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const projectsClassicListColumnsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_project_column)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // projectsClassicListColumns
  router.get(
    `/projects/:project_id/columns`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicListColumnsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            projectsClassicListColumnsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project_column[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicListColumns(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicListColumnsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicCreateColumnParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsClassicCreateColumnResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_project_column],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicCreateColumn
  router.post(
    `/projects/:project_id/columns`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicCreateColumnParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicCreateColumnRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_project_column>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicCreateColumn(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicCreateColumnResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const rateLimitGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_rate_limit_overview],
      ["304", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // rateLimitGet
  router.get(
    `/rate_limit`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_rate_limit_overview>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .rateLimitGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, rateLimitGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetParamSchema = z.object({owner: z.string(), repo: z.string()})

  const reposGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_full_repository],
      ["301", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGet
  router.get(
    `/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_full_repository>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateParamSchema = z.object({owner: z.string(), repo: z.string()})

  const reposUpdateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_full_repository],
      ["307", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposUpdate
  router.patch(
    `/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_full_repository>(200)
          },
          with307() {
            return new ExpressRuntimeResponse<t_basic_error>(307)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposUpdateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteParamSchema = z.object({owner: z.string(), repo: z.string()})

  const reposDeleteResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["307", s_basic_error],
      [
        "403",
        z.object({
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
      ["404", s_basic_error],
      ["409", s_basic_error],
    ],
    undefined,
  )

  // reposDelete
  router.delete(
    `/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with307() {
            return new ExpressRuntimeResponse<t_basic_error>(307)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              message?: string | undefined
            }>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDelete(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListArtifactsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListArtifactsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    name: z.string().optional(),
  })

  const actionsListArtifactsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            artifacts: z.array(s_artifact),
          }),
        ],
      ],
      undefined,
    )

  // actionsListArtifactsForRepo
  router.get(
    `/repos/:owner/:repo/actions/artifacts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListArtifactsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListArtifactsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              artifacts: t_artifact[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListArtifactsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListArtifactsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetArtifactParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    artifact_id: z.coerce.number(),
  })

  const actionsGetArtifactResponseBodyValidator = responseValidationFactory(
    [["200", s_artifact]],
    undefined,
  )

  // actionsGetArtifact
  router.get(
    `/repos/:owner/:repo/actions/artifacts/:artifact_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetArtifactParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_artifact>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetArtifact(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsGetArtifactResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteArtifactParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    artifact_id: z.coerce.number(),
  })

  const actionsDeleteArtifactResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // actionsDeleteArtifact
  router.delete(
    `/repos/:owner/:repo/actions/artifacts/:artifact_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteArtifactParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteArtifact(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsDeleteArtifactResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDownloadArtifactParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    artifact_id: z.coerce.number(),
    archive_format: z.string(),
  })

  const actionsDownloadArtifactResponseBodyValidator =
    responseValidationFactory(
      [
        ["302", z.undefined()],
        ["410", s_basic_error],
      ],
      undefined,
    )

  // actionsDownloadArtifact
  router.get(
    `/repos/:owner/:repo/actions/artifacts/:artifact_id/:archive_format`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDownloadArtifactParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDownloadArtifact(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsDownloadArtifactResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetActionsCacheUsageParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetActionsCacheUsageResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_cache_usage_by_repository]],
      undefined,
    )

  // actionsGetActionsCacheUsage
  router.get(
    `/repos/:owner/:repo/actions/cache/usage`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetActionsCacheUsageParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_cache_usage_by_repository>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetActionsCacheUsage(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetActionsCacheUsageResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetActionsCacheListParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetActionsCacheListQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    ref: z.string().optional(),
    key: z.string().optional(),
    sort: z
      .enum(["created_at", "last_accessed_at", "size_in_bytes"])
      .optional()
      .default("last_accessed_at"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
  })

  const actionsGetActionsCacheListResponseBodyValidator =
    responseValidationFactory([["200", s_actions_cache_list]], undefined)

  // actionsGetActionsCacheList
  router.get(
    `/repos/:owner/:repo/actions/caches`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetActionsCacheListParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsGetActionsCacheListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_cache_list>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetActionsCacheList(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetActionsCacheListResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteActionsCacheByKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsDeleteActionsCacheByKeyQuerySchema = z.object({
    key: z.string(),
    ref: z.string().optional(),
  })

  const actionsDeleteActionsCacheByKeyResponseBodyValidator =
    responseValidationFactory([["200", s_actions_cache_list]], undefined)

  // actionsDeleteActionsCacheByKey
  router.delete(
    `/repos/:owner/:repo/actions/caches`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteActionsCacheByKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsDeleteActionsCacheByKeyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_cache_list>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteActionsCacheByKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteActionsCacheByKeyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteActionsCacheByIdParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    cache_id: z.coerce.number(),
  })

  const actionsDeleteActionsCacheByIdResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteActionsCacheById
  router.delete(
    `/repos/:owner/:repo/actions/caches/:cache_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteActionsCacheByIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteActionsCacheById(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteActionsCacheByIdResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetJobForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    job_id: z.coerce.number(),
  })

  const actionsGetJobForWorkflowRunResponseBodyValidator =
    responseValidationFactory([["200", s_job]], undefined)

  // actionsGetJobForWorkflowRun
  router.get(
    `/repos/:owner/:repo/actions/jobs/:job_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetJobForWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_job>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetJobForWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetJobForWorkflowRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDownloadJobLogsForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    job_id: z.coerce.number(),
  })

  const actionsDownloadJobLogsForWorkflowRunResponseBodyValidator =
    responseValidationFactory([["302", z.undefined()]], undefined)

  // actionsDownloadJobLogsForWorkflowRun
  router.get(
    `/repos/:owner/:repo/actions/jobs/:job_id/logs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDownloadJobLogsForWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDownloadJobLogsForWorkflowRun(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDownloadJobLogsForWorkflowRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsReRunJobForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    job_id: z.coerce.number(),
  })

  const actionsReRunJobForWorkflowRunResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // actionsReRunJobForWorkflowRun
  router.post(
    `/repos/:owner/:repo/actions/jobs/:job_id/rerun`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsReRunJobForWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsReRunJobForWorkflowRunRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsReRunJobForWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsReRunJobForWorkflowRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetCustomOidcSubClaimForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetCustomOidcSubClaimForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_oidc_custom_sub_repo],
        ["400", s_scim_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // actionsGetCustomOidcSubClaimForRepo
  router.get(
    `/repos/:owner/:repo/actions/oidc/customization/sub`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetCustomOidcSubClaimForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_oidc_custom_sub_repo>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetCustomOidcSubClaimForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetCustomOidcSubClaimForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetCustomOidcSubClaimForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetCustomOidcSubClaimForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["400", s_scim_error],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsSetCustomOidcSubClaimForRepo
  router.put(
    `/repos/:owner/:repo/actions/oidc/customization/sub`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetCustomOidcSubClaimForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetCustomOidcSubClaimForRepoRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetCustomOidcSubClaimForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetCustomOidcSubClaimForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRepoOrganizationSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoOrganizationSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListRepoOrganizationSecretsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            secrets: z.array(s_actions_secret),
          }),
        ],
      ],
      undefined,
    )

  // actionsListRepoOrganizationSecrets
  router.get(
    `/repos/:owner/:repo/actions/organization-secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRepoOrganizationSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListRepoOrganizationSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_actions_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRepoOrganizationSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListRepoOrganizationSecretsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRepoOrganizationVariablesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoOrganizationVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListRepoOrganizationVariablesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            variables: z.array(s_actions_variable),
          }),
        ],
      ],
      undefined,
    )

  // actionsListRepoOrganizationVariables
  router.get(
    `/repos/:owner/:repo/actions/organization-variables`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRepoOrganizationVariablesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListRepoOrganizationVariablesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              total_count: number
              variables: t_actions_variable[]
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRepoOrganizationVariables(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListRepoOrganizationVariablesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetGithubActionsPermissionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetGithubActionsPermissionsRepositoryResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_repository_permissions]],
      undefined,
    )

  // actionsGetGithubActionsPermissionsRepository
  router.get(
    `/repos/:owner/:repo/actions/permissions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetGithubActionsPermissionsRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_repository_permissions>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetGithubActionsPermissionsRepository(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetGithubActionsPermissionsRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetGithubActionsPermissionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetGithubActionsPermissionsRepositoryResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetGithubActionsPermissionsRepository
  router.put(
    `/repos/:owner/:repo/actions/permissions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetGithubActionsPermissionsRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetGithubActionsPermissionsRepositoryRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetGithubActionsPermissionsRepository(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetGithubActionsPermissionsRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetWorkflowAccessToRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetWorkflowAccessToRepositoryResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_workflow_access_to_repository]],
      undefined,
    )

  // actionsGetWorkflowAccessToRepository
  router.get(
    `/repos/:owner/:repo/actions/permissions/access`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetWorkflowAccessToRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_workflow_access_to_repository>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetWorkflowAccessToRepository(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetWorkflowAccessToRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetWorkflowAccessToRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetWorkflowAccessToRepositoryResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetWorkflowAccessToRepository
  router.put(
    `/repos/:owner/:repo/actions/permissions/access`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetWorkflowAccessToRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_actions_workflow_access_to_repository,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetWorkflowAccessToRepository(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetWorkflowAccessToRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetAllowedActionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetAllowedActionsRepositoryResponseBodyValidator =
    responseValidationFactory([["200", s_selected_actions]], undefined)

  // actionsGetAllowedActionsRepository
  router.get(
    `/repos/:owner/:repo/actions/permissions/selected-actions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetAllowedActionsRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_selected_actions>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetAllowedActionsRepository(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetAllowedActionsRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetAllowedActionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetAllowedActionsRepositoryResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsSetAllowedActionsRepository
  router.put(
    `/repos/:owner/:repo/actions/permissions/selected-actions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetAllowedActionsRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_selected_actions.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetAllowedActionsRepository(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetAllowedActionsRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema =
    z.object({owner: z.string(), repo: z.string()})

  const actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponseBodyValidator =
    responseValidationFactory(
      [["200", s_actions_get_default_workflow_permissions]],
      undefined,
    )

  // actionsGetGithubActionsDefaultWorkflowPermissionsRepository
  router.get(
    `/repos/:owner/:repo/actions/permissions/workflow`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_get_default_workflow_permissions>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema =
    z.object({owner: z.string(), repo: z.string()})

  const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // actionsSetGithubActionsDefaultWorkflowPermissionsRepository
  router.put(
    `/repos/:owner/:repo/actions/permissions/workflow`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_actions_set_default_workflow_permissions,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListSelfHostedRunnersForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListSelfHostedRunnersForRepoQuerySchema = z.object({
    name: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListSelfHostedRunnersForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            runners: z.array(s_runner),
          }),
        ],
      ],
      undefined,
    )

  // actionsListSelfHostedRunnersForRepo
  router.get(
    `/repos/:owner/:repo/actions/runners`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListSelfHostedRunnersForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListSelfHostedRunnersForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              runners: t_runner[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListSelfHostedRunnersForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListSelfHostedRunnersForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRunnerApplicationsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRunnerApplicationsForRepoResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_runner_application)]],
      undefined,
    )

  // actionsListRunnerApplicationsForRepo
  router.get(
    `/repos/:owner/:repo/actions/runners/downloads`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRunnerApplicationsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_runner_application[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRunnerApplicationsForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListRunnerApplicationsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGenerateRunnerJitconfigForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGenerateRunnerJitconfigForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.object({runner: s_runner, encoded_jit_config: z.string()})],
        ["404", s_basic_error],
        ["409", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsGenerateRunnerJitconfigForRepo
  router.post(
    `/repos/:owner/:repo/actions/runners/generate-jitconfig`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGenerateRunnerJitconfigForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsGenerateRunnerJitconfigForRepoRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<{
              encoded_jit_config: string
              runner: t_runner
            }>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGenerateRunnerJitconfigForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGenerateRunnerJitconfigForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateRegistrationTokenForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsCreateRegistrationTokenForRepoResponseBodyValidator =
    responseValidationFactory([["201", s_authentication_token]], undefined)

  // actionsCreateRegistrationTokenForRepo
  router.post(
    `/repos/:owner/:repo/actions/runners/registration-token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateRegistrationTokenForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_authentication_token>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateRegistrationTokenForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateRegistrationTokenForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateRemoveTokenForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsCreateRemoveTokenForRepoResponseBodyValidator =
    responseValidationFactory([["201", s_authentication_token]], undefined)

  // actionsCreateRemoveTokenForRepo
  router.post(
    `/repos/:owner/:repo/actions/runners/remove-token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateRemoveTokenForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_authentication_token>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateRemoveTokenForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateRemoveTokenForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsGetSelfHostedRunnerForRepoResponseBodyValidator =
    responseValidationFactory([["200", s_runner]], undefined)

  // actionsGetSelfHostedRunnerForRepo
  router.get(
    `/repos/:owner/:repo/actions/runners/:runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetSelfHostedRunnerForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_runner>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetSelfHostedRunnerForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetSelfHostedRunnerForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteSelfHostedRunnerFromRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsDeleteSelfHostedRunnerFromRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsDeleteSelfHostedRunnerFromRepo
  router.delete(
    `/repos/:owner/:repo/actions/runners/:runner_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteSelfHostedRunnerFromRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteSelfHostedRunnerFromRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteSelfHostedRunnerFromRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListLabelsForSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsListLabelsForSelfHostedRunnerForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // actionsListLabelsForSelfHostedRunnerForRepo
  router.get(
    `/repos/:owner/:repo/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListLabelsForSelfHostedRunnerForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListLabelsForSelfHostedRunnerForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListLabelsForSelfHostedRunnerForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsAddCustomLabelsToSelfHostedRunnerForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsAddCustomLabelsToSelfHostedRunnerForRepo
  router.post(
    `/repos/:owner/:repo/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsAddCustomLabelsToSelfHostedRunnerForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsAddCustomLabelsToSelfHostedRunnerForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsSetCustomLabelsForSelfHostedRunnerForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsSetCustomLabelsForSelfHostedRunnerForRepo
  router.put(
    `/repos/:owner/:repo/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsSetCustomLabelsForSelfHostedRunnerForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsSetCustomLabelsForSelfHostedRunnerForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema =
    z.object({
      owner: z.string(),
      repo: z.string(),
      runner_id: z.coerce.number(),
    })

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo
  router.delete(
    `/repos/:owner/:repo/actions/runners/:runner_id/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema =
    z.object({
      owner: z.string(),
      repo: z.string(),
      runner_id: z.coerce.number(),
      name: z.string(),
    })

  const actionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            labels: z.array(s_runner_label),
          }),
        ],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // actionsRemoveCustomLabelFromSelfHostedRunnerForRepo
  router.delete(
    `/repos/:owner/:repo/actions/runners/:runner_id/labels/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              labels: t_runner_label[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListWorkflowRunsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListWorkflowRunsForRepoQuerySchema = z.object({
    actor: z.string().optional(),
    branch: z.string().optional(),
    event: z.string().optional(),
    status: z
      .enum([
        "completed",
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "skipped",
        "stale",
        "success",
        "timed_out",
        "in_progress",
        "queued",
        "requested",
        "waiting",
        "pending",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    created: z.iso.datetime({offset: true}).optional(),
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
    check_suite_id: z.coerce.number().optional(),
    head_sha: z.string().optional(),
  })

  const actionsListWorkflowRunsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            workflow_runs: z.array(s_workflow_run),
          }),
        ],
      ],
      undefined,
    )

  // actionsListWorkflowRunsForRepo
  router.get(
    `/repos/:owner/:repo/actions/runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListWorkflowRunsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListWorkflowRunsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              total_count: number
              workflow_runs: t_workflow_run[]
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListWorkflowRunsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListWorkflowRunsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsGetWorkflowRunQuerySchema = z.object({
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
  })

  const actionsGetWorkflowRunResponseBodyValidator = responseValidationFactory(
    [["200", s_workflow_run]],
    undefined,
  )

  // actionsGetWorkflowRun
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsGetWorkflowRunQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_workflow_run>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsGetWorkflowRunResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsDeleteWorkflowRunResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteWorkflowRun
  router.delete(
    `/repos/:owner/:repo/actions/runs/:run_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsDeleteWorkflowRunResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetReviewsForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsGetReviewsForRunResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_environment_approvals)]],
      undefined,
    )

  // actionsGetReviewsForRun
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/approvals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetReviewsForRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_environment_approvals[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetReviewsForRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsGetReviewsForRunResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsApproveWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsApproveWorkflowRunResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // actionsApproveWorkflowRun
  router.post(
    `/repos/:owner/:repo/actions/runs/:run_id/approve`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsApproveWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsApproveWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsApproveWorkflowRunResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListWorkflowRunArtifactsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsListWorkflowRunArtifactsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    name: z.string().optional(),
  })

  const actionsListWorkflowRunArtifactsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            artifacts: z.array(s_artifact),
          }),
        ],
      ],
      undefined,
    )

  // actionsListWorkflowRunArtifacts
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/artifacts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListWorkflowRunArtifactsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListWorkflowRunArtifactsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              artifacts: t_artifact[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListWorkflowRunArtifacts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListWorkflowRunArtifactsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetWorkflowRunAttemptParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  const actionsGetWorkflowRunAttemptQuerySchema = z.object({
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
  })

  const actionsGetWorkflowRunAttemptResponseBodyValidator =
    responseValidationFactory([["200", s_workflow_run]], undefined)

  // actionsGetWorkflowRunAttempt
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetWorkflowRunAttemptParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsGetWorkflowRunAttemptQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_workflow_run>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetWorkflowRunAttempt(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetWorkflowRunAttemptResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListJobsForWorkflowRunAttemptParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  const actionsListJobsForWorkflowRunAttemptQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListJobsForWorkflowRunAttemptResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({total_count: z.coerce.number(), jobs: z.array(s_job)}),
        ],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // actionsListJobsForWorkflowRunAttempt
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/jobs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListJobsForWorkflowRunAttemptParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListJobsForWorkflowRunAttemptQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              jobs: t_job[]
              total_count: number
            }>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListJobsForWorkflowRunAttempt(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListJobsForWorkflowRunAttemptResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDownloadWorkflowRunAttemptLogsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  const actionsDownloadWorkflowRunAttemptLogsResponseBodyValidator =
    responseValidationFactory([["302", z.undefined()]], undefined)

  // actionsDownloadWorkflowRunAttemptLogs
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/logs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDownloadWorkflowRunAttemptLogsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDownloadWorkflowRunAttemptLogs(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDownloadWorkflowRunAttemptLogsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCancelWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsCancelWorkflowRunResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", s_empty_object],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // actionsCancelWorkflowRun
  router.post(
    `/repos/:owner/:repo/actions/runs/:run_id/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCancelWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_empty_object>(202)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCancelWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsCancelWorkflowRunResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsReviewCustomGatesForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReviewCustomGatesForRunResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsReviewCustomGatesForRun
  router.post(
    `/repos/:owner/:repo/actions/runs/:run_id/deployment_protection_rule`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsReviewCustomGatesForRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsReviewCustomGatesForRunRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsReviewCustomGatesForRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsReviewCustomGatesForRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsForceCancelWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsForceCancelWorkflowRunResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", s_empty_object],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // actionsForceCancelWorkflowRun
  router.post(
    `/repos/:owner/:repo/actions/runs/:run_id/force-cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsForceCancelWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_empty_object>(202)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsForceCancelWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsForceCancelWorkflowRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListJobsForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsListJobsForWorkflowRunQuerySchema = z.object({
    filter: z.enum(["latest", "all"]).optional().default("latest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListJobsForWorkflowRunResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({total_count: z.coerce.number(), jobs: z.array(s_job)}),
        ],
      ],
      undefined,
    )

  // actionsListJobsForWorkflowRun
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/jobs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListJobsForWorkflowRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListJobsForWorkflowRunQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              jobs: t_job[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListJobsForWorkflowRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListJobsForWorkflowRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDownloadWorkflowRunLogsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsDownloadWorkflowRunLogsResponseBodyValidator =
    responseValidationFactory([["302", z.undefined()]], undefined)

  // actionsDownloadWorkflowRunLogs
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/logs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDownloadWorkflowRunLogsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDownloadWorkflowRunLogs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDownloadWorkflowRunLogsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteWorkflowRunLogsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsDeleteWorkflowRunLogsResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // actionsDeleteWorkflowRunLogs
  router.delete(
    `/repos/:owner/:repo/actions/runs/:run_id/logs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteWorkflowRunLogsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteWorkflowRunLogs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteWorkflowRunLogsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetPendingDeploymentsForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsGetPendingDeploymentsForRunResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_pending_deployment)]],
      undefined,
    )

  // actionsGetPendingDeploymentsForRun
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/pending_deployments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetPendingDeploymentsForRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pending_deployment[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetPendingDeploymentsForRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetPendingDeploymentsForRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsReviewPendingDeploymentsForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReviewPendingDeploymentsForRunResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_deployment)]], undefined)

  // actionsReviewPendingDeploymentsForRun
  router.post(
    `/repos/:owner/:repo/actions/runs/:run_id/pending_deployments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsReviewPendingDeploymentsForRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsReviewPendingDeploymentsForRunRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsReviewPendingDeploymentsForRun(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsReviewPendingDeploymentsForRunResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsReRunWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReRunWorkflowResponseBodyValidator = responseValidationFactory(
    [["201", s_empty_object]],
    undefined,
  )

  // actionsReRunWorkflow
  router.post(
    `/repos/:owner/:repo/actions/runs/:run_id/rerun`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsReRunWorkflowParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsReRunWorkflowRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsReRunWorkflow(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsReRunWorkflowResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsReRunWorkflowFailedJobsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReRunWorkflowFailedJobsResponseBodyValidator =
    responseValidationFactory([["201", s_empty_object]], undefined)

  // actionsReRunWorkflowFailedJobs
  router.post(
    `/repos/:owner/:repo/actions/runs/:run_id/rerun-failed-jobs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsReRunWorkflowFailedJobsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsReRunWorkflowFailedJobsRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsReRunWorkflowFailedJobs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsReRunWorkflowFailedJobsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetWorkflowRunUsageParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsGetWorkflowRunUsageResponseBodyValidator =
    responseValidationFactory([["200", s_workflow_run_usage]], undefined)

  // actionsGetWorkflowRunUsage
  router.get(
    `/repos/:owner/:repo/actions/runs/:run_id/timing`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetWorkflowRunUsageParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_workflow_run_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetWorkflowRunUsage(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetWorkflowRunUsageResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRepoSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListRepoSecretsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          secrets: z.array(s_actions_secret),
        }),
      ],
    ],
    undefined,
  )

  // actionsListRepoSecrets
  router.get(
    `/repos/:owner/:repo/actions/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRepoSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListRepoSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_actions_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRepoSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsListRepoSecretsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetRepoPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetRepoPublicKeyResponseBodyValidator =
    responseValidationFactory([["200", s_actions_public_key]], undefined)

  // actionsGetRepoPublicKey
  router.get(
    `/repos/:owner/:repo/actions/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetRepoPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetRepoPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsGetRepoPublicKeyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const actionsGetRepoSecretResponseBodyValidator = responseValidationFactory(
    [["200", s_actions_secret]],
    undefined,
  )

  // actionsGetRepoSecret
  router.get(
    `/repos/:owner/:repo/actions/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_secret>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsGetRepoSecretResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const actionsCreateOrUpdateRepoSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // actionsCreateOrUpdateRepoSecret
  router.put(
    `/repos/:owner/:repo/actions/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateOrUpdateRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateOrUpdateRepoSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateOrUpdateRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateOrUpdateRepoSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const actionsDeleteRepoSecretResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteRepoSecret
  router.delete(
    `/repos/:owner/:repo/actions/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsDeleteRepoSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRepoVariablesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListRepoVariablesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            variables: z.array(s_actions_variable),
          }),
        ],
      ],
      undefined,
    )

  // actionsListRepoVariables
  router.get(
    `/repos/:owner/:repo/actions/variables`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRepoVariablesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListRepoVariablesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              total_count: number
              variables: t_actions_variable[]
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRepoVariables(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsListRepoVariablesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsCreateRepoVariableResponseBodyValidator =
    responseValidationFactory([["201", s_empty_object]], undefined)

  // actionsCreateRepoVariable
  router.post(
    `/repos/:owner/:repo/actions/variables`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateRepoVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateRepoVariableRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateRepoVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsCreateRepoVariableResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const actionsGetRepoVariableResponseBodyValidator = responseValidationFactory(
    [["200", s_actions_variable]],
    undefined,
  )

  // actionsGetRepoVariable
  router.get(
    `/repos/:owner/:repo/actions/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetRepoVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_variable>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetRepoVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsGetRepoVariableResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsUpdateRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const actionsUpdateRepoVariableResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsUpdateRepoVariable
  router.patch(
    `/repos/:owner/:repo/actions/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsUpdateRepoVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsUpdateRepoVariableRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsUpdateRepoVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsUpdateRepoVariableResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const actionsDeleteRepoVariableResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteRepoVariable
  router.delete(
    `/repos/:owner/:repo/actions/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteRepoVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteRepoVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsDeleteRepoVariableResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListRepoWorkflowsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoWorkflowsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListRepoWorkflowsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            workflows: z.array(s_workflow),
          }),
        ],
      ],
      undefined,
    )

  // actionsListRepoWorkflows
  router.get(
    `/repos/:owner/:repo/actions/workflows`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListRepoWorkflowsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListRepoWorkflowsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              total_count: number
              workflows: t_workflow[]
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListRepoWorkflows(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsListRepoWorkflowsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsGetWorkflowResponseBodyValidator = responseValidationFactory(
    [["200", s_workflow]],
    undefined,
  )

  // actionsGetWorkflow
  router.get(
    `/repos/:owner/:repo/actions/workflows/:workflow_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetWorkflowParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_workflow>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetWorkflow(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsGetWorkflowResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDisableWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsDisableWorkflowResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // actionsDisableWorkflow
  router.put(
    `/repos/:owner/:repo/actions/workflows/:workflow_id/disable`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDisableWorkflowParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDisableWorkflow(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsDisableWorkflowResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateWorkflowDispatchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsCreateWorkflowDispatchResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsCreateWorkflowDispatch
  router.post(
    `/repos/:owner/:repo/actions/workflows/:workflow_id/dispatches`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateWorkflowDispatchParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateWorkflowDispatchRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateWorkflowDispatch(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateWorkflowDispatchResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsEnableWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsEnableWorkflowResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // actionsEnableWorkflow
  router.put(
    `/repos/:owner/:repo/actions/workflows/:workflow_id/enable`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsEnableWorkflowParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsEnableWorkflow(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, actionsEnableWorkflowResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListWorkflowRunsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsListWorkflowRunsQuerySchema = z.object({
    actor: z.string().optional(),
    branch: z.string().optional(),
    event: z.string().optional(),
    status: z
      .enum([
        "completed",
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "skipped",
        "stale",
        "success",
        "timed_out",
        "in_progress",
        "queued",
        "requested",
        "waiting",
        "pending",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    created: z.iso.datetime({offset: true}).optional(),
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
    check_suite_id: z.coerce.number().optional(),
    head_sha: z.string().optional(),
  })

  const actionsListWorkflowRunsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            workflow_runs: z.array(s_workflow_run),
          }),
        ],
      ],
      undefined,
    )

  // actionsListWorkflowRuns
  router.get(
    `/repos/:owner/:repo/actions/workflows/:workflow_id/runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListWorkflowRunsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListWorkflowRunsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              total_count: number
              workflow_runs: t_workflow_run[]
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListWorkflowRuns(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsListWorkflowRunsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetWorkflowUsageParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsGetWorkflowUsageResponseBodyValidator =
    responseValidationFactory([["200", s_workflow_usage]], undefined)

  // actionsGetWorkflowUsage
  router.get(
    `/repos/:owner/:repo/actions/workflows/:workflow_id/timing`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetWorkflowUsageParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_workflow_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetWorkflowUsage(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, actionsGetWorkflowUsageResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListActivitiesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListActivitiesQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    ref: z.string().optional(),
    actor: z.string().optional(),
    time_period: z.enum(["day", "week", "month", "quarter", "year"]).optional(),
    activity_type: z
      .enum([
        "push",
        "force_push",
        "branch_creation",
        "branch_deletion",
        "pr_merge",
        "merge_queue_merge",
      ])
      .optional(),
  })

  const reposListActivitiesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_activity)],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // reposListActivities
  router.get(
    `/repos/:owner/:repo/activity`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListActivitiesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListActivitiesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_activity[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListActivities(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListActivitiesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListAssigneesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListAssigneesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListAssigneesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_simple_user)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesListAssignees
  router.get(
    `/repos/:owner/:repo/assignees`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListAssigneesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListAssigneesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListAssignees(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListAssigneesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesCheckUserCanBeAssignedParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    assignee: z.string(),
  })

  const issuesCheckUserCanBeAssignedResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // issuesCheckUserCanBeAssigned
  router.get(
    `/repos/:owner/:repo/assignees/:assignee`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesCheckUserCanBeAssignedParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesCheckUserCanBeAssigned(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              issuesCheckUserCanBeAssignedResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateAttestationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateAttestationResponseBodyValidator = responseValidationFactory(
    [
      ["201", z.object({id: z.coerce.number().optional()})],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateAttestation
  router.post(
    `/repos/:owner/:repo/attestations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateAttestationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateAttestationRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<{
              id?: number | undefined
            }>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateAttestation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCreateAttestationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListAttestationsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    subject_digest: z.string(),
  })

  const reposListAttestationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    predicate_type: z.string().optional(),
  })

  const reposListAttestationsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          attestations: z
            .array(
              z.object({
                bundle: z
                  .object({
                    mediaType: z.string().optional(),
                    verificationMaterial: z
                      .record(z.string(), z.unknown())
                      .optional(),
                    dsseEnvelope: z.record(z.string(), z.unknown()).optional(),
                  })
                  .optional(),
                repository_id: z.coerce.number().optional(),
                bundle_url: z.string().optional(),
              }),
            )
            .optional(),
        }),
      ],
    ],
    undefined,
  )

  // reposListAttestations
  router.get(
    `/repos/:owner/:repo/attestations/:subject_digest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListAttestationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListAttestationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              attestations?:
                | {
                    bundle?:
                      | {
                          dsseEnvelope?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                          mediaType?: string | undefined
                          verificationMaterial?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                        }
                      | undefined
                    bundle_url?: string | undefined
                    repository_id?: number | undefined
                  }[]
                | undefined
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListAttestations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListAttestationsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListAutolinksParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListAutolinksResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_autolink)]],
    undefined,
  )

  // reposListAutolinks
  router.get(
    `/repos/:owner/:repo/autolinks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListAutolinksParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_autolink[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListAutolinks(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListAutolinksResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateAutolinkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateAutolinkResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_autolink],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateAutolink
  router.post(
    `/repos/:owner/:repo/autolinks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateAutolinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateAutolinkRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_autolink>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateAutolink(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateAutolinkResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAutolinkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    autolink_id: z.coerce.number(),
  })

  const reposGetAutolinkResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_autolink],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetAutolink
  router.get(
    `/repos/:owner/:repo/autolinks/:autolink_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAutolinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_autolink>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAutolink(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetAutolinkResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteAutolinkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    autolink_id: z.coerce.number(),
  })

  const reposDeleteAutolinkResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposDeleteAutolink
  router.delete(
    `/repos/:owner/:repo/autolinks/:autolink_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteAutolinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteAutolink(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteAutolinkResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCheckAutomatedSecurityFixesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCheckAutomatedSecurityFixesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_check_automated_security_fixes],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // reposCheckAutomatedSecurityFixes
  router.get(
    `/repos/:owner/:repo/automated-security-fixes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCheckAutomatedSecurityFixesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_check_automated_security_fixes>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCheckAutomatedSecurityFixes(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCheckAutomatedSecurityFixesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposEnableAutomatedSecurityFixesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposEnableAutomatedSecurityFixesResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposEnableAutomatedSecurityFixes
  router.put(
    `/repos/:owner/:repo/automated-security-fixes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposEnableAutomatedSecurityFixesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposEnableAutomatedSecurityFixes(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposEnableAutomatedSecurityFixesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDisableAutomatedSecurityFixesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposDisableAutomatedSecurityFixesResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposDisableAutomatedSecurityFixes
  router.delete(
    `/repos/:owner/:repo/automated-security-fixes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDisableAutomatedSecurityFixesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDisableAutomatedSecurityFixes(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDisableAutomatedSecurityFixesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListBranchesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListBranchesQuerySchema = z.object({
    protected: PermissiveBoolean.optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListBranchesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_short_branch)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposListBranches
  router.get(
    `/repos/:owner/:repo/branches`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListBranchesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListBranchesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_short_branch[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListBranches(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListBranchesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetBranchResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_branch_with_protection],
      ["301", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetBranch
  router.get(
    `/repos/:owner/:repo/branches/:branch`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetBranchParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_branch_with_protection>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetBranch(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetBranchResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetBranchProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_branch_protection],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetBranchProtection
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetBranchProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_branch_protection>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetBranchProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetBranchProtectionResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposUpdateBranchProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_protected_branch],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // reposUpdateBranchProtection
  router.put(
    `/repos/:owner/:repo/branches/:branch/protection`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateBranchProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateBranchProtectionRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_protected_branch>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateBranchProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposUpdateBranchProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposDeleteBranchProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // reposDeleteBranchProtection
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteBranchProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteBranchProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDeleteBranchProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAdminBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetAdminBranchProtectionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_protected_branch_admin_enforced]],
      undefined,
    )

  // reposGetAdminBranchProtection
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/enforce_admins`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAdminBranchProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_protected_branch_admin_enforced>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAdminBranchProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetAdminBranchProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposSetAdminBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetAdminBranchProtectionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_protected_branch_admin_enforced]],
      undefined,
    )

  // reposSetAdminBranchProtection
  router.post(
    `/repos/:owner/:repo/branches/:branch/protection/enforce_admins`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposSetAdminBranchProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_protected_branch_admin_enforced>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposSetAdminBranchProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposSetAdminBranchProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteAdminBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposDeleteAdminBranchProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposDeleteAdminBranchProtection
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/enforce_admins`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteAdminBranchProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteAdminBranchProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDeleteAdminBranchProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetPullRequestReviewProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetPullRequestReviewProtectionResponseBodyValidator =
    responseValidationFactory(
      [["200", s_protected_branch_pull_request_review]],
      undefined,
    )

  // reposGetPullRequestReviewProtection
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetPullRequestReviewProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_protected_branch_pull_request_review>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetPullRequestReviewProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetPullRequestReviewProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdatePullRequestReviewProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposUpdatePullRequestReviewProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_protected_branch_pull_request_review],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposUpdatePullRequestReviewProtection
  router.patch(
    `/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdatePullRequestReviewProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdatePullRequestReviewProtectionRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_protected_branch_pull_request_review>(
              200,
            )
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdatePullRequestReviewProtection(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposUpdatePullRequestReviewProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeletePullRequestReviewProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposDeletePullRequestReviewProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposDeletePullRequestReviewProtection
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeletePullRequestReviewProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeletePullRequestReviewProtection(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDeletePullRequestReviewProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCommitSignatureProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetCommitSignatureProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_protected_branch_admin_enforced],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetCommitSignatureProtection
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/required_signatures`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCommitSignatureProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_protected_branch_admin_enforced>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCommitSignatureProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCommitSignatureProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateCommitSignatureProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposCreateCommitSignatureProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_protected_branch_admin_enforced],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposCreateCommitSignatureProtection
  router.post(
    `/repos/:owner/:repo/branches/:branch/protection/required_signatures`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateCommitSignatureProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_protected_branch_admin_enforced>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateCommitSignatureProtection(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateCommitSignatureProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteCommitSignatureProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposDeleteCommitSignatureProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposDeleteCommitSignatureProtection
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/required_signatures`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteCommitSignatureProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteCommitSignatureProtection(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDeleteCommitSignatureProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetStatusChecksProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetStatusChecksProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_status_check_policy],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetStatusChecksProtection
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/required_status_checks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetStatusChecksProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_status_check_policy>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetStatusChecksProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetStatusChecksProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateStatusCheckProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposUpdateStatusCheckProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_status_check_policy],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposUpdateStatusCheckProtection
  router.patch(
    `/repos/:owner/:repo/branches/:branch/protection/required_status_checks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateStatusCheckProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateStatusCheckProtectionRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_status_check_policy>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateStatusCheckProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposUpdateStatusCheckProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRemoveStatusCheckProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveStatusCheckProtectionResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposRemoveStatusCheckProtection
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/required_status_checks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRemoveStatusCheckProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRemoveStatusCheckProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposRemoveStatusCheckProtectionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAllStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetAllStatusCheckContextsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(z.string())],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetAllStatusCheckContexts
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAllStatusCheckContextsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAllStatusCheckContexts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetAllStatusCheckContextsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposAddStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddStatusCheckContextsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(z.string())],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposAddStatusCheckContexts
  router.post(
    `/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposAddStatusCheckContextsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposAddStatusCheckContextsRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposAddStatusCheckContexts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposAddStatusCheckContextsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposSetStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetStatusCheckContextsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(z.string())],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposSetStatusCheckContexts
  router.put(
    `/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposSetStatusCheckContextsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposSetStatusCheckContextsRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposSetStatusCheckContexts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposSetStatusCheckContextsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRemoveStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveStatusCheckContextsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(z.string())],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposRemoveStatusCheckContexts
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRemoveStatusCheckContextsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposRemoveStatusCheckContextsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRemoveStatusCheckContexts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposRemoveStatusCheckContextsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_branch_restriction_policy],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetAccessRestrictions
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_branch_restriction_policy>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposDeleteAccessRestrictionsResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposDeleteAccessRestrictions
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDeleteAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAppsWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetAppsWithAccessToProtectedBranchResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_integration)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetAppsWithAccessToProtectedBranch
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/apps`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAppsWithAccessToProtectedBranchParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_integration[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAppsWithAccessToProtectedBranch(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetAppsWithAccessToProtectedBranchResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposAddAppAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddAppAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_integration)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposAddAppAccessRestrictions
  router.post(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/apps`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposAddAppAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposAddAppAccessRestrictionsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_integration[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposAddAppAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposAddAppAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposSetAppAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetAppAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_integration)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposSetAppAccessRestrictions
  router.put(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/apps`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposSetAppAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposSetAppAccessRestrictionsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_integration[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposSetAppAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposSetAppAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRemoveAppAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveAppAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_integration)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposRemoveAppAccessRestrictions
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/apps`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRemoveAppAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposRemoveAppAccessRestrictionsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_integration[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRemoveAppAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposRemoveAppAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetTeamsWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetTeamsWithAccessToProtectedBranchResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_team)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetTeamsWithAccessToProtectedBranch
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetTeamsWithAccessToProtectedBranchParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetTeamsWithAccessToProtectedBranch(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetTeamsWithAccessToProtectedBranchResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposAddTeamAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddTeamAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_team)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposAddTeamAccessRestrictions
  router.post(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposAddTeamAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposAddTeamAccessRestrictionsRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposAddTeamAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposAddTeamAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposSetTeamAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetTeamAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_team)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposSetTeamAccessRestrictions
  router.put(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposSetTeamAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposSetTeamAccessRestrictionsRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposSetTeamAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposSetTeamAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRemoveTeamAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveTeamAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_team)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposRemoveTeamAccessRestrictions
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRemoveTeamAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposRemoveTeamAccessRestrictionsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRemoveTeamAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposRemoveTeamAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetUsersWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetUsersWithAccessToProtectedBranchResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetUsersWithAccessToProtectedBranch
  router.get(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetUsersWithAccessToProtectedBranchParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetUsersWithAccessToProtectedBranch(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetUsersWithAccessToProtectedBranchResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposAddUserAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddUserAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposAddUserAccessRestrictions
  router.post(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposAddUserAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposAddUserAccessRestrictionsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposAddUserAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposAddUserAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposSetUserAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetUserAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposSetUserAccessRestrictions
  router.put(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposSetUserAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposSetUserAccessRestrictionsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposSetUserAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposSetUserAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRemoveUserAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveUserAccessRestrictionsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposRemoveUserAccessRestrictions
  router.delete(
    `/repos/:owner/:repo/branches/:branch/protection/restrictions/users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRemoveUserAccessRestrictionsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposRemoveUserAccessRestrictionsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRemoveUserAccessRestrictions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposRemoveUserAccessRestrictionsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRenameBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRenameBranchResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_branch_with_protection],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposRenameBranch
  router.post(
    `/repos/:owner/:repo/branches/:branch/rename`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRenameBranchParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposRenameBranchRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_branch_with_protection>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRenameBranch(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposRenameBranchResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksCreateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const checksCreateResponseBodyValidator = responseValidationFactory(
    [["201", s_check_run]],
    undefined,
  )

  // checksCreate
  router.post(
    `/repos/:owner/:repo/check-runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksCreateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ChecksCreateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_check_run>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksCreate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksCreateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksGetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  const checksGetResponseBodyValidator = responseValidationFactory(
    [["200", s_check_run]],
    undefined,
  )

  // checksGet
  router.get(
    `/repos/:owner/:repo/check-runs/:check_run_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_check_run>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksUpdateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  const checksUpdateResponseBodyValidator = responseValidationFactory(
    [["200", s_check_run]],
    undefined,
  )

  // checksUpdate
  router.patch(
    `/repos/:owner/:repo/check-runs/:check_run_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksUpdateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ChecksUpdateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_check_run>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksUpdate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksUpdateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksListAnnotationsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  const checksListAnnotationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const checksListAnnotationsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_check_annotation)]],
    undefined,
  )

  // checksListAnnotations
  router.get(
    `/repos/:owner/:repo/check-runs/:check_run_id/annotations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksListAnnotationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            checksListAnnotationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_check_annotation[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksListAnnotations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksListAnnotationsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksRerequestRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  const checksRerequestRunResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_empty_object],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_basic_error],
    ],
    undefined,
  )

  // checksRerequestRun
  router.post(
    `/repos/:owner/:repo/check-runs/:check_run_id/rerequest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksRerequestRunParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksRerequestRun(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksRerequestRunResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksCreateSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const checksCreateSuiteResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_check_suite],
      ["201", s_check_suite],
    ],
    undefined,
  )

  // checksCreateSuite
  router.post(
    `/repos/:owner/:repo/check-suites`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksCreateSuiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ChecksCreateSuiteRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_check_suite>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_check_suite>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksCreateSuite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksCreateSuiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksSetSuitesPreferencesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const checksSetSuitesPreferencesResponseBodyValidator =
    responseValidationFactory([["200", s_check_suite_preference]], undefined)

  // checksSetSuitesPreferences
  router.patch(
    `/repos/:owner/:repo/check-suites/preferences`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksSetSuitesPreferencesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ChecksSetSuitesPreferencesRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_check_suite_preference>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksSetSuitesPreferences(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              checksSetSuitesPreferencesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const checksGetSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_suite_id: z.coerce.number(),
  })

  const checksGetSuiteResponseBodyValidator = responseValidationFactory(
    [["200", s_check_suite]],
    undefined,
  )

  // checksGetSuite
  router.get(
    `/repos/:owner/:repo/check-suites/:check_suite_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksGetSuiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_check_suite>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksGetSuite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksGetSuiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksListForSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_suite_id: z.coerce.number(),
  })

  const checksListForSuiteQuerySchema = z.object({
    check_name: z.string().optional(),
    status: z.enum(["queued", "in_progress", "completed"]).optional(),
    filter: z.enum(["latest", "all"]).optional().default("latest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const checksListForSuiteResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          check_runs: z.array(s_check_run),
        }),
      ],
    ],
    undefined,
  )

  // checksListForSuite
  router.get(
    `/repos/:owner/:repo/check-suites/:check_suite_id/check-runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksListForSuiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            checksListForSuiteQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              check_runs: t_check_run[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksListForSuite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksListForSuiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksRerequestSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_suite_id: z.coerce.number(),
  })

  const checksRerequestSuiteResponseBodyValidator = responseValidationFactory(
    [["201", s_empty_object]],
    undefined,
  )

  // checksRerequestSuite
  router.post(
    `/repos/:owner/:repo/check-suites/:check_suite_id/rerequest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksRerequestSuiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksRerequestSuite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksRerequestSuiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningListAlertsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningListAlertsForRepoQuerySchema = z.object({
    tool_name: s_code_scanning_analysis_tool_name.optional(),
    tool_guid: s_code_scanning_analysis_tool_guid.optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    ref: s_code_scanning_ref.optional(),
    pr: z.coerce.number().optional(),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    before: z.string().optional(),
    after: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    state: s_code_scanning_alert_state_query.optional(),
    severity: s_code_scanning_alert_severity.optional(),
  })

  const codeScanningListAlertsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_scanning_alert_items)],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningListAlertsForRepo
  router.get(
    `/repos/:owner/:repo/code-scanning/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningListAlertsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeScanningListAlertsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_alert_items[]>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningListAlertsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningListAlertsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningGetAlertResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_code_scanning_alert],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // codeScanningGetAlert
  router.get(
    `/repos/:owner/:repo/code-scanning/alerts/:alert_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetAlertParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_alert>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetAlert(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, codeScanningGetAlertResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningUpdateAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningUpdateAlertResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_scanning_alert],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningUpdateAlert
  router.patch(
    `/repos/:owner/:repo/code-scanning/alerts/:alert_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningUpdateAlertParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeScanningUpdateAlertRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_alert>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningUpdateAlert(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codeScanningUpdateAlertResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetAutofixParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningGetAutofixResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_code_scanning_autofix],
      ["400", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // codeScanningGetAutofix
  router.get(
    `/repos/:owner/:repo/code-scanning/alerts/:alert_number/autofix`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetAutofixParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_autofix>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_basic_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetAutofix(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codeScanningGetAutofixResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningCreateAutofixParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningCreateAutofixResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_scanning_autofix],
        ["202", s_code_scanning_autofix],
        ["400", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningCreateAutofix
  router.post(
    `/repos/:owner/:repo/code-scanning/alerts/:alert_number/autofix`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningCreateAutofixParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_autofix>(200)
          },
          with202() {
            return new ExpressRuntimeResponse<t_code_scanning_autofix>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_basic_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningCreateAutofix(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codeScanningCreateAutofixResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningCommitAutofixParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningCommitAutofixResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_code_scanning_autofix_commits_response],
        ["400", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningCommitAutofix
  router.post(
    `/repos/:owner/:repo/code-scanning/alerts/:alert_number/autofix/commits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningCommitAutofixParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_code_scanning_autofix_commits.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_code_scanning_autofix_commits_response>(
              201,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<t_basic_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningCommitAutofix(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codeScanningCommitAutofixResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningListAlertInstancesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningListAlertInstancesQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    ref: s_code_scanning_ref.optional(),
    pr: z.coerce.number().optional(),
  })

  const codeScanningListAlertInstancesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_scanning_alert_instance)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningListAlertInstances
  router.get(
    `/repos/:owner/:repo/code-scanning/alerts/:alert_number/instances`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningListAlertInstancesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeScanningListAlertInstancesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_alert_instance[]>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningListAlertInstances(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningListAlertInstancesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningListRecentAnalysesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningListRecentAnalysesQuerySchema = z.object({
    tool_name: s_code_scanning_analysis_tool_name.optional(),
    tool_guid: s_code_scanning_analysis_tool_guid.optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    pr: z.coerce.number().optional(),
    ref: s_code_scanning_ref.optional(),
    sarif_id: s_code_scanning_analysis_sarif_id.optional(),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z.enum(["created"]).optional().default("created"),
  })

  const codeScanningListRecentAnalysesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_scanning_analysis)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningListRecentAnalyses
  router.get(
    `/repos/:owner/:repo/code-scanning/analyses`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningListRecentAnalysesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeScanningListRecentAnalysesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_analysis[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningListRecentAnalyses(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningListRecentAnalysesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    analysis_id: z.coerce.number(),
  })

  const codeScanningGetAnalysisResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.record(z.string(), z.unknown())],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningGetAnalysis
  router.get(
    `/repos/:owner/:repo/code-scanning/analyses/:analysis_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetAnalysisParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetAnalysis(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codeScanningGetAnalysisResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningDeleteAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    analysis_id: z.coerce.number(),
  })

  const codeScanningDeleteAnalysisQuerySchema = z.object({
    confirm_delete: z.string().nullable().optional(),
  })

  const codeScanningDeleteAnalysisResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_scanning_analysis_deletion],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningDeleteAnalysis
  router.delete(
    `/repos/:owner/:repo/code-scanning/analyses/:analysis_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningDeleteAnalysisParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codeScanningDeleteAnalysisQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_analysis_deletion>(
              200,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningDeleteAnalysis(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningDeleteAnalysisResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningListCodeqlDatabasesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningListCodeqlDatabasesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_scanning_codeql_database)],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningListCodeqlDatabases
  router.get(
    `/repos/:owner/:repo/code-scanning/codeql/databases`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningListCodeqlDatabasesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_code_scanning_codeql_database[]
            >(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningListCodeqlDatabases(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningListCodeqlDatabasesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetCodeqlDatabaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    language: z.string(),
  })

  const codeScanningGetCodeqlDatabaseResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_scanning_codeql_database],
        ["302", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningGetCodeqlDatabase
  router.get(
    `/repos/:owner/:repo/code-scanning/codeql/databases/:language`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetCodeqlDatabaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_codeql_database>(
              200,
            )
          },
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetCodeqlDatabase(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningGetCodeqlDatabaseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningDeleteCodeqlDatabaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    language: z.string(),
  })

  const codeScanningDeleteCodeqlDatabaseResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningDeleteCodeqlDatabase
  router.delete(
    `/repos/:owner/:repo/code-scanning/codeql/databases/:language`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningDeleteCodeqlDatabaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningDeleteCodeqlDatabase(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningDeleteCodeqlDatabaseResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningCreateVariantAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningCreateVariantAnalysisResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_code_scanning_variant_analysis],
        ["404", s_basic_error],
        ["422", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningCreateVariantAnalysis
  router.post(
    `/repos/:owner/:repo/code-scanning/codeql/variant-analyses`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningCreateVariantAnalysisParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeScanningCreateVariantAnalysisRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_code_scanning_variant_analysis>(
              201,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningCreateVariantAnalysis(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningCreateVariantAnalysisResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetVariantAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    codeql_variant_analysis_id: z.coerce.number(),
  })

  const codeScanningGetVariantAnalysisResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_scanning_variant_analysis],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningGetVariantAnalysis
  router.get(
    `/repos/:owner/:repo/code-scanning/codeql/variant-analyses/:codeql_variant_analysis_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetVariantAnalysisParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_variant_analysis>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetVariantAnalysis(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningGetVariantAnalysisResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetVariantAnalysisRepoTaskParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    codeql_variant_analysis_id: z.coerce.number(),
    repo_owner: z.string(),
    repo_name: z.string(),
  })

  const codeScanningGetVariantAnalysisRepoTaskResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_scanning_variant_analysis_repo_task],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningGetVariantAnalysisRepoTask
  router.get(
    `/repos/:owner/:repo/code-scanning/codeql/variant-analyses/:codeql_variant_analysis_id/repos/:repo_owner/:repo_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetVariantAnalysisRepoTaskParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_variant_analysis_repo_task>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetVariantAnalysisRepoTask(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningGetVariantAnalysisRepoTaskResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetDefaultSetupParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningGetDefaultSetupResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_scanning_default_setup],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningGetDefaultSetup
  router.get(
    `/repos/:owner/:repo/code-scanning/default-setup`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetDefaultSetupParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_default_setup>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetDefaultSetup(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningGetDefaultSetupResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningUpdateDefaultSetupParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningUpdateDefaultSetupResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_empty_object],
        ["202", s_code_scanning_default_setup_update_response],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
        ["422", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningUpdateDefaultSetup
  router.patch(
    `/repos/:owner/:repo/code-scanning/default-setup`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningUpdateDefaultSetupParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_code_scanning_default_setup_update,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_empty_object>(200)
          },
          with202() {
            return new ExpressRuntimeResponse<t_code_scanning_default_setup_update_response>(
              202,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningUpdateDefaultSetup(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeScanningUpdateDefaultSetupResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningUploadSarifParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningUploadSarifResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", s_code_scanning_sarifs_receipt],
        ["400", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["413", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codeScanningUploadSarif
  router.post(
    `/repos/:owner/:repo/code-scanning/sarifs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningUploadSarifParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodeScanningUploadSarifRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_code_scanning_sarifs_receipt>(
              202,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with413() {
            return new ExpressRuntimeResponse<void>(413)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningUploadSarif(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codeScanningUploadSarifResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codeScanningGetSarifParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    sarif_id: z.string(),
  })

  const codeScanningGetSarifResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_code_scanning_sarifs_status],
      ["403", s_basic_error],
      ["404", z.undefined()],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // codeScanningGetSarif
  router.get(
    `/repos/:owner/:repo/code-scanning/sarifs/:sarif_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeScanningGetSarifParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_scanning_sarifs_status>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeScanningGetSarif(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, codeScanningGetSarifResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codeSecurityGetConfigurationForRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeSecurityGetConfigurationForRepositoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_code_security_configuration_for_repository],
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codeSecurityGetConfigurationForRepository
  router.get(
    `/repos/:owner/:repo/code-security-configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codeSecurityGetConfigurationForRepositoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_security_configuration_for_repository>(
              200,
            )
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codeSecurityGetConfigurationForRepository(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codeSecurityGetConfigurationForRepositoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCodeownersErrorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCodeownersErrorsQuerySchema = z.object({
    ref: z.string().optional(),
  })

  const reposCodeownersErrorsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_codeowners_errors],
      ["404", z.undefined()],
    ],
    undefined,
  )

  // reposCodeownersErrors
  router.get(
    `/repos/:owner/:repo/codeowners/errors`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCodeownersErrorsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposCodeownersErrorsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codeowners_errors>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCodeownersErrors(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCodeownersErrorsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListInRepositoryForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesListInRepositoryForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const codespacesListInRepositoryForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            codespaces: z.array(s_codespace),
          }),
        ],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesListInRepositoryForAuthenticatedUser
  router.get(
    `/repos/:owner/:repo/codespaces`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesListInRepositoryForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesListInRepositoryForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              codespaces: t_codespace[]
              total_count: number
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListInRepositoryForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesListInRepositoryForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCreateWithRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesCreateWithRepoForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_codespace],
        ["202", s_codespace],
        ["400", s_scim_error],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codespacesCreateWithRepoForAuthenticatedUser
  router.post(
    `/repos/:owner/:repo/codespaces`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesCreateWithRepoForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesCreateWithRepoForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_codespace>(201)
          },
          with202() {
            return new ExpressRuntimeResponse<t_codespace>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCreateWithRepoForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCreateWithRepoForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema =
    z.object({owner: z.string(), repo: z.string()})

  const codespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema =
    z.object({
      per_page: z.coerce.number().optional().default(30),
      page: z.coerce.number().optional().default(1),
    })

  const codespacesListDevcontainersInRepositoryForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            devcontainers: z.array(
              z.object({
                path: z.string(),
                name: z.string().optional(),
                display_name: z.string().optional(),
              }),
            ),
          }),
        ],
        ["400", s_scim_error],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesListDevcontainersInRepositoryForAuthenticatedUser
  router.get(
    `/repos/:owner/:repo/codespaces/devcontainers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              devcontainers: {
                display_name?: string | undefined
                name?: string | undefined
                path: string
              }[]
              total_count: number
            }>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListDevcontainersInRepositoryForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesListDevcontainersInRepositoryForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesRepoMachinesForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesRepoMachinesForAuthenticatedUserQuerySchema = z.object({
    location: z.string().optional(),
    client_ip: z.string().optional(),
    ref: z.string().optional(),
  })

  const codespacesRepoMachinesForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            machines: z.array(s_codespace_machine),
          }),
        ],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesRepoMachinesForAuthenticatedUser
  router.get(
    `/repos/:owner/:repo/codespaces/machines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesRepoMachinesForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesRepoMachinesForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              machines: t_codespace_machine[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesRepoMachinesForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesRepoMachinesForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesPreFlightWithRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesPreFlightWithRepoForAuthenticatedUserQuerySchema = z.object({
    ref: z.string().optional(),
    client_ip: z.string().optional(),
  })

  const codespacesPreFlightWithRepoForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            billable_owner: s_simple_user.optional(),
            defaults: z
              .object({
                location: z.string(),
                devcontainer_path: z.string().nullable(),
              })
              .optional(),
          }),
        ],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codespacesPreFlightWithRepoForAuthenticatedUser
  router.get(
    `/repos/:owner/:repo/codespaces/new`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              billable_owner?: t_simple_user | undefined
              defaults?:
                | {
                    devcontainer_path: string | null
                    location: string
                  }
                | undefined
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesPreFlightWithRepoForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesPreFlightWithRepoForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCheckPermissionsForDevcontainerParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesCheckPermissionsForDevcontainerQuerySchema = z.object({
    ref: z.string(),
    devcontainer_path: z.string(),
  })

  const codespacesCheckPermissionsForDevcontainerResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_codespaces_permissions_check_for_devcontainer],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codespacesCheckPermissionsForDevcontainer
  router.get(
    `/repos/:owner/:repo/codespaces/permissions_check`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesCheckPermissionsForDevcontainerParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesCheckPermissionsForDevcontainerQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespaces_permissions_check_for_devcontainer>(
              200,
            )
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCheckPermissionsForDevcontainer(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCheckPermissionsForDevcontainerResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListRepoSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const codespacesListRepoSecretsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            secrets: z.array(s_repo_codespaces_secret),
          }),
        ],
      ],
      undefined,
    )

  // codespacesListRepoSecrets
  router.get(
    `/repos/:owner/:repo/codespaces/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesListRepoSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            codespacesListRepoSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_repo_codespaces_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListRepoSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codespacesListRepoSecretsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetRepoPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesGetRepoPublicKeyResponseBodyValidator =
    responseValidationFactory([["200", s_codespaces_public_key]], undefined)

  // codespacesGetRepoPublicKey
  router.get(
    `/repos/:owner/:repo/codespaces/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetRepoPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespaces_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetRepoPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesGetRepoPublicKeyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const codespacesGetRepoSecretResponseBodyValidator =
    responseValidationFactory([["200", s_repo_codespaces_secret]], undefined)

  // codespacesGetRepoSecret
  router.get(
    `/repos/:owner/:repo/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repo_codespaces_secret>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, codespacesGetRepoSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const codespacesCreateOrUpdateRepoSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // codespacesCreateOrUpdateRepoSecret
  router.put(
    `/repos/:owner/:repo/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesCreateOrUpdateRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesCreateOrUpdateRepoSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCreateOrUpdateRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCreateOrUpdateRepoSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesDeleteRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const codespacesDeleteRepoSecretResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // codespacesDeleteRepoSecret
  router.delete(
    `/repos/:owner/:repo/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesDeleteRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesDeleteRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesDeleteRepoSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListCollaboratorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListCollaboratorsQuerySchema = z.object({
    affiliation: z.enum(["outside", "direct", "all"]).optional().default("all"),
    permission: z
      .enum(["pull", "triage", "push", "maintain", "admin"])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListCollaboratorsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_collaborator)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposListCollaborators
  router.get(
    `/repos/:owner/:repo/collaborators`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListCollaboratorsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListCollaboratorsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_collaborator[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListCollaborators(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposListCollaboratorsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCheckCollaboratorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  const reposCheckCollaboratorResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", z.undefined()],
    ],
    undefined,
  )

  // reposCheckCollaborator
  router.get(
    `/repos/:owner/:repo/collaborators/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCheckCollaboratorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCheckCollaborator(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCheckCollaboratorResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposAddCollaboratorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  const reposAddCollaboratorResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_repository_invitation],
      ["204", z.undefined()],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposAddCollaborator
  router.put(
    `/repos/:owner/:repo/collaborators/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposAddCollaboratorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposAddCollaboratorRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_repository_invitation>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposAddCollaborator(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposAddCollaboratorResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRemoveCollaboratorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  const reposRemoveCollaboratorResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposRemoveCollaborator
  router.delete(
    `/repos/:owner/:repo/collaborators/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRemoveCollaboratorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRemoveCollaborator(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposRemoveCollaboratorResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCollaboratorPermissionLevelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  const reposGetCollaboratorPermissionLevelResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_repository_collaborator_permission],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetCollaboratorPermissionLevel
  router.get(
    `/repos/:owner/:repo/collaborators/:username/permission`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCollaboratorPermissionLevelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_collaborator_permission>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCollaboratorPermissionLevel(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCollaboratorPermissionLevelResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListCommitCommentsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListCommitCommentsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListCommitCommentsForRepoResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_commit_comment)]], undefined)

  // reposListCommitCommentsForRepo
  router.get(
    `/repos/:owner/:repo/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListCommitCommentsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListCommitCommentsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit_comment[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListCommitCommentsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListCommitCommentsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reposGetCommitCommentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_commit_comment],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetCommitComment
  router.get(
    `/repos/:owner/:repo/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCommitCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit_comment>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCommitComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetCommitCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reposUpdateCommitCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_commit_comment],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposUpdateCommitComment
  router.patch(
    `/repos/:owner/:repo/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateCommitCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateCommitCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit_comment>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateCommitComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposUpdateCommitCommentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reposDeleteCommitCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposDeleteCommitComment
  router.delete(
    `/repos/:owner/:repo/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteCommitCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteCommitComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposDeleteCommitCommentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForCommitCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForCommitCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_reaction)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reactionsListForCommitComment
  router.get(
    `/repos/:owner/:repo/comments/:comment_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForCommitCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForCommitCommentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForCommitComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsListForCommitCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForCommitCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_reaction],
        ["201", s_reaction],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reactionsCreateForCommitComment
  router.post(
    `/repos/:owner/:repo/comments/:comment_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForCommitCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForCommitCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForCommitComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsCreateForCommitCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsDeleteForCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  const reactionsDeleteForCommitCommentResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reactionsDeleteForCommitComment
  router.delete(
    `/repos/:owner/:repo/comments/:comment_id/reactions/:reaction_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsDeleteForCommitCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsDeleteForCommitComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsDeleteForCommitCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListCommitsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListCommitsQuerySchema = z.object({
    sha: z.string().optional(),
    path: z.string().optional(),
    author: z.string().optional(),
    committer: z.string().optional(),
    since: z.iso.datetime({offset: true}).optional(),
    until: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListCommitsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_commit)],
      ["400", s_scim_error],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposListCommits
  router.get(
    `/repos/:owner/:repo/commits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListCommitsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListCommitsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListCommits(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListCommitsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListBranchesForHeadCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const reposListBranchesForHeadCommitResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_branch_short)],
        ["409", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposListBranchesForHeadCommit
  router.get(
    `/repos/:owner/:repo/commits/:commit_sha/branches-where-head`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListBranchesForHeadCommitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_branch_short[]>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListBranchesForHeadCommit(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListBranchesForHeadCommitResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListCommentsForCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const reposListCommentsForCommitQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListCommentsForCommitResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_commit_comment)]], undefined)

  // reposListCommentsForCommit
  router.get(
    `/repos/:owner/:repo/commits/:commit_sha/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListCommentsForCommitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListCommentsForCommitQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit_comment[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListCommentsForCommit(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListCommentsForCommitResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const reposCreateCommitCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_commit_comment],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposCreateCommitComment
  router.post(
    `/repos/:owner/:repo/commits/:commit_sha/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateCommitCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateCommitCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_commit_comment>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateCommitComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCreateCommitCommentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListPullRequestsAssociatedWithCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const reposListPullRequestsAssociatedWithCommitQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListPullRequestsAssociatedWithCommitResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_pull_request_simple)],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // reposListPullRequestsAssociatedWithCommit
  router.get(
    `/repos/:owner/:repo/commits/:commit_sha/pulls`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListPullRequestsAssociatedWithCommitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListPullRequestsAssociatedWithCommitQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_simple[]>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListPullRequestsAssociatedWithCommit(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListPullRequestsAssociatedWithCommitResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposGetCommitQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const reposGetCommitResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_commit],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error],
      ["500", s_basic_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // reposGetCommit
  router.get(
    `/repos/:owner/:repo/commits/:ref`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCommitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetCommitQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCommit(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetCommitResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksListForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const checksListForRefQuerySchema = z.object({
    check_name: z.string().optional(),
    status: z.enum(["queued", "in_progress", "completed"]).optional(),
    filter: z.enum(["latest", "all"]).optional().default("latest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    app_id: z.coerce.number().optional(),
  })

  const checksListForRefResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          check_runs: z.array(s_check_run),
        }),
      ],
    ],
    undefined,
  )

  // checksListForRef
  router.get(
    `/repos/:owner/:repo/commits/:ref/check-runs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksListForRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            checksListForRefQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              check_runs: t_check_run[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksListForRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, checksListForRefResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const checksListSuitesForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const checksListSuitesForRefQuerySchema = z.object({
    app_id: z.coerce.number().optional(),
    check_name: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const checksListSuitesForRefResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          check_suites: z.array(s_check_suite),
        }),
      ],
    ],
    undefined,
  )

  // checksListSuitesForRef
  router.get(
    `/repos/:owner/:repo/commits/:ref/check-suites`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            checksListSuitesForRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            checksListSuitesForRefQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              check_suites: t_check_suite[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .checksListSuitesForRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, checksListSuitesForRefResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCombinedStatusForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposGetCombinedStatusForRefQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposGetCombinedStatusForRefResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_combined_commit_status],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetCombinedStatusForRef
  router.get(
    `/repos/:owner/:repo/commits/:ref/status`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCombinedStatusForRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetCombinedStatusForRefQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_combined_commit_status>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCombinedStatusForRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCombinedStatusForRefResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListCommitStatusesForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposListCommitStatusesForRefQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListCommitStatusesForRefResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_status)],
        ["301", s_basic_error],
      ],
      undefined,
    )

  // reposListCommitStatusesForRef
  router.get(
    `/repos/:owner/:repo/commits/:ref/statuses`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListCommitStatusesForRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListCommitStatusesForRefQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_status[]>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListCommitStatusesForRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListCommitStatusesForRefResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCommunityProfileMetricsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetCommunityProfileMetricsResponseBodyValidator =
    responseValidationFactory([["200", s_community_profile]], undefined)

  // reposGetCommunityProfileMetrics
  router.get(
    `/repos/:owner/:repo/community/profile`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCommunityProfileMetricsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_community_profile>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCommunityProfileMetrics(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCommunityProfileMetricsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCompareCommitsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    basehead: z.string(),
  })

  const reposCompareCommitsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const reposCompareCommitsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_commit_comparison],
      ["404", s_basic_error],
      ["500", s_basic_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // reposCompareCommits
  router.get(
    `/repos/:owner/:repo/compare/:basehead`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCompareCommitsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposCompareCommitsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit_comparison>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCompareCommits(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCompareCommitsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetContentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    path: z.string(),
  })

  const reposGetContentQuerySchema = z.object({ref: z.string().optional()})

  const reposGetContentResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.union([
          s_content_directory,
          s_content_file,
          s_content_symlink,
          s_content_submodule,
        ]),
      ],
      ["302", z.undefined()],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetContent
  router.get(
    `/repos/:owner/:repo/contents/:path`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetContentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetContentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              | t_content_directory
              | t_content_file
              | t_content_symlink
              | t_content_submodule
            >(200)
          },
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetContent(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetContentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateOrUpdateFileContentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    path: z.string(),
  })

  const reposCreateOrUpdateFileContentsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_file_commit],
        ["201", s_file_commit],
        ["404", s_basic_error],
        ["409", z.union([s_basic_error, s_repository_rule_violation_error])],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposCreateOrUpdateFileContents
  router.put(
    `/repos/:owner/:repo/contents/:path`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateOrUpdateFileContentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateOrUpdateFileContentsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_file_commit>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_file_commit>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<
              t_basic_error | t_repository_rule_violation_error
            >(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateOrUpdateFileContents(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateOrUpdateFileContentsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteFileParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    path: z.string(),
  })

  const reposDeleteFileResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_file_commit],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // reposDeleteFile
  router.delete(
    `/repos/:owner/:repo/contents/:path`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteFileParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposDeleteFileRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_file_commit>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteFile(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteFileResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListContributorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListContributorsQuerySchema = z.object({
    anon: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListContributorsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_contributor)],
      ["204", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposListContributors
  router.get(
    `/repos/:owner/:repo/contributors`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListContributorsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListContributorsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_contributor[]>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListContributors(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListContributorsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotListAlertsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependabotListAlertsForRepoQuerySchema = z.object({
    state: z.string().optional(),
    severity: z.string().optional(),
    ecosystem: z.string().optional(),
    package: z.string().optional(),
    manifest: z.string().optional(),
    epss_percentage: z.string().optional(),
    has: z.union([z.string(), z.array(z.enum(["patch"]))]).optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z
      .enum(["created", "updated", "epss_percentage"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    first: z.coerce.number().min(1).max(100).optional().default(30),
    last: z.coerce.number().min(1).max(100).optional(),
  })

  const dependabotListAlertsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_dependabot_alert)],
        ["304", z.undefined()],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // dependabotListAlertsForRepo
  router.get(
    `/repos/:owner/:repo/dependabot/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotListAlertsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependabotListAlertsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependabot_alert[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotListAlertsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotListAlertsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotGetAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const dependabotGetAlertResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_dependabot_alert],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // dependabotGetAlert
  router.get(
    `/repos/:owner/:repo/dependabot/alerts/:alert_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotGetAlertParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependabot_alert>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotGetAlert(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, dependabotGetAlertResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotUpdateAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const dependabotUpdateAlertResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_dependabot_alert],
      ["400", s_scim_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // dependabotUpdateAlert
  router.patch(
    `/repos/:owner/:repo/dependabot/alerts/:alert_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotUpdateAlertParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_DependabotUpdateAlertRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependabot_alert>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotUpdateAlert(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, dependabotUpdateAlertResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotListRepoSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependabotListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const dependabotListRepoSecretsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            secrets: z.array(s_dependabot_secret),
          }),
        ],
      ],
      undefined,
    )

  // dependabotListRepoSecrets
  router.get(
    `/repos/:owner/:repo/dependabot/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotListRepoSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependabotListRepoSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_dependabot_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotListRepoSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependabotListRepoSecretsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotGetRepoPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependabotGetRepoPublicKeyResponseBodyValidator =
    responseValidationFactory([["200", s_dependabot_public_key]], undefined)

  // dependabotGetRepoPublicKey
  router.get(
    `/repos/:owner/:repo/dependabot/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotGetRepoPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependabot_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotGetRepoPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotGetRepoPublicKeyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotGetRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const dependabotGetRepoSecretResponseBodyValidator =
    responseValidationFactory([["200", s_dependabot_secret]], undefined)

  // dependabotGetRepoSecret
  router.get(
    `/repos/:owner/:repo/dependabot/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotGetRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependabot_secret>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotGetRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependabotGetRepoSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const dependabotCreateOrUpdateRepoSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // dependabotCreateOrUpdateRepoSecret
  router.put(
    `/repos/:owner/:repo/dependabot/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotCreateOrUpdateRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_DependabotCreateOrUpdateRepoSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotCreateOrUpdateRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotCreateOrUpdateRepoSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependabotDeleteRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const dependabotDeleteRepoSecretResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // dependabotDeleteRepoSecret
  router.delete(
    `/repos/:owner/:repo/dependabot/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependabotDeleteRepoSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependabotDeleteRepoSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependabotDeleteRepoSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependencyGraphDiffRangeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    basehead: z.string(),
  })

  const dependencyGraphDiffRangeQuerySchema = z.object({
    name: z.string().optional(),
  })

  const dependencyGraphDiffRangeResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_dependency_graph_diff],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // dependencyGraphDiffRange
  router.get(
    `/repos/:owner/:repo/dependency-graph/compare/:basehead`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependencyGraphDiffRangeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            dependencyGraphDiffRangeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependency_graph_diff>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependencyGraphDiffRange(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependencyGraphDiffRangeResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependencyGraphExportSbomParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependencyGraphExportSbomResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_dependency_graph_spdx_sbom],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // dependencyGraphExportSbom
  router.get(
    `/repos/:owner/:repo/dependency-graph/sbom`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependencyGraphExportSbomParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_dependency_graph_spdx_sbom>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependencyGraphExportSbom(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, dependencyGraphExportSbomResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const dependencyGraphCreateRepositorySnapshotParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependencyGraphCreateRepositorySnapshotResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "201",
          z.object({
            id: z.coerce.number(),
            created_at: z.string(),
            result: z.string(),
            message: z.string(),
          }),
        ],
      ],
      undefined,
    )

  // dependencyGraphCreateRepositorySnapshot
  router.post(
    `/repos/:owner/:repo/dependency-graph/snapshots`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            dependencyGraphCreateRepositorySnapshotParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_snapshot,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<{
              created_at: string
              id: number
              message: string
              result: string
            }>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .dependencyGraphCreateRepositorySnapshot(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              dependencyGraphCreateRepositorySnapshotResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListDeploymentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListDeploymentsQuerySchema = z.object({
    sha: z.string().optional().default("none"),
    ref: z.string().optional().default("none"),
    task: z.string().optional().default("none"),
    environment: z.string().nullable().optional().default("none"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListDeploymentsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_deployment)]],
    undefined,
  )

  // reposListDeployments
  router.get(
    `/repos/:owner/:repo/deployments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListDeploymentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListDeploymentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListDeployments(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListDeploymentsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateDeploymentResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_deployment],
      ["202", z.object({message: z.string().optional()})],
      ["409", z.undefined()],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateDeployment
  router.post(
    `/repos/:owner/:repo/deployments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateDeploymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateDeploymentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_deployment>(201)
          },
          with202() {
            return new ExpressRuntimeResponse<{
              message?: string | undefined
            }>(202)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateDeployment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateDeploymentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  const reposGetDeploymentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_deployment],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetDeployment
  router.get(
    `/repos/:owner/:repo/deployments/:deployment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetDeploymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetDeployment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetDeploymentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  const reposDeleteDeploymentResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // reposDeleteDeployment
  router.delete(
    `/repos/:owner/:repo/deployments/:deployment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteDeploymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteDeployment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteDeploymentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListDeploymentStatusesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  const reposListDeploymentStatusesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListDeploymentStatusesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_deployment_status)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposListDeploymentStatuses
  router.get(
    `/repos/:owner/:repo/deployments/:deployment_id/statuses`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListDeploymentStatusesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListDeploymentStatusesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment_status[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListDeploymentStatuses(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListDeploymentStatusesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateDeploymentStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  const reposCreateDeploymentStatusResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_deployment_status],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposCreateDeploymentStatus
  router.post(
    `/repos/:owner/:repo/deployments/:deployment_id/statuses`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateDeploymentStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateDeploymentStatusRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_deployment_status>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateDeploymentStatus(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateDeploymentStatusResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetDeploymentStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
    status_id: z.coerce.number(),
  })

  const reposGetDeploymentStatusResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_deployment_status],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetDeploymentStatus
  router.get(
    `/repos/:owner/:repo/deployments/:deployment_id/statuses/:status_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetDeploymentStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment_status>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetDeploymentStatus(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetDeploymentStatusResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateDispatchEventParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateDispatchEventResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposCreateDispatchEvent
  router.post(
    `/repos/:owner/:repo/dispatches`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateDispatchEventParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateDispatchEventRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateDispatchEvent(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCreateDispatchEventResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAllEnvironmentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetAllEnvironmentsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposGetAllEnvironmentsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number().optional(),
            environments: z.array(s_environment).optional(),
          }),
        ],
      ],
      undefined,
    )

  // reposGetAllEnvironments
  router.get(
    `/repos/:owner/:repo/environments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAllEnvironmentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetAllEnvironmentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              environments?: t_environment[] | undefined
              total_count?: number | undefined
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAllEnvironments(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetAllEnvironmentsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetEnvironmentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposGetEnvironmentResponseBodyValidator = responseValidationFactory(
    [["200", s_environment]],
    undefined,
  )

  // reposGetEnvironment
  router.get(
    `/repos/:owner/:repo/environments/:environment_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetEnvironmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_environment>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetEnvironment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetEnvironmentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateOrUpdateEnvironmentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposCreateOrUpdateEnvironmentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_environment],
        ["422", s_basic_error],
      ],
      undefined,
    )

  // reposCreateOrUpdateEnvironment
  router.put(
    `/repos/:owner/:repo/environments/:environment_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateOrUpdateEnvironmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateOrUpdateEnvironmentRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_environment>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_basic_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateOrUpdateEnvironment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateOrUpdateEnvironmentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteAnEnvironmentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposDeleteAnEnvironmentResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposDeleteAnEnvironment
  router.delete(
    `/repos/:owner/:repo/environments/:environment_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteAnEnvironmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteAnEnvironment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposDeleteAnEnvironmentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListDeploymentBranchPoliciesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposListDeploymentBranchPoliciesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListDeploymentBranchPoliciesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            branch_policies: z.array(s_deployment_branch_policy),
          }),
        ],
      ],
      undefined,
    )

  // reposListDeploymentBranchPolicies
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListDeploymentBranchPoliciesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListDeploymentBranchPoliciesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              branch_policies: t_deployment_branch_policy[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListDeploymentBranchPolicies(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListDeploymentBranchPoliciesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposCreateDeploymentBranchPolicyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_deployment_branch_policy],
        ["303", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // reposCreateDeploymentBranchPolicy
  router.post(
    `/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateDeploymentBranchPolicyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_deployment_branch_policy_name_pattern_with_type,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment_branch_policy>(200)
          },
          with303() {
            return new ExpressRuntimeResponse<void>(303)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateDeploymentBranchPolicy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateDeploymentBranchPolicyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    branch_policy_id: z.coerce.number(),
  })

  const reposGetDeploymentBranchPolicyResponseBodyValidator =
    responseValidationFactory([["200", s_deployment_branch_policy]], undefined)

  // reposGetDeploymentBranchPolicy
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetDeploymentBranchPolicyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment_branch_policy>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetDeploymentBranchPolicy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetDeploymentBranchPolicyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    branch_policy_id: z.coerce.number(),
  })

  const reposUpdateDeploymentBranchPolicyResponseBodyValidator =
    responseValidationFactory([["200", s_deployment_branch_policy]], undefined)

  // reposUpdateDeploymentBranchPolicy
  router.put(
    `/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateDeploymentBranchPolicyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_deployment_branch_policy_name_pattern,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment_branch_policy>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateDeploymentBranchPolicy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposUpdateDeploymentBranchPolicyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    branch_policy_id: z.coerce.number(),
  })

  const reposDeleteDeploymentBranchPolicyResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposDeleteDeploymentBranchPolicy
  router.delete(
    `/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteDeploymentBranchPolicyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteDeploymentBranchPolicy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDeleteDeploymentBranchPolicyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAllDeploymentProtectionRulesParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
  })

  const reposGetAllDeploymentProtectionRulesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number().optional(),
            custom_deployment_protection_rules: z
              .array(s_deployment_protection_rule)
              .optional(),
          }),
        ],
      ],
      undefined,
    )

  // reposGetAllDeploymentProtectionRules
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAllDeploymentProtectionRulesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              custom_deployment_protection_rules?:
                | t_deployment_protection_rule[]
                | undefined
              total_count?: number | undefined
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAllDeploymentProtectionRules(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetAllDeploymentProtectionRulesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateDeploymentProtectionRuleParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
  })

  const reposCreateDeploymentProtectionRuleResponseBodyValidator =
    responseValidationFactory(
      [["201", s_deployment_protection_rule]],
      undefined,
    )

  // reposCreateDeploymentProtectionRule
  router.post(
    `/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateDeploymentProtectionRuleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateDeploymentProtectionRuleRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_deployment_protection_rule>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateDeploymentProtectionRule(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateDeploymentProtectionRuleResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListCustomDeploymentRuleIntegrationsParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
  })

  const reposListCustomDeploymentRuleIntegrationsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const reposListCustomDeploymentRuleIntegrationsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number().optional(),
            available_custom_deployment_protection_rule_integrations: z
              .array(s_custom_deployment_rule_app)
              .optional(),
          }),
        ],
      ],
      undefined,
    )

  // reposListCustomDeploymentRuleIntegrations
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules/apps`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListCustomDeploymentRuleIntegrationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListCustomDeploymentRuleIntegrationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              available_custom_deployment_protection_rule_integrations?:
                | t_custom_deployment_rule_app[]
                | undefined
              total_count?: number | undefined
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListCustomDeploymentRuleIntegrations(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListCustomDeploymentRuleIntegrationsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCustomDeploymentProtectionRuleParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    protection_rule_id: z.coerce.number(),
  })

  const reposGetCustomDeploymentProtectionRuleResponseBodyValidator =
    responseValidationFactory(
      [["200", s_deployment_protection_rule]],
      undefined,
    )

  // reposGetCustomDeploymentProtectionRule
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules/:protection_rule_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCustomDeploymentProtectionRuleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deployment_protection_rule>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCustomDeploymentProtectionRule(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCustomDeploymentProtectionRuleResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDisableDeploymentProtectionRuleParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
    protection_rule_id: z.coerce.number(),
  })

  const reposDisableDeploymentProtectionRuleResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposDisableDeploymentProtectionRule
  router.delete(
    `/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules/:protection_rule_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDisableDeploymentProtectionRuleParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDisableDeploymentProtectionRule(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDisableDeploymentProtectionRuleResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListEnvironmentSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const actionsListEnvironmentSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListEnvironmentSecretsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            secrets: z.array(s_actions_secret),
          }),
        ],
      ],
      undefined,
    )

  // actionsListEnvironmentSecrets
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListEnvironmentSecretsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListEnvironmentSecretsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_actions_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListEnvironmentSecrets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListEnvironmentSecretsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetEnvironmentPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const actionsGetEnvironmentPublicKeyResponseBodyValidator =
    responseValidationFactory([["200", s_actions_public_key]], undefined)

  // actionsGetEnvironmentPublicKey
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetEnvironmentPublicKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetEnvironmentPublicKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetEnvironmentPublicKeyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetEnvironmentSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    secret_name: z.string(),
  })

  const actionsGetEnvironmentSecretResponseBodyValidator =
    responseValidationFactory([["200", s_actions_secret]], undefined)

  // actionsGetEnvironmentSecret
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetEnvironmentSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_secret>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetEnvironmentSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetEnvironmentSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateOrUpdateEnvironmentSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    secret_name: z.string(),
  })

  const actionsCreateOrUpdateEnvironmentSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // actionsCreateOrUpdateEnvironmentSecret
  router.put(
    `/repos/:owner/:repo/environments/:environment_name/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateOrUpdateEnvironmentSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateOrUpdateEnvironmentSecretRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateOrUpdateEnvironmentSecret(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateOrUpdateEnvironmentSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteEnvironmentSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    secret_name: z.string(),
  })

  const actionsDeleteEnvironmentSecretResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteEnvironmentSecret
  router.delete(
    `/repos/:owner/:repo/environments/:environment_name/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteEnvironmentSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteEnvironmentSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteEnvironmentSecretResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsListEnvironmentVariablesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const actionsListEnvironmentVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  const actionsListEnvironmentVariablesResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            variables: z.array(s_actions_variable),
          }),
        ],
      ],
      undefined,
    )

  // actionsListEnvironmentVariables
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/variables`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsListEnvironmentVariablesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            actionsListEnvironmentVariablesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              total_count: number
              variables: t_actions_variable[]
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsListEnvironmentVariables(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsListEnvironmentVariablesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsCreateEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const actionsCreateEnvironmentVariableResponseBodyValidator =
    responseValidationFactory([["201", s_empty_object]], undefined)

  // actionsCreateEnvironmentVariable
  router.post(
    `/repos/:owner/:repo/environments/:environment_name/variables`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsCreateEnvironmentVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsCreateEnvironmentVariableRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsCreateEnvironmentVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsCreateEnvironmentVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsGetEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    name: z.string(),
  })

  const actionsGetEnvironmentVariableResponseBodyValidator =
    responseValidationFactory([["200", s_actions_variable]], undefined)

  // actionsGetEnvironmentVariable
  router.get(
    `/repos/:owner/:repo/environments/:environment_name/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsGetEnvironmentVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_variable>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsGetEnvironmentVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsGetEnvironmentVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsUpdateEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
    environment_name: z.string(),
  })

  const actionsUpdateEnvironmentVariableResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsUpdateEnvironmentVariable
  router.patch(
    `/repos/:owner/:repo/environments/:environment_name/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsUpdateEnvironmentVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActionsUpdateEnvironmentVariableRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsUpdateEnvironmentVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsUpdateEnvironmentVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const actionsDeleteEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
    environment_name: z.string(),
  })

  const actionsDeleteEnvironmentVariableResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // actionsDeleteEnvironmentVariable
  router.delete(
    `/repos/:owner/:repo/environments/:environment_name/variables/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            actionsDeleteEnvironmentVariableParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .actionsDeleteEnvironmentVariable(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              actionsDeleteEnvironmentVariableResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListRepoEventsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListRepoEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListRepoEventsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_event)]],
    undefined,
  )

  // activityListRepoEvents
  router.get(
    `/repos/:owner/:repo/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListRepoEventsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListRepoEventsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListRepoEvents(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, activityListRepoEventsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListForksParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListForksQuerySchema = z.object({
    sort: z
      .enum(["newest", "oldest", "stargazers", "watchers"])
      .optional()
      .default("newest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListForksResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_minimal_repository)],
      ["400", s_scim_error],
    ],
    undefined,
  )

  // reposListForks
  router.get(
    `/repos/:owner/:repo/forks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListForksParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListForksQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListForks(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListForksResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateForkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateForkResponseBodyValidator = responseValidationFactory(
    [
      ["202", s_full_repository],
      ["400", s_scim_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateFork
  router.post(
    `/repos/:owner/:repo/forks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateForkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateForkRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_full_repository>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateFork(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateForkResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitCreateBlobParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateBlobResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_short_blob],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", z.union([s_validation_error, s_repository_rule_violation_error])],
    ],
    undefined,
  )

  // gitCreateBlob
  router.post(
    `/repos/:owner/:repo/git/blobs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitCreateBlobParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GitCreateBlobRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_short_blob>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<
              t_validation_error | t_repository_rule_violation_error
            >(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitCreateBlob(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitCreateBlobResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitGetBlobParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    file_sha: z.string(),
  })

  const gitGetBlobResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_blob],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gitGetBlob
  router.get(
    `/repos/:owner/:repo/git/blobs/:file_sha`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitGetBlobParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_blob>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitGetBlob(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitGetBlobResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitCreateCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateCommitResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_git_commit],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gitCreateCommit
  router.post(
    `/repos/:owner/:repo/git/commits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitCreateCommitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GitCreateCommitRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_git_commit>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitCreateCommit(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitCreateCommitResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitGetCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const gitGetCommitResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_git_commit],
      ["404", s_basic_error],
      ["409", s_basic_error],
    ],
    undefined,
  )

  // gitGetCommit
  router.get(
    `/repos/:owner/:repo/git/commits/:commit_sha`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitGetCommitParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_git_commit>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitGetCommit(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitGetCommitResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitListMatchingRefsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const gitListMatchingRefsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_git_ref)],
      ["409", s_basic_error],
    ],
    undefined,
  )

  // gitListMatchingRefs
  router.get(
    `/repos/:owner/:repo/git/matching-refs/:ref`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitListMatchingRefsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_git_ref[]>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitListMatchingRefs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitListMatchingRefsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitGetRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const gitGetRefResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_git_ref],
      ["404", s_basic_error],
      ["409", s_basic_error],
    ],
    undefined,
  )

  // gitGetRef
  router.get(
    `/repos/:owner/:repo/git/ref/:ref`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitGetRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_git_ref>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitGetRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitGetRefResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitCreateRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateRefResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_git_ref],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gitCreateRef
  router.post(
    `/repos/:owner/:repo/git/refs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitCreateRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GitCreateRefRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_git_ref>(201)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitCreateRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitCreateRefResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitUpdateRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const gitUpdateRefResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_git_ref],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gitUpdateRef
  router.patch(
    `/repos/:owner/:repo/git/refs/:ref`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitUpdateRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GitUpdateRefRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_git_ref>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitUpdateRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitUpdateRefResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitDeleteRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const gitDeleteRefResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["409", s_basic_error],
      ["422", z.undefined()],
    ],
    undefined,
  )

  // gitDeleteRef
  router.delete(
    `/repos/:owner/:repo/git/refs/:ref`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitDeleteRefParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitDeleteRef(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitDeleteRefResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitCreateTagParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateTagResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_git_tag],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gitCreateTag
  router.post(
    `/repos/:owner/:repo/git/tags`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitCreateTagParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GitCreateTagRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_git_tag>(201)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitCreateTag(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitCreateTagResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitGetTagParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tag_sha: z.string(),
  })

  const gitGetTagResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_git_tag],
      ["404", s_basic_error],
      ["409", s_basic_error],
    ],
    undefined,
  )

  // gitGetTag
  router.get(
    `/repos/:owner/:repo/git/tags/:tag_sha`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitGetTagParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_git_tag>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitGetTag(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitGetTagResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitCreateTreeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateTreeResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_git_tree],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gitCreateTree
  router.post(
    `/repos/:owner/:repo/git/trees`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitCreateTreeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_GitCreateTreeRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_git_tree>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitCreateTree(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitCreateTreeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const gitGetTreeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tree_sha: z.string(),
  })

  const gitGetTreeQuerySchema = z.object({recursive: z.string().optional()})

  const gitGetTreeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_git_tree],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gitGetTree
  router.get(
    `/repos/:owner/:repo/git/trees/:tree_sha`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gitGetTreeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            gitGetTreeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_git_tree>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gitGetTree(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gitGetTreeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListWebhooksParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListWebhooksQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListWebhooksResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_hook)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposListWebhooks
  router.get(
    `/repos/:owner/:repo/hooks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListWebhooksParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListWebhooksQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListWebhooks(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListWebhooksResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_hook],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateWebhook
  router.post(
    `/repos/:owner/:repo/hooks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateWebhookRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_hook>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposGetWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_hook],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetWebhook
  router.get(
    `/repos/:owner/:repo/hooks/:hook_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposUpdateWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_hook],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposUpdateWebhook
  router.patch(
    `/repos/:owner/:repo/hooks/:hook_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateWebhookRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposUpdateWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposDeleteWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposDeleteWebhook
  router.delete(
    `/repos/:owner/:repo/hooks/:hook_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetWebhookConfigForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposGetWebhookConfigForRepoResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_config]], undefined)

  // reposGetWebhookConfigForRepo
  router.get(
    `/repos/:owner/:repo/hooks/:hook_id/config`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetWebhookConfigForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_config>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetWebhookConfigForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetWebhookConfigForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateWebhookConfigForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposUpdateWebhookConfigForRepoResponseBodyValidator =
    responseValidationFactory([["200", s_webhook_config]], undefined)

  // reposUpdateWebhookConfigForRepo
  router.patch(
    `/repos/:owner/:repo/hooks/:hook_id/config`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateWebhookConfigForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateWebhookConfigForRepoRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_webhook_config>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateWebhookConfigForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposUpdateWebhookConfigForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListWebhookDeliveriesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    cursor: z.string().optional(),
  })

  const reposListWebhookDeliveriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_hook_delivery_item)],
        ["400", s_scim_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposListWebhookDeliveries
  router.get(
    `/repos/:owner/:repo/hooks/:hook_id/deliveries`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListWebhookDeliveriesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListWebhookDeliveriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook_delivery_item[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListWebhookDeliveries(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListWebhookDeliveriesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetWebhookDeliveryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  const reposGetWebhookDeliveryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_hook_delivery],
        ["400", s_scim_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposGetWebhookDelivery
  router.get(
    `/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetWebhookDeliveryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hook_delivery>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetWebhookDelivery(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetWebhookDeliveryResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRedeliverWebhookDeliveryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  const reposRedeliverWebhookDeliveryResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["400", s_scim_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposRedeliverWebhookDelivery
  router.post(
    `/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id/attempts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRedeliverWebhookDeliveryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRedeliverWebhookDelivery(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposRedeliverWebhookDeliveryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposPingWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposPingWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposPingWebhook
  router.post(
    `/repos/:owner/:repo/hooks/:hook_id/pings`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposPingWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposPingWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposPingWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposTestPushWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposTestPushWebhookResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposTestPushWebhook
  router.post(
    `/repos/:owner/:repo/hooks/:hook_id/tests`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposTestPushWebhookParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposTestPushWebhook(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposTestPushWebhookResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsGetImportStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsGetImportStatusResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_import],
        ["404", s_basic_error],
        ["503", s_basic_error],
      ],
      undefined,
    )

  // migrationsGetImportStatus
  router.get(
    `/repos/:owner/:repo/import`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsGetImportStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_import>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsGetImportStatus(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, migrationsGetImportStatusResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsStartImportParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsStartImportResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_import],
      ["404", s_basic_error],
      ["422", s_validation_error],
      ["503", s_basic_error],
    ],
    undefined,
  )

  // migrationsStartImport
  router.put(
    `/repos/:owner/:repo/import`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsStartImportParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_MigrationsStartImportRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_import>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsStartImport(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, migrationsStartImportResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsUpdateImportParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsUpdateImportResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_import],
      ["503", s_basic_error],
    ],
    undefined,
  )

  // migrationsUpdateImport
  router.patch(
    `/repos/:owner/:repo/import`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsUpdateImportParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_MigrationsUpdateImportRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_import>(200)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsUpdateImport(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, migrationsUpdateImportResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsCancelImportParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsCancelImportResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["503", s_basic_error],
    ],
    undefined,
  )

  // migrationsCancelImport
  router.delete(
    `/repos/:owner/:repo/import`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsCancelImportParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsCancelImport(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, migrationsCancelImportResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsGetCommitAuthorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsGetCommitAuthorsQuerySchema = z.object({
    since: z.coerce.number().optional(),
  })

  const migrationsGetCommitAuthorsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_porter_author)],
        ["404", s_basic_error],
        ["503", s_basic_error],
      ],
      undefined,
    )

  // migrationsGetCommitAuthors
  router.get(
    `/repos/:owner/:repo/import/authors`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsGetCommitAuthorsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            migrationsGetCommitAuthorsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_porter_author[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsGetCommitAuthors(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsGetCommitAuthorsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsMapCommitAuthorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    author_id: z.coerce.number(),
  })

  const migrationsMapCommitAuthorResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_porter_author],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["503", s_basic_error],
      ],
      undefined,
    )

  // migrationsMapCommitAuthor
  router.patch(
    `/repos/:owner/:repo/import/authors/:author_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsMapCommitAuthorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_MigrationsMapCommitAuthorRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_porter_author>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsMapCommitAuthor(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, migrationsMapCommitAuthorResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsGetLargeFilesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsGetLargeFilesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_porter_large_file)],
        ["503", s_basic_error],
      ],
      undefined,
    )

  // migrationsGetLargeFiles
  router.get(
    `/repos/:owner/:repo/import/large_files`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsGetLargeFilesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_porter_large_file[]>(200)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsGetLargeFiles(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, migrationsGetLargeFilesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsSetLfsPreferenceParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsSetLfsPreferenceResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_import],
        ["422", s_validation_error],
        ["503", s_basic_error],
      ],
      undefined,
    )

  // migrationsSetLfsPreference
  router.patch(
    `/repos/:owner/:repo/import/lfs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsSetLfsPreferenceParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_MigrationsSetLfsPreferenceRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_import>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<t_basic_error>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsSetLfsPreference(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsSetLfsPreferenceResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetRepoInstallationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const appsGetRepoInstallationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_installation],
        ["301", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // appsGetRepoInstallation
  router.get(
    `/repos/:owner/:repo/installation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetRepoInstallationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_installation>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetRepoInstallation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsGetRepoInstallationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsGetRestrictionsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const interactionsGetRestrictionsForRepoResponseBodyValidator =
    responseValidationFactory(
      [["200", z.union([s_interaction_limit_response, z.object({})])]],
      undefined,
    )

  // interactionsGetRestrictionsForRepo
  router.get(
    `/repos/:owner/:repo/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            interactionsGetRestrictionsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_interaction_limit_response | EmptyObject
            >(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsGetRestrictionsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsGetRestrictionsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsSetRestrictionsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const interactionsSetRestrictionsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_interaction_limit_response],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // interactionsSetRestrictionsForRepo
  router.put(
    `/repos/:owner/:repo/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            interactionsSetRestrictionsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_interaction_limit,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_interaction_limit_response>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsSetRestrictionsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsSetRestrictionsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsRemoveRestrictionsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const interactionsRemoveRestrictionsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["409", z.undefined()],
      ],
      undefined,
    )

  // interactionsRemoveRestrictionsForRepo
  router.delete(
    `/repos/:owner/:repo/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            interactionsRemoveRestrictionsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsRemoveRestrictionsForRepo(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsRemoveRestrictionsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListInvitationsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListInvitationsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_repository_invitation)]],
    undefined,
  )

  // reposListInvitations
  router.get(
    `/repos/:owner/:repo/invitations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListInvitationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListInvitationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_invitation[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListInvitations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListInvitationsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateInvitationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    invitation_id: z.coerce.number(),
  })

  const reposUpdateInvitationResponseBodyValidator = responseValidationFactory(
    [["200", s_repository_invitation]],
    undefined,
  )

  // reposUpdateInvitation
  router.patch(
    `/repos/:owner/:repo/invitations/:invitation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateInvitationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateInvitationRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_invitation>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateInvitation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposUpdateInvitationResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteInvitationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    invitation_id: z.coerce.number(),
  })

  const reposDeleteInvitationResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // reposDeleteInvitation
  router.delete(
    `/repos/:owner/:repo/invitations/:invitation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteInvitationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteInvitation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteInvitationResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListForRepoQuerySchema = z.object({
    milestone: z.string().optional(),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    assignee: z.string().optional(),
    type: z.string().optional(),
    creator: z.string().optional(),
    mentioned: z.string().optional(),
    labels: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListForRepoResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_issue)],
      ["301", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesListForRepo
  router.get(
    `/repos/:owner/:repo/issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue[]>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListForRepoResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesCreateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesCreateResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_issue],
      ["400", s_scim_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
      ["422", s_validation_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // issuesCreate
  router.post(
    `/repos/:owner/:repo/issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesCreateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesCreateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_issue>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesCreate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesCreateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListCommentsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListCommentsForRepoQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListCommentsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_issue_comment)],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // issuesListCommentsForRepo
  router.get(
    `/repos/:owner/:repo/issues/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListCommentsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListCommentsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_comment[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListCommentsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, issuesListCommentsForRepoResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesGetCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const issuesGetCommentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue_comment],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesGetComment
  router.get(
    `/repos/:owner/:repo/issues/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesGetCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_comment>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesGetComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesGetCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesUpdateCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const issuesUpdateCommentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue_comment],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesUpdateComment
  router.patch(
    `/repos/:owner/:repo/issues/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesUpdateCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesUpdateCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_comment>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesUpdateComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesUpdateCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesDeleteCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const issuesDeleteCommentResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // issuesDeleteComment
  router.delete(
    `/repos/:owner/:repo/issues/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesDeleteCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesDeleteComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesDeleteCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForIssueCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForIssueCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForIssueCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_reaction)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reactionsListForIssueComment
  router.get(
    `/repos/:owner/:repo/issues/comments/:comment_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForIssueCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForIssueCommentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForIssueComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsListForIssueCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForIssueCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForIssueCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_reaction],
        ["201", s_reaction],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reactionsCreateForIssueComment
  router.post(
    `/repos/:owner/:repo/issues/comments/:comment_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForIssueCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForIssueCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForIssueComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsCreateForIssueCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsDeleteForIssueCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  const reactionsDeleteForIssueCommentResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reactionsDeleteForIssueComment
  router.delete(
    `/repos/:owner/:repo/issues/comments/:comment_id/reactions/:reaction_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsDeleteForIssueCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsDeleteForIssueComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsDeleteForIssueCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListEventsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListEventsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListEventsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_issue_event)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // issuesListEventsForRepo
  router.get(
    `/repos/:owner/:repo/issues/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListEventsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListEventsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_event[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListEventsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, issuesListEventsForRepoResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesGetEventParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    event_id: z.coerce.number(),
  })

  const issuesGetEventResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue_event],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // issuesGetEvent
  router.get(
    `/repos/:owner/:repo/issues/events/:event_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesGetEventParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_event>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesGetEvent(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesGetEventResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesGetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue],
      ["301", s_basic_error],
      ["304", z.undefined()],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // issuesGet
  router.get(
    `/repos/:owner/:repo/issues/:issue_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesUpdateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesUpdateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue],
      ["301", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
      ["422", s_validation_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // issuesUpdate
  router.patch(
    `/repos/:owner/:repo/issues/:issue_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesUpdateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesUpdateRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesUpdate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesUpdateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesAddAssigneesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddAssigneesResponseBodyValidator = responseValidationFactory(
    [["201", s_issue]],
    undefined,
  )

  // issuesAddAssignees
  router.post(
    `/repos/:owner/:repo/issues/:issue_number/assignees`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesAddAssigneesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesAddAssigneesRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_issue>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesAddAssignees(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesAddAssigneesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesRemoveAssigneesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesRemoveAssigneesResponseBodyValidator = responseValidationFactory(
    [["200", s_issue]],
    undefined,
  )

  // issuesRemoveAssignees
  router.delete(
    `/repos/:owner/:repo/issues/:issue_number/assignees`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesRemoveAssigneesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesRemoveAssigneesRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesRemoveAssignees(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesRemoveAssigneesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesCheckUserCanBeAssignedToIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
    assignee: z.string(),
  })

  const issuesCheckUserCanBeAssignedToIssueResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // issuesCheckUserCanBeAssignedToIssue
  router.get(
    `/repos/:owner/:repo/issues/:issue_number/assignees/:assignee`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesCheckUserCanBeAssignedToIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesCheckUserCanBeAssignedToIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              issuesCheckUserCanBeAssignedToIssueResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListCommentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListCommentsQuerySchema = z.object({
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListCommentsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_issue_comment)],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // issuesListComments
  router.get(
    `/repos/:owner/:repo/issues/:issue_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListCommentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListCommentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_comment[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListComments(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListCommentsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesCreateCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesCreateCommentResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_issue_comment],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesCreateComment
  router.post(
    `/repos/:owner/:repo/issues/:issue_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesCreateCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesCreateCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_issue_comment>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesCreateComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesCreateCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListEventsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListEventsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_issue_event_for_issue)],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // issuesListEvents
  router.get(
    `/repos/:owner/:repo/issues/:issue_number/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListEventsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListEventsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue_event_for_issue[]>(200)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListEvents(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListEventsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListLabelsOnIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListLabelsOnIssueQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListLabelsOnIssueResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_label)],
        ["301", s_basic_error],
        ["404", s_basic_error],
        ["410", s_basic_error],
      ],
      undefined,
    )

  // issuesListLabelsOnIssue
  router.get(
    `/repos/:owner/:repo/issues/:issue_number/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListLabelsOnIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListLabelsOnIssueQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label[]>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListLabelsOnIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, issuesListLabelsOnIssueResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesAddLabelsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddLabelsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_label)],
      ["301", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesAddLabels
  router.post(
    `/repos/:owner/:repo/issues/:issue_number/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesAddLabelsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesAddLabelsRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label[]>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesAddLabels(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesAddLabelsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesSetLabelsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesSetLabelsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_label)],
      ["301", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesSetLabels
  router.put(
    `/repos/:owner/:repo/issues/:issue_number/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesSetLabelsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesSetLabelsRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label[]>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesSetLabels(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesSetLabelsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesRemoveAllLabelsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesRemoveAllLabelsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["301", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // issuesRemoveAllLabels
  router.delete(
    `/repos/:owner/:repo/issues/:issue_number/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesRemoveAllLabelsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesRemoveAllLabels(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesRemoveAllLabelsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesRemoveLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
    name: z.string(),
  })

  const issuesRemoveLabelResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_label)],
      ["301", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // issuesRemoveLabel
  router.delete(
    `/repos/:owner/:repo/issues/:issue_number/labels/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesRemoveLabelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label[]>(200)
          },
          with301() {
            return new ExpressRuntimeResponse<t_basic_error>(301)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesRemoveLabel(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesRemoveLabelResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesLockParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesLockResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesLock
  router.put(
    `/repos/:owner/:repo/issues/:issue_number/lock`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesLockParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesLockRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesLock(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesLockResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesUnlockParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesUnlockResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesUnlock
  router.delete(
    `/repos/:owner/:repo/issues/:issue_number/lock`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesUnlockParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesUnlock(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesUnlockResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const reactionsListForIssueQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForIssueResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_reaction)],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // reactionsListForIssue
  router.get(
    `/repos/:owner/:repo/issues/:issue_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForIssueQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reactionsListForIssueResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const reactionsCreateForIssueResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_reaction],
        ["201", s_reaction],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reactionsCreateForIssue
  router.post(
    `/repos/:owner/:repo/issues/:issue_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForIssueRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reactionsCreateForIssueResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsDeleteForIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  const reactionsDeleteForIssueResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reactionsDeleteForIssue
  router.delete(
    `/repos/:owner/:repo/issues/:issue_number/reactions/:reaction_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsDeleteForIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsDeleteForIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reactionsDeleteForIssueResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesRemoveSubIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesRemoveSubIssueResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_issue],
      ["400", s_scim_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesRemoveSubIssue
  router.delete(
    `/repos/:owner/:repo/issues/:issue_number/sub_issue`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesRemoveSubIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesRemoveSubIssueRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesRemoveSubIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesRemoveSubIssueResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListSubIssuesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListSubIssuesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListSubIssuesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_issue)],
      ["404", s_basic_error],
      ["410", s_basic_error],
    ],
    undefined,
  )

  // issuesListSubIssues
  router.get(
    `/repos/:owner/:repo/issues/:issue_number/sub_issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListSubIssuesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListSubIssuesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListSubIssues(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListSubIssuesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesAddSubIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddSubIssueResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_issue],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["410", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesAddSubIssue
  router.post(
    `/repos/:owner/:repo/issues/:issue_number/sub_issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesAddSubIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesAddSubIssueRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_issue>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesAddSubIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesAddSubIssueResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesReprioritizeSubIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesReprioritizeSubIssueResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_issue],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // issuesReprioritizeSubIssue
  router.patch(
    `/repos/:owner/:repo/issues/:issue_number/sub_issues/priority`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesReprioritizeSubIssueParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesReprioritizeSubIssueRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesReprioritizeSubIssue(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              issuesReprioritizeSubIssueResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListEventsForTimelineParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListEventsForTimelineQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListEventsForTimelineResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_timeline_issue_events)],
        ["404", s_basic_error],
        ["410", s_basic_error],
      ],
      undefined,
    )

  // issuesListEventsForTimeline
  router.get(
    `/repos/:owner/:repo/issues/:issue_number/timeline`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListEventsForTimelineParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListEventsForTimelineQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_timeline_issue_events[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListEventsForTimeline(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              issuesListEventsForTimelineResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListDeployKeysParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListDeployKeysQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListDeployKeysResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_deploy_key)]],
    undefined,
  )

  // reposListDeployKeys
  router.get(
    `/repos/:owner/:repo/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListDeployKeysParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListDeployKeysQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deploy_key[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListDeployKeys(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListDeployKeysResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateDeployKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateDeployKeyResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_deploy_key],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateDeployKey
  router.post(
    `/repos/:owner/:repo/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateDeployKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateDeployKeyRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_deploy_key>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateDeployKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateDeployKeyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetDeployKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    key_id: z.coerce.number(),
  })

  const reposGetDeployKeyResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_deploy_key],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetDeployKey
  router.get(
    `/repos/:owner/:repo/keys/:key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetDeployKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_deploy_key>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetDeployKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetDeployKeyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteDeployKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    key_id: z.coerce.number(),
  })

  const reposDeleteDeployKeyResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // reposDeleteDeployKey
  router.delete(
    `/repos/:owner/:repo/keys/:key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteDeployKeyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteDeployKey(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteDeployKeyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListLabelsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListLabelsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListLabelsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_label)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // issuesListLabelsForRepo
  router.get(
    `/repos/:owner/:repo/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListLabelsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListLabelsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListLabelsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, issuesListLabelsForRepoResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesCreateLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesCreateLabelResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_label],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesCreateLabel
  router.post(
    `/repos/:owner/:repo/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesCreateLabelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesCreateLabelRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_label>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesCreateLabel(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesCreateLabelResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesGetLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const issuesGetLabelResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_label],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesGetLabel
  router.get(
    `/repos/:owner/:repo/labels/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesGetLabelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesGetLabel(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesGetLabelResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesUpdateLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const issuesUpdateLabelResponseBodyValidator = responseValidationFactory(
    [["200", s_label]],
    undefined,
  )

  // issuesUpdateLabel
  router.patch(
    `/repos/:owner/:repo/labels/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesUpdateLabelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesUpdateLabelRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesUpdateLabel(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesUpdateLabelResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesDeleteLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const issuesDeleteLabelResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // issuesDeleteLabel
  router.delete(
    `/repos/:owner/:repo/labels/:name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesDeleteLabelParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesDeleteLabel(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesDeleteLabelResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListLanguagesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListLanguagesResponseBodyValidator = responseValidationFactory(
    [["200", s_language]],
    undefined,
  )

  // reposListLanguages
  router.get(
    `/repos/:owner/:repo/languages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListLanguagesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_language>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListLanguages(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListLanguagesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const licensesGetForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const licensesGetForRepoQuerySchema = z.object({
    ref: s_code_scanning_ref.optional(),
  })

  const licensesGetForRepoResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_license_content],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // licensesGetForRepo
  router.get(
    `/repos/:owner/:repo/license`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            licensesGetForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            licensesGetForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_license_content>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .licensesGetForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, licensesGetForRepoResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposMergeUpstreamParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposMergeUpstreamResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_merged_upstream],
      ["409", z.undefined()],
      ["422", z.undefined()],
    ],
    undefined,
  )

  // reposMergeUpstream
  router.post(
    `/repos/:owner/:repo/merge-upstream`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposMergeUpstreamParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposMergeUpstreamRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_merged_upstream>(200)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposMergeUpstream(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposMergeUpstreamResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposMergeParamSchema = z.object({owner: z.string(), repo: z.string()})

  const reposMergeResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_commit],
      ["204", z.undefined()],
      ["403", s_basic_error],
      ["404", z.undefined()],
      ["409", z.undefined()],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposMerge
  router.post(
    `/repos/:owner/:repo/merges`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposMergeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposMergeRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_commit>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<void>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposMerge(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposMergeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListMilestonesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListMilestonesQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    sort: z.enum(["due_on", "completeness"]).optional().default("due_on"),
    direction: z.enum(["asc", "desc"]).optional().default("asc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListMilestonesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_milestone)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesListMilestones
  router.get(
    `/repos/:owner/:repo/milestones`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListMilestonesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListMilestonesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_milestone[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListMilestones(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesListMilestonesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesCreateMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesCreateMilestoneResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_milestone],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // issuesCreateMilestone
  router.post(
    `/repos/:owner/:repo/milestones`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesCreateMilestoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesCreateMilestoneRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_milestone>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesCreateMilestone(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesCreateMilestoneResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesGetMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesGetMilestoneResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_milestone],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesGetMilestone
  router.get(
    `/repos/:owner/:repo/milestones/:milestone_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesGetMilestoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_milestone>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesGetMilestone(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesGetMilestoneResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesUpdateMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesUpdateMilestoneResponseBodyValidator = responseValidationFactory(
    [["200", s_milestone]],
    undefined,
  )

  // issuesUpdateMilestone
  router.patch(
    `/repos/:owner/:repo/milestones/:milestone_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesUpdateMilestoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IssuesUpdateMilestoneRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_milestone>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesUpdateMilestone(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesUpdateMilestoneResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesDeleteMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesDeleteMilestoneResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // issuesDeleteMilestone
  router.delete(
    `/repos/:owner/:repo/milestones/:milestone_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesDeleteMilestoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesDeleteMilestone(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, issuesDeleteMilestoneResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListLabelsForMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesListLabelsForMilestoneQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListLabelsForMilestoneResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_label)]], undefined)

  // issuesListLabelsForMilestone
  router.get(
    `/repos/:owner/:repo/milestones/:milestone_number/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            issuesListLabelsForMilestoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            issuesListLabelsForMilestoneQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_label[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListLabelsForMilestone(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              issuesListLabelsForMilestoneResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListRepoNotificationsForAuthenticatedUserParamSchema = z.object(
    {owner: z.string(), repo: z.string()},
  )

  const activityListRepoNotificationsForAuthenticatedUserQuerySchema = z.object(
    {
      all: PermissiveBoolean.optional().default(false),
      participating: PermissiveBoolean.optional().default(false),
      since: z.iso.datetime({offset: true}).optional(),
      before: z.iso.datetime({offset: true}).optional(),
      per_page: z.coerce.number().optional().default(30),
      page: z.coerce.number().optional().default(1),
    },
  )

  const activityListRepoNotificationsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_thread)]], undefined)

  // activityListRepoNotificationsForAuthenticatedUser
  router.get(
    `/repos/:owner/:repo/notifications`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListRepoNotificationsForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListRepoNotificationsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_thread[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListRepoNotificationsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListRepoNotificationsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityMarkRepoNotificationsAsReadParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityMarkRepoNotificationsAsReadResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "202",
          z.object({
            message: z.string().optional(),
            url: z.string().optional(),
          }),
        ],
        ["205", z.undefined()],
      ],
      undefined,
    )

  // activityMarkRepoNotificationsAsRead
  router.put(
    `/repos/:owner/:repo/notifications`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityMarkRepoNotificationsAsReadParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActivityMarkRepoNotificationsAsReadRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              message?: string | undefined
              url?: string | undefined
            }>(202)
          },
          with205() {
            return new ExpressRuntimeResponse<void>(205)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityMarkRepoNotificationsAsRead(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityMarkRepoNotificationsAsReadResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetPagesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetPagesResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_page],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetPages
  router.get(
    `/repos/:owner/:repo/pages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetPagesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_page>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetPages(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetPagesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreatePagesSiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreatePagesSiteResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_page],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreatePagesSite
  router.post(
    `/repos/:owner/:repo/pages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreatePagesSiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreatePagesSiteRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_page>(201)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreatePagesSite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreatePagesSiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateInformationAboutPagesSiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposUpdateInformationAboutPagesSiteResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["400", s_scim_error],
        ["409", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposUpdateInformationAboutPagesSite
  router.put(
    `/repos/:owner/:repo/pages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateInformationAboutPagesSiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateInformationAboutPagesSiteRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateInformationAboutPagesSite(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposUpdateInformationAboutPagesSiteResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeletePagesSiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposDeletePagesSiteResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
      ["409", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposDeletePagesSite
  router.delete(
    `/repos/:owner/:repo/pages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeletePagesSiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeletePagesSite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeletePagesSiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListPagesBuildsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListPagesBuildsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListPagesBuildsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_page_build)]],
    undefined,
  )

  // reposListPagesBuilds
  router.get(
    `/repos/:owner/:repo/pages/builds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListPagesBuildsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListPagesBuildsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_page_build[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListPagesBuilds(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListPagesBuildsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposRequestPagesBuildParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposRequestPagesBuildResponseBodyValidator = responseValidationFactory(
    [["201", s_page_build_status]],
    undefined,
  )

  // reposRequestPagesBuild
  router.post(
    `/repos/:owner/:repo/pages/builds`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposRequestPagesBuildParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_page_build_status>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposRequestPagesBuild(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposRequestPagesBuildResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetLatestPagesBuildParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetLatestPagesBuildResponseBodyValidator =
    responseValidationFactory([["200", s_page_build]], undefined)

  // reposGetLatestPagesBuild
  router.get(
    `/repos/:owner/:repo/pages/builds/latest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetLatestPagesBuildParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_page_build>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetLatestPagesBuild(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetLatestPagesBuildResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetPagesBuildParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    build_id: z.coerce.number(),
  })

  const reposGetPagesBuildResponseBodyValidator = responseValidationFactory(
    [["200", s_page_build]],
    undefined,
  )

  // reposGetPagesBuild
  router.get(
    `/repos/:owner/:repo/pages/builds/:build_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetPagesBuildParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_page_build>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetPagesBuild(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetPagesBuildResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreatePagesDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreatePagesDeploymentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_page_deployment],
        ["400", s_scim_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposCreatePagesDeployment
  router.post(
    `/repos/:owner/:repo/pages/deployments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreatePagesDeploymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreatePagesDeploymentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_page_deployment>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreatePagesDeployment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreatePagesDeploymentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetPagesDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pages_deployment_id: z.union([z.coerce.number(), z.string()]),
  })

  const reposGetPagesDeploymentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_pages_deployment_status],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetPagesDeployment
  router.get(
    `/repos/:owner/:repo/pages/deployments/:pages_deployment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetPagesDeploymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pages_deployment_status>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetPagesDeployment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetPagesDeploymentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCancelPagesDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pages_deployment_id: z.union([z.coerce.number(), z.string()]),
  })

  const reposCancelPagesDeploymentResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposCancelPagesDeployment
  router.post(
    `/repos/:owner/:repo/pages/deployments/:pages_deployment_id/cancel`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCancelPagesDeploymentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCancelPagesDeployment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCancelPagesDeploymentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetPagesHealthCheckParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetPagesHealthCheckResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_pages_health_check],
        ["202", s_empty_object],
        ["400", z.undefined()],
        ["404", s_basic_error],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // reposGetPagesHealthCheck
  router.get(
    `/repos/:owner/:repo/pages/health`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetPagesHealthCheckParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pages_health_check>(200)
          },
          with202() {
            return new ExpressRuntimeResponse<t_empty_object>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetPagesHealthCheck(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetPagesHealthCheckResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCheckPrivateVulnerabilityReportingParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCheckPrivateVulnerabilityReportingResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.object({enabled: PermissiveBoolean})],
        ["422", s_scim_error],
      ],
      undefined,
    )

  // reposCheckPrivateVulnerabilityReporting
  router.get(
    `/repos/:owner/:repo/private-vulnerability-reporting`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCheckPrivateVulnerabilityReportingParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              enabled: boolean
            }>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_scim_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCheckPrivateVulnerabilityReporting(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCheckPrivateVulnerabilityReportingResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposEnablePrivateVulnerabilityReportingParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposEnablePrivateVulnerabilityReportingResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["422", s_scim_error],
      ],
      undefined,
    )

  // reposEnablePrivateVulnerabilityReporting
  router.put(
    `/repos/:owner/:repo/private-vulnerability-reporting`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposEnablePrivateVulnerabilityReportingParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<t_scim_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposEnablePrivateVulnerabilityReporting(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposEnablePrivateVulnerabilityReportingResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDisablePrivateVulnerabilityReportingParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposDisablePrivateVulnerabilityReportingResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["422", s_scim_error],
      ],
      undefined,
    )

  // reposDisablePrivateVulnerabilityReporting
  router.delete(
    `/repos/:owner/:repo/private-vulnerability-reporting`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDisablePrivateVulnerabilityReportingParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<t_scim_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDisablePrivateVulnerabilityReporting(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDisablePrivateVulnerabilityReportingResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicListForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const projectsClassicListForRepoQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const projectsClassicListForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_project)],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["410", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicListForRepo
  router.get(
    `/repos/:owner/:repo/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicListForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            projectsClassicListForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicListForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicListForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicCreateForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const projectsClassicCreateForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_project],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["410", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicCreateForRepo
  router.post(
    `/repos/:owner/:repo/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicCreateForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicCreateForRepoRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_project>(201)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with410() {
            return new ExpressRuntimeResponse<t_basic_error>(410)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicCreateForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicCreateForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCustomPropertiesValuesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetCustomPropertiesValuesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_custom_property_value)],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetCustomPropertiesValues
  router.get(
    `/repos/:owner/:repo/properties/values`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCustomPropertiesValuesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_custom_property_value[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCustomPropertiesValues(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCustomPropertiesValuesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateOrUpdateCustomPropertiesValuesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateOrUpdateCustomPropertiesValuesResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposCreateOrUpdateCustomPropertiesValues
  router.patch(
    `/repos/:owner/:repo/properties/values`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateOrUpdateCustomPropertiesValuesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateOrUpdateCustomPropertiesValuesRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateOrUpdateCustomPropertiesValues(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateOrUpdateCustomPropertiesValuesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListParamSchema = z.object({owner: z.string(), repo: z.string()})

  const pullsListQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    head: z.string().optional(),
    base: z.string().optional(),
    sort: z
      .enum(["created", "updated", "popularity", "long-running"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const pullsListResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_pull_request_simple)],
      ["304", z.undefined()],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // pullsList
  router.get(
    `/repos/:owner/:repo/pulls`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            pullsListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_simple[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsList(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsListResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsCreateParamSchema = z.object({owner: z.string(), repo: z.string()})

  const pullsCreateResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_pull_request],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // pullsCreate
  router.post(
    `/repos/:owner/:repo/pulls`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsCreateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsCreateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_pull_request>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsCreate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsCreateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListReviewCommentsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const pullsListReviewCommentsForRepoQuerySchema = z.object({
    sort: z.enum(["created", "updated", "created_at"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const pullsListReviewCommentsForRepoResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_pull_request_review_comment)]],
      undefined,
    )

  // pullsListReviewCommentsForRepo
  router.get(
    `/repos/:owner/:repo/pulls/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListReviewCommentsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            pullsListReviewCommentsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review_comment[]>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsListReviewCommentsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              pullsListReviewCommentsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsGetReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const pullsGetReviewCommentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request_review_comment],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // pullsGetReviewComment
  router.get(
    `/repos/:owner/:repo/pulls/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsGetReviewCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review_comment>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsGetReviewComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsGetReviewCommentResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsUpdateReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const pullsUpdateReviewCommentResponseBodyValidator =
    responseValidationFactory(
      [["200", s_pull_request_review_comment]],
      undefined,
    )

  // pullsUpdateReviewComment
  router.patch(
    `/repos/:owner/:repo/pulls/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsUpdateReviewCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsUpdateReviewCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review_comment>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsUpdateReviewComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, pullsUpdateReviewCommentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsDeleteReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const pullsDeleteReviewCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // pullsDeleteReviewComment
  router.delete(
    `/repos/:owner/:repo/pulls/comments/:comment_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsDeleteReviewCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsDeleteReviewComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, pullsDeleteReviewCommentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForPullRequestReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForPullRequestReviewCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForPullRequestReviewCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_reaction)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reactionsListForPullRequestReviewComment
  router.get(
    `/repos/:owner/:repo/pulls/comments/:comment_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForPullRequestReviewCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForPullRequestReviewCommentQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForPullRequestReviewComment(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsListForPullRequestReviewCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForPullRequestReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForPullRequestReviewCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_reaction],
        ["201", s_reaction],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reactionsCreateForPullRequestReviewComment
  router.post(
    `/repos/:owner/:repo/pulls/comments/:comment_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForPullRequestReviewCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForPullRequestReviewCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForPullRequestReviewComment(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsCreateForPullRequestReviewCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsDeleteForPullRequestCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  const reactionsDeleteForPullRequestCommentResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reactionsDeleteForPullRequestComment
  router.delete(
    `/repos/:owner/:repo/pulls/comments/:comment_id/reactions/:reaction_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsDeleteForPullRequestCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsDeleteForPullRequestComment(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsDeleteForPullRequestCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsGetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsGetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request],
      ["304", z.undefined()],
      ["404", s_basic_error],
      ["406", s_basic_error],
      ["500", s_basic_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // pullsGet
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsGetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with406() {
            return new ExpressRuntimeResponse<t_basic_error>(406)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsGet(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsGetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsUpdateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsUpdateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // pullsUpdate
  router.patch(
    `/repos/:owner/:repo/pulls/:pull_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsUpdateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsUpdateRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsUpdate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsUpdateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCreateWithPrForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const codespacesCreateWithPrForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_codespace],
        ["202", s_codespace],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codespacesCreateWithPrForAuthenticatedUser
  router.post(
    `/repos/:owner/:repo/pulls/:pull_number/codespaces`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesCreateWithPrForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesCreateWithPrForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_codespace>(201)
          },
          with202() {
            return new ExpressRuntimeResponse<t_codespace>(202)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCreateWithPrForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCreateWithPrForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListReviewCommentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListReviewCommentsQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const pullsListReviewCommentsResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_pull_request_review_comment)]],
      undefined,
    )

  // pullsListReviewComments
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListReviewCommentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            pullsListReviewCommentsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review_comment[]>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsListReviewComments(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, pullsListReviewCommentsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsCreateReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsCreateReviewCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_pull_request_review_comment],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // pullsCreateReviewComment
  router.post(
    `/repos/:owner/:repo/pulls/:pull_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsCreateReviewCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsCreateReviewCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_pull_request_review_comment>(
              201,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsCreateReviewComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, pullsCreateReviewCommentResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsCreateReplyForReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    comment_id: z.coerce.number(),
  })

  const pullsCreateReplyForReviewCommentResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_pull_request_review_comment],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // pullsCreateReplyForReviewComment
  router.post(
    `/repos/:owner/:repo/pulls/:pull_number/comments/:comment_id/replies`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsCreateReplyForReviewCommentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsCreateReplyForReviewCommentRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_pull_request_review_comment>(
              201,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsCreateReplyForReviewComment(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              pullsCreateReplyForReviewCommentResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListCommitsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListCommitsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const pullsListCommitsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_commit)]],
    undefined,
  )

  // pullsListCommits
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/commits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListCommitsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            pullsListCommitsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsListCommits(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsListCommitsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListFilesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListFilesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const pullsListFilesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_diff_entry)],
      ["422", s_validation_error],
      ["500", s_basic_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // pullsListFiles
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/files`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListFilesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            pullsListFilesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_diff_entry[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsListFiles(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsListFilesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsCheckIfMergedParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsCheckIfMergedResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", z.undefined()],
    ],
    undefined,
  )

  // pullsCheckIfMerged
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/merge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsCheckIfMergedParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsCheckIfMerged(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsCheckIfMergedResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsMergeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsMergeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request_merge_result],
      ["403", s_basic_error],
      ["404", s_basic_error],
      [
        "405",
        z.object({
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
      [
        "409",
        z.object({
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // pullsMerge
  router.put(
    `/repos/:owner/:repo/pulls/:pull_number/merge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsMergeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsMergeRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_merge_result>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with405() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              message?: string | undefined
            }>(405)
          },
          with409() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              message?: string | undefined
            }>(409)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsMerge(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsMergeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListRequestedReviewersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListRequestedReviewersResponseBodyValidator =
    responseValidationFactory(
      [["200", s_pull_request_review_request]],
      undefined,
    )

  // pullsListRequestedReviewers
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/requested_reviewers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListRequestedReviewersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review_request>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsListRequestedReviewers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              pullsListRequestedReviewersResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsRequestReviewersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsRequestReviewersResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_pull_request_simple],
      ["403", s_basic_error],
      ["422", z.undefined()],
    ],
    undefined,
  )

  // pullsRequestReviewers
  router.post(
    `/repos/:owner/:repo/pulls/:pull_number/requested_reviewers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsRequestReviewersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsRequestReviewersRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_pull_request_simple>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsRequestReviewers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsRequestReviewersResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsRemoveRequestedReviewersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsRemoveRequestedReviewersResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_pull_request_simple],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // pullsRemoveRequestedReviewers
  router.delete(
    `/repos/:owner/:repo/pulls/:pull_number/requested_reviewers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsRemoveRequestedReviewersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsRemoveRequestedReviewersRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_simple>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsRemoveRequestedReviewers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              pullsRemoveRequestedReviewersResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListReviewsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListReviewsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const pullsListReviewsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_pull_request_review)]],
    undefined,
  )

  // pullsListReviews
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/reviews`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListReviewsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            pullsListReviewsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsListReviews(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsListReviewsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsCreateReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsCreateReviewResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request_review],
      ["403", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // pullsCreateReview
  router.post(
    `/repos/:owner/:repo/pulls/:pull_number/reviews`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsCreateReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsCreateReviewRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsCreateReview(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsCreateReviewResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsGetReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsGetReviewResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request_review],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // pullsGetReview
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsGetReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsGetReview(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsGetReviewResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsUpdateReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsUpdateReviewResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request_review],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // pullsUpdateReview
  router.put(
    `/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsUpdateReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsUpdateReviewRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsUpdateReview(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsUpdateReviewResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsDeletePendingReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsDeletePendingReviewResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_pull_request_review],
        ["404", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // pullsDeletePendingReview
  router.delete(
    `/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsDeletePendingReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsDeletePendingReview(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, pullsDeletePendingReviewResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsListCommentsForReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsListCommentsForReviewQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const pullsListCommentsForReviewResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_review_comment)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // pullsListCommentsForReview
  router.get(
    `/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsListCommentsForReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            pullsListCommentsForReviewQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_review_comment[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsListCommentsForReview(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              pullsListCommentsForReviewResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsDismissReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsDismissReviewResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request_review],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // pullsDismissReview
  router.put(
    `/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/dismissals`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsDismissReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsDismissReviewRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsDismissReview(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsDismissReviewResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsSubmitReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsSubmitReviewResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_pull_request_review],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // pullsSubmitReview
  router.post(
    `/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsSubmitReviewParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsSubmitReviewRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_pull_request_review>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsSubmitReview(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsSubmitReviewResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const pullsUpdateBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsUpdateBranchResponseBodyValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({message: z.string().optional(), url: z.string().optional()}),
      ],
      ["403", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // pullsUpdateBranch
  router.put(
    `/repos/:owner/:repo/pulls/:pull_number/update-branch`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pullsUpdateBranchParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_PullsUpdateBranchRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              message?: string | undefined
              url?: string | undefined
            }>(202)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .pullsUpdateBranch(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, pullsUpdateBranchResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetReadmeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetReadmeQuerySchema = z.object({ref: z.string().optional()})

  const reposGetReadmeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_content_file],
      ["304", z.undefined()],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposGetReadme
  router.get(
    `/repos/:owner/:repo/readme`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetReadmeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetReadmeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_content_file>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetReadme(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetReadmeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetReadmeInDirectoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    dir: z.string(),
  })

  const reposGetReadmeInDirectoryQuerySchema = z.object({
    ref: z.string().optional(),
  })

  const reposGetReadmeInDirectoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_content_file],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposGetReadmeInDirectory
  router.get(
    `/repos/:owner/:repo/readme/:dir`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetReadmeInDirectoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetReadmeInDirectoryQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_content_file>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetReadmeInDirectory(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetReadmeInDirectoryResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListReleasesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListReleasesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListReleasesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_release)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposListReleases
  router.get(
    `/repos/:owner/:repo/releases`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListReleasesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListReleasesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListReleases(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListReleasesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateReleaseResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_release],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposCreateRelease
  router.post(
    `/repos/:owner/:repo/releases`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateReleaseRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_release>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposCreateReleaseResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    asset_id: z.coerce.number(),
  })

  const reposGetReleaseAssetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_release_asset],
      ["302", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetReleaseAsset
  router.get(
    `/repos/:owner/:repo/releases/assets/:asset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetReleaseAssetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release_asset>(200)
          },
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetReleaseAsset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetReleaseAssetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    asset_id: z.coerce.number(),
  })

  const reposUpdateReleaseAssetResponseBodyValidator =
    responseValidationFactory([["200", s_release_asset]], undefined)

  // reposUpdateReleaseAsset
  router.patch(
    `/repos/:owner/:repo/releases/assets/:asset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateReleaseAssetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateReleaseAssetRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release_asset>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateReleaseAsset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposUpdateReleaseAssetResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    asset_id: z.coerce.number(),
  })

  const reposDeleteReleaseAssetResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposDeleteReleaseAsset
  router.delete(
    `/repos/:owner/:repo/releases/assets/:asset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteReleaseAssetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteReleaseAsset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposDeleteReleaseAssetResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGenerateReleaseNotesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGenerateReleaseNotesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_release_notes_content],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGenerateReleaseNotes
  router.post(
    `/repos/:owner/:repo/releases/generate-notes`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGenerateReleaseNotesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposGenerateReleaseNotesRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release_notes_content>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGenerateReleaseNotes(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGenerateReleaseNotesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetLatestReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetLatestReleaseResponseBodyValidator = responseValidationFactory(
    [["200", s_release]],
    undefined,
  )

  // reposGetLatestRelease
  router.get(
    `/repos/:owner/:repo/releases/latest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetLatestReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetLatestRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetLatestReleaseResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetReleaseByTagParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tag: z.string(),
  })

  const reposGetReleaseByTagResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_release],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetReleaseByTag
  router.get(
    `/repos/:owner/:repo/releases/tags/:tag`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetReleaseByTagParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetReleaseByTag(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetReleaseByTagResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposGetReleaseResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_release],
      ["401", z.undefined()],
    ],
    undefined,
  )

  // reposGetRelease
  router.get(
    `/repos/:owner/:repo/releases/:release_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<void>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetReleaseResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposUpdateReleaseResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_release],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposUpdateRelease
  router.patch(
    `/repos/:owner/:repo/releases/:release_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateReleaseRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposUpdateReleaseResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposDeleteReleaseResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // reposDeleteRelease
  router.delete(
    `/repos/:owner/:repo/releases/:release_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposDeleteReleaseResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListReleaseAssetsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposListReleaseAssetsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListReleaseAssetsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_release_asset)]],
    undefined,
  )

  // reposListReleaseAssets
  router.get(
    `/repos/:owner/:repo/releases/:release_id/assets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListReleaseAssetsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListReleaseAssetsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_release_asset[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListReleaseAssets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposListReleaseAssetsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUploadReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposUploadReleaseAssetQuerySchema = z.object({
    name: z.string(),
    label: z.string().optional(),
  })

  const reposUploadReleaseAssetResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_release_asset],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // reposUploadReleaseAsset
  router.post(
    `/repos/:owner/:repo/releases/:release_id/assets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUploadReleaseAssetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposUploadReleaseAssetQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          // todo: request bodies with content-type 'application/octet-stream' not yet supported
          body: parseRequestInput(
            z.never().optional(),
            req.body,
            RequestInputType.RequestBody,
          ) as never,
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_release_asset>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUploadReleaseAsset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposUploadReleaseAssetResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reactionsListForReleaseQuerySchema = z.object({
    content: z
      .enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForReleaseResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_reaction)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reactionsListForRelease
  router.get(
    `/repos/:owner/:repo/releases/:release_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForReleaseQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reactionsListForReleaseResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reactionsCreateForReleaseResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_reaction],
        ["201", s_reaction],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reactionsCreateForRelease
  router.post(
    `/repos/:owner/:repo/releases/:release_id/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForReleaseRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reactionsCreateForReleaseResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsDeleteForReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  const reactionsDeleteForReleaseResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reactionsDeleteForRelease
  router.delete(
    `/repos/:owner/:repo/releases/:release_id/reactions/:reaction_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsDeleteForReleaseParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsDeleteForRelease(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reactionsDeleteForReleaseResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetBranchRulesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetBranchRulesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposGetBranchRulesResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_repository_rule_detailed)]],
    undefined,
  )

  // reposGetBranchRules
  router.get(
    `/repos/:owner/:repo/rules/branches/:branch`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetBranchRulesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetBranchRulesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_rule_detailed[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetBranchRules(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetBranchRulesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetRepoRulesetsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetRepoRulesetsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    includes_parents: PermissiveBoolean.optional().default(true),
    targets: z.string().optional(),
  })

  const reposGetRepoRulesetsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_repository_ruleset)],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetRepoRulesets
  router.get(
    `/repos/:owner/:repo/rulesets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetRepoRulesetsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetRepoRulesetsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_ruleset[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetRepoRulesets(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetRepoRulesetsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateRepoRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_repository_ruleset],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposCreateRepoRuleset
  router.post(
    `/repos/:owner/:repo/rulesets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateRepoRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateRepoRulesetRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_repository_ruleset>(201)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateRepoRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCreateRepoRulesetResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetRepoRuleSuitesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetRepoRuleSuitesQuerySchema = z.object({
    ref: z.string().optional(),
    time_period: z
      .enum(["hour", "day", "week", "month"])
      .optional()
      .default("day"),
    actor_name: z.string().optional(),
    rule_suite_result: z
      .enum(["pass", "fail", "bypass", "all"])
      .optional()
      .default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposGetRepoRuleSuitesResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_rule_suites],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetRepoRuleSuites
  router.get(
    `/repos/:owner/:repo/rulesets/rule-suites`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetRepoRuleSuitesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetRepoRuleSuitesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_rule_suites>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetRepoRuleSuites(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetRepoRuleSuitesResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetRepoRuleSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    rule_suite_id: z.coerce.number(),
  })

  const reposGetRepoRuleSuiteResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_rule_suite],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetRepoRuleSuite
  router.get(
    `/repos/:owner/:repo/rulesets/rule-suites/:rule_suite_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetRepoRuleSuiteParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_rule_suite>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetRepoRuleSuite(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetRepoRuleSuiteResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposGetRepoRulesetQuerySchema = z.object({
    includes_parents: PermissiveBoolean.optional().default(true),
  })

  const reposGetRepoRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_repository_ruleset],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposGetRepoRuleset
  router.get(
    `/repos/:owner/:repo/rulesets/:ruleset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetRepoRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetRepoRulesetQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_ruleset>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetRepoRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetRepoRulesetResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposUpdateRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposUpdateRepoRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_repository_ruleset],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposUpdateRepoRuleset
  router.put(
    `/repos/:owner/:repo/rulesets/:ruleset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposUpdateRepoRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposUpdateRepoRulesetRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_ruleset>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposUpdateRepoRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposUpdateRepoRulesetResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposDeleteRepoRulesetResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
      ["500", s_basic_error],
    ],
    undefined,
  )

  // reposDeleteRepoRuleset
  router.delete(
    `/repos/:owner/:repo/rulesets/:ruleset_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteRepoRulesetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteRepoRuleset(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposDeleteRepoRulesetResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetRepoRulesetHistoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposGetRepoRulesetHistoryQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposGetRepoRulesetHistoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_ruleset_version)],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // reposGetRepoRulesetHistory
  router.get(
    `/repos/:owner/:repo/rulesets/:ruleset_id/history`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetRepoRulesetHistoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetRepoRulesetHistoryQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ruleset_version[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetRepoRulesetHistory(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetRepoRulesetHistoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetRepoRulesetVersionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
    version_id: z.coerce.number(),
  })

  const reposGetRepoRulesetVersionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_ruleset_version_with_state],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // reposGetRepoRulesetVersion
  router.get(
    `/repos/:owner/:repo/rulesets/:ruleset_id/history/:version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetRepoRulesetVersionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ruleset_version_with_state>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetRepoRulesetVersion(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetRepoRulesetVersionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningListAlertsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const secretScanningListAlertsForRepoQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.string().optional(),
    resolution: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    validity: z.string().optional(),
    is_publicly_leaked: PermissiveBoolean.optional().default(false),
    is_multi_repo: PermissiveBoolean.optional().default(false),
    hide_secret: PermissiveBoolean.optional().default(false),
  })

  const secretScanningListAlertsForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_secret_scanning_alert)],
        ["404", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // secretScanningListAlertsForRepo
  router.get(
    `/repos/:owner/:repo/secret-scanning/alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningListAlertsForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            secretScanningListAlertsForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_secret_scanning_alert[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningListAlertsForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              secretScanningListAlertsForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningGetAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const secretScanningGetAlertQuerySchema = z.object({
    hide_secret: PermissiveBoolean.optional().default(false),
  })

  const secretScanningGetAlertResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_secret_scanning_alert],
      ["304", z.undefined()],
      ["404", z.undefined()],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // secretScanningGetAlert
  router.get(
    `/repos/:owner/:repo/secret-scanning/alerts/:alert_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningGetAlertParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            secretScanningGetAlertQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_secret_scanning_alert>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningGetAlert(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, secretScanningGetAlertResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningUpdateAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const secretScanningUpdateAlertResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_secret_scanning_alert],
        ["400", z.undefined()],
        ["404", z.undefined()],
        ["422", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // secretScanningUpdateAlert
  router.patch(
    `/repos/:owner/:repo/secret-scanning/alerts/:alert_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningUpdateAlertParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_SecretScanningUpdateAlertRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_secret_scanning_alert>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningUpdateAlert(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, secretScanningUpdateAlertResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningListLocationsForAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const secretScanningListLocationsForAlertQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const secretScanningListLocationsForAlertResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_secret_scanning_location)],
        ["404", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // secretScanningListLocationsForAlert
  router.get(
    `/repos/:owner/:repo/secret-scanning/alerts/:alert_number/locations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningListLocationsForAlertParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            secretScanningListLocationsForAlertQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_secret_scanning_location[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningListLocationsForAlert(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              secretScanningListLocationsForAlertResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningCreatePushProtectionBypassParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const secretScanningCreatePushProtectionBypassResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_secret_scanning_push_protection_bypass],
        ["403", z.undefined()],
        ["404", z.undefined()],
        ["422", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // secretScanningCreatePushProtectionBypass
  router.post(
    `/repos/:owner/:repo/secret-scanning/push-protection-bypasses`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningCreatePushProtectionBypassParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_SecretScanningCreatePushProtectionBypassRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_secret_scanning_push_protection_bypass>(
              200,
            )
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningCreatePushProtectionBypass(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              secretScanningCreatePushProtectionBypassResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const secretScanningGetScanHistoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const secretScanningGetScanHistoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_secret_scanning_scan_history],
        ["404", z.undefined()],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // secretScanningGetScanHistory
  router.get(
    `/repos/:owner/:repo/secret-scanning/scan-history`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            secretScanningGetScanHistoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_secret_scanning_scan_history>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .secretScanningGetScanHistory(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              secretScanningGetScanHistoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesListRepositoryAdvisoriesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const securityAdvisoriesListRepositoryAdvisoriesQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .enum(["created", "updated", "published"])
      .optional()
      .default("created"),
    before: z.string().optional(),
    after: z.string().optional(),
    per_page: z.coerce.number().min(1).max(100).optional().default(30),
    state: z.enum(["triage", "draft", "published", "closed"]).optional(),
  })

  const securityAdvisoriesListRepositoryAdvisoriesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_repository_advisory)],
        ["400", s_scim_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // securityAdvisoriesListRepositoryAdvisories
  router.get(
    `/repos/:owner/:repo/security-advisories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesListRepositoryAdvisoriesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            securityAdvisoriesListRepositoryAdvisoriesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_advisory[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesListRepositoryAdvisories(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesListRepositoryAdvisoriesResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesCreateRepositoryAdvisoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const securityAdvisoriesCreateRepositoryAdvisoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_repository_advisory],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // securityAdvisoriesCreateRepositoryAdvisory
  router.post(
    `/repos/:owner/:repo/security-advisories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesCreateRepositoryAdvisoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_repository_advisory_create,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_repository_advisory>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesCreateRepositoryAdvisory(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesCreateRepositoryAdvisoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesCreatePrivateVulnerabilityReportParamSchema =
    z.object({owner: z.string(), repo: z.string()})

  const securityAdvisoriesCreatePrivateVulnerabilityReportResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_repository_advisory],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // securityAdvisoriesCreatePrivateVulnerabilityReport
  router.post(
    `/repos/:owner/:repo/security-advisories/reports`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesCreatePrivateVulnerabilityReportParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_private_vulnerability_report_create,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_repository_advisory>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesCreatePrivateVulnerabilityReport(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesCreatePrivateVulnerabilityReportResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesGetRepositoryAdvisoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ghsa_id: z.string(),
  })

  const securityAdvisoriesGetRepositoryAdvisoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_repository_advisory],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // securityAdvisoriesGetRepositoryAdvisory
  router.get(
    `/repos/:owner/:repo/security-advisories/:ghsa_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesGetRepositoryAdvisoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_advisory>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesGetRepositoryAdvisory(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesGetRepositoryAdvisoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesUpdateRepositoryAdvisoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ghsa_id: z.string(),
  })

  const securityAdvisoriesUpdateRepositoryAdvisoryResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_repository_advisory],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // securityAdvisoriesUpdateRepositoryAdvisory
  router.patch(
    `/repos/:owner/:repo/security-advisories/:ghsa_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesUpdateRepositoryAdvisoryParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_repository_advisory_update,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_advisory>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesUpdateRepositoryAdvisory(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesUpdateRepositoryAdvisoryResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema =
    z.object({owner: z.string(), repo: z.string(), ghsa_id: z.string()})

  const securityAdvisoriesCreateRepositoryAdvisoryCveRequestResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // securityAdvisoriesCreateRepositoryAdvisoryCveRequest
  router.post(
    `/repos/:owner/:repo/security-advisories/:ghsa_id/cve`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesCreateRepositoryAdvisoryCveRequest(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesCreateRepositoryAdvisoryCveRequestResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const securityAdvisoriesCreateForkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ghsa_id: z.string(),
  })

  const securityAdvisoriesCreateForkResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", s_full_repository],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // securityAdvisoriesCreateFork
  router.post(
    `/repos/:owner/:repo/security-advisories/:ghsa_id/forks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            securityAdvisoriesCreateForkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_full_repository>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .securityAdvisoriesCreateFork(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              securityAdvisoriesCreateForkResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListStargazersForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListStargazersForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListStargazersForRepoResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.union([z.array(s_simple_user), z.array(s_stargazer)])],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // activityListStargazersForRepo
  router.get(
    `/repos/:owner/:repo/stargazers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListStargazersForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListStargazersForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[] | t_stargazer[]>(
              200,
            )
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListStargazersForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListStargazersForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCodeFrequencyStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetCodeFrequencyStatsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_code_frequency_stat)],
        ["202", z.record(z.string(), z.unknown())],
        ["204", z.undefined()],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // reposGetCodeFrequencyStats
  router.get(
    `/repos/:owner/:repo/stats/code_frequency`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCodeFrequencyStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_frequency_stat[]>(200)
          },
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCodeFrequencyStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCodeFrequencyStatsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetCommitActivityStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetCommitActivityStatsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_commit_activity)],
        ["202", z.record(z.string(), z.unknown())],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // reposGetCommitActivityStats
  router.get(
    `/repos/:owner/:repo/stats/commit_activity`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetCommitActivityStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_commit_activity[]>(200)
          },
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetCommitActivityStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetCommitActivityStatsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetContributorsStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetContributorsStatsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_contributor_activity)],
        ["202", z.record(z.string(), z.unknown())],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // reposGetContributorsStats
  router.get(
    `/repos/:owner/:repo/stats/contributors`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetContributorsStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_contributor_activity[]>(200)
          },
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetContributorsStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetContributorsStatsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetParticipationStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetParticipationStatsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_participation_stats],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposGetParticipationStats
  router.get(
    `/repos/:owner/:repo/stats/participation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetParticipationStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_participation_stats>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetParticipationStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposGetParticipationStatsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetPunchCardStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetPunchCardStatsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_code_frequency_stat)],
      ["204", z.undefined()],
    ],
    undefined,
  )

  // reposGetPunchCardStats
  router.get(
    `/repos/:owner/:repo/stats/punch_card`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetPunchCardStatsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_code_frequency_stat[]>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetPunchCardStats(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposGetPunchCardStatsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateCommitStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    sha: z.string(),
  })

  const reposCreateCommitStatusResponseBodyValidator =
    responseValidationFactory([["201", s_status]], undefined)

  // reposCreateCommitStatus
  router.post(
    `/repos/:owner/:repo/statuses/:sha`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateCommitStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateCommitStatusRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_status>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateCommitStatus(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCreateCommitStatusResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListWatchersForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListWatchersForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListWatchersForRepoResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_simple_user)]], undefined)

  // activityListWatchersForRepo
  router.get(
    `/repos/:owner/:repo/subscribers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListWatchersForRepoParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListWatchersForRepoQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListWatchersForRepo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListWatchersForRepoResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityGetRepoSubscriptionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityGetRepoSubscriptionResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_repository_subscription],
        ["403", s_basic_error],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // activityGetRepoSubscription
  router.get(
    `/repos/:owner/:repo/subscription`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityGetRepoSubscriptionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_subscription>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityGetRepoSubscription(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityGetRepoSubscriptionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activitySetRepoSubscriptionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activitySetRepoSubscriptionResponseBodyValidator =
    responseValidationFactory([["200", s_repository_subscription]], undefined)

  // activitySetRepoSubscription
  router.put(
    `/repos/:owner/:repo/subscription`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activitySetRepoSubscriptionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ActivitySetRepoSubscriptionRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_subscription>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activitySetRepoSubscription(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activitySetRepoSubscriptionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityDeleteRepoSubscriptionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityDeleteRepoSubscriptionResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // activityDeleteRepoSubscription
  router.delete(
    `/repos/:owner/:repo/subscription`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityDeleteRepoSubscriptionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityDeleteRepoSubscription(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityDeleteRepoSubscriptionResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListTagsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListTagsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListTagsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_tag)]],
    undefined,
  )

  // reposListTags
  router.get(
    `/repos/:owner/:repo/tags`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListTagsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListTagsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tag[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListTags(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListTagsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListTagProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListTagProtectionResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_tag_protection)],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposListTagProtection
  router.get(
    `/repos/:owner/:repo/tags/protection`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListTagProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_tag_protection[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListTagProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposListTagProtectionResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateTagProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateTagProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_tag_protection],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposCreateTagProtection
  router.post(
    `/repos/:owner/:repo/tags/protection`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateTagProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateTagProtectionRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_tag_protection>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateTagProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCreateTagProtectionResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeleteTagProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tag_protection_id: z.coerce.number(),
  })

  const reposDeleteTagProtectionResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposDeleteTagProtection
  router.delete(
    `/repos/:owner/:repo/tags/protection/:tag_protection_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeleteTagProtectionParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeleteTagProtection(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposDeleteTagProtectionResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDownloadTarballArchiveParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposDownloadTarballArchiveResponseBodyValidator =
    responseValidationFactory([["302", z.undefined()]], undefined)

  // reposDownloadTarballArchive
  router.get(
    `/repos/:owner/:repo/tarball/:ref`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDownloadTarballArchiveParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDownloadTarballArchive(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDownloadTarballArchiveResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListTeamsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListTeamsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_team)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposListTeams
  router.get(
    `/repos/:owner/:repo/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListTeamsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListTeamsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListTeams(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListTeamsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetAllTopicsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetAllTopicsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const reposGetAllTopicsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_topic],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // reposGetAllTopics
  router.get(
    `/repos/:owner/:repo/topics`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetAllTopicsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetAllTopicsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_topic>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetAllTopics(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetAllTopicsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposReplaceAllTopicsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposReplaceAllTopicsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_topic],
      ["404", s_basic_error],
      ["422", s_validation_error_simple],
    ],
    undefined,
  )

  // reposReplaceAllTopics
  router.put(
    `/repos/:owner/:repo/topics`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposReplaceAllTopicsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposReplaceAllTopicsRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_topic>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposReplaceAllTopics(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposReplaceAllTopicsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetClonesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetClonesQuerySchema = z.object({
    per: z.enum(["day", "week"]).optional().default("day"),
  })

  const reposGetClonesResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_clone_traffic],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // reposGetClones
  router.get(
    `/repos/:owner/:repo/traffic/clones`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetClonesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetClonesQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_clone_traffic>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetClones(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetClonesResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetTopPathsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetTopPathsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_content_traffic)],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // reposGetTopPaths
  router.get(
    `/repos/:owner/:repo/traffic/popular/paths`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetTopPathsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_content_traffic[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetTopPaths(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetTopPathsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetTopReferrersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetTopReferrersResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_referrer_traffic)],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // reposGetTopReferrers
  router.get(
    `/repos/:owner/:repo/traffic/popular/referrers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetTopReferrersParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_referrer_traffic[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetTopReferrers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetTopReferrersResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposGetViewsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetViewsQuerySchema = z.object({
    per: z.enum(["day", "week"]).optional().default("day"),
  })

  const reposGetViewsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_view_traffic],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // reposGetViews
  router.get(
    `/repos/:owner/:repo/traffic/views`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposGetViewsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposGetViewsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_view_traffic>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposGetViews(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposGetViewsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposTransferParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposTransferResponseBodyValidator = responseValidationFactory(
    [["202", s_minimal_repository]],
    undefined,
  )

  // reposTransfer
  router.post(
    `/repos/:owner/:repo/transfer`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposTransferParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposTransferRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_minimal_repository>(202)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposTransfer(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposTransferResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCheckVulnerabilityAlertsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCheckVulnerabilityAlertsResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // reposCheckVulnerabilityAlerts
  router.get(
    `/repos/:owner/:repo/vulnerability-alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCheckVulnerabilityAlertsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCheckVulnerabilityAlerts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCheckVulnerabilityAlertsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposEnableVulnerabilityAlertsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposEnableVulnerabilityAlertsResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposEnableVulnerabilityAlerts
  router.put(
    `/repos/:owner/:repo/vulnerability-alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposEnableVulnerabilityAlertsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposEnableVulnerabilityAlerts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposEnableVulnerabilityAlertsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDisableVulnerabilityAlertsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposDisableVulnerabilityAlertsResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // reposDisableVulnerabilityAlerts
  router.delete(
    `/repos/:owner/:repo/vulnerability-alerts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDisableVulnerabilityAlertsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDisableVulnerabilityAlerts(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDisableVulnerabilityAlertsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDownloadZipballArchiveParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposDownloadZipballArchiveResponseBodyValidator =
    responseValidationFactory([["302", z.undefined()]], undefined)

  // reposDownloadZipballArchive
  router.get(
    `/repos/:owner/:repo/zipball/:ref`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDownloadZipballArchiveParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDownloadZipballArchive(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDownloadZipballArchiveResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateUsingTemplateParamSchema = z.object({
    template_owner: z.string(),
    template_repo: z.string(),
  })

  const reposCreateUsingTemplateResponseBodyValidator =
    responseValidationFactory([["201", s_full_repository]], undefined)

  // reposCreateUsingTemplate
  router.post(
    `/repos/:template_owner/:template_repo/generate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposCreateUsingTemplateParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateUsingTemplateRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_full_repository>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateUsingTemplate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, reposCreateUsingTemplateResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListPublicQuerySchema = z.object({
    since: z.coerce.number().optional(),
  })

  const reposListPublicResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_minimal_repository)],
      ["304", z.undefined()],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // reposListPublic
  router.get(
    `/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            reposListPublicQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListPublic(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListPublicResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const searchCodeQuerySchema = z.object({
    q: z.string(),
    sort: z.enum(["indexed"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const searchCodeResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          incomplete_results: PermissiveBoolean,
          items: z.array(s_code_search_result_item),
        }),
      ],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["422", s_validation_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // searchCode
  router.get(
    `/search/code`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            searchCodeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              incomplete_results: boolean
              items: t_code_search_result_item[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .searchCode(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, searchCodeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const searchCommitsQuerySchema = z.object({
    q: z.string(),
    sort: z.enum(["author-date", "committer-date"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const searchCommitsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          incomplete_results: PermissiveBoolean,
          items: z.array(s_commit_search_result_item),
        }),
      ],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // searchCommits
  router.get(
    `/search/commits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            searchCommitsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              incomplete_results: boolean
              items: t_commit_search_result_item[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .searchCommits(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, searchCommitsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const searchIssuesAndPullRequestsQuerySchema = z.object({
    q: z.string(),
    sort: z
      .enum([
        "comments",
        "reactions",
        "reactions-+1",
        "reactions--1",
        "reactions-smile",
        "reactions-thinking_face",
        "reactions-heart",
        "reactions-tada",
        "interactions",
        "created",
        "updated",
      ])
      .optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    advanced_search: z.string().optional(),
  })

  const searchIssuesAndPullRequestsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            incomplete_results: PermissiveBoolean,
            items: z.array(s_issue_search_result_item),
          }),
        ],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["422", s_validation_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // searchIssuesAndPullRequests
  router.get(
    `/search/issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            searchIssuesAndPullRequestsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              incomplete_results: boolean
              items: t_issue_search_result_item[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .searchIssuesAndPullRequests(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              searchIssuesAndPullRequestsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const searchLabelsQuerySchema = z.object({
    repository_id: z.coerce.number(),
    q: z.string(),
    sort: z.enum(["created", "updated"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const searchLabelsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          incomplete_results: PermissiveBoolean,
          items: z.array(s_label_search_result_item),
        }),
      ],
      ["304", z.undefined()],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // searchLabels
  router.get(
    `/search/labels`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            searchLabelsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              incomplete_results: boolean
              items: t_label_search_result_item[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .searchLabels(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, searchLabelsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const searchReposQuerySchema = z.object({
    q: z.string(),
    sort: z
      .enum(["stars", "forks", "help-wanted-issues", "updated"])
      .optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const searchReposResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          incomplete_results: PermissiveBoolean,
          items: z.array(s_repo_search_result_item),
        }),
      ],
      ["304", z.undefined()],
      ["422", s_validation_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // searchRepos
  router.get(
    `/search/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            searchReposQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              incomplete_results: boolean
              items: t_repo_search_result_item[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .searchRepos(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, searchReposResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const searchTopicsQuerySchema = z.object({
    q: z.string(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const searchTopicsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          incomplete_results: PermissiveBoolean,
          items: z.array(s_topic_search_result_item),
        }),
      ],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // searchTopics
  router.get(
    `/search/topics`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            searchTopicsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              incomplete_results: boolean
              items: t_topic_search_result_item[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .searchTopics(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, searchTopicsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const searchUsersQuerySchema = z.object({
    q: z.string(),
    sort: z.enum(["followers", "repositories", "joined"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const searchUsersResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          total_count: z.coerce.number(),
          incomplete_results: PermissiveBoolean,
          items: z.array(s_user_search_result_item),
        }),
      ],
      ["304", z.undefined()],
      ["422", s_validation_error],
      [
        "503",
        z.object({
          code: z.string().optional(),
          message: z.string().optional(),
          documentation_url: z.string().optional(),
        }),
      ],
    ],
    undefined,
  )

  // searchUsers
  router.get(
    `/search/users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            searchUsersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              incomplete_results: boolean
              items: t_user_search_result_item[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .searchUsers(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, searchUsersResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetLegacyParamSchema = z.object({team_id: z.coerce.number()})

  const teamsGetLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_team_full],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // teamsGetLegacy
  router.get(
    `/teams/:team_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_full>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsGetLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsUpdateLegacyParamSchema = z.object({team_id: z.coerce.number()})

  const teamsUpdateLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_team_full],
      ["201", s_team_full],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // teamsUpdateLegacy
  router.patch(
    `/teams/:team_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsUpdateLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsUpdateLegacyRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_full>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_team_full>(201)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsUpdateLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsUpdateLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsDeleteLegacyParamSchema = z.object({team_id: z.coerce.number()})

  const teamsDeleteLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // teamsDeleteLegacy
  router.delete(
    `/teams/:team_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsDeleteLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsDeleteLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsDeleteLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListDiscussionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListDiscussionsLegacyQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListDiscussionsLegacyResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_team_discussion)]], undefined)

  // teamsListDiscussionsLegacy
  router.get(
    `/teams/:team_id/discussions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListDiscussionsLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListDiscussionsLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListDiscussionsLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsListDiscussionsLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCreateDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsCreateDiscussionLegacyResponseBodyValidator =
    responseValidationFactory([["201", s_team_discussion]], undefined)

  // teamsCreateDiscussionLegacy
  router.post(
    `/teams/:team_id/discussions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCreateDiscussionLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsCreateDiscussionLegacyRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_team_discussion>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCreateDiscussionLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCreateDiscussionLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsGetDiscussionLegacyResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion]], undefined)

  // teamsGetDiscussionLegacy
  router.get(
    `/teams/:team_id/discussions/:discussion_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetDiscussionLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetDiscussionLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsGetDiscussionLegacyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsUpdateDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionLegacyResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion]], undefined)

  // teamsUpdateDiscussionLegacy
  router.patch(
    `/teams/:team_id/discussions/:discussion_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsUpdateDiscussionLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsUpdateDiscussionLegacyRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsUpdateDiscussionLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsUpdateDiscussionLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsDeleteDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsDeleteDiscussionLegacyResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // teamsDeleteDiscussionLegacy
  router.delete(
    `/teams/:team_id/discussions/:discussion_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsDeleteDiscussionLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsDeleteDiscussionLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsDeleteDiscussionLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListDiscussionCommentsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsListDiscussionCommentsLegacyQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListDiscussionCommentsLegacyResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_team_discussion_comment)]],
      undefined,
    )

  // teamsListDiscussionCommentsLegacy
  router.get(
    `/teams/:team_id/discussions/:discussion_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListDiscussionCommentsLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListDiscussionCommentsLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion_comment[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListDiscussionCommentsLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsListDiscussionCommentsLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCreateDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsCreateDiscussionCommentLegacyResponseBodyValidator =
    responseValidationFactory([["201", s_team_discussion_comment]], undefined)

  // teamsCreateDiscussionCommentLegacy
  router.post(
    `/teams/:team_id/discussions/:discussion_number/comments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCreateDiscussionCommentLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsCreateDiscussionCommentLegacyRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_team_discussion_comment>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCreateDiscussionCommentLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCreateDiscussionCommentLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsGetDiscussionCommentLegacyResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion_comment]], undefined)

  // teamsGetDiscussionCommentLegacy
  router.get(
    `/teams/:team_id/discussions/:discussion_number/comments/:comment_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetDiscussionCommentLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion_comment>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetDiscussionCommentLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsGetDiscussionCommentLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsUpdateDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionCommentLegacyResponseBodyValidator =
    responseValidationFactory([["200", s_team_discussion_comment]], undefined)

  // teamsUpdateDiscussionCommentLegacy
  router.patch(
    `/teams/:team_id/discussions/:discussion_number/comments/:comment_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsUpdateDiscussionCommentLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsUpdateDiscussionCommentLegacyRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_discussion_comment>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsUpdateDiscussionCommentLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsUpdateDiscussionCommentLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsDeleteDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsDeleteDiscussionCommentLegacyResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // teamsDeleteDiscussionCommentLegacy
  router.delete(
    `/teams/:team_id/discussions/:discussion_number/comments/:comment_number`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsDeleteDiscussionCommentLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsDeleteDiscussionCommentLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsDeleteDiscussionCommentLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForTeamDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionCommentLegacyQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForTeamDiscussionCommentLegacyResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_reaction)]], undefined)

  // reactionsListForTeamDiscussionCommentLegacy
  router.get(
    `/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForTeamDiscussionCommentLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForTeamDiscussionCommentLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForTeamDiscussionCommentLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsListForTeamDiscussionCommentLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForTeamDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionCommentLegacyResponseBodyValidator =
    responseValidationFactory([["201", s_reaction]], undefined)

  // reactionsCreateForTeamDiscussionCommentLegacy
  router.post(
    `/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForTeamDiscussionCommentLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForTeamDiscussionCommentLegacyRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForTeamDiscussionCommentLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsCreateForTeamDiscussionCommentLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsListForTeamDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionLegacyQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reactionsListForTeamDiscussionLegacyResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_reaction)]], undefined)

  // reactionsListForTeamDiscussionLegacy
  router.get(
    `/teams/:team_id/discussions/:discussion_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsListForTeamDiscussionLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reactionsListForTeamDiscussionLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_reaction[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsListForTeamDiscussionLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsListForTeamDiscussionLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reactionsCreateForTeamDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionLegacyResponseBodyValidator =
    responseValidationFactory([["201", s_reaction]], undefined)

  // reactionsCreateForTeamDiscussionLegacy
  router.post(
    `/teams/:team_id/discussions/:discussion_number/reactions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reactionsCreateForTeamDiscussionLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ReactionsCreateForTeamDiscussionLegacyRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_reaction>(201)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reactionsCreateForTeamDiscussionLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reactionsCreateForTeamDiscussionLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListPendingInvitationsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListPendingInvitationsLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListPendingInvitationsLegacyResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_organization_invitation)]],
      undefined,
    )

  // teamsListPendingInvitationsLegacy
  router.get(
    `/teams/:team_id/invitations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListPendingInvitationsLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListPendingInvitationsLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_invitation[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListPendingInvitationsLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsListPendingInvitationsLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListMembersLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListMembersLegacyQuerySchema = z.object({
    role: z.enum(["member", "maintainer", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListMembersLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_simple_user)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // teamsListMembersLegacy
  router.get(
    `/teams/:team_id/members`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListMembersLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListMembersLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListMembersLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsListMembersLegacyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  const teamsGetMemberLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["404", z.undefined()],
    ],
    undefined,
  )

  // teamsGetMemberLegacy
  router.get(
    `/teams/:team_id/members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetMemberLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetMemberLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsGetMemberLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsAddMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  const teamsAddMemberLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_basic_error],
      ["404", z.undefined()],
      ["422", z.undefined()],
    ],
    undefined,
  )

  // teamsAddMemberLegacy
  router.put(
    `/teams/:team_id/members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsAddMemberLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsAddMemberLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsAddMemberLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsRemoveMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  const teamsRemoveMemberLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // teamsRemoveMemberLegacy
  router.delete(
    `/teams/:team_id/members/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsRemoveMemberLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsRemoveMemberLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsRemoveMemberLegacyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsGetMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  const teamsGetMembershipForUserLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_membership],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // teamsGetMembershipForUserLegacy
  router.get(
    `/teams/:team_id/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsGetMembershipForUserLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_membership>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsGetMembershipForUserLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsGetMembershipForUserLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsAddOrUpdateMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  const teamsAddOrUpdateMembershipForUserLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_membership],
        ["403", z.undefined()],
        ["404", s_basic_error],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // teamsAddOrUpdateMembershipForUserLegacy
  router.put(
    `/teams/:team_id/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsAddOrUpdateMembershipForUserLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsAddOrUpdateMembershipForUserLegacyRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_membership>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsAddOrUpdateMembershipForUserLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsAddOrUpdateMembershipForUserLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsRemoveMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  const teamsRemoveMembershipForUserLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", z.undefined()],
      ],
      undefined,
    )

  // teamsRemoveMembershipForUserLegacy
  router.delete(
    `/teams/:team_id/memberships/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsRemoveMembershipForUserLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsRemoveMembershipForUserLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsRemoveMembershipForUserLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListProjectsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListProjectsLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListProjectsLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_team_project)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // teamsListProjectsLegacy
  router.get(
    `/teams/:team_id/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListProjectsLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListProjectsLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_project[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListProjectsLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsListProjectsLegacyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCheckPermissionsForProjectLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  const teamsCheckPermissionsForProjectLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_project],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // teamsCheckPermissionsForProjectLegacy
  router.get(
    `/teams/:team_id/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCheckPermissionsForProjectLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_project>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCheckPermissionsForProjectLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCheckPermissionsForProjectLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsAddOrUpdateProjectPermissionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  const teamsAddOrUpdateProjectPermissionsLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        [
          "403",
          z.object({
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // teamsAddOrUpdateProjectPermissionsLegacy
  router.put(
    `/teams/:team_id/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsAddOrUpdateProjectPermissionsLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsAddOrUpdateProjectPermissionsLegacyRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<{
              documentation_url?: string | undefined
              message?: string | undefined
            }>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsAddOrUpdateProjectPermissionsLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsAddOrUpdateProjectPermissionsLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsRemoveProjectLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  const teamsRemoveProjectLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // teamsRemoveProjectLegacy
  router.delete(
    `/teams/:team_id/projects/:project_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsRemoveProjectLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsRemoveProjectLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, teamsRemoveProjectLegacyResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListReposLegacyParamSchema = z.object({team_id: z.coerce.number()})

  const teamsListReposLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListReposLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_minimal_repository)],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // teamsListReposLegacy
  router.get(
    `/teams/:team_id/repos`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListReposLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListReposLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListReposLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsListReposLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsCheckPermissionsForRepoLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsCheckPermissionsForRepoLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_team_repository],
        ["204", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // teamsCheckPermissionsForRepoLegacy
  router.get(
    `/teams/:team_id/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsCheckPermissionsForRepoLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_repository>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsCheckPermissionsForRepoLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsCheckPermissionsForRepoLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsAddOrUpdateRepoPermissionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsAddOrUpdateRepoPermissionsLegacyResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // teamsAddOrUpdateRepoPermissionsLegacy
  router.put(
    `/teams/:team_id/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsAddOrUpdateRepoPermissionsLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TeamsAddOrUpdateRepoPermissionsLegacyRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsAddOrUpdateRepoPermissionsLegacy(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsAddOrUpdateRepoPermissionsLegacyResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsRemoveRepoLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsRemoveRepoLegacyResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // teamsRemoveRepoLegacy
  router.delete(
    `/teams/:team_id/repos/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsRemoveRepoLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsRemoveRepoLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsRemoveRepoLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListChildLegacyParamSchema = z.object({team_id: z.coerce.number()})

  const teamsListChildLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListChildLegacyResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_team)],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // teamsListChildLegacy
  router.get(
    `/teams/:team_id/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            teamsListChildLegacyParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            teamsListChildLegacyQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListChildLegacy(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, teamsListChildLegacyResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersGetAuthenticatedResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.union([s_private_user, s_public_user])],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
    ],
    undefined,
  )

  // usersGetAuthenticated
  router.get(
    `/user`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_private_user | t_public_user>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersGetAuthenticated(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersGetAuthenticatedResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersUpdateAuthenticatedResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_private_user],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersUpdateAuthenticated
  router.patch(
    `/user`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersUpdateAuthenticatedRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_private_user>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersUpdateAuthenticated(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, usersUpdateAuthenticatedResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListBlockedByAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListBlockedByAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersListBlockedByAuthenticatedUser
  router.get(
    `/user/blocks`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListBlockedByAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListBlockedByAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListBlockedByAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersCheckBlockedParamSchema = z.object({username: z.string()})

  const usersCheckBlockedResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // usersCheckBlocked
  router.get(
    `/user/blocks/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersCheckBlockedParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersCheckBlocked(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersCheckBlockedResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersBlockParamSchema = z.object({username: z.string()})

  const usersBlockResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // usersBlock
  router.put(
    `/user/blocks/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersBlockParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersBlock(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersBlockResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersUnblockParamSchema = z.object({username: z.string()})

  const usersUnblockResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // usersUnblock
  router.delete(
    `/user/blocks/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersUnblockParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersUnblock(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersUnblockResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    repository_id: z.coerce.number().optional(),
  })

  const codespacesListForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            codespaces: z.array(s_codespace),
          }),
        ],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesListForAuthenticatedUser
  router.get(
    `/user/codespaces`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            codespacesListForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              codespaces: t_codespace[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesListForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCreateForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_codespace],
        ["202", s_codespace],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // codespacesCreateForAuthenticatedUser
  router.post(
    `/user/codespaces`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_CodespacesCreateForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_codespace>(201)
          },
          with202() {
            return new ExpressRuntimeResponse<t_codespace>(202)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCreateForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCreateForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListSecretsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const codespacesListSecretsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            secrets: z.array(s_codespaces_secret),
          }),
        ],
      ],
      undefined,
    )

  // codespacesListSecretsForAuthenticatedUser
  router.get(
    `/user/codespaces/secrets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            codespacesListSecretsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              secrets: t_codespaces_secret[]
              total_count: number
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListSecretsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesListSecretsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetPublicKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [["200", s_codespaces_user_public_key]],
      undefined,
    )

  // codespacesGetPublicKeyForAuthenticatedUser
  router.get(
    `/user/codespaces/secrets/public-key`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespaces_user_public_key>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetPublicKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesGetPublicKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetSecretForAuthenticatedUserParamSchema = z.object({
    secret_name: z.string(),
  })

  const codespacesGetSecretForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["200", s_codespaces_secret]], undefined)

  // codespacesGetSecretForAuthenticatedUser
  router.get(
    `/user/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetSecretForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespaces_secret>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetSecretForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesGetSecretForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema =
    z.object({secret_name: z.string()})

  const codespacesCreateOrUpdateSecretForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_empty_object],
        ["204", z.undefined()],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // codespacesCreateOrUpdateSecretForAuthenticatedUser
  router.put(
    `/user/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCreateOrUpdateSecretForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCreateOrUpdateSecretForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesDeleteSecretForAuthenticatedUserParamSchema = z.object({
    secret_name: z.string(),
  })

  const codespacesDeleteSecretForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // codespacesDeleteSecretForAuthenticatedUser
  router.delete(
    `/user/codespaces/secrets/:secret_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesDeleteSecretForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesDeleteSecretForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesDeleteSecretForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesListRepositoriesForSecretForAuthenticatedUserParamSchema =
    z.object({secret_name: z.string()})

  const codespacesListRepositoriesForSecretForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repositories: z.array(s_minimal_repository),
          }),
        ],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesListRepositoriesForSecretForAuthenticatedUser
  router.get(
    `/user/codespaces/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_minimal_repository[]
              total_count: number
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesListRepositoriesForSecretForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesListRepositoriesForSecretForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema =
    z.object({secret_name: z.string()})

  const codespacesSetRepositoriesForSecretForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesSetRepositoriesForSecretForAuthenticatedUser
  router.put(
    `/user/codespaces/secrets/:secret_name/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesSetRepositoriesForSecretForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesSetRepositoriesForSecretForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesAddRepositoryForSecretForAuthenticatedUserParamSchema =
    z.object({secret_name: z.string(), repository_id: z.coerce.number()})

  const codespacesAddRepositoryForSecretForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesAddRepositoryForSecretForAuthenticatedUser
  router.put(
    `/user/codespaces/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesAddRepositoryForSecretForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesAddRepositoryForSecretForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema =
    z.object({secret_name: z.string(), repository_id: z.coerce.number()})

  const codespacesRemoveRepositoryForSecretForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesRemoveRepositoryForSecretForAuthenticatedUser
  router.delete(
    `/user/codespaces/secrets/:secret_name/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesRemoveRepositoryForSecretForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesRemoveRepositoryForSecretForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesGetForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_codespace],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesGetForAuthenticatedUser
  router.get(
    `/user/codespaces/:codespace_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespace>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesGetForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesUpdateForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesUpdateForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_codespace],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codespacesUpdateForAuthenticatedUser
  router.patch(
    `/user/codespaces/:codespace_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesUpdateForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesUpdateForAuthenticatedUserRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespace>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesUpdateForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesUpdateForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesDeleteForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesDeleteForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", z.record(z.string(), z.unknown())],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesDeleteForAuthenticatedUser
  router.delete(
    `/user/codespaces/:codespace_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesDeleteForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              [key: string]: unknown | undefined
            }>(202)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesDeleteForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesDeleteForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesExportForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesExportForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["202", s_codespace_export_details],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesExportForAuthenticatedUser
  router.post(
    `/user/codespaces/:codespace_name/exports`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesExportForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<t_codespace_export_details>(202)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesExportForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesExportForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesGetExportDetailsForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
    export_id: z.string(),
  })

  const codespacesGetExportDetailsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_codespace_export_details],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // codespacesGetExportDetailsForAuthenticatedUser
  router.get(
    `/user/codespaces/:codespace_name/exports/:export_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesGetExportDetailsForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespace_export_details>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesGetExportDetailsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesGetExportDetailsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesCodespaceMachinesForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesCodespaceMachinesForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            machines: z.array(s_codespace_machine),
          }),
        ],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesCodespaceMachinesForAuthenticatedUser
  router.get(
    `/user/codespaces/:codespace_name/machines`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesCodespaceMachinesForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              machines: t_codespace_machine[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesCodespaceMachinesForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesCodespaceMachinesForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesPublishForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesPublishForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_codespace_with_full_repository],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // codespacesPublishForAuthenticatedUser
  router.post(
    `/user/codespaces/:codespace_name/publish`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesPublishForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CodespacesPublishForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_codespace_with_full_repository>(
              201,
            )
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesPublishForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesPublishForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesStartForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesStartForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_codespace],
        ["304", z.undefined()],
        ["400", s_scim_error],
        ["401", s_basic_error],
        ["402", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesStartForAuthenticatedUser
  router.post(
    `/user/codespaces/:codespace_name/start`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesStartForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespace>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with402() {
            return new ExpressRuntimeResponse<t_basic_error>(402)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesStartForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesStartForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const codespacesStopForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesStopForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_codespace],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["500", s_basic_error],
      ],
      undefined,
    )

  // codespacesStopForAuthenticatedUser
  router.post(
    `/user/codespaces/:codespace_name/stop`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            codespacesStopForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_codespace>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .codespacesStopForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              codespacesStopForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_package)]], undefined)

  // packagesListDockerMigrationConflictingPackagesForAuthenticatedUser
  router.get(
    `/user/docker/conflicts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesListDockerMigrationConflictingPackagesForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesListDockerMigrationConflictingPackagesForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersSetPrimaryEmailVisibilityForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_email)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersSetPrimaryEmailVisibilityForAuthenticatedUser
  router.patch(
    `/user/email/visibility`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_email[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersSetPrimaryEmailVisibilityForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersSetPrimaryEmailVisibilityForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListEmailsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListEmailsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_email)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersListEmailsForAuthenticatedUser
  router.get(
    `/user/emails`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListEmailsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_email[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListEmailsForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListEmailsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersAddEmailForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.array(s_email)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersAddEmailForAuthenticatedUser
  router.post(
    `/user/emails`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersAddEmailForAuthenticatedUserRequestBody.optional(),
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_email[]>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersAddEmailForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersAddEmailForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeleteEmailForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersDeleteEmailForAuthenticatedUser
  router.delete(
    `/user/emails`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersDeleteEmailForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeleteEmailForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeleteEmailForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListFollowersForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListFollowersForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // usersListFollowersForAuthenticatedUser
  router.get(
    `/user/followers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListFollowersForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListFollowersForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListFollowersForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListFollowedByAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListFollowedByAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_simple_user)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // usersListFollowedByAuthenticatedUser
  router.get(
    `/user/following`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListFollowedByAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListFollowedByAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListFollowedByAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersCheckPersonIsFollowedByAuthenticatedParamSchema = z.object({
    username: z.string(),
  })

  const usersCheckPersonIsFollowedByAuthenticatedResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersCheckPersonIsFollowedByAuthenticated
  router.get(
    `/user/following/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersCheckPersonIsFollowedByAuthenticatedParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersCheckPersonIsFollowedByAuthenticated(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersCheckPersonIsFollowedByAuthenticatedResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersFollowParamSchema = z.object({username: z.string()})

  const usersFollowResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // usersFollow
  router.put(
    `/user/following/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersFollowParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersFollow(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersFollowResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersUnfollowParamSchema = z.object({username: z.string()})

  const usersUnfollowResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["304", z.undefined()],
      ["401", s_basic_error],
      ["403", s_basic_error],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // usersUnfollow
  router.delete(
    `/user/following/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersUnfollowParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersUnfollow(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersUnfollowResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListGpgKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListGpgKeysForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_gpg_key)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersListGpgKeysForAuthenticatedUser
  router.get(
    `/user/gpg_keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListGpgKeysForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gpg_key[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListGpgKeysForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListGpgKeysForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersCreateGpgKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_gpg_key],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersCreateGpgKeyForAuthenticatedUser
  router.post(
    `/user/gpg_keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersCreateGpgKeyForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_gpg_key>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersCreateGpgKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersCreateGpgKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersGetGpgKeyForAuthenticatedUserParamSchema = z.object({
    gpg_key_id: z.coerce.number(),
  })

  const usersGetGpgKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_gpg_key],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersGetGpgKeyForAuthenticatedUser
  router.get(
    `/user/gpg_keys/:gpg_key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersGetGpgKeyForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gpg_key>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersGetGpgKeyForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersGetGpgKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeleteGpgKeyForAuthenticatedUserParamSchema = z.object({
    gpg_key_id: z.coerce.number(),
  })

  const usersDeleteGpgKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersDeleteGpgKeyForAuthenticatedUser
  router.delete(
    `/user/gpg_keys/:gpg_key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersDeleteGpgKeyForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeleteGpgKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeleteGpgKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListInstallationsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListInstallationsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            installations: z.array(s_installation),
          }),
        ],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // appsListInstallationsForAuthenticatedUser
  router.get(
    `/user/installations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListInstallationsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              installations: t_installation[]
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListInstallationsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsListInstallationsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListInstallationReposForAuthenticatedUserParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsListInstallationReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListInstallationReposForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            total_count: z.coerce.number(),
            repository_selection: z.string().optional(),
            repositories: z.array(s_repository),
          }),
        ],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // appsListInstallationReposForAuthenticatedUser
  router.get(
    `/user/installations/:installation_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsListInstallationReposForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            appsListInstallationReposForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              repositories: t_repository[]
              repository_selection?: string | undefined
              total_count: number
            }>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListInstallationReposForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsListInstallationReposForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsAddRepoToInstallationForAuthenticatedUserParamSchema = z.object({
    installation_id: z.coerce.number(),
    repository_id: z.coerce.number(),
  })

  const appsAddRepoToInstallationForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // appsAddRepoToInstallationForAuthenticatedUser
  router.put(
    `/user/installations/:installation_id/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsAddRepoToInstallationForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsAddRepoToInstallationForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsAddRepoToInstallationForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsRemoveRepoFromInstallationForAuthenticatedUserParamSchema =
    z.object({
      installation_id: z.coerce.number(),
      repository_id: z.coerce.number(),
    })

  const appsRemoveRepoFromInstallationForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", z.undefined()],
      ],
      undefined,
    )

  // appsRemoveRepoFromInstallationForAuthenticatedUser
  router.delete(
    `/user/installations/:installation_id/repositories/:repository_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<void>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsRemoveRepoFromInstallationForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsRemoveRepoFromInstallationForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsGetRestrictionsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.union([s_interaction_limit_response, z.object({})])],
        ["204", z.undefined()],
      ],
      undefined,
    )

  // interactionsGetRestrictionsForAuthenticatedUser
  router.get(
    `/user/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_interaction_limit_response | EmptyObject
            >(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsGetRestrictionsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsGetRestrictionsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsSetRestrictionsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_interaction_limit_response],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // interactionsSetRestrictionsForAuthenticatedUser
  router.put(
    `/user/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_interaction_limit,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_interaction_limit_response>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsSetRestrictionsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsSetRestrictionsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const interactionsRemoveRestrictionsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["204", z.undefined()]], undefined)

  // interactionsRemoveRestrictionsForAuthenticatedUser
  router.delete(
    `/user/interaction-limits`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .interactionsRemoveRestrictionsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              interactionsRemoveRestrictionsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const issuesListForAuthenticatedUserQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional()
      .default("assigned"),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    labels: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const issuesListForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_issue)],
        ["304", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // issuesListForAuthenticatedUser
  router.get(
    `/user/issues`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            issuesListForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_issue[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .issuesListForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              issuesListForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListPublicSshKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListPublicSshKeysForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_key)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersListPublicSshKeysForAuthenticatedUser
  router.get(
    `/user/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListPublicSshKeysForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_key[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListPublicSshKeysForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListPublicSshKeysForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersCreatePublicSshKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_key],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersCreatePublicSshKeyForAuthenticatedUser
  router.post(
    `/user/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersCreatePublicSshKeyForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_key>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersCreatePublicSshKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersCreatePublicSshKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersGetPublicSshKeyForAuthenticatedUserParamSchema = z.object({
    key_id: z.coerce.number(),
  })

  const usersGetPublicSshKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_key],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersGetPublicSshKeyForAuthenticatedUser
  router.get(
    `/user/keys/:key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersGetPublicSshKeyForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_key>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersGetPublicSshKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersGetPublicSshKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeletePublicSshKeyForAuthenticatedUserParamSchema = z.object({
    key_id: z.coerce.number(),
  })

  const usersDeletePublicSshKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersDeletePublicSshKeyForAuthenticatedUser
  router.delete(
    `/user/keys/:key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersDeletePublicSshKeyForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeletePublicSshKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeletePublicSshKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListSubscriptionsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListSubscriptionsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_user_marketplace_purchase)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // appsListSubscriptionsForAuthenticatedUser
  router.get(
    `/user/marketplace_purchases`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListSubscriptionsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_user_marketplace_purchase[]>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListSubscriptionsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsListSubscriptionsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsListSubscriptionsForAuthenticatedUserStubbedQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const appsListSubscriptionsForAuthenticatedUserStubbedResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_user_marketplace_purchase)],
        ["304", z.undefined()],
        ["401", s_basic_error],
      ],
      undefined,
    )

  // appsListSubscriptionsForAuthenticatedUserStubbed
  router.get(
    `/user/marketplace_purchases/stubbed`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            appsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_user_marketplace_purchase[]>(
              200,
            )
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsListSubscriptionsForAuthenticatedUserStubbed(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              appsListSubscriptionsForAuthenticatedUserStubbedResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListMembershipsForAuthenticatedUserQuerySchema = z.object({
    state: z.enum(["active", "pending"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListMembershipsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_org_membership)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // orgsListMembershipsForAuthenticatedUser
  router.get(
    `/user/memberships/orgs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            orgsListMembershipsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_membership[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListMembershipsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListMembershipsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsGetMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
  })

  const orgsGetMembershipForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_org_membership],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // orgsGetMembershipForAuthenticatedUser
  router.get(
    `/user/memberships/orgs/:org`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsGetMembershipForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_membership>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsGetMembershipForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsGetMembershipForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsUpdateMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
  })

  const orgsUpdateMembershipForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_org_membership],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // orgsUpdateMembershipForAuthenticatedUser
  router.patch(
    `/user/memberships/orgs/:org`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsUpdateMembershipForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OrgsUpdateMembershipForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_org_membership>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsUpdateMembershipForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsUpdateMembershipForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const migrationsListForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_migration)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // migrationsListForAuthenticatedUser
  router.get(
    `/user/migrations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            migrationsListForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_migration[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsListForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsListForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsStartForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_migration],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // migrationsStartForAuthenticatedUser
  router.post(
    `/user/migrations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_MigrationsStartForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_migration>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsStartForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsStartForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsGetStatusForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsGetStatusForAuthenticatedUserQuerySchema = z.object({
    exclude: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()),
      )
      .optional(),
  })

  const migrationsGetStatusForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_migration],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsGetStatusForAuthenticatedUser
  router.get(
    `/user/migrations/:migration_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsGetStatusForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            migrationsGetStatusForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_migration>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsGetStatusForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsGetStatusForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsGetArchiveForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsGetArchiveForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["302", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // migrationsGetArchiveForAuthenticatedUser
  router.get(
    `/user/migrations/:migration_id/archive`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsGetArchiveForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with302() {
            return new ExpressRuntimeResponse<void>(302)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsGetArchiveForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsGetArchiveForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsDeleteArchiveForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsDeleteArchiveForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsDeleteArchiveForAuthenticatedUser
  router.delete(
    `/user/migrations/:migration_id/archive`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsDeleteArchiveForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsDeleteArchiveForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsDeleteArchiveForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsUnlockRepoForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
    repo_name: z.string(),
  })

  const migrationsUnlockRepoForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsUnlockRepoForAuthenticatedUser
  router.delete(
    `/user/migrations/:migration_id/repos/:repo_name/lock`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsUnlockRepoForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsUnlockRepoForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsUnlockRepoForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const migrationsListReposForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsListReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const migrationsListReposForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_minimal_repository)],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // migrationsListReposForAuthenticatedUser
  router.get(
    `/user/migrations/:migration_id/repositories`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            migrationsListReposForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            migrationsListReposForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .migrationsListReposForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              migrationsListReposForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_organization_simple)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // orgsListForAuthenticatedUser
  router.get(
    `/user/orgs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            orgsListForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_simple[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              orgsListForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesListPackagesForAuthenticatedUserQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const packagesListPackagesForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package)],
        ["400", z.undefined()],
      ],
      undefined,
    )

  // packagesListPackagesForAuthenticatedUser
  router.get(
    `/user/packages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            packagesListPackagesForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesListPackagesForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesListPackagesForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetPackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
  })

  const packagesGetPackageForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["200", s_package]], undefined)

  // packagesGetPackageForAuthenticatedUser
  router.get(
    `/user/packages/:package_type/:package_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetPackageForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetPackageForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetPackageForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesDeletePackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
  })

  const packagesDeletePackageForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesDeletePackageForAuthenticatedUser
  router.delete(
    `/user/packages/:package_type/:package_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesDeletePackageForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesDeletePackageForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesDeletePackageForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesRestorePackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
  })

  const packagesRestorePackageForAuthenticatedUserQuerySchema = z.object({
    token: z.string().optional(),
  })

  const packagesRestorePackageForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesRestorePackageForAuthenticatedUser
  router.post(
    `/user/packages/:package_type/:package_name/restore`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesRestorePackageForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            packagesRestorePackageForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesRestorePackageForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesRestorePackageForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema =
    z.object({
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
    })

  const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema =
    z.object({
      page: z.coerce.number().optional().default(1),
      per_page: z.coerce.number().optional().default(30),
      state: z.enum(["active", "deleted"]).optional().default("active"),
    })

  const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package_version)],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser
  router.get(
    `/user/packages/:package_type/:package_name/versions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package_version[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetPackageVersionForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    package_version_id: z.coerce.number(),
  })

  const packagesGetPackageVersionForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["200", s_package_version]], undefined)

  // packagesGetPackageVersionForAuthenticatedUser
  router.get(
    `/user/packages/:package_type/:package_name/versions/:package_version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetPackageVersionForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package_version>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetPackageVersionForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetPackageVersionForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesDeletePackageVersionForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    package_version_id: z.coerce.number(),
  })

  const packagesDeletePackageVersionForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesDeletePackageVersionForAuthenticatedUser
  router.delete(
    `/user/packages/:package_type/:package_name/versions/:package_version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesDeletePackageVersionForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesDeletePackageVersionForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesDeletePackageVersionForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesRestorePackageVersionForAuthenticatedUserParamSchema = z.object(
    {
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
      package_version_id: z.coerce.number(),
    },
  )

  const packagesRestorePackageVersionForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesRestorePackageVersionForAuthenticatedUser
  router.post(
    `/user/packages/:package_type/:package_name/versions/:package_version_id/restore`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesRestorePackageVersionForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesRestorePackageVersionForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesRestorePackageVersionForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicCreateForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_project],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", s_validation_error_simple],
      ],
      undefined,
    )

  // projectsClassicCreateForAuthenticatedUser
  router.post(
    `/user/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_ProjectsClassicCreateForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_project>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error_simple>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicCreateForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicCreateForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListPublicEmailsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListPublicEmailsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_email)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersListPublicEmailsForAuthenticatedUser
  router.get(
    `/user/public_emails`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListPublicEmailsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_email[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListPublicEmailsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListPublicEmailsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListForAuthenticatedUserQuerySchema = z.object({
    visibility: z.enum(["all", "public", "private"]).optional().default("all"),
    affiliation: z
      .string()
      .optional()
      .default("owner,collaborator,organization_member"),
    type: z
      .enum(["all", "owner", "public", "private", "member"])
      .optional()
      .default("all"),
    sort: z
      .enum(["created", "updated", "pushed", "full_name"])
      .optional()
      .default("full_name"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    since: z.iso.datetime({offset: true}).optional(),
    before: z.iso.datetime({offset: true}).optional(),
  })

  const reposListForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_repository)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposListForAuthenticatedUser
  router.get(
    `/user/repos`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            reposListForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposCreateForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_full_repository],
        ["304", z.undefined()],
        ["400", s_scim_error],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // reposCreateForAuthenticatedUser
  router.post(
    `/user/repos`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_ReposCreateForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_full_repository>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposCreateForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposCreateForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListInvitationsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListInvitationsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_repository_invitation)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // reposListInvitationsForAuthenticatedUser
  router.get(
    `/user/repository_invitations`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            reposListInvitationsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_repository_invitation[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListInvitationsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposListInvitationsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposAcceptInvitationForAuthenticatedUserParamSchema = z.object({
    invitation_id: z.coerce.number(),
  })

  const reposAcceptInvitationForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // reposAcceptInvitationForAuthenticatedUser
  router.patch(
    `/user/repository_invitations/:invitation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposAcceptInvitationForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposAcceptInvitationForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposAcceptInvitationForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposDeclineInvitationForAuthenticatedUserParamSchema = z.object({
    invitation_id: z.coerce.number(),
  })

  const reposDeclineInvitationForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["409", s_basic_error],
      ],
      undefined,
    )

  // reposDeclineInvitationForAuthenticatedUser
  router.delete(
    `/user/repository_invitations/:invitation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposDeclineInvitationForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_basic_error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposDeclineInvitationForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              reposDeclineInvitationForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListSocialAccountsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListSocialAccountsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_social_account)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersListSocialAccountsForAuthenticatedUser
  router.get(
    `/user/social_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListSocialAccountsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_social_account[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListSocialAccountsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListSocialAccountsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersAddSocialAccountForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", z.array(s_social_account)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersAddSocialAccountForAuthenticatedUser
  router.post(
    `/user/social_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersAddSocialAccountForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_social_account[]>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersAddSocialAccountForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersAddSocialAccountForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeleteSocialAccountForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersDeleteSocialAccountForAuthenticatedUser
  router.delete(
    `/user/social_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersDeleteSocialAccountForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeleteSocialAccountForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeleteSocialAccountForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListSshSigningKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListSshSigningKeysForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_ssh_signing_key)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersListSshSigningKeysForAuthenticatedUser
  router.get(
    `/user/ssh_signing_keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListSshSigningKeysForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ssh_signing_key[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListSshSigningKeysForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListSshSigningKeysForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersCreateSshSigningKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["201", s_ssh_signing_key],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // usersCreateSshSigningKeyForAuthenticatedUser
  router.post(
    `/user/ssh_signing_keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_UsersCreateSshSigningKeyForAuthenticatedUserRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_ssh_signing_key>(201)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersCreateSshSigningKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersCreateSshSigningKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersGetSshSigningKeyForAuthenticatedUserParamSchema = z.object({
    ssh_signing_key_id: z.coerce.number(),
  })

  const usersGetSshSigningKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_ssh_signing_key],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersGetSshSigningKeyForAuthenticatedUser
  router.get(
    `/user/ssh_signing_keys/:ssh_signing_key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersGetSshSigningKeyForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ssh_signing_key>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersGetSshSigningKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersGetSshSigningKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeleteSshSigningKeyForAuthenticatedUserParamSchema = z.object({
    ssh_signing_key_id: z.coerce.number(),
  })

  const usersDeleteSshSigningKeyForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersDeleteSshSigningKeyForAuthenticatedUser
  router.delete(
    `/user/ssh_signing_keys/:ssh_signing_key_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeleteSshSigningKeyForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeleteSshSigningKeyForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListReposStarredByAuthenticatedUserQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListReposStarredByAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_starred_repository)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // activityListReposStarredByAuthenticatedUser
  router.get(
    `/user/starred`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            activityListReposStarredByAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_starred_repository[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListReposStarredByAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListReposStarredByAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityCheckRepoIsStarredByAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityCheckRepoIsStarredByAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // activityCheckRepoIsStarredByAuthenticatedUser
  router.get(
    `/user/starred/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityCheckRepoIsStarredByAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityCheckRepoIsStarredByAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityCheckRepoIsStarredByAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityStarRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityStarRepoForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // activityStarRepoForAuthenticatedUser
  router.put(
    `/user/starred/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityStarRepoForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityStarRepoForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityStarRepoForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityUnstarRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityUnstarRepoForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // activityUnstarRepoForAuthenticatedUser
  router.delete(
    `/user/starred/:owner/:repo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityUnstarRepoForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityUnstarRepoForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityUnstarRepoForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListWatchedReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListWatchedReposForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_minimal_repository)],
        ["304", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // activityListWatchedReposForAuthenticatedUser
  router.get(
    `/user/subscriptions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            activityListWatchedReposForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListWatchedReposForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListWatchedReposForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const teamsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const teamsListForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_team_full)],
        ["304", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // teamsListForAuthenticatedUser
  router.get(
    `/user/teams`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            teamsListForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_team_full[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .teamsListForAuthenticatedUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              teamsListForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersGetByIdParamSchema = z.object({account_id: z.coerce.number()})

  const usersGetByIdResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.union([s_private_user, s_public_user])],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // usersGetById
  router.get(
    `/user/:account_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersGetByIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_private_user | t_public_user>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersGetById(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersGetByIdResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListQuerySchema = z.object({
    since: z.coerce.number().optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  const usersListResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_simple_user)],
      ["304", z.undefined()],
    ],
    undefined,
  )

  // usersList
  router.get(
    `/users`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            usersListQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          with304() {
            return new ExpressRuntimeResponse<void>(304)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersList(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersListResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersGetByUsernameParamSchema = z.object({username: z.string()})

  const usersGetByUsernameResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.union([s_private_user, s_public_user])],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // usersGetByUsername
  router.get(
    `/users/:username`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersGetByUsernameParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_private_user | t_public_user>(
              200,
            )
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersGetByUsername(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersGetByUsernameResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListAttestationsBulkParamSchema = z.object({username: z.string()})

  const usersListAttestationsBulkQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
  })

  const usersListAttestationsBulkResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            attestations_subject_digests: z
              .record(
                z.string(),
                z
                  .array(
                    z.object({
                      bundle: z
                        .object({
                          mediaType: z.string().optional(),
                          verificationMaterial: z
                            .record(z.string(), z.unknown())
                            .optional(),
                          dsseEnvelope: z
                            .record(z.string(), z.unknown())
                            .optional(),
                        })
                        .optional(),
                      repository_id: z.coerce.number().optional(),
                      bundle_url: z.string().optional(),
                    }),
                  )
                  .nullable(),
              )
              .optional(),
            page_info: z
              .object({
                has_next: PermissiveBoolean.optional(),
                has_previous: PermissiveBoolean.optional(),
                next: z.string().optional(),
                previous: z.string().optional(),
              })
              .optional(),
          }),
        ],
      ],
      undefined,
    )

  // usersListAttestationsBulk
  router.post(
    `/users/:username/attestations/bulk-list`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListAttestationsBulkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListAttestationsBulkQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            s_UsersListAttestationsBulkRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              attestations_subject_digests?:
                | {
                    [key: string]:
                      | (
                          | {
                              bundle?:
                                | {
                                    dsseEnvelope?:
                                      | {
                                          [key: string]: unknown | undefined
                                        }
                                      | undefined
                                    mediaType?: string | undefined
                                    verificationMaterial?:
                                      | {
                                          [key: string]: unknown | undefined
                                        }
                                      | undefined
                                  }
                                | undefined
                              bundle_url?: string | undefined
                              repository_id?: number | undefined
                            }[]
                          | null
                        )
                      | undefined
                  }
                | undefined
              page_info?:
                | {
                    has_next?: boolean | undefined
                    has_previous?: boolean | undefined
                    next?: string | undefined
                    previous?: string | undefined
                  }
                | undefined
            }>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListAttestationsBulk(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, usersListAttestationsBulkResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeleteAttestationsBulkParamSchema = z.object({
    username: z.string(),
  })

  const usersDeleteAttestationsBulkResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersDeleteAttestationsBulk
  router.post(
    `/users/:username/attestations/delete-request`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersDeleteAttestationsBulkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_UsersDeleteAttestationsBulkRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeleteAttestationsBulk(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeleteAttestationsBulkResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeleteAttestationsBySubjectDigestParamSchema = z.object({
    username: z.string(),
    subject_digest: z.string(),
  })

  const usersDeleteAttestationsBySubjectDigestResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["204", z.undefined()],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersDeleteAttestationsBySubjectDigest
  router.delete(
    `/users/:username/attestations/digest/:subject_digest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersDeleteAttestationsBySubjectDigestParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeleteAttestationsBySubjectDigest(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeleteAttestationsBySubjectDigestResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersDeleteAttestationsByIdParamSchema = z.object({
    username: z.string(),
    attestation_id: z.coerce.number(),
  })

  const usersDeleteAttestationsByIdResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["204", z.undefined()],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // usersDeleteAttestationsById
  router.delete(
    `/users/:username/attestations/:attestation_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersDeleteAttestationsByIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersDeleteAttestationsById(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersDeleteAttestationsByIdResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListAttestationsParamSchema = z.object({
    username: z.string(),
    subject_digest: z.string(),
  })

  const usersListAttestationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    predicate_type: z.string().optional(),
  })

  const usersListAttestationsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          attestations: z
            .array(
              z.object({
                bundle: z
                  .object({
                    mediaType: z.string().optional(),
                    verificationMaterial: z
                      .record(z.string(), z.unknown())
                      .optional(),
                    dsseEnvelope: z.record(z.string(), z.unknown()).optional(),
                  })
                  .optional(),
                repository_id: z.coerce.number().optional(),
                bundle_url: z.string().optional(),
              }),
            )
            .optional(),
        }),
      ],
      ["201", s_empty_object],
      ["204", z.undefined()],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // usersListAttestations
  router.get(
    `/users/:username/attestations/:subject_digest`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListAttestationsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListAttestationsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              attestations?:
                | {
                    bundle?:
                      | {
                          dsseEnvelope?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                          mediaType?: string | undefined
                          verificationMaterial?:
                            | {
                                [key: string]: unknown | undefined
                              }
                            | undefined
                        }
                      | undefined
                    bundle_url?: string | undefined
                    repository_id?: number | undefined
                  }[]
                | undefined
            }>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_empty_object>(201)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListAttestations(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, usersListAttestationsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesListDockerMigrationConflictingPackagesForUserParamSchema =
    z.object({username: z.string()})

  const packagesListDockerMigrationConflictingPackagesForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package)],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // packagesListDockerMigrationConflictingPackagesForUser
  router.get(
    `/users/:username/docker/conflicts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesListDockerMigrationConflictingPackagesForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesListDockerMigrationConflictingPackagesForUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesListDockerMigrationConflictingPackagesForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListEventsForAuthenticatedUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListEventsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListEventsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_event)]], undefined)

  // activityListEventsForAuthenticatedUser
  router.get(
    `/users/:username/events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListEventsForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListEventsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListEventsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListEventsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListOrgEventsForAuthenticatedUserParamSchema = z.object({
    username: z.string(),
    org: z.string(),
  })

  const activityListOrgEventsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListOrgEventsForAuthenticatedUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_event)]], undefined)

  // activityListOrgEventsForAuthenticatedUser
  router.get(
    `/users/:username/events/orgs/:org`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListOrgEventsForAuthenticatedUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListOrgEventsForAuthenticatedUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListOrgEventsForAuthenticatedUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListOrgEventsForAuthenticatedUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListPublicEventsForUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListPublicEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListPublicEventsForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_event)]], undefined)

  // activityListPublicEventsForUser
  router.get(
    `/users/:username/events/public`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListPublicEventsForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListPublicEventsForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListPublicEventsForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListPublicEventsForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListFollowersForUserParamSchema = z.object({username: z.string()})

  const usersListFollowersForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListFollowersForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_simple_user)]], undefined)

  // usersListFollowersForUser
  router.get(
    `/users/:username/followers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListFollowersForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListFollowersForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListFollowersForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, usersListFollowersForUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListFollowingForUserParamSchema = z.object({username: z.string()})

  const usersListFollowingForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListFollowingForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_simple_user)]], undefined)

  // usersListFollowingForUser
  router.get(
    `/users/:username/following`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListFollowingForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListFollowingForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_simple_user[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListFollowingForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, usersListFollowingForUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersCheckFollowingForUserParamSchema = z.object({
    username: z.string(),
    target_user: z.string(),
  })

  const usersCheckFollowingForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["404", z.undefined()],
      ],
      undefined,
    )

  // usersCheckFollowingForUser
  router.get(
    `/users/:username/following/:target_user`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersCheckFollowingForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with404() {
            return new ExpressRuntimeResponse<void>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersCheckFollowingForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersCheckFollowingForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const gistsListForUserParamSchema = z.object({username: z.string()})

  const gistsListForUserQuerySchema = z.object({
    since: z.iso.datetime({offset: true}).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const gistsListForUserResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_base_gist)],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // gistsListForUser
  router.get(
    `/users/:username/gists`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            gistsListForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            gistsListForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_base_gist[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .gistsListForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, gistsListForUserResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListGpgKeysForUserParamSchema = z.object({username: z.string()})

  const usersListGpgKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListGpgKeysForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_gpg_key)]], undefined)

  // usersListGpgKeysForUser
  router.get(
    `/users/:username/gpg_keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListGpgKeysForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListGpgKeysForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_gpg_key[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListGpgKeysForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, usersListGpgKeysForUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersGetContextForUserParamSchema = z.object({username: z.string()})

  const usersGetContextForUserQuerySchema = z.object({
    subject_type: z
      .enum(["organization", "repository", "issue", "pull_request"])
      .optional(),
    subject_id: z.string().optional(),
  })

  const usersGetContextForUserResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_hovercard],
      ["404", s_basic_error],
      ["422", s_validation_error],
    ],
    undefined,
  )

  // usersGetContextForUser
  router.get(
    `/users/:username/hovercard`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersGetContextForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersGetContextForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_hovercard>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersGetContextForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, usersGetContextForUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const appsGetUserInstallationParamSchema = z.object({username: z.string()})

  const appsGetUserInstallationResponseBodyValidator =
    responseValidationFactory([["200", s_installation]], undefined)

  // appsGetUserInstallation
  router.get(
    `/users/:username/installation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            appsGetUserInstallationParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_installation>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .appsGetUserInstallation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, appsGetUserInstallationResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListPublicKeysForUserParamSchema = z.object({username: z.string()})

  const usersListPublicKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListPublicKeysForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_key_simple)]], undefined)

  // usersListPublicKeysForUser
  router.get(
    `/users/:username/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListPublicKeysForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListPublicKeysForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_key_simple[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListPublicKeysForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListPublicKeysForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const orgsListForUserParamSchema = z.object({username: z.string()})

  const orgsListForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const orgsListForUserResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_organization_simple)]],
    undefined,
  )

  // orgsListForUser
  router.get(
    `/users/:username/orgs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            orgsListForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            orgsListForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_organization_simple[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .orgsListForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, orgsListForUserResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesListPackagesForUserParamSchema = z.object({
    username: z.string(),
  })

  const packagesListPackagesForUserQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  const packagesListPackagesForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package)],
        ["400", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
      ],
      undefined,
    )

  // packagesListPackagesForUser
  router.get(
    `/users/:username/packages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesListPackagesForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            packagesListPackagesForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesListPackagesForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesListPackagesForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetPackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
  })

  const packagesGetPackageForUserResponseBodyValidator =
    responseValidationFactory([["200", s_package]], undefined)

  // packagesGetPackageForUser
  router.get(
    `/users/:username/packages/:package_type/:package_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetPackageForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetPackageForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, packagesGetPackageForUserResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesDeletePackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
  })

  const packagesDeletePackageForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesDeletePackageForUser
  router.delete(
    `/users/:username/packages/:package_type/:package_name`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesDeletePackageForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesDeletePackageForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesDeletePackageForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesRestorePackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
  })

  const packagesRestorePackageForUserQuerySchema = z.object({
    token: z.string().optional(),
  })

  const packagesRestorePackageForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesRestorePackageForUser
  router.post(
    `/users/:username/packages/:package_type/:package_name/restore`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesRestorePackageForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            packagesRestorePackageForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesRestorePackageForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesRestorePackageForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByUserParamSchema =
    z.object({
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
      username: z.string(),
    })

  const packagesGetAllPackageVersionsForPackageOwnedByUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_package_version)],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesGetAllPackageVersionsForPackageOwnedByUser
  router.get(
    `/users/:username/packages/:package_type/:package_name/versions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package_version[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetAllPackageVersionsForPackageOwnedByUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetAllPackageVersionsForPackageOwnedByUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesGetPackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    package_version_id: z.coerce.number(),
    username: z.string(),
  })

  const packagesGetPackageVersionForUserResponseBodyValidator =
    responseValidationFactory([["200", s_package_version]], undefined)

  // packagesGetPackageVersionForUser
  router.get(
    `/users/:username/packages/:package_type/:package_name/versions/:package_version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesGetPackageVersionForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_package_version>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesGetPackageVersionForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesGetPackageVersionForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesDeletePackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
    package_version_id: z.coerce.number(),
  })

  const packagesDeletePackageVersionForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesDeletePackageVersionForUser
  router.delete(
    `/users/:username/packages/:package_type/:package_name/versions/:package_version_id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesDeletePackageVersionForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesDeletePackageVersionForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesDeletePackageVersionForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const packagesRestorePackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
    package_version_id: z.coerce.number(),
  })

  const packagesRestorePackageVersionForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_basic_error],
        ["403", s_basic_error],
        ["404", s_basic_error],
      ],
      undefined,
    )

  // packagesRestorePackageVersionForUser
  router.post(
    `/users/:username/packages/:package_type/:package_name/versions/:package_version_id/restore`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            packagesRestorePackageVersionForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_basic_error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .packagesRestorePackageVersionForUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              packagesRestorePackageVersionForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const projectsClassicListForUserParamSchema = z.object({username: z.string()})

  const projectsClassicListForUserQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const projectsClassicListForUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_project)],
        ["422", s_validation_error],
      ],
      undefined,
    )

  // projectsClassicListForUser
  router.get(
    `/users/:username/projects`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            projectsClassicListForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            projectsClassicListForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_project[]>(200)
          },
          with422() {
            return new ExpressRuntimeResponse<t_validation_error>(422)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .projectsClassicListForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              projectsClassicListForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListReceivedEventsForUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReceivedEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListReceivedEventsForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_event)]], undefined)

  // activityListReceivedEventsForUser
  router.get(
    `/users/:username/received_events`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListReceivedEventsForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListReceivedEventsForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListReceivedEventsForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListReceivedEventsForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListReceivedPublicEventsForUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReceivedPublicEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListReceivedPublicEventsForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_event)]], undefined)

  // activityListReceivedPublicEventsForUser
  router.get(
    `/users/:username/received_events/public`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListReceivedPublicEventsForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListReceivedPublicEventsForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_event[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListReceivedPublicEventsForUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListReceivedPublicEventsForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const reposListForUserParamSchema = z.object({username: z.string()})

  const reposListForUserQuerySchema = z.object({
    type: z.enum(["all", "owner", "member"]).optional().default("owner"),
    sort: z
      .enum(["created", "updated", "pushed", "full_name"])
      .optional()
      .default("full_name"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const reposListForUserResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_minimal_repository)]],
    undefined,
  )

  // reposListForUser
  router.get(
    `/users/:username/repos`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reposListForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            reposListForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .reposListForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, reposListForUserResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetGithubActionsBillingUserParamSchema = z.object({
    username: z.string(),
  })

  const billingGetGithubActionsBillingUserResponseBodyValidator =
    responseValidationFactory([["200", s_actions_billing_usage]], undefined)

  // billingGetGithubActionsBillingUser
  router.get(
    `/users/:username/settings/billing/actions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetGithubActionsBillingUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_actions_billing_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetGithubActionsBillingUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetGithubActionsBillingUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetGithubPackagesBillingUserParamSchema = z.object({
    username: z.string(),
  })

  const billingGetGithubPackagesBillingUserResponseBodyValidator =
    responseValidationFactory([["200", s_packages_billing_usage]], undefined)

  // billingGetGithubPackagesBillingUser
  router.get(
    `/users/:username/settings/billing/packages`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetGithubPackagesBillingUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_packages_billing_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetGithubPackagesBillingUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetGithubPackagesBillingUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetSharedStorageBillingUserParamSchema = z.object({
    username: z.string(),
  })

  const billingGetSharedStorageBillingUserResponseBodyValidator =
    responseValidationFactory([["200", s_combined_billing_usage]], undefined)

  // billingGetSharedStorageBillingUser
  router.get(
    `/users/:username/settings/billing/shared-storage`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetSharedStorageBillingUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_combined_billing_usage>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetSharedStorageBillingUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetSharedStorageBillingUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const billingGetGithubBillingUsageReportUserParamSchema = z.object({
    username: z.string(),
  })

  const billingGetGithubBillingUsageReportUserQuerySchema = z.object({
    year: z.coerce.number().optional(),
    month: z.coerce.number().optional(),
    day: z.coerce.number().optional(),
    hour: z.coerce.number().optional(),
  })

  const billingGetGithubBillingUsageReportUserResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_billing_usage_report_user],
        ["400", s_scim_error],
        ["403", s_basic_error],
        ["500", s_basic_error],
        [
          "503",
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            documentation_url: z.string().optional(),
          }),
        ],
      ],
      undefined,
    )

  // billingGetGithubBillingUsageReportUser
  router.get(
    `/users/:username/settings/billing/usage`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            billingGetGithubBillingUsageReportUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            billingGetGithubBillingUsageReportUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_billing_usage_report_user>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_scim_error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_basic_error>(403)
          },
          with500() {
            return new ExpressRuntimeResponse<t_basic_error>(500)
          },
          with503() {
            return new ExpressRuntimeResponse<{
              code?: string | undefined
              documentation_url?: string | undefined
              message?: string | undefined
            }>(503)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .billingGetGithubBillingUsageReportUser(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              billingGetGithubBillingUsageReportUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListSocialAccountsForUserParamSchema = z.object({
    username: z.string(),
  })

  const usersListSocialAccountsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListSocialAccountsForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_social_account)]], undefined)

  // usersListSocialAccountsForUser
  router.get(
    `/users/:username/social_accounts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListSocialAccountsForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListSocialAccountsForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_social_account[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListSocialAccountsForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListSocialAccountsForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const usersListSshSigningKeysForUserParamSchema = z.object({
    username: z.string(),
  })

  const usersListSshSigningKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const usersListSshSigningKeysForUserResponseBodyValidator =
    responseValidationFactory([["200", z.array(s_ssh_signing_key)]], undefined)

  // usersListSshSigningKeysForUser
  router.get(
    `/users/:username/ssh_signing_keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            usersListSshSigningKeysForUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            usersListSshSigningKeysForUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ssh_signing_key[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .usersListSshSigningKeysForUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              usersListSshSigningKeysForUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListReposStarredByUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReposStarredByUserQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListReposStarredByUserResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.array(s_starred_repository), z.array(s_repository)]),
        ],
      ],
      undefined,
    )

  // activityListReposStarredByUser
  router.get(
    `/users/:username/starred`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListReposStarredByUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListReposStarredByUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              t_starred_repository[] | t_repository[]
            >(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListReposStarredByUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListReposStarredByUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const activityListReposWatchedByUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReposWatchedByUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  const activityListReposWatchedByUserResponseBodyValidator =
    responseValidationFactory(
      [["200", z.array(s_minimal_repository)]],
      undefined,
    )

  // activityListReposWatchedByUser
  router.get(
    `/users/:username/subscriptions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            activityListReposWatchedByUserParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            activityListReposWatchedByUserQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_minimal_repository[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .activityListReposWatchedByUser(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              activityListReposWatchedByUserResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const metaGetAllVersionsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(z.string())],
      ["404", s_basic_error],
    ],
    undefined,
  )

  // metaGetAllVersions
  router.get(
    `/versions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string[]>(200)
          },
          with404() {
            return new ExpressRuntimeResponse<t_basic_error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .metaGetAllVersions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, metaGetAllVersionsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const metaGetZenResponseBodyValidator = responseValidationFactory(
    [["200", z.string()]],
    undefined,
  )

  // metaGetZen
  router.get(
    `/zen`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .metaGetZen(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, metaGetZenResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // GitHub v3 REST API
  return startServer(config)
}
