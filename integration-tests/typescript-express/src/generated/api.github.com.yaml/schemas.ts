/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {z} from "zod/v4"

export const PermissiveBoolean = z.preprocess((value) => {
  if (typeof value === "string" && (value === "true" || value === "false")) {
    return value === "true"
  } else if (typeof value === "number" && (value === 1 || value === 0)) {
    return value === 1
  }
  return value
}, z.boolean())

export const s_actions_billing_usage = z.object({
  total_minutes_used: z.coerce.number(),
  total_paid_minutes_used: z.coerce.number(),
  included_minutes: z.coerce.number(),
  minutes_used_breakdown: z.object({
    UBUNTU: z.coerce.number().optional(),
    MACOS: z.coerce.number().optional(),
    WINDOWS: z.coerce.number().optional(),
    ubuntu_4_core: z.coerce.number().optional(),
    ubuntu_8_core: z.coerce.number().optional(),
    ubuntu_16_core: z.coerce.number().optional(),
    ubuntu_32_core: z.coerce.number().optional(),
    ubuntu_64_core: z.coerce.number().optional(),
    windows_4_core: z.coerce.number().optional(),
    windows_8_core: z.coerce.number().optional(),
    windows_16_core: z.coerce.number().optional(),
    windows_32_core: z.coerce.number().optional(),
    windows_64_core: z.coerce.number().optional(),
    macos_12_core: z.coerce.number().optional(),
    total: z.coerce.number().optional(),
  }),
})

export const s_actions_cache_list = z.object({
  total_count: z.coerce.number(),
  actions_caches: z.array(
    z.object({
      id: z.coerce.number().optional(),
      ref: z.string().optional(),
      key: z.string().optional(),
      version: z.string().optional(),
      last_accessed_at: z.iso.datetime({offset: true}).optional(),
      created_at: z.iso.datetime({offset: true}).optional(),
      size_in_bytes: z.coerce.number().optional(),
    }),
  ),
})

export const s_actions_cache_usage_by_repository = z.object({
  full_name: z.string(),
  active_caches_size_in_bytes: z.coerce.number(),
  active_caches_count: z.coerce.number(),
})

export const s_actions_cache_usage_org_enterprise = z.object({
  total_active_caches_count: z.coerce.number(),
  total_active_caches_size_in_bytes: z.coerce.number(),
})

export const s_actions_can_approve_pull_request_reviews = PermissiveBoolean

export const s_actions_default_workflow_permissions = z.enum(["read", "write"])

export const s_actions_enabled = PermissiveBoolean

export const s_actions_hosted_runner_image = z.object({
  id: z.string(),
  platform: z.string(),
  size_gb: z.coerce.number(),
  display_name: z.string(),
  source: z.enum(["github", "partner", "custom"]),
})

export const s_actions_hosted_runner_limits = z.object({
  public_ips: z.object({
    maximum: z.coerce.number(),
    current_usage: z.coerce.number(),
  }),
})

export const s_actions_hosted_runner_machine_spec = z.object({
  id: z.string(),
  cpu_cores: z.coerce.number(),
  memory_gb: z.coerce.number(),
  storage_gb: z.coerce.number(),
})

export const s_actions_public_key = z.object({
  key_id: z.string(),
  key: z.string(),
  id: z.coerce.number().optional(),
  url: z.string().optional(),
  title: z.string().optional(),
  created_at: z.string().optional(),
})

export const s_actions_secret = z.object({
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_actions_variable = z.object({
  name: z.string(),
  value: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_actions_workflow_access_to_repository = z.object({
  access_level: z.enum(["none", "user", "organization"]),
})

export const s_actor = z.object({
  id: z.coerce.number(),
  login: z.string(),
  display_login: z.string().optional(),
  gravatar_id: z.string().nullable(),
  url: z.string(),
  avatar_url: z.string(),
})

export const s_alert_auto_dismissed_at = z.iso
  .datetime({offset: true})
  .nullable()

export const s_alert_created_at = z.iso.datetime({offset: true})

export const s_alert_dismissed_at = z.iso.datetime({offset: true}).nullable()

export const s_alert_fixed_at = z.iso.datetime({offset: true}).nullable()

export const s_alert_html_url = z.string()

export const s_alert_instances_url = z.string()

export const s_alert_number = z.coerce.number()

export const s_alert_updated_at = z.iso.datetime({offset: true})

export const s_alert_url = z.string()

export const s_allowed_actions = z.enum(["all", "local_only", "selected"])

export const s_api_insights_route_stats = z.array(
  z.object({
    http_method: z.string().optional(),
    api_route: z.string().optional(),
    total_request_count: z.coerce.number().optional(),
    rate_limited_request_count: z.coerce.number().optional(),
    last_rate_limited_timestamp: z.string().nullable().optional(),
    last_request_timestamp: z.string().optional(),
  }),
)

export const s_api_insights_subject_stats = z.array(
  z.object({
    subject_type: z.string().optional(),
    subject_name: z.string().optional(),
    subject_id: z.coerce.number().optional(),
    total_request_count: z.coerce.number().optional(),
    rate_limited_request_count: z.coerce.number().optional(),
    last_rate_limited_timestamp: z.string().nullable().optional(),
    last_request_timestamp: z.string().optional(),
  }),
)

export const s_api_insights_summary_stats = z.object({
  total_request_count: z.coerce.number().optional(),
  rate_limited_request_count: z.coerce.number().optional(),
})

export const s_api_insights_time_stats = z.array(
  z.object({
    timestamp: z.string().optional(),
    total_request_count: z.coerce.number().optional(),
    rate_limited_request_count: z.coerce.number().optional(),
  }),
)

export const s_api_insights_user_stats = z.array(
  z.object({
    actor_type: z.string().optional(),
    actor_name: z.string().optional(),
    actor_id: z.coerce.number().optional(),
    integration_id: z.coerce.number().nullable().optional(),
    oauth_application_id: z.coerce.number().nullable().optional(),
    total_request_count: z.coerce.number().optional(),
    rate_limited_request_count: z.coerce.number().optional(),
    last_rate_limited_timestamp: z.string().nullable().optional(),
    last_request_timestamp: z.string().optional(),
  }),
)

export const s_api_overview = z.object({
  verifiable_password_authentication: PermissiveBoolean,
  ssh_key_fingerprints: z
    .object({
      SHA256_RSA: z.string().optional(),
      SHA256_DSA: z.string().optional(),
      SHA256_ECDSA: z.string().optional(),
      SHA256_ED25519: z.string().optional(),
    })
    .optional(),
  ssh_keys: z.array(z.string()).optional(),
  hooks: z.array(z.string()).optional(),
  github_enterprise_importer: z.array(z.string()).optional(),
  web: z.array(z.string()).optional(),
  api: z.array(z.string()).optional(),
  git: z.array(z.string()).optional(),
  packages: z.array(z.string()).optional(),
  pages: z.array(z.string()).optional(),
  importer: z.array(z.string()).optional(),
  actions: z.array(z.string()).optional(),
  actions_macos: z.array(z.string()).optional(),
  codespaces: z.array(z.string()).optional(),
  dependabot: z.array(z.string()).optional(),
  copilot: z.array(z.string()).optional(),
  domains: z
    .object({
      website: z.array(z.string()).optional(),
      codespaces: z.array(z.string()).optional(),
      copilot: z.array(z.string()).optional(),
      packages: z.array(z.string()).optional(),
      actions: z.array(z.string()).optional(),
      actions_inbound: z
        .object({
          full_domains: z.array(z.string()).optional(),
          wildcard_domains: z.array(z.string()).optional(),
        })
        .optional(),
      artifact_attestations: z
        .object({
          trust_domain: z.string().optional(),
          services: z.array(z.string()).optional(),
        })
        .optional(),
    })
    .optional(),
})

export const s_app_permissions = z.object({
  actions: z.enum(["read", "write"]).optional(),
  administration: z.enum(["read", "write"]).optional(),
  checks: z.enum(["read", "write"]).optional(),
  codespaces: z.enum(["read", "write"]).optional(),
  contents: z.enum(["read", "write"]).optional(),
  dependabot_secrets: z.enum(["read", "write"]).optional(),
  deployments: z.enum(["read", "write"]).optional(),
  environments: z.enum(["read", "write"]).optional(),
  issues: z.enum(["read", "write"]).optional(),
  metadata: z.enum(["read", "write"]).optional(),
  packages: z.enum(["read", "write"]).optional(),
  pages: z.enum(["read", "write"]).optional(),
  pull_requests: z.enum(["read", "write"]).optional(),
  repository_custom_properties: z.enum(["read", "write"]).optional(),
  repository_hooks: z.enum(["read", "write"]).optional(),
  repository_projects: z.enum(["read", "write", "admin"]).optional(),
  secret_scanning_alerts: z.enum(["read", "write"]).optional(),
  secrets: z.enum(["read", "write"]).optional(),
  security_events: z.enum(["read", "write"]).optional(),
  single_file: z.enum(["read", "write"]).optional(),
  statuses: z.enum(["read", "write"]).optional(),
  vulnerability_alerts: z.enum(["read", "write"]).optional(),
  workflows: z.enum(["write"]).optional(),
  members: z.enum(["read", "write"]).optional(),
  organization_administration: z.enum(["read", "write"]).optional(),
  organization_custom_roles: z.enum(["read", "write"]).optional(),
  organization_custom_org_roles: z.enum(["read", "write"]).optional(),
  organization_custom_properties: z.enum(["read", "write", "admin"]).optional(),
  organization_copilot_seat_management: z.enum(["write"]).optional(),
  organization_announcement_banners: z.enum(["read", "write"]).optional(),
  organization_events: z.enum(["read"]).optional(),
  organization_hooks: z.enum(["read", "write"]).optional(),
  organization_personal_access_tokens: z.enum(["read", "write"]).optional(),
  organization_personal_access_token_requests: z
    .enum(["read", "write"])
    .optional(),
  organization_plan: z.enum(["read"]).optional(),
  organization_projects: z.enum(["read", "write", "admin"]).optional(),
  organization_packages: z.enum(["read", "write"]).optional(),
  organization_secrets: z.enum(["read", "write"]).optional(),
  organization_self_hosted_runners: z.enum(["read", "write"]).optional(),
  organization_user_blocking: z.enum(["read", "write"]).optional(),
  team_discussions: z.enum(["read", "write"]).optional(),
  email_addresses: z.enum(["read", "write"]).optional(),
  followers: z.enum(["read", "write"]).optional(),
  git_ssh_keys: z.enum(["read", "write"]).optional(),
  gpg_keys: z.enum(["read", "write"]).optional(),
  interaction_limits: z.enum(["read", "write"]).optional(),
  profile: z.enum(["write"]).optional(),
  starring: z.enum(["read", "write"]).optional(),
})

export const s_artifact = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  size_in_bytes: z.coerce.number(),
  url: z.string(),
  archive_download_url: z.string(),
  expired: PermissiveBoolean,
  created_at: z.iso.datetime({offset: true}).nullable(),
  expires_at: z.iso.datetime({offset: true}).nullable(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  digest: z.string().nullable().optional(),
  workflow_run: z
    .object({
      id: z.coerce.number().optional(),
      repository_id: z.coerce.number().optional(),
      head_repository_id: z.coerce.number().optional(),
      head_branch: z.string().optional(),
      head_sha: z.string().optional(),
    })
    .nullable()
    .optional(),
})

export const s_author_association = z.enum([
  "COLLABORATOR",
  "CONTRIBUTOR",
  "FIRST_TIMER",
  "FIRST_TIME_CONTRIBUTOR",
  "MANNEQUIN",
  "MEMBER",
  "NONE",
  "OWNER",
])

export const s_autolink = z.object({
  id: z.coerce.number(),
  key_prefix: z.string(),
  url_template: z.string(),
  is_alphanumeric: PermissiveBoolean,
})

export const s_basic_error = z.object({
  message: z.string().optional(),
  documentation_url: z.string().optional(),
  url: z.string().optional(),
  status: z.string().optional(),
})

export const s_billing_usage_report = z.object({
  usageItems: z
    .array(
      z.object({
        date: z.string(),
        product: z.string(),
        sku: z.string(),
        quantity: z.coerce.number(),
        unitType: z.string(),
        pricePerUnit: z.coerce.number(),
        grossAmount: z.coerce.number(),
        discountAmount: z.coerce.number(),
        netAmount: z.coerce.number(),
        organizationName: z.string(),
        repositoryName: z.string().optional(),
      }),
    )
    .optional(),
})

export const s_billing_usage_report_user = z.object({
  usageItems: z
    .array(
      z.object({
        date: z.string(),
        product: z.string(),
        sku: z.string(),
        quantity: z.coerce.number(),
        unitType: z.string(),
        pricePerUnit: z.coerce.number(),
        grossAmount: z.coerce.number(),
        discountAmount: z.coerce.number(),
        netAmount: z.coerce.number(),
        repositoryName: z.string().optional(),
      }),
    )
    .optional(),
})

export const s_blob = z.object({
  content: z.string(),
  encoding: z.string(),
  url: z.string(),
  sha: z.string(),
  size: z.coerce.number().nullable(),
  node_id: z.string(),
  highlighted_content: z.string().optional(),
})

export const s_branch_restriction_policy = z.object({
  url: z.string(),
  users_url: z.string(),
  teams_url: z.string(),
  apps_url: z.string(),
  users: z.array(
    z.object({
      login: z.string().optional(),
      id: z.coerce.number().optional(),
      node_id: z.string().optional(),
      avatar_url: z.string().optional(),
      gravatar_id: z.string().optional(),
      url: z.string().optional(),
      html_url: z.string().optional(),
      followers_url: z.string().optional(),
      following_url: z.string().optional(),
      gists_url: z.string().optional(),
      starred_url: z.string().optional(),
      subscriptions_url: z.string().optional(),
      organizations_url: z.string().optional(),
      repos_url: z.string().optional(),
      events_url: z.string().optional(),
      received_events_url: z.string().optional(),
      type: z.string().optional(),
      site_admin: PermissiveBoolean.optional(),
      user_view_type: z.string().optional(),
    }),
  ),
  teams: z.array(
    z.object({
      id: z.coerce.number().optional(),
      node_id: z.string().optional(),
      url: z.string().optional(),
      html_url: z.string().optional(),
      name: z.string().optional(),
      slug: z.string().optional(),
      description: z.string().nullable().optional(),
      privacy: z.string().optional(),
      notification_setting: z.string().optional(),
      permission: z.string().optional(),
      members_url: z.string().optional(),
      repositories_url: z.string().optional(),
      parent: z.string().nullable().optional(),
    }),
  ),
  apps: z.array(
    z.object({
      id: z.coerce.number().optional(),
      slug: z.string().optional(),
      node_id: z.string().optional(),
      owner: z
        .object({
          login: z.string().optional(),
          id: z.coerce.number().optional(),
          node_id: z.string().optional(),
          url: z.string().optional(),
          repos_url: z.string().optional(),
          events_url: z.string().optional(),
          hooks_url: z.string().optional(),
          issues_url: z.string().optional(),
          members_url: z.string().optional(),
          public_members_url: z.string().optional(),
          avatar_url: z.string().optional(),
          description: z.string().optional(),
          gravatar_id: z.string().optional(),
          html_url: z.string().optional(),
          followers_url: z.string().optional(),
          following_url: z.string().optional(),
          gists_url: z.string().optional(),
          starred_url: z.string().optional(),
          subscriptions_url: z.string().optional(),
          organizations_url: z.string().optional(),
          received_events_url: z.string().optional(),
          type: z.string().optional(),
          site_admin: PermissiveBoolean.optional(),
          user_view_type: z.string().optional(),
        })
        .optional(),
      name: z.string().optional(),
      client_id: z.string().optional(),
      description: z.string().optional(),
      external_url: z.string().optional(),
      html_url: z.string().optional(),
      created_at: z.string().optional(),
      updated_at: z.string().optional(),
      permissions: z
        .object({
          metadata: z.string().optional(),
          contents: z.string().optional(),
          issues: z.string().optional(),
          single_file: z.string().optional(),
        })
        .optional(),
      events: z.array(z.string()).optional(),
    }),
  ),
})

export const s_branch_short = z.object({
  name: z.string(),
  commit: z.object({sha: z.string(), url: z.string()}),
  protected: PermissiveBoolean,
})

export const s_campaign_state = z.enum(["open", "closed"])

export const s_check_annotation = z.object({
  path: z.string(),
  start_line: z.coerce.number(),
  end_line: z.coerce.number(),
  start_column: z.coerce.number().nullable(),
  end_column: z.coerce.number().nullable(),
  annotation_level: z.string().nullable(),
  title: z.string().nullable(),
  message: z.string().nullable(),
  raw_details: z.string().nullable(),
  blob_href: z.string(),
})

export const s_check_automated_security_fixes = z.object({
  enabled: PermissiveBoolean,
  paused: PermissiveBoolean,
})

export const s_classroom_assignment_grade = z.object({
  assignment_name: z.string(),
  assignment_url: z.string(),
  starter_code_url: z.string(),
  github_username: z.string(),
  roster_identifier: z.string(),
  student_repository_name: z.string(),
  student_repository_url: z.string(),
  submission_timestamp: z.string(),
  points_awarded: z.coerce.number(),
  points_available: z.coerce.number(),
  group_name: z.string().optional(),
})

export const s_code_frequency_stat = z.array(z.coerce.number())

export const s_code_of_conduct = z.object({
  key: z.string(),
  name: z.string(),
  url: z.string(),
  body: z.string().optional(),
  html_url: z.string().nullable(),
})

export const s_code_of_conduct_simple = z.object({
  url: z.string(),
  key: z.string(),
  name: z.string(),
  html_url: z.string().nullable(),
})

export const s_code_scanning_alert_classification = z
  .enum(["source", "generated", "test", "library"])
  .nullable()

export const s_code_scanning_alert_create_request = PermissiveBoolean

export const s_code_scanning_alert_dismissed_comment = z
  .string()
  .max(280)
  .nullable()

export const s_code_scanning_alert_dismissed_reason = z
  .enum(["false positive", "won't fix", "used in tests"])
  .nullable()

export const s_code_scanning_alert_environment = z.string()

export const s_code_scanning_alert_location = z.object({
  path: z.string().optional(),
  start_line: z.coerce.number().optional(),
  end_line: z.coerce.number().optional(),
  start_column: z.coerce.number().optional(),
  end_column: z.coerce.number().optional(),
})

export const s_code_scanning_alert_rule = z.object({
  id: z.string().nullable().optional(),
  name: z.string().optional(),
  severity: z.enum(["none", "note", "warning", "error"]).nullable().optional(),
  security_severity_level: z
    .enum(["low", "medium", "high", "critical"])
    .nullable()
    .optional(),
  description: z.string().optional(),
  full_description: z.string().optional(),
  tags: z.array(z.string()).nullable().optional(),
  help: z.string().nullable().optional(),
  help_uri: z.string().nullable().optional(),
})

export const s_code_scanning_alert_rule_summary = z.object({
  id: z.string().nullable().optional(),
  name: z.string().optional(),
  severity: z.enum(["none", "note", "warning", "error"]).nullable().optional(),
  security_severity_level: z
    .enum(["low", "medium", "high", "critical"])
    .nullable()
    .optional(),
  description: z.string().optional(),
  full_description: z.string().optional(),
  tags: z.array(z.string()).nullable().optional(),
  help: z.string().nullable().optional(),
  help_uri: z.string().nullable().optional(),
})

export const s_code_scanning_alert_set_state = z.enum(["open", "dismissed"])

export const s_code_scanning_alert_severity = z.enum([
  "critical",
  "high",
  "medium",
  "low",
  "warning",
  "note",
  "error",
])

export const s_code_scanning_alert_state = z
  .enum(["open", "dismissed", "fixed"])
  .nullable()

export const s_code_scanning_alert_state_query = z.enum([
  "open",
  "closed",
  "dismissed",
  "fixed",
])

export const s_code_scanning_analysis_analysis_key = z.string()

export const s_code_scanning_analysis_category = z.string()

export const s_code_scanning_analysis_commit_sha = z
  .string()
  .min(40)
  .max(40)
  .regex(new RegExp("^[0-9a-fA-F]+$"))

export const s_code_scanning_analysis_created_at = z.iso.datetime({
  offset: true,
})

export const s_code_scanning_analysis_deletion = z.object({
  next_analysis_url: z.string().nullable(),
  confirm_delete_url: z.string().nullable(),
})

export const s_code_scanning_analysis_environment = z.string()

export const s_code_scanning_analysis_sarif_file = z.string()

export const s_code_scanning_analysis_sarif_id = z.string()

export const s_code_scanning_analysis_tool_guid = z.string().nullable()

export const s_code_scanning_analysis_tool_name = z.string()

export const s_code_scanning_analysis_tool_version = z.string().nullable()

export const s_code_scanning_analysis_url = z.string()

export const s_code_scanning_autofix_commits = z
  .object({target_ref: z.string().optional(), message: z.string().optional()})
  .nullable()

export const s_code_scanning_autofix_commits_response = z.object({
  target_ref: z.string().optional(),
  sha: z.string().optional(),
})

export const s_code_scanning_autofix_description = z.string().nullable()

export const s_code_scanning_autofix_started_at = z.iso.datetime({offset: true})

export const s_code_scanning_autofix_status = z.enum([
  "pending",
  "error",
  "success",
  "outdated",
])

export const s_code_scanning_default_setup = z.object({
  state: z.enum(["configured", "not-configured"]).optional(),
  languages: z
    .array(
      z.enum([
        "actions",
        "c-cpp",
        "csharp",
        "go",
        "java-kotlin",
        "javascript-typescript",
        "javascript",
        "python",
        "ruby",
        "typescript",
        "swift",
      ]),
    )
    .optional(),
  runner_type: z.enum(["standard", "labeled"]).nullable().optional(),
  runner_label: z.string().nullable().optional(),
  query_suite: z.enum(["default", "extended"]).optional(),
  threat_model: z.enum(["remote", "remote_and_local"]).optional(),
  updated_at: z.iso.datetime({offset: true}).nullable().optional(),
  schedule: z.enum(["weekly"]).nullable().optional(),
})

export const s_code_scanning_default_setup_options = z
  .object({
    runner_type: z.enum(["standard", "labeled", "not_set"]).optional(),
    runner_label: z.string().nullable().optional(),
  })
  .nullable()

export const s_code_scanning_default_setup_update = z.object({
  state: z.enum(["configured", "not-configured"]).optional(),
  runner_type: z.enum(["standard", "labeled"]).optional(),
  runner_label: z.string().nullable().optional(),
  query_suite: z.enum(["default", "extended"]).optional(),
  threat_model: z.enum(["remote", "remote_and_local"]).optional(),
  languages: z
    .array(
      z.enum([
        "actions",
        "c-cpp",
        "csharp",
        "go",
        "java-kotlin",
        "javascript-typescript",
        "python",
        "ruby",
        "swift",
      ]),
    )
    .optional(),
})

export const s_code_scanning_default_setup_update_response = z.object({
  run_id: z.coerce.number().optional(),
  run_url: z.string().optional(),
})

export const s_code_scanning_options = z
  .object({allow_advanced: PermissiveBoolean.nullable().optional()})
  .nullable()

export const s_code_scanning_ref = z.string()

export const s_code_scanning_ref_full = z
  .string()
  .regex(new RegExp("^refs/(heads|tags|pull)/.*$"))

export const s_code_scanning_sarifs_status = z.object({
  processing_status: z.enum(["pending", "complete", "failed"]).optional(),
  analyses_url: z.string().nullable().optional(),
  errors: z.array(z.string()).nullable().optional(),
})

export const s_code_scanning_variant_analysis_language = z.enum([
  "cpp",
  "csharp",
  "go",
  "java",
  "javascript",
  "python",
  "ruby",
  "rust",
  "swift",
])

export const s_code_scanning_variant_analysis_repository = z.object({
  id: z.coerce.number(),
  name: z.string(),
  full_name: z.string(),
  private: PermissiveBoolean,
  stargazers_count: z.coerce.number(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
})

export const s_code_scanning_variant_analysis_status = z.enum([
  "pending",
  "in_progress",
  "succeeded",
  "failed",
  "canceled",
  "timed_out",
])

export const s_code_security_configuration = z.object({
  id: z.coerce.number().optional(),
  name: z.string().optional(),
  target_type: z.enum(["global", "organization", "enterprise"]).optional(),
  description: z.string().optional(),
  advanced_security: z
    .enum(["enabled", "disabled", "code_security", "secret_protection"])
    .optional(),
  dependency_graph: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependency_graph_autosubmit_action: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  dependency_graph_autosubmit_action_options: z
    .object({labeled_runners: PermissiveBoolean.optional()})
    .optional(),
  dependabot_alerts: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependabot_security_updates: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  code_scanning_options: z
    .object({allow_advanced: PermissiveBoolean.nullable().optional()})
    .nullable()
    .optional(),
  code_scanning_default_setup: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  code_scanning_default_setup_options: z
    .object({
      runner_type: z
        .enum(["standard", "labeled", "not_set"])
        .nullable()
        .optional(),
      runner_label: z.string().nullable().optional(),
    })
    .nullable()
    .optional(),
  code_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning: z.enum(["enabled", "disabled", "not_set"]).optional(),
  secret_scanning_push_protection: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_delegated_bypass: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_delegated_bypass_options: z
    .object({
      reviewers: z
        .array(
          z.object({
            reviewer_id: z.coerce.number(),
            reviewer_type: z.enum(["TEAM", "ROLE"]),
          }),
        )
        .optional(),
    })
    .optional(),
  secret_scanning_validity_checks: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_non_provider_patterns: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_generic_secrets: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  private_vulnerability_reporting: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  enforcement: z.enum(["enforced", "unenforced"]).optional(),
  url: z.string().optional(),
  html_url: z.string().optional(),
  created_at: z.iso.datetime({offset: true}).optional(),
  updated_at: z.iso.datetime({offset: true}).optional(),
})

export const s_codeowners_errors = z.object({
  errors: z.array(
    z.object({
      line: z.coerce.number(),
      column: z.coerce.number(),
      source: z.string().optional(),
      kind: z.string(),
      suggestion: z.string().nullable().optional(),
      message: z.string(),
      path: z.string(),
    }),
  ),
})

export const s_codespace_export_details = z.object({
  state: z.string().nullable().optional(),
  completed_at: z.iso.datetime({offset: true}).nullable().optional(),
  branch: z.string().nullable().optional(),
  sha: z.string().nullable().optional(),
  id: z.string().optional(),
  export_url: z.string().optional(),
  html_url: z.string().nullable().optional(),
})

export const s_codespace_machine = z.object({
  name: z.string(),
  display_name: z.string(),
  operating_system: z.string(),
  storage_in_bytes: z.coerce.number(),
  memory_in_bytes: z.coerce.number(),
  cpus: z.coerce.number(),
  prebuild_availability: z.enum(["none", "ready", "in_progress"]).nullable(),
})

export const s_codespaces_org_secret = z.object({
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repositories_url: z.string().optional(),
})

export const s_codespaces_permissions_check_for_devcontainer = z.object({
  accepted: PermissiveBoolean,
})

export const s_codespaces_public_key = z.object({
  key_id: z.string(),
  key: z.string(),
  id: z.coerce.number().optional(),
  url: z.string().optional(),
  title: z.string().optional(),
  created_at: z.string().optional(),
})

export const s_codespaces_secret = z.object({
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repositories_url: z.string(),
})

export const s_codespaces_user_public_key = z.object({
  key_id: z.string(),
  key: z.string(),
})

export const s_collaborator = z.object({
  login: z.string(),
  id: z.coerce.number(),
  email: z.string().nullable().optional(),
  name: z.string().nullable().optional(),
  node_id: z.string(),
  avatar_url: z.string(),
  gravatar_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  followers_url: z.string(),
  following_url: z.string(),
  gists_url: z.string(),
  starred_url: z.string(),
  subscriptions_url: z.string(),
  organizations_url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  received_events_url: z.string(),
  type: z.string(),
  site_admin: PermissiveBoolean,
  permissions: z
    .object({
      pull: PermissiveBoolean,
      triage: PermissiveBoolean.optional(),
      push: PermissiveBoolean,
      maintain: PermissiveBoolean.optional(),
      admin: PermissiveBoolean,
    })
    .optional(),
  role_name: z.string(),
  user_view_type: z.string().optional(),
})

export const s_combined_billing_usage = z.object({
  days_left_in_billing_cycle: z.coerce.number(),
  estimated_paid_storage_for_month: z.coerce.number(),
  estimated_storage_for_month: z.coerce.number(),
})

export const s_commit_activity = z.object({
  days: z.array(z.coerce.number()),
  total: z.coerce.number(),
  week: z.coerce.number(),
})

export const s_content_directory = z.array(
  z.object({
    type: z.enum(["dir", "file", "submodule", "symlink"]),
    size: z.coerce.number(),
    name: z.string(),
    path: z.string(),
    content: z.string().optional(),
    sha: z.string(),
    url: z.string(),
    git_url: z.string().nullable(),
    html_url: z.string().nullable(),
    download_url: z.string().nullable(),
    _links: z.object({
      git: z.string().nullable(),
      html: z.string().nullable(),
      self: z.string(),
    }),
  }),
)

export const s_content_file = z.object({
  type: z.enum(["file"]),
  encoding: z.string(),
  size: z.coerce.number(),
  name: z.string(),
  path: z.string(),
  content: z.string(),
  sha: z.string(),
  url: z.string(),
  git_url: z.string().nullable(),
  html_url: z.string().nullable(),
  download_url: z.string().nullable(),
  _links: z.object({
    git: z.string().nullable(),
    html: z.string().nullable(),
    self: z.string(),
  }),
  target: z.string().optional(),
  submodule_git_url: z.string().optional(),
})

export const s_content_submodule = z.object({
  type: z.enum(["submodule"]),
  submodule_git_url: z.string(),
  size: z.coerce.number(),
  name: z.string(),
  path: z.string(),
  sha: z.string(),
  url: z.string(),
  git_url: z.string().nullable(),
  html_url: z.string().nullable(),
  download_url: z.string().nullable(),
  _links: z.object({
    git: z.string().nullable(),
    html: z.string().nullable(),
    self: z.string(),
  }),
})

export const s_content_symlink = z.object({
  type: z.enum(["symlink"]),
  target: z.string(),
  size: z.coerce.number(),
  name: z.string(),
  path: z.string(),
  sha: z.string(),
  url: z.string(),
  git_url: z.string().nullable(),
  html_url: z.string().nullable(),
  download_url: z.string().nullable(),
  _links: z.object({
    git: z.string().nullable(),
    html: z.string().nullable(),
    self: z.string(),
  }),
})

export const s_content_traffic = z.object({
  path: z.string(),
  title: z.string(),
  count: z.coerce.number(),
  uniques: z.coerce.number(),
})

export const s_contributor = z.object({
  login: z.string().optional(),
  id: z.coerce.number().optional(),
  node_id: z.string().optional(),
  avatar_url: z.string().optional(),
  gravatar_id: z.string().nullable().optional(),
  url: z.string().optional(),
  html_url: z.string().optional(),
  followers_url: z.string().optional(),
  following_url: z.string().optional(),
  gists_url: z.string().optional(),
  starred_url: z.string().optional(),
  subscriptions_url: z.string().optional(),
  organizations_url: z.string().optional(),
  repos_url: z.string().optional(),
  events_url: z.string().optional(),
  received_events_url: z.string().optional(),
  type: z.string(),
  site_admin: PermissiveBoolean.optional(),
  contributions: z.coerce.number(),
  email: z.string().optional(),
  name: z.string().optional(),
  user_view_type: z.string().optional(),
})

export const s_copilot_dotcom_chat = z
  .intersection(
    z.object({
      total_engaged_users: z.coerce.number().optional(),
      models: z
        .array(
          z.object({
            name: z.string().optional(),
            is_custom_model: PermissiveBoolean.optional(),
            custom_model_training_date: z.string().nullable().optional(),
            total_engaged_users: z.coerce.number().optional(),
            total_chats: z.coerce.number().optional(),
          }),
        )
        .optional(),
    }),
    z.record(z.string(), z.unknown()),
  )
  .nullable()

export const s_copilot_dotcom_pull_requests = z
  .intersection(
    z.object({
      total_engaged_users: z.coerce.number().optional(),
      repositories: z
        .array(
          z.object({
            name: z.string().optional(),
            total_engaged_users: z.coerce.number().optional(),
            models: z
              .array(
                z.object({
                  name: z.string().optional(),
                  is_custom_model: PermissiveBoolean.optional(),
                  custom_model_training_date: z.string().nullable().optional(),
                  total_pr_summaries_created: z.coerce.number().optional(),
                  total_engaged_users: z.coerce.number().optional(),
                }),
              )
              .optional(),
          }),
        )
        .optional(),
    }),
    z.record(z.string(), z.unknown()),
  )
  .nullable()

export const s_copilot_ide_chat = z
  .intersection(
    z.object({
      total_engaged_users: z.coerce.number().optional(),
      editors: z
        .array(
          z.object({
            name: z.string().optional(),
            total_engaged_users: z.coerce.number().optional(),
            models: z
              .array(
                z.object({
                  name: z.string().optional(),
                  is_custom_model: PermissiveBoolean.optional(),
                  custom_model_training_date: z.string().nullable().optional(),
                  total_engaged_users: z.coerce.number().optional(),
                  total_chats: z.coerce.number().optional(),
                  total_chat_insertion_events: z.coerce.number().optional(),
                  total_chat_copy_events: z.coerce.number().optional(),
                }),
              )
              .optional(),
          }),
        )
        .optional(),
    }),
    z.record(z.string(), z.unknown()),
  )
  .nullable()

export const s_copilot_ide_code_completions = z
  .intersection(
    z.object({
      total_engaged_users: z.coerce.number().optional(),
      languages: z
        .array(
          z.object({
            name: z.string().optional(),
            total_engaged_users: z.coerce.number().optional(),
          }),
        )
        .optional(),
      editors: z
        .array(
          z.intersection(
            z.object({
              name: z.string().optional(),
              total_engaged_users: z.coerce.number().optional(),
              models: z
                .array(
                  z.object({
                    name: z.string().optional(),
                    is_custom_model: PermissiveBoolean.optional(),
                    custom_model_training_date: z
                      .string()
                      .nullable()
                      .optional(),
                    total_engaged_users: z.coerce.number().optional(),
                    languages: z
                      .array(
                        z.object({
                          name: z.string().optional(),
                          total_engaged_users: z.coerce.number().optional(),
                          total_code_suggestions: z.coerce.number().optional(),
                          total_code_acceptances: z.coerce.number().optional(),
                          total_code_lines_suggested: z.coerce
                            .number()
                            .optional(),
                          total_code_lines_accepted: z.coerce
                            .number()
                            .optional(),
                        }),
                      )
                      .optional(),
                  }),
                )
                .optional(),
            }),
            z.record(z.string(), z.unknown()),
          ),
        )
        .optional(),
    }),
    z.record(z.string(), z.unknown()),
  )
  .nullable()

export const s_copilot_organization_seat_breakdown = z.object({
  total: z.coerce.number().optional(),
  added_this_cycle: z.coerce.number().optional(),
  pending_cancellation: z.coerce.number().optional(),
  pending_invitation: z.coerce.number().optional(),
  active_this_cycle: z.coerce.number().optional(),
  inactive_this_cycle: z.coerce.number().optional(),
})

export const s_custom_deployment_rule_app = z.object({
  id: z.coerce.number(),
  slug: z.string(),
  integration_url: z.string(),
  node_id: z.string(),
})

export const s_custom_property = z.object({
  property_name: z.string(),
  url: z.string().optional(),
  source_type: z.enum(["organization", "enterprise"]).optional(),
  value_type: z.enum(["string", "single_select", "multi_select", "true_false"]),
  required: PermissiveBoolean.optional(),
  default_value: z
    .union([z.string(), z.array(z.string())])
    .nullable()
    .optional(),
  description: z.string().nullable().optional(),
  allowed_values: z.array(z.string().max(75)).max(200).nullable().optional(),
  values_editable_by: z
    .enum(["org_actors", "org_and_repo_actors"])
    .nullable()
    .optional(),
})

export const s_custom_property_set_payload = z.object({
  value_type: z.enum(["string", "single_select", "multi_select", "true_false"]),
  required: PermissiveBoolean.optional(),
  default_value: z
    .union([z.string(), z.array(z.string())])
    .nullable()
    .optional(),
  description: z.string().nullable().optional(),
  allowed_values: z.array(z.string().max(75)).max(200).nullable().optional(),
  values_editable_by: z
    .enum(["org_actors", "org_and_repo_actors"])
    .nullable()
    .optional(),
})

export const s_custom_property_value = z.object({
  property_name: z.string(),
  value: z.union([z.string(), z.array(z.string())]).nullable(),
})

export const s_cvss_severities = z
  .object({
    cvss_v3: z
      .object({
        vector_string: z.string().nullable(),
        score: z.coerce.number().min(0).max(10).nullable(),
      })
      .nullable()
      .optional(),
    cvss_v4: z
      .object({
        vector_string: z.string().nullable(),
        score: z.coerce.number().min(0).max(10).nullable(),
      })
      .nullable()
      .optional(),
  })
  .nullable()

export const s_dependabot_alert_package = z.object({
  ecosystem: z.string(),
  name: z.string(),
})

export const s_dependabot_public_key = z.object({
  key_id: z.string(),
  key: z.string(),
})

export const s_dependabot_secret = z.object({
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_dependency_graph_diff = z.array(
  z.object({
    change_type: z.enum(["added", "removed"]),
    manifest: z.string(),
    ecosystem: z.string(),
    name: z.string(),
    version: z.string(),
    package_url: z.string().nullable(),
    license: z.string().nullable(),
    source_repository_url: z.string().nullable(),
    vulnerabilities: z.array(
      z.object({
        severity: z.string(),
        advisory_ghsa_id: z.string(),
        advisory_summary: z.string(),
        advisory_url: z.string(),
      }),
    ),
    scope: z.enum(["unknown", "runtime", "development"]),
  }),
)

export const s_dependency_graph_spdx_sbom = z.object({
  sbom: z.object({
    SPDXID: z.string(),
    spdxVersion: z.string(),
    comment: z.string().optional(),
    creationInfo: z.object({
      created: z.string(),
      creators: z.array(z.string()),
    }),
    name: z.string(),
    dataLicense: z.string(),
    documentNamespace: z.string(),
    packages: z.array(
      z.object({
        SPDXID: z.string().optional(),
        name: z.string().optional(),
        versionInfo: z.string().optional(),
        downloadLocation: z.string().optional(),
        filesAnalyzed: PermissiveBoolean.optional(),
        licenseConcluded: z.string().optional(),
        licenseDeclared: z.string().optional(),
        supplier: z.string().optional(),
        copyrightText: z.string().optional(),
        externalRefs: z
          .array(
            z.object({
              referenceCategory: z.string(),
              referenceLocator: z.string(),
              referenceType: z.string(),
            }),
          )
          .optional(),
      }),
    ),
    relationships: z
      .array(
        z.object({
          relationshipType: z.string().optional(),
          spdxElementId: z.string().optional(),
          relatedSpdxElement: z.string().optional(),
        }),
      )
      .optional(),
  }),
})

export const s_deploy_key = z.object({
  id: z.coerce.number(),
  key: z.string(),
  url: z.string(),
  title: z.string(),
  verified: PermissiveBoolean,
  created_at: z.string(),
  read_only: PermissiveBoolean,
  added_by: z.string().nullable().optional(),
  last_used: z.iso.datetime({offset: true}).nullable().optional(),
  enabled: PermissiveBoolean.optional(),
})

export const s_deployment_branch_policy = z.object({
  id: z.coerce.number().optional(),
  node_id: z.string().optional(),
  name: z.string().optional(),
  type: z.enum(["branch", "tag"]).optional(),
})

export const s_deployment_branch_policy_name_pattern = z.object({
  name: z.string(),
})

export const s_deployment_branch_policy_name_pattern_with_type = z.object({
  name: z.string(),
  type: z.enum(["branch", "tag"]).optional(),
})

export const s_deployment_branch_policy_settings = z
  .object({
    protected_branches: PermissiveBoolean,
    custom_branch_policies: PermissiveBoolean,
  })
  .nullable()

export const s_deployment_reviewer_type = z.enum(["User", "Team"])

export const s_diff_entry = z.object({
  sha: z.string(),
  filename: z.string(),
  status: z.enum([
    "added",
    "removed",
    "modified",
    "renamed",
    "copied",
    "changed",
    "unchanged",
  ]),
  additions: z.coerce.number(),
  deletions: z.coerce.number(),
  changes: z.coerce.number(),
  blob_url: z.string(),
  raw_url: z.string(),
  contents_url: z.string(),
  patch: z.string().optional(),
  previous_filename: z.string().optional(),
})

export const s_email = z.object({
  email: z.email(),
  primary: PermissiveBoolean,
  verified: PermissiveBoolean,
  visibility: z.string().nullable(),
})

export const s_empty_object = z.object({})

export const s_enabled_repositories = z.enum(["all", "none", "selected"])

export const s_enterprise = z.object({
  description: z.string().nullable().optional(),
  html_url: z.string(),
  website_url: z.string().nullable().optional(),
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  slug: z.string(),
  created_at: z.iso.datetime({offset: true}).nullable(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  avatar_url: z.string(),
})

export const s_enterprise_team = z.object({
  id: z.coerce.number(),
  name: z.string(),
  description: z.string().optional(),
  slug: z.string(),
  url: z.string(),
  sync_to_organizations: z.string().optional(),
  organization_selection_type: z.string().optional(),
  group_id: z.string().nullable().optional(),
  group_name: z.string().nullable().optional(),
  html_url: z.string(),
  members_url: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_file_commit = z.object({
  content: z
    .object({
      name: z.string().optional(),
      path: z.string().optional(),
      sha: z.string().optional(),
      size: z.coerce.number().optional(),
      url: z.string().optional(),
      html_url: z.string().optional(),
      git_url: z.string().optional(),
      download_url: z.string().optional(),
      type: z.string().optional(),
      _links: z
        .object({
          self: z.string().optional(),
          git: z.string().optional(),
          html: z.string().optional(),
        })
        .optional(),
    })
    .nullable(),
  commit: z.object({
    sha: z.string().optional(),
    node_id: z.string().optional(),
    url: z.string().optional(),
    html_url: z.string().optional(),
    author: z
      .object({
        date: z.string().optional(),
        name: z.string().optional(),
        email: z.string().optional(),
      })
      .optional(),
    committer: z
      .object({
        date: z.string().optional(),
        name: z.string().optional(),
        email: z.string().optional(),
      })
      .optional(),
    message: z.string().optional(),
    tree: z
      .object({url: z.string().optional(), sha: z.string().optional()})
      .optional(),
    parents: z
      .array(
        z.object({
          url: z.string().optional(),
          html_url: z.string().optional(),
          sha: z.string().optional(),
        }),
      )
      .optional(),
    verification: z
      .object({
        verified: PermissiveBoolean.optional(),
        reason: z.string().optional(),
        signature: z.string().nullable().optional(),
        payload: z.string().nullable().optional(),
        verified_at: z.string().nullable().optional(),
      })
      .optional(),
  }),
})

export const s_git_commit = z.object({
  sha: z.string(),
  node_id: z.string(),
  url: z.string(),
  author: z.object({
    date: z.iso.datetime({offset: true}),
    email: z.string(),
    name: z.string(),
  }),
  committer: z.object({
    date: z.iso.datetime({offset: true}),
    email: z.string(),
    name: z.string(),
  }),
  message: z.string(),
  tree: z.object({sha: z.string(), url: z.string()}),
  parents: z.array(
    z.object({sha: z.string(), url: z.string(), html_url: z.string()}),
  ),
  verification: z.object({
    verified: PermissiveBoolean,
    reason: z.string(),
    signature: z.string().nullable(),
    payload: z.string().nullable(),
    verified_at: z.string().nullable(),
  }),
  html_url: z.string(),
})

export const s_git_ref = z.object({
  ref: z.string(),
  node_id: z.string(),
  url: z.string(),
  object: z.object({
    type: z.string(),
    sha: z.string().min(40).max(40),
    url: z.string(),
  }),
})

export const s_git_tree = z.object({
  sha: z.string(),
  url: z.string().optional(),
  truncated: PermissiveBoolean,
  tree: z.array(
    z.object({
      path: z.string(),
      mode: z.string(),
      type: z.string(),
      sha: z.string(),
      size: z.coerce.number().optional(),
      url: z.string().optional(),
    }),
  ),
})

export const s_gitignore_template = z.object({
  name: z.string(),
  source: z.string(),
})

export const s_gpg_key = z.object({
  id: z.coerce.number(),
  name: z.string().nullable().optional(),
  primary_key_id: z.coerce.number().nullable(),
  key_id: z.string(),
  public_key: z.string(),
  emails: z.array(
    z.object({
      email: z.string().optional(),
      verified: PermissiveBoolean.optional(),
    }),
  ),
  subkeys: z.array(
    z.object({
      id: z.coerce.number().optional(),
      primary_key_id: z.coerce.number().optional(),
      key_id: z.string().optional(),
      public_key: z.string().optional(),
      emails: z
        .array(
          z.object({
            email: z.string().optional(),
            verified: PermissiveBoolean.optional(),
          }),
        )
        .optional(),
      subkeys: z.array(z.unknown()).optional(),
      can_sign: PermissiveBoolean.optional(),
      can_encrypt_comms: PermissiveBoolean.optional(),
      can_encrypt_storage: PermissiveBoolean.optional(),
      can_certify: PermissiveBoolean.optional(),
      created_at: z.string().optional(),
      expires_at: z.string().nullable().optional(),
      raw_key: z.string().nullable().optional(),
      revoked: PermissiveBoolean.optional(),
    }),
  ),
  can_sign: PermissiveBoolean,
  can_encrypt_comms: PermissiveBoolean,
  can_encrypt_storage: PermissiveBoolean,
  can_certify: PermissiveBoolean,
  created_at: z.iso.datetime({offset: true}),
  expires_at: z.iso.datetime({offset: true}).nullable(),
  revoked: PermissiveBoolean,
  raw_key: z.string().nullable(),
})

export const s_hook_delivery = z.object({
  id: z.coerce.number(),
  guid: z.string(),
  delivered_at: z.iso.datetime({offset: true}),
  redelivery: PermissiveBoolean,
  duration: z.coerce.number(),
  status: z.string(),
  status_code: z.coerce.number(),
  event: z.string(),
  action: z.string().nullable(),
  installation_id: z.coerce.number().nullable(),
  repository_id: z.coerce.number().nullable(),
  throttled_at: z.iso.datetime({offset: true}).nullable().optional(),
  url: z.string().optional(),
  request: z.object({
    headers: z.record(z.string(), z.unknown()).nullable(),
    payload: z.record(z.string(), z.unknown()).nullable(),
  }),
  response: z.object({
    headers: z.record(z.string(), z.unknown()).nullable(),
    payload: z.string().nullable(),
  }),
})

export const s_hook_delivery_item = z.object({
  id: z.coerce.number(),
  guid: z.string(),
  delivered_at: z.iso.datetime({offset: true}),
  redelivery: PermissiveBoolean,
  duration: z.coerce.number(),
  status: z.string(),
  status_code: z.coerce.number(),
  event: z.string(),
  action: z.string().nullable(),
  installation_id: z.coerce.number().nullable(),
  repository_id: z.coerce.number().nullable(),
  throttled_at: z.iso.datetime({offset: true}).nullable().optional(),
})

export const s_hook_response = z.object({
  code: z.coerce.number().nullable(),
  status: z.string().nullable(),
  message: z.string().nullable(),
})

export const s_hovercard = z.object({
  contexts: z.array(z.object({message: z.string(), octicon: z.string()})),
})

export const s_import = z.object({
  vcs: z.string().nullable(),
  use_lfs: PermissiveBoolean.optional(),
  vcs_url: z.string(),
  svc_root: z.string().optional(),
  tfvc_project: z.string().optional(),
  status: z.enum([
    "auth",
    "error",
    "none",
    "detecting",
    "choose",
    "auth_failed",
    "importing",
    "mapping",
    "waiting_to_push",
    "pushing",
    "complete",
    "setup",
    "unknown",
    "detection_found_multiple",
    "detection_found_nothing",
    "detection_needs_auth",
  ]),
  status_text: z.string().nullable().optional(),
  failed_step: z.string().nullable().optional(),
  error_message: z.string().nullable().optional(),
  import_percent: z.coerce.number().nullable().optional(),
  commit_count: z.coerce.number().nullable().optional(),
  push_percent: z.coerce.number().nullable().optional(),
  has_large_files: PermissiveBoolean.optional(),
  large_files_size: z.coerce.number().optional(),
  large_files_count: z.coerce.number().optional(),
  project_choices: z
    .array(
      z.object({
        vcs: z.string().optional(),
        tfvc_project: z.string().optional(),
        human_name: z.string().optional(),
      }),
    )
    .optional(),
  message: z.string().optional(),
  authors_count: z.coerce.number().nullable().optional(),
  url: z.string(),
  html_url: z.string(),
  authors_url: z.string(),
  repository_url: z.string(),
  svn_root: z.string().optional(),
})

export const s_interaction_expiry = z.enum([
  "one_day",
  "three_days",
  "one_week",
  "one_month",
  "six_months",
])

export const s_interaction_group = z.enum([
  "existing_users",
  "contributors_only",
  "collaborators_only",
])

export const s_issue_event_dismissed_review = z.object({
  state: z.string(),
  review_id: z.coerce.number(),
  dismissal_message: z.string().nullable(),
  dismissal_commit_id: z.string().nullable().optional(),
})

export const s_issue_event_label = z.object({
  name: z.string().nullable(),
  color: z.string().nullable(),
})

export const s_issue_event_milestone = z.object({title: z.string()})

export const s_issue_event_project_card = z.object({
  url: z.string(),
  id: z.coerce.number(),
  project_url: z.string(),
  project_id: z.coerce.number(),
  column_name: z.string(),
  previous_column_name: z.string().optional(),
})

export const s_issue_event_rename = z.object({from: z.string(), to: z.string()})

export const s_issue_type = z
  .object({
    id: z.coerce.number(),
    node_id: z.string(),
    name: z.string(),
    description: z.string().nullable(),
    color: z
      .enum([
        "gray",
        "blue",
        "green",
        "yellow",
        "orange",
        "red",
        "pink",
        "purple",
      ])
      .nullable()
      .optional(),
    created_at: z.iso.datetime({offset: true}).optional(),
    updated_at: z.iso.datetime({offset: true}).optional(),
    is_enabled: PermissiveBoolean.optional(),
  })
  .nullable()

export const s_job = z.object({
  id: z.coerce.number(),
  run_id: z.coerce.number(),
  run_url: z.string(),
  run_attempt: z.coerce.number().optional(),
  node_id: z.string(),
  head_sha: z.string(),
  url: z.string(),
  html_url: z.string().nullable(),
  status: z.enum([
    "queued",
    "in_progress",
    "completed",
    "waiting",
    "requested",
    "pending",
  ]),
  conclusion: z
    .enum([
      "success",
      "failure",
      "neutral",
      "cancelled",
      "skipped",
      "timed_out",
      "action_required",
    ])
    .nullable(),
  created_at: z.iso.datetime({offset: true}),
  started_at: z.iso.datetime({offset: true}),
  completed_at: z.iso.datetime({offset: true}).nullable(),
  name: z.string(),
  steps: z
    .array(
      z.object({
        status: z.enum(["queued", "in_progress", "completed"]),
        conclusion: z.string().nullable(),
        name: z.string(),
        number: z.coerce.number(),
        started_at: z.iso.datetime({offset: true}).nullable().optional(),
        completed_at: z.iso.datetime({offset: true}).nullable().optional(),
      }),
    )
    .optional(),
  check_run_url: z.string(),
  labels: z.array(z.string()),
  runner_id: z.coerce.number().nullable(),
  runner_name: z.string().nullable(),
  runner_group_id: z.coerce.number().nullable(),
  runner_group_name: z.string().nullable(),
  workflow_name: z.string().nullable(),
  head_branch: z.string().nullable(),
})

export const s_key = z.object({
  key: z.string(),
  id: z.coerce.number(),
  url: z.string(),
  title: z.string(),
  created_at: z.iso.datetime({offset: true}),
  verified: PermissiveBoolean,
  read_only: PermissiveBoolean,
  last_used: z.iso.datetime({offset: true}).nullable().optional(),
})

export const s_key_simple = z.object({
  id: z.coerce.number(),
  key: z.string(),
  created_at: z.iso.datetime({offset: true}).optional(),
  last_used: z.iso.datetime({offset: true}).nullable().optional(),
})

export const s_label = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  name: z.string(),
  description: z.string().nullable(),
  color: z.string(),
  default: PermissiveBoolean,
})

export const s_language = z.record(z.string(), z.coerce.number())

export const s_license = z.object({
  key: z.string(),
  name: z.string(),
  spdx_id: z.string().nullable(),
  url: z.string().nullable(),
  node_id: z.string(),
  html_url: z.string(),
  description: z.string(),
  implementation: z.string(),
  permissions: z.array(z.string()),
  conditions: z.array(z.string()),
  limitations: z.array(z.string()),
  body: z.string(),
  featured: PermissiveBoolean,
})

export const s_license_simple = z.object({
  key: z.string(),
  name: z.string(),
  url: z.string().nullable(),
  spdx_id: z.string().nullable(),
  node_id: z.string(),
  html_url: z.string().optional(),
})

export const s_link = z.object({href: z.string()})

export const s_link_with_type = z.object({href: z.string(), type: z.string()})

export const s_marketplace_account = z.object({
  url: z.string(),
  id: z.coerce.number(),
  type: z.string(),
  node_id: z.string().optional(),
  login: z.string(),
  email: z.email().nullable().optional(),
  organization_billing_email: z.email().nullable().optional(),
})

export const s_marketplace_listing_plan = z.object({
  url: z.string(),
  accounts_url: z.string(),
  id: z.coerce.number(),
  number: z.coerce.number(),
  name: z.string(),
  description: z.string(),
  monthly_price_in_cents: z.coerce.number(),
  yearly_price_in_cents: z.coerce.number(),
  price_model: z.enum(["FREE", "FLAT_RATE", "PER_UNIT"]),
  has_free_trial: PermissiveBoolean,
  unit_name: z.string().nullable(),
  state: z.string(),
  bullets: z.array(z.string()),
})

export const s_merged_upstream = z.object({
  message: z.string().optional(),
  merge_type: z.enum(["merge", "fast-forward", "none"]).optional(),
  base_branch: z.string().optional(),
})

export const s_metadata = z.record(
  z.string(),
  z.union([z.string(), z.coerce.number(), PermissiveBoolean]).nullable(),
)

export const s_network_configuration = z.object({
  id: z.string(),
  name: z.string(),
  compute_service: z.enum(["none", "actions", "codespaces"]).optional(),
  network_settings_ids: z.array(z.string()).optional(),
  created_on: z.iso.datetime({offset: true}).nullable(),
})

export const s_network_settings = z.object({
  id: z.string(),
  network_configuration_id: z.string().optional(),
  name: z.string(),
  subnet_id: z.string(),
  region: z.string(),
})

export const s_nullable_actions_hosted_runner_pool_image = z
  .object({
    id: z.string(),
    size_gb: z.coerce.number(),
    display_name: z.string(),
    source: z.enum(["github", "partner", "custom"]),
  })
  .nullable()

export const s_nullable_alert_updated_at = z.iso
  .datetime({offset: true})
  .nullable()

export const s_nullable_code_of_conduct_simple = z
  .object({
    url: z.string(),
    key: z.string(),
    name: z.string(),
    html_url: z.string().nullable(),
  })
  .nullable()

export const s_nullable_codespace_machine = z
  .object({
    name: z.string(),
    display_name: z.string(),
    operating_system: z.string(),
    storage_in_bytes: z.coerce.number(),
    memory_in_bytes: z.coerce.number(),
    cpus: z.coerce.number(),
    prebuild_availability: z.enum(["none", "ready", "in_progress"]).nullable(),
  })
  .nullable()

export const s_nullable_collaborator = z
  .object({
    login: z.string(),
    id: z.coerce.number(),
    email: z.string().nullable().optional(),
    name: z.string().nullable().optional(),
    node_id: z.string(),
    avatar_url: z.string(),
    gravatar_id: z.string().nullable(),
    url: z.string(),
    html_url: z.string(),
    followers_url: z.string(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    subscriptions_url: z.string(),
    organizations_url: z.string(),
    repos_url: z.string(),
    events_url: z.string(),
    received_events_url: z.string(),
    type: z.string(),
    site_admin: PermissiveBoolean,
    permissions: z
      .object({
        pull: PermissiveBoolean,
        triage: PermissiveBoolean.optional(),
        push: PermissiveBoolean,
        maintain: PermissiveBoolean.optional(),
        admin: PermissiveBoolean,
      })
      .optional(),
    role_name: z.string(),
    user_view_type: z.string().optional(),
  })
  .nullable()

export const s_nullable_community_health_file = z
  .object({url: z.string(), html_url: z.string()})
  .nullable()

export const s_nullable_git_user = z
  .object({
    name: z.string().optional(),
    email: z.string().optional(),
    date: z.string().optional(),
  })
  .nullable()

export const s_nullable_license_simple = z
  .object({
    key: z.string(),
    name: z.string(),
    url: z.string().nullable(),
    spdx_id: z.string().nullable(),
    node_id: z.string(),
    html_url: z.string().optional(),
  })
  .nullable()

export const s_nullable_organization_simple = z
  .object({
    login: z.string(),
    id: z.coerce.number(),
    node_id: z.string(),
    url: z.string(),
    repos_url: z.string(),
    events_url: z.string(),
    hooks_url: z.string(),
    issues_url: z.string(),
    members_url: z.string(),
    public_members_url: z.string(),
    avatar_url: z.string(),
    description: z.string().nullable(),
  })
  .nullable()

export const s_nullable_simple_commit = z
  .object({
    id: z.string(),
    tree_id: z.string(),
    message: z.string(),
    timestamp: z.iso.datetime({offset: true}),
    author: z.object({name: z.string(), email: z.email()}).nullable(),
    committer: z.object({name: z.string(), email: z.email()}).nullable(),
  })
  .nullable()

export const s_nullable_simple_user = z
  .object({
    name: z.string().nullable().optional(),
    email: z.string().nullable().optional(),
    login: z.string(),
    id: z.coerce.number(),
    node_id: z.string(),
    avatar_url: z.string(),
    gravatar_id: z.string().nullable(),
    url: z.string(),
    html_url: z.string(),
    followers_url: z.string(),
    following_url: z.string(),
    gists_url: z.string(),
    starred_url: z.string(),
    subscriptions_url: z.string(),
    organizations_url: z.string(),
    repos_url: z.string(),
    events_url: z.string(),
    received_events_url: z.string(),
    type: z.string(),
    site_admin: PermissiveBoolean,
    starred_at: z.string().optional(),
    user_view_type: z.string().optional(),
  })
  .nullable()

export const s_nullable_team_simple = z
  .object({
    id: z.coerce.number(),
    node_id: z.string(),
    url: z.string(),
    members_url: z.string(),
    name: z.string(),
    description: z.string().nullable(),
    permission: z.string(),
    privacy: z.string().optional(),
    notification_setting: z.string().optional(),
    html_url: z.string(),
    repositories_url: z.string(),
    slug: z.string(),
    ldap_dn: z.string().optional(),
  })
  .nullable()

export const s_oidc_custom_sub = z.object({
  include_claim_keys: z.array(z.string()),
})

export const s_oidc_custom_sub_repo = z.object({
  use_default: PermissiveBoolean,
  include_claim_keys: z.array(z.string()).optional(),
})

export const s_org_hook = z.object({
  id: z.coerce.number(),
  url: z.string(),
  ping_url: z.string(),
  deliveries_url: z.string().optional(),
  name: z.string(),
  events: z.array(z.string()),
  active: PermissiveBoolean,
  config: z.object({
    url: z.string().optional(),
    insecure_ssl: z.string().optional(),
    content_type: z.string().optional(),
    secret: z.string().optional(),
  }),
  updated_at: z.iso.datetime({offset: true}),
  created_at: z.iso.datetime({offset: true}),
  type: z.string(),
})

export const s_org_private_registry_configuration = z.object({
  name: z.string(),
  registry_type: z.enum([
    "maven_repository",
    "nuget_feed",
    "goproxy_server",
    "npm_registry",
    "rubygems_server",
    "cargo_registry",
    "composer_repository",
    "docker_registry",
    "git_source",
    "helm_registry",
    "hex_organization",
    "hex_repository",
    "pub_repository",
    "python_index",
    "terraform_registry",
  ]),
  username: z.string().nullable().optional(),
  visibility: z.enum(["all", "private", "selected"]),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_org_private_registry_configuration_with_selected_repositories =
  z.object({
    name: z.string(),
    registry_type: z.enum([
      "maven_repository",
      "nuget_feed",
      "goproxy_server",
      "npm_registry",
      "rubygems_server",
      "cargo_registry",
      "composer_repository",
      "docker_registry",
      "git_source",
      "helm_registry",
      "hex_organization",
      "hex_repository",
      "pub_repository",
      "python_index",
      "terraform_registry",
    ]),
    username: z.string().optional(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
    created_at: z.iso.datetime({offset: true}),
    updated_at: z.iso.datetime({offset: true}),
  })

export const s_organization_actions_secret = z.object({
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repositories_url: z.string().optional(),
})

export const s_organization_actions_variable = z.object({
  name: z.string(),
  value: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repositories_url: z.string().optional(),
})

export const s_organization_create_issue_type = z.object({
  name: z.string(),
  is_enabled: PermissiveBoolean,
  description: z.string().nullable().optional(),
  color: z
    .enum([
      "gray",
      "blue",
      "green",
      "yellow",
      "orange",
      "red",
      "pink",
      "purple",
    ])
    .nullable()
    .optional(),
})

export const s_organization_dependabot_secret = z.object({
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repositories_url: z.string().optional(),
})

export const s_organization_full = z.object({
  login: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  hooks_url: z.string(),
  issues_url: z.string(),
  members_url: z.string(),
  public_members_url: z.string(),
  avatar_url: z.string(),
  description: z.string().nullable(),
  name: z.string().optional(),
  company: z.string().optional(),
  blog: z.string().optional(),
  location: z.string().optional(),
  email: z.email().optional(),
  twitter_username: z.string().nullable().optional(),
  is_verified: PermissiveBoolean.optional(),
  has_organization_projects: PermissiveBoolean,
  has_repository_projects: PermissiveBoolean,
  public_repos: z.coerce.number(),
  public_gists: z.coerce.number(),
  followers: z.coerce.number(),
  following: z.coerce.number(),
  html_url: z.string(),
  type: z.string(),
  total_private_repos: z.coerce.number().optional(),
  owned_private_repos: z.coerce.number().optional(),
  private_gists: z.coerce.number().nullable().optional(),
  disk_usage: z.coerce.number().nullable().optional(),
  collaborators: z.coerce.number().nullable().optional(),
  billing_email: z.email().nullable().optional(),
  plan: z
    .object({
      name: z.string(),
      space: z.coerce.number(),
      private_repos: z.coerce.number(),
      filled_seats: z.coerce.number().optional(),
      seats: z.coerce.number().optional(),
    })
    .optional(),
  default_repository_permission: z.string().nullable().optional(),
  default_repository_branch: z.string().nullable().optional(),
  members_can_create_repositories: PermissiveBoolean.nullable().optional(),
  two_factor_requirement_enabled: PermissiveBoolean.nullable().optional(),
  members_allowed_repository_creation_type: z.string().optional(),
  members_can_create_public_repositories: PermissiveBoolean.optional(),
  members_can_create_private_repositories: PermissiveBoolean.optional(),
  members_can_create_internal_repositories: PermissiveBoolean.optional(),
  members_can_create_pages: PermissiveBoolean.optional(),
  members_can_create_public_pages: PermissiveBoolean.optional(),
  members_can_create_private_pages: PermissiveBoolean.optional(),
  members_can_delete_repositories: PermissiveBoolean.optional(),
  members_can_change_repo_visibility: PermissiveBoolean.optional(),
  members_can_invite_outside_collaborators: PermissiveBoolean.optional(),
  members_can_delete_issues: PermissiveBoolean.optional(),
  display_commenter_full_name_setting_enabled: PermissiveBoolean.optional(),
  readers_can_create_discussions: PermissiveBoolean.optional(),
  members_can_create_teams: PermissiveBoolean.optional(),
  members_can_view_dependency_insights: PermissiveBoolean.optional(),
  members_can_fork_private_repositories:
    PermissiveBoolean.nullable().optional(),
  web_commit_signoff_required: PermissiveBoolean.optional(),
  advanced_security_enabled_for_new_repositories: PermissiveBoolean.optional(),
  dependabot_alerts_enabled_for_new_repositories: PermissiveBoolean.optional(),
  dependabot_security_updates_enabled_for_new_repositories:
    PermissiveBoolean.optional(),
  dependency_graph_enabled_for_new_repositories: PermissiveBoolean.optional(),
  secret_scanning_enabled_for_new_repositories: PermissiveBoolean.optional(),
  secret_scanning_push_protection_enabled_for_new_repositories:
    PermissiveBoolean.optional(),
  secret_scanning_push_protection_custom_link_enabled:
    PermissiveBoolean.optional(),
  secret_scanning_push_protection_custom_link: z.string().nullable().optional(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  archived_at: z.iso.datetime({offset: true}).nullable(),
  deploy_keys_enabled_for_repositories: PermissiveBoolean.optional(),
})

export const s_organization_simple = z.object({
  login: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  hooks_url: z.string(),
  issues_url: z.string(),
  members_url: z.string(),
  public_members_url: z.string(),
  avatar_url: z.string(),
  description: z.string().nullable(),
})

export const s_organization_update_issue_type = z.object({
  name: z.string(),
  is_enabled: PermissiveBoolean,
  description: z.string().nullable().optional(),
  color: z
    .enum([
      "gray",
      "blue",
      "green",
      "yellow",
      "orange",
      "red",
      "pink",
      "purple",
    ])
    .nullable()
    .optional(),
})

export const s_package_version = z.object({
  id: z.coerce.number(),
  name: z.string(),
  url: z.string(),
  package_html_url: z.string(),
  html_url: z.string().optional(),
  license: z.string().optional(),
  description: z.string().optional(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  deleted_at: z.iso.datetime({offset: true}).optional(),
  metadata: z
    .object({
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      container: z.object({tags: z.array(z.string())}).optional(),
      docker: z.object({tag: z.array(z.string()).optional()}).optional(),
    })
    .optional(),
})

export const s_packages_billing_usage = z.object({
  total_gigabytes_bandwidth_used: z.coerce.number(),
  total_paid_gigabytes_bandwidth_used: z.coerce.number(),
  included_gigabytes_bandwidth: z.coerce.number(),
})

export const s_page_build_status = z.object({
  url: z.string(),
  status: z.string(),
})

export const s_page_deployment = z.object({
  id: z.union([z.coerce.number(), z.string()]),
  status_url: z.string(),
  page_url: z.string(),
  preview_url: z.string().optional(),
})

export const s_pages_deployment_status = z.object({
  status: z
    .enum([
      "deployment_in_progress",
      "syncing_files",
      "finished_file_sync",
      "updating_pages",
      "purging_cdn",
      "deployment_cancelled",
      "deployment_failed",
      "deployment_content_failed",
      "deployment_attempt_error",
      "deployment_lost",
      "succeed",
    ])
    .optional(),
})

export const s_pages_health_check = z.object({
  domain: z
    .object({
      host: z.string().optional(),
      uri: z.string().optional(),
      nameservers: z.string().optional(),
      dns_resolves: PermissiveBoolean.optional(),
      is_proxied: PermissiveBoolean.nullable().optional(),
      is_cloudflare_ip: PermissiveBoolean.nullable().optional(),
      is_fastly_ip: PermissiveBoolean.nullable().optional(),
      is_old_ip_address: PermissiveBoolean.nullable().optional(),
      is_a_record: PermissiveBoolean.nullable().optional(),
      has_cname_record: PermissiveBoolean.nullable().optional(),
      has_mx_records_present: PermissiveBoolean.nullable().optional(),
      is_valid_domain: PermissiveBoolean.optional(),
      is_apex_domain: PermissiveBoolean.optional(),
      should_be_a_record: PermissiveBoolean.nullable().optional(),
      is_cname_to_github_user_domain: PermissiveBoolean.nullable().optional(),
      is_cname_to_pages_dot_github_dot_com:
        PermissiveBoolean.nullable().optional(),
      is_cname_to_fastly: PermissiveBoolean.nullable().optional(),
      is_pointed_to_github_pages_ip: PermissiveBoolean.nullable().optional(),
      is_non_github_pages_ip_present: PermissiveBoolean.nullable().optional(),
      is_pages_domain: PermissiveBoolean.optional(),
      is_served_by_pages: PermissiveBoolean.nullable().optional(),
      is_valid: PermissiveBoolean.optional(),
      reason: z.string().nullable().optional(),
      responds_to_https: PermissiveBoolean.optional(),
      enforces_https: PermissiveBoolean.optional(),
      https_error: z.string().nullable().optional(),
      is_https_eligible: PermissiveBoolean.nullable().optional(),
      caa_error: z.string().nullable().optional(),
    })
    .optional(),
  alt_domain: z
    .object({
      host: z.string().optional(),
      uri: z.string().optional(),
      nameservers: z.string().optional(),
      dns_resolves: PermissiveBoolean.optional(),
      is_proxied: PermissiveBoolean.nullable().optional(),
      is_cloudflare_ip: PermissiveBoolean.nullable().optional(),
      is_fastly_ip: PermissiveBoolean.nullable().optional(),
      is_old_ip_address: PermissiveBoolean.nullable().optional(),
      is_a_record: PermissiveBoolean.nullable().optional(),
      has_cname_record: PermissiveBoolean.nullable().optional(),
      has_mx_records_present: PermissiveBoolean.nullable().optional(),
      is_valid_domain: PermissiveBoolean.optional(),
      is_apex_domain: PermissiveBoolean.optional(),
      should_be_a_record: PermissiveBoolean.nullable().optional(),
      is_cname_to_github_user_domain: PermissiveBoolean.nullable().optional(),
      is_cname_to_pages_dot_github_dot_com:
        PermissiveBoolean.nullable().optional(),
      is_cname_to_fastly: PermissiveBoolean.nullable().optional(),
      is_pointed_to_github_pages_ip: PermissiveBoolean.nullable().optional(),
      is_non_github_pages_ip_present: PermissiveBoolean.nullable().optional(),
      is_pages_domain: PermissiveBoolean.optional(),
      is_served_by_pages: PermissiveBoolean.nullable().optional(),
      is_valid: PermissiveBoolean.optional(),
      reason: z.string().nullable().optional(),
      responds_to_https: PermissiveBoolean.optional(),
      enforces_https: PermissiveBoolean.optional(),
      https_error: z.string().nullable().optional(),
      is_https_eligible: PermissiveBoolean.nullable().optional(),
      caa_error: z.string().nullable().optional(),
    })
    .nullable()
    .optional(),
})

export const s_pages_https_certificate = z.object({
  state: z.enum([
    "new",
    "authorization_created",
    "authorization_pending",
    "authorized",
    "authorization_revoked",
    "issued",
    "uploaded",
    "approved",
    "errored",
    "bad_authz",
    "destroy_pending",
    "dns_changed",
  ]),
  description: z.string(),
  domains: z.array(z.string()),
  expires_at: z.string().optional(),
})

export const s_pages_source_hash = z.object({
  branch: z.string(),
  path: z.string(),
})

export const s_participation_stats = z.object({
  all: z.array(z.coerce.number()),
  owner: z.array(z.coerce.number()),
})

export const s_porter_author = z.object({
  id: z.coerce.number(),
  remote_id: z.string(),
  remote_name: z.string(),
  email: z.string(),
  name: z.string(),
  url: z.string(),
  import_url: z.string(),
})

export const s_porter_large_file = z.object({
  ref_name: z.string(),
  path: z.string(),
  oid: z.string(),
  size: z.coerce.number(),
})

export const s_prevent_self_review = PermissiveBoolean

export const s_private_user = z.object({
  login: z.string(),
  id: z.coerce.number(),
  user_view_type: z.string().optional(),
  node_id: z.string(),
  avatar_url: z.string(),
  gravatar_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  followers_url: z.string(),
  following_url: z.string(),
  gists_url: z.string(),
  starred_url: z.string(),
  subscriptions_url: z.string(),
  organizations_url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  received_events_url: z.string(),
  type: z.string(),
  site_admin: PermissiveBoolean,
  name: z.string().nullable(),
  company: z.string().nullable(),
  blog: z.string().nullable(),
  location: z.string().nullable(),
  email: z.email().nullable(),
  notification_email: z.email().nullable().optional(),
  hireable: PermissiveBoolean.nullable(),
  bio: z.string().nullable(),
  twitter_username: z.string().nullable().optional(),
  public_repos: z.coerce.number(),
  public_gists: z.coerce.number(),
  followers: z.coerce.number(),
  following: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  private_gists: z.coerce.number(),
  total_private_repos: z.coerce.number(),
  owned_private_repos: z.coerce.number(),
  disk_usage: z.coerce.number(),
  collaborators: z.coerce.number(),
  two_factor_authentication: PermissiveBoolean,
  plan: z
    .object({
      collaborators: z.coerce.number(),
      name: z.string(),
      space: z.coerce.number(),
      private_repos: z.coerce.number(),
    })
    .optional(),
  business_plus: PermissiveBoolean.optional(),
  ldap_dn: z.string().optional(),
})

export const s_project_column = z.object({
  url: z.string(),
  project_url: z.string(),
  cards_url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_protected_branch_admin_enforced = z.object({
  url: z.string(),
  enabled: PermissiveBoolean,
})

export const s_protected_branch_required_status_check = z.object({
  url: z.string().optional(),
  enforcement_level: z.string().optional(),
  contexts: z.array(z.string()),
  checks: z.array(
    z.object({context: z.string(), app_id: z.coerce.number().nullable()}),
  ),
  contexts_url: z.string().optional(),
  strict: PermissiveBoolean.optional(),
})

export const s_public_ip = z.object({
  enabled: PermissiveBoolean.optional(),
  prefix: z.string().optional(),
  length: z.coerce.number().optional(),
})

export const s_public_user = z.object({
  login: z.string(),
  id: z.coerce.number(),
  user_view_type: z.string().optional(),
  node_id: z.string(),
  avatar_url: z.string(),
  gravatar_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  followers_url: z.string(),
  following_url: z.string(),
  gists_url: z.string(),
  starred_url: z.string(),
  subscriptions_url: z.string(),
  organizations_url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  received_events_url: z.string(),
  type: z.string(),
  site_admin: PermissiveBoolean,
  name: z.string().nullable(),
  company: z.string().nullable(),
  blog: z.string().nullable(),
  location: z.string().nullable(),
  email: z.email().nullable(),
  notification_email: z.email().nullable().optional(),
  hireable: PermissiveBoolean.nullable(),
  bio: z.string().nullable(),
  twitter_username: z.string().nullable().optional(),
  public_repos: z.coerce.number(),
  public_gists: z.coerce.number(),
  followers: z.coerce.number(),
  following: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  plan: z
    .object({
      collaborators: z.coerce.number(),
      name: z.string(),
      space: z.coerce.number(),
      private_repos: z.coerce.number(),
    })
    .optional(),
  private_gists: z.coerce.number().optional(),
  total_private_repos: z.coerce.number().optional(),
  owned_private_repos: z.coerce.number().optional(),
  disk_usage: z.coerce.number().optional(),
  collaborators: z.coerce.number().optional(),
})

export const s_pull_request_merge_result = z.object({
  sha: z.string(),
  merged: PermissiveBoolean,
  message: z.string(),
})

export const s_pull_request_minimal = z.object({
  id: z.coerce.number(),
  number: z.coerce.number(),
  url: z.string(),
  head: z.object({
    ref: z.string(),
    sha: z.string(),
    repo: z.object({id: z.coerce.number(), url: z.string(), name: z.string()}),
  }),
  base: z.object({
    ref: z.string(),
    sha: z.string(),
    repo: z.object({id: z.coerce.number(), url: z.string(), name: z.string()}),
  }),
})

export const s_rate_limit = z.object({
  limit: z.coerce.number(),
  remaining: z.coerce.number(),
  reset: z.coerce.number(),
  used: z.coerce.number(),
})

export const s_reaction_rollup = z.object({
  url: z.string(),
  total_count: z.coerce.number(),
  "+1": z.coerce.number(),
  "-1": z.coerce.number(),
  laugh: z.coerce.number(),
  confused: z.coerce.number(),
  heart: z.coerce.number(),
  hooray: z.coerce.number(),
  eyes: z.coerce.number(),
  rocket: z.coerce.number(),
})

export const s_referenced_workflow = z.object({
  path: z.string(),
  sha: z.string(),
  ref: z.string().optional(),
})

export const s_referrer_traffic = z.object({
  referrer: z.string(),
  count: z.coerce.number(),
  uniques: z.coerce.number(),
})

export const s_release_notes_content = z.object({
  name: z.string(),
  body: z.string(),
})

export const s_repo_codespaces_secret = z.object({
  name: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_repository_rule_branch_name_pattern = z.object({
  type: z.enum(["branch_name_pattern"]),
  parameters: z
    .object({
      name: z.string().optional(),
      negate: PermissiveBoolean.optional(),
      operator: z.enum(["starts_with", "ends_with", "contains", "regex"]),
      pattern: z.string(),
    })
    .optional(),
})

export const s_repository_rule_commit_author_email_pattern = z.object({
  type: z.enum(["commit_author_email_pattern"]),
  parameters: z
    .object({
      name: z.string().optional(),
      negate: PermissiveBoolean.optional(),
      operator: z.enum(["starts_with", "ends_with", "contains", "regex"]),
      pattern: z.string(),
    })
    .optional(),
})

export const s_repository_rule_commit_message_pattern = z.object({
  type: z.enum(["commit_message_pattern"]),
  parameters: z
    .object({
      name: z.string().optional(),
      negate: PermissiveBoolean.optional(),
      operator: z.enum(["starts_with", "ends_with", "contains", "regex"]),
      pattern: z.string(),
    })
    .optional(),
})

export const s_repository_rule_committer_email_pattern = z.object({
  type: z.enum(["committer_email_pattern"]),
  parameters: z
    .object({
      name: z.string().optional(),
      negate: PermissiveBoolean.optional(),
      operator: z.enum(["starts_with", "ends_with", "contains", "regex"]),
      pattern: z.string(),
    })
    .optional(),
})

export const s_repository_rule_creation = z.object({type: z.enum(["creation"])})

export const s_repository_rule_deletion = z.object({type: z.enum(["deletion"])})

export const s_repository_rule_enforcement = z.enum([
  "disabled",
  "active",
  "evaluate",
])

export const s_repository_rule_file_extension_restriction = z.object({
  type: z.enum(["file_extension_restriction"]),
  parameters: z
    .object({restricted_file_extensions: z.array(z.string())})
    .optional(),
})

export const s_repository_rule_file_path_restriction = z.object({
  type: z.enum(["file_path_restriction"]),
  parameters: z.object({restricted_file_paths: z.array(z.string())}).optional(),
})

export const s_repository_rule_max_file_path_length = z.object({
  type: z.enum(["max_file_path_length"]),
  parameters: z
    .object({max_file_path_length: z.coerce.number().min(1).max(32767)})
    .optional(),
})

export const s_repository_rule_max_file_size = z.object({
  type: z.enum(["max_file_size"]),
  parameters: z
    .object({max_file_size: z.coerce.number().min(1).max(100)})
    .optional(),
})

export const s_repository_rule_merge_queue = z.object({
  type: z.enum(["merge_queue"]),
  parameters: z
    .object({
      check_response_timeout_minutes: z.coerce.number().min(1).max(360),
      grouping_strategy: z.enum(["ALLGREEN", "HEADGREEN"]),
      max_entries_to_build: z.coerce.number().min(0).max(100),
      max_entries_to_merge: z.coerce.number().min(0).max(100),
      merge_method: z.enum(["MERGE", "SQUASH", "REBASE"]),
      min_entries_to_merge: z.coerce.number().min(0).max(100),
      min_entries_to_merge_wait_minutes: z.coerce.number().min(0).max(360),
    })
    .optional(),
})

export const s_repository_rule_non_fast_forward = z.object({
  type: z.enum(["non_fast_forward"]),
})

export const s_repository_rule_params_code_scanning_tool = z.object({
  alerts_threshold: z.enum(["none", "errors", "errors_and_warnings", "all"]),
  security_alerts_threshold: z.enum([
    "none",
    "critical",
    "high_or_higher",
    "medium_or_higher",
    "all",
  ]),
  tool: z.string(),
})

export const s_repository_rule_params_status_check_configuration = z.object({
  context: z.string(),
  integration_id: z.coerce.number().optional(),
})

export const s_repository_rule_params_workflow_file_reference = z.object({
  path: z.string(),
  ref: z.string().optional(),
  repository_id: z.coerce.number(),
  sha: z.string().optional(),
})

export const s_repository_rule_pull_request = z.object({
  type: z.enum(["pull_request"]),
  parameters: z
    .object({
      allowed_merge_methods: z
        .array(z.enum(["merge", "squash", "rebase"]))
        .optional(),
      automatic_copilot_code_review_enabled: PermissiveBoolean.optional(),
      dismiss_stale_reviews_on_push: PermissiveBoolean,
      require_code_owner_review: PermissiveBoolean,
      require_last_push_approval: PermissiveBoolean,
      required_approving_review_count: z.coerce.number().min(0).max(10),
      required_review_thread_resolution: PermissiveBoolean,
    })
    .optional(),
})

export const s_repository_rule_required_deployments = z.object({
  type: z.enum(["required_deployments"]),
  parameters: z
    .object({required_deployment_environments: z.array(z.string())})
    .optional(),
})

export const s_repository_rule_required_linear_history = z.object({
  type: z.enum(["required_linear_history"]),
})

export const s_repository_rule_required_signatures = z.object({
  type: z.enum(["required_signatures"]),
})

export const s_repository_rule_ruleset_info = z.object({
  ruleset_source_type: z.enum(["Repository", "Organization"]).optional(),
  ruleset_source: z.string().optional(),
  ruleset_id: z.coerce.number().optional(),
})

export const s_repository_rule_tag_name_pattern = z.object({
  type: z.enum(["tag_name_pattern"]),
  parameters: z
    .object({
      name: z.string().optional(),
      negate: PermissiveBoolean.optional(),
      operator: z.enum(["starts_with", "ends_with", "contains", "regex"]),
      pattern: z.string(),
    })
    .optional(),
})

export const s_repository_rule_update = z.object({
  type: z.enum(["update"]),
  parameters: z
    .object({update_allows_fetch_and_merge: PermissiveBoolean})
    .optional(),
})

export const s_repository_ruleset_bypass_actor = z.object({
  actor_id: z.coerce.number().nullable().optional(),
  actor_type: z.enum([
    "Integration",
    "OrganizationAdmin",
    "RepositoryRole",
    "Team",
    "DeployKey",
  ]),
  bypass_mode: z.enum(["always", "pull_request"]).optional().default("always"),
})

export const s_repository_ruleset_conditions = z.object({
  ref_name: z
    .object({
      include: z.array(z.string()).optional(),
      exclude: z.array(z.string()).optional(),
    })
    .optional(),
})

export const s_repository_ruleset_conditions_repository_id_target = z.object({
  repository_id: z.object({
    repository_ids: z.array(z.coerce.number()).optional(),
  }),
})

export const s_repository_ruleset_conditions_repository_name_target = z.object({
  repository_name: z.object({
    include: z.array(z.string()).optional(),
    exclude: z.array(z.string()).optional(),
    protected: PermissiveBoolean.optional(),
  }),
})

export const s_repository_ruleset_conditions_repository_property_spec =
  z.object({
    name: z.string(),
    property_values: z.array(z.string()),
    source: z.enum(["custom", "system"]).optional(),
  })

export const s_repository_subscription = z.object({
  subscribed: PermissiveBoolean,
  ignored: PermissiveBoolean,
  reason: z.string().nullable(),
  created_at: z.iso.datetime({offset: true}),
  url: z.string(),
  repository_url: z.string(),
})

export const s_review_custom_gates_comment_required = z.object({
  environment_name: z.string(),
  comment: z.string(),
})

export const s_review_custom_gates_state_required = z.object({
  environment_name: z.string(),
  state: z.enum(["approved", "rejected"]),
  comment: z.string().optional(),
})

export const s_root = z.object({
  current_user_url: z.string(),
  current_user_authorizations_html_url: z.string(),
  authorizations_url: z.string(),
  code_search_url: z.string(),
  commit_search_url: z.string(),
  emails_url: z.string(),
  emojis_url: z.string(),
  events_url: z.string(),
  feeds_url: z.string(),
  followers_url: z.string(),
  following_url: z.string(),
  gists_url: z.string(),
  hub_url: z.string().optional(),
  issue_search_url: z.string(),
  issues_url: z.string(),
  keys_url: z.string(),
  label_search_url: z.string(),
  notifications_url: z.string(),
  organization_url: z.string(),
  organization_repositories_url: z.string(),
  organization_teams_url: z.string(),
  public_gists_url: z.string(),
  rate_limit_url: z.string(),
  repository_url: z.string(),
  repository_search_url: z.string(),
  current_user_repositories_url: z.string(),
  starred_url: z.string(),
  starred_gists_url: z.string(),
  topic_search_url: z.string().optional(),
  user_url: z.string(),
  user_organizations_url: z.string(),
  user_repositories_url: z.string(),
  user_search_url: z.string(),
})

export const s_rule_suite = z.object({
  id: z.coerce.number().optional(),
  actor_id: z.coerce.number().nullable().optional(),
  actor_name: z.string().nullable().optional(),
  before_sha: z.string().optional(),
  after_sha: z.string().optional(),
  ref: z.string().optional(),
  repository_id: z.coerce.number().optional(),
  repository_name: z.string().optional(),
  pushed_at: z.iso.datetime({offset: true}).optional(),
  result: z.enum(["pass", "fail", "bypass"]).optional(),
  evaluation_result: z.enum(["pass", "fail", "bypass"]).nullable().optional(),
  rule_evaluations: z
    .array(
      z.object({
        rule_source: z
          .object({
            type: z.string().optional(),
            id: z.coerce.number().nullable().optional(),
            name: z.string().nullable().optional(),
          })
          .optional(),
        enforcement: z
          .enum(["active", "evaluate", "deleted ruleset"])
          .optional(),
        result: z.enum(["pass", "fail"]).optional(),
        rule_type: z.string().optional(),
        details: z.string().nullable().optional(),
      }),
    )
    .optional(),
})

export const s_rule_suites = z.array(
  z.object({
    id: z.coerce.number().optional(),
    actor_id: z.coerce.number().optional(),
    actor_name: z.string().optional(),
    before_sha: z.string().optional(),
    after_sha: z.string().optional(),
    ref: z.string().optional(),
    repository_id: z.coerce.number().optional(),
    repository_name: z.string().optional(),
    pushed_at: z.iso.datetime({offset: true}).optional(),
    result: z.enum(["pass", "fail", "bypass"]).optional(),
    evaluation_result: z.enum(["pass", "fail", "bypass"]).optional(),
  }),
)

export const s_ruleset_version = z.object({
  version_id: z.coerce.number(),
  actor: z.object({
    id: z.coerce.number().optional(),
    type: z.string().optional(),
  }),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_runner_application = z.object({
  os: z.string(),
  architecture: z.string(),
  download_url: z.string(),
  filename: z.string(),
  temp_download_token: z.string().optional(),
  sha256_checksum: z.string().optional(),
})

export const s_runner_groups_org = z.object({
  id: z.coerce.number(),
  name: z.string(),
  visibility: z.string(),
  default: PermissiveBoolean,
  selected_repositories_url: z.string().optional(),
  runners_url: z.string(),
  hosted_runners_url: z.string().optional(),
  network_configuration_id: z.string().optional(),
  inherited: PermissiveBoolean,
  inherited_allows_public_repositories: PermissiveBoolean.optional(),
  allows_public_repositories: PermissiveBoolean,
  workflow_restrictions_read_only: PermissiveBoolean.optional().default(false),
  restricted_to_workflows: PermissiveBoolean.optional().default(false),
  selected_workflows: z.array(z.string()).optional(),
})

export const s_runner_label = z.object({
  id: z.coerce.number().optional(),
  name: z.string(),
  type: z.enum(["read-only", "custom"]).optional(),
})

export const s_scim_error = z.object({
  message: z.string().nullable().optional(),
  documentation_url: z.string().nullable().optional(),
  detail: z.string().nullable().optional(),
  status: z.coerce.number().optional(),
  scimType: z.string().nullable().optional(),
  schemas: z.array(z.string()).optional(),
})

export const s_search_result_text_matches = z.array(
  z.object({
    object_url: z.string().optional(),
    object_type: z.string().nullable().optional(),
    property: z.string().optional(),
    fragment: z.string().optional(),
    matches: z
      .array(
        z.object({
          text: z.string().optional(),
          indices: z.array(z.coerce.number()).optional(),
        }),
      )
      .optional(),
  }),
)

export const s_secret_scanning_alert_resolution = z
  .enum(["false_positive", "wont_fix", "revoked", "used_in_tests"])
  .nullable()

export const s_secret_scanning_alert_resolution_comment = z.string().nullable()

export const s_secret_scanning_alert_state = z.enum(["open", "resolved"])

export const s_secret_scanning_location_commit = z.object({
  path: z.string(),
  start_line: z.coerce.number(),
  end_line: z.coerce.number(),
  start_column: z.coerce.number(),
  end_column: z.coerce.number(),
  blob_sha: z.string(),
  blob_url: z.string(),
  commit_sha: z.string(),
  commit_url: z.string(),
})

export const s_secret_scanning_location_discussion_body = z.object({
  discussion_body_url: z.string(),
})

export const s_secret_scanning_location_discussion_comment = z.object({
  discussion_comment_url: z.string(),
})

export const s_secret_scanning_location_discussion_title = z.object({
  discussion_title_url: z.string(),
})

export const s_secret_scanning_location_issue_body = z.object({
  issue_body_url: z.string(),
})

export const s_secret_scanning_location_issue_comment = z.object({
  issue_comment_url: z.string(),
})

export const s_secret_scanning_location_issue_title = z.object({
  issue_title_url: z.string(),
})

export const s_secret_scanning_location_pull_request_body = z.object({
  pull_request_body_url: z.string(),
})

export const s_secret_scanning_location_pull_request_comment = z.object({
  pull_request_comment_url: z.string(),
})

export const s_secret_scanning_location_pull_request_review = z.object({
  pull_request_review_url: z.string(),
})

export const s_secret_scanning_location_pull_request_review_comment = z.object({
  pull_request_review_comment_url: z.string(),
})

export const s_secret_scanning_location_pull_request_title = z.object({
  pull_request_title_url: z.string(),
})

export const s_secret_scanning_location_wiki_commit = z.object({
  path: z.string(),
  start_line: z.coerce.number(),
  end_line: z.coerce.number(),
  start_column: z.coerce.number(),
  end_column: z.coerce.number(),
  blob_sha: z.string(),
  page_url: z.string(),
  commit_sha: z.string(),
  commit_url: z.string(),
})

export const s_secret_scanning_push_protection_bypass_placeholder_id =
  z.string()

export const s_secret_scanning_push_protection_bypass_reason = z.enum([
  "false_positive",
  "used_in_tests",
  "will_fix_later",
])

export const s_secret_scanning_scan = z.object({
  type: z.string().optional(),
  status: z.string().optional(),
  completed_at: z.iso.datetime({offset: true}).nullable().optional(),
  started_at: z.iso.datetime({offset: true}).nullable().optional(),
})

export const s_security_advisory_credit_types = z.enum([
  "analyst",
  "finder",
  "reporter",
  "coordinator",
  "remediation_developer",
  "remediation_reviewer",
  "remediation_verifier",
  "tool",
  "sponsor",
  "other",
])

export const s_security_advisory_ecosystems = z.enum([
  "rubygems",
  "npm",
  "pip",
  "maven",
  "nuget",
  "composer",
  "go",
  "rust",
  "erlang",
  "actions",
  "pub",
  "other",
  "swift",
])

export const s_security_advisory_epss = z
  .object({
    percentage: z.coerce.number().min(0).max(100).optional(),
    percentile: z.coerce.number().min(0).max(100).optional(),
  })
  .nullable()

export const s_security_and_analysis = z
  .object({
    advanced_security: z
      .object({status: z.enum(["enabled", "disabled"]).optional()})
      .optional(),
    code_security: z
      .object({status: z.enum(["enabled", "disabled"]).optional()})
      .optional(),
    dependabot_security_updates: z
      .object({status: z.enum(["enabled", "disabled"]).optional()})
      .optional(),
    secret_scanning: z
      .object({status: z.enum(["enabled", "disabled"]).optional()})
      .optional(),
    secret_scanning_push_protection: z
      .object({status: z.enum(["enabled", "disabled"]).optional()})
      .optional(),
    secret_scanning_non_provider_patterns: z
      .object({status: z.enum(["enabled", "disabled"]).optional()})
      .optional(),
    secret_scanning_ai_detection: z
      .object({status: z.enum(["enabled", "disabled"]).optional()})
      .optional(),
  })
  .nullable()

export const s_selected_actions = z.object({
  github_owned_allowed: PermissiveBoolean.optional(),
  verified_allowed: PermissiveBoolean.optional(),
  patterns_allowed: z.array(z.string()).optional(),
})

export const s_selected_actions_url = z.string()

export const s_short_blob = z.object({url: z.string(), sha: z.string()})

export const s_simple_classroom = z.object({
  id: z.coerce.number(),
  name: z.string(),
  archived: PermissiveBoolean,
  url: z.string(),
})

export const s_simple_classroom_organization = z.object({
  id: z.coerce.number(),
  login: z.string(),
  node_id: z.string(),
  html_url: z.string(),
  name: z.string().nullable(),
  avatar_url: z.string(),
})

export const s_simple_classroom_repository = z.object({
  id: z.coerce.number(),
  full_name: z.string(),
  html_url: z.string(),
  node_id: z.string(),
  private: PermissiveBoolean,
  default_branch: z.string(),
})

export const s_simple_classroom_user = z.object({
  id: z.coerce.number(),
  login: z.string(),
  avatar_url: z.string(),
  html_url: z.string(),
})

export const s_simple_commit = z.object({
  id: z.string(),
  tree_id: z.string(),
  message: z.string(),
  timestamp: z.iso.datetime({offset: true}),
  author: z.object({name: z.string(), email: z.email()}).nullable(),
  committer: z.object({name: z.string(), email: z.email()}).nullable(),
})

export const s_simple_commit_status = z.object({
  description: z.string().nullable(),
  id: z.coerce.number(),
  node_id: z.string(),
  state: z.string(),
  context: z.string(),
  target_url: z.string().nullable(),
  required: PermissiveBoolean.nullable().optional(),
  avatar_url: z.string().nullable(),
  url: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_simple_user = z.object({
  name: z.string().nullable().optional(),
  email: z.string().nullable().optional(),
  login: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  avatar_url: z.string(),
  gravatar_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  followers_url: z.string(),
  following_url: z.string(),
  gists_url: z.string(),
  starred_url: z.string(),
  subscriptions_url: z.string(),
  organizations_url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  received_events_url: z.string(),
  type: z.string(),
  site_admin: PermissiveBoolean,
  starred_at: z.string().optional(),
  user_view_type: z.string().optional(),
})

export const s_social_account = z.object({
  provider: z.string(),
  url: z.string(),
})

export const s_ssh_signing_key = z.object({
  key: z.string(),
  id: z.coerce.number(),
  title: z.string(),
  created_at: z.iso.datetime({offset: true}),
})

export const s_status_check_policy = z.object({
  url: z.string(),
  strict: PermissiveBoolean,
  contexts: z.array(z.string()),
  checks: z.array(
    z.object({context: z.string(), app_id: z.coerce.number().nullable()}),
  ),
  contexts_url: z.string(),
})

export const s_sub_issues_summary = z.object({
  total: z.coerce.number(),
  completed: z.coerce.number(),
  percent_completed: z.coerce.number(),
})

export const s_tag = z.object({
  name: z.string(),
  commit: z.object({sha: z.string(), url: z.string()}),
  zipball_url: z.string(),
  tarball_url: z.string(),
  node_id: z.string(),
})

export const s_tag_protection = z.object({
  id: z.coerce.number().optional(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
  enabled: PermissiveBoolean.optional(),
  pattern: z.string(),
})

export const s_team_membership = z.object({
  url: z.string(),
  role: z.enum(["member", "maintainer"]).default("member"),
  state: z.enum(["active", "pending"]),
})

export const s_team_organization = z.object({
  login: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  hooks_url: z.string(),
  issues_url: z.string(),
  members_url: z.string(),
  public_members_url: z.string(),
  avatar_url: z.string(),
  description: z.string().nullable(),
  name: z.string().optional(),
  company: z.string().optional(),
  blog: z.string().optional(),
  location: z.string().optional(),
  email: z.email().optional(),
  twitter_username: z.string().nullable().optional(),
  is_verified: PermissiveBoolean.optional(),
  has_organization_projects: PermissiveBoolean,
  has_repository_projects: PermissiveBoolean,
  public_repos: z.coerce.number(),
  public_gists: z.coerce.number(),
  followers: z.coerce.number(),
  following: z.coerce.number(),
  html_url: z.string(),
  created_at: z.iso.datetime({offset: true}),
  type: z.string(),
  total_private_repos: z.coerce.number().optional(),
  owned_private_repos: z.coerce.number().optional(),
  private_gists: z.coerce.number().nullable().optional(),
  disk_usage: z.coerce.number().nullable().optional(),
  collaborators: z.coerce.number().nullable().optional(),
  billing_email: z.email().nullable().optional(),
  plan: z
    .object({
      name: z.string(),
      space: z.coerce.number(),
      private_repos: z.coerce.number(),
      filled_seats: z.coerce.number().optional(),
      seats: z.coerce.number().optional(),
    })
    .optional(),
  default_repository_permission: z.string().nullable().optional(),
  members_can_create_repositories: PermissiveBoolean.nullable().optional(),
  two_factor_requirement_enabled: PermissiveBoolean.nullable().optional(),
  members_allowed_repository_creation_type: z.string().optional(),
  members_can_create_public_repositories: PermissiveBoolean.optional(),
  members_can_create_private_repositories: PermissiveBoolean.optional(),
  members_can_create_internal_repositories: PermissiveBoolean.optional(),
  members_can_create_pages: PermissiveBoolean.optional(),
  members_can_create_public_pages: PermissiveBoolean.optional(),
  members_can_create_private_pages: PermissiveBoolean.optional(),
  members_can_fork_private_repositories:
    PermissiveBoolean.nullable().optional(),
  web_commit_signoff_required: PermissiveBoolean.optional(),
  updated_at: z.iso.datetime({offset: true}),
  archived_at: z.iso.datetime({offset: true}).nullable(),
})

export const s_team_simple = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  members_url: z.string(),
  name: z.string(),
  description: z.string().nullable(),
  permission: z.string(),
  privacy: z.string().optional(),
  notification_setting: z.string().optional(),
  html_url: z.string(),
  repositories_url: z.string(),
  slug: z.string(),
  ldap_dn: z.string().optional(),
})

export const s_thread_subscription = z.object({
  subscribed: PermissiveBoolean,
  ignored: PermissiveBoolean,
  reason: z.string().nullable(),
  created_at: z.iso.datetime({offset: true}).nullable(),
  url: z.string(),
  thread_url: z.string().optional(),
  repository_url: z.string().optional(),
})

export const s_timeline_committed_event = z.object({
  event: z.string().optional(),
  sha: z.string(),
  node_id: z.string(),
  url: z.string(),
  author: z.object({
    date: z.iso.datetime({offset: true}),
    email: z.string(),
    name: z.string(),
  }),
  committer: z.object({
    date: z.iso.datetime({offset: true}),
    email: z.string(),
    name: z.string(),
  }),
  message: z.string(),
  tree: z.object({sha: z.string(), url: z.string()}),
  parents: z.array(
    z.object({sha: z.string(), url: z.string(), html_url: z.string()}),
  ),
  verification: z.object({
    verified: PermissiveBoolean,
    reason: z.string(),
    signature: z.string().nullable(),
    payload: z.string().nullable(),
    verified_at: z.string().nullable(),
  }),
  html_url: z.string(),
})

export const s_topic = z.object({names: z.array(z.string())})

export const s_traffic = z.object({
  timestamp: z.iso.datetime({offset: true}),
  uniques: z.coerce.number(),
  count: z.coerce.number(),
})

export const s_validation_error = z.object({
  message: z.string(),
  documentation_url: z.string(),
  errors: z
    .array(
      z.object({
        resource: z.string().optional(),
        field: z.string().optional(),
        message: z.string().optional(),
        code: z.string(),
        index: z.coerce.number().optional(),
        value: z
          .union([
            z.string().nullable(),
            z.coerce.number().nullable(),
            z.array(z.string()).nullable(),
          ])
          .optional(),
      }),
    )
    .optional(),
})

export const s_validation_error_simple = z.object({
  message: z.string(),
  documentation_url: z.string(),
  errors: z.array(z.string()).optional(),
})

export const s_verification = z.object({
  verified: PermissiveBoolean,
  reason: z.string(),
  payload: z.string().nullable(),
  signature: z.string().nullable(),
  verified_at: z.string().nullable(),
})

export const s_wait_timer = z.coerce.number()

export const s_webhook_config_content_type = z.string()

export const s_webhook_config_insecure_ssl = z.union([
  z.string(),
  z.coerce.number(),
])

export const s_webhook_config_secret = z.string()

export const s_webhook_config_url = z.string()

export const s_workflow = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  path: z.string(),
  state: z.enum([
    "active",
    "deleted",
    "disabled_fork",
    "disabled_inactivity",
    "disabled_manually",
  ]),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  url: z.string(),
  html_url: z.string(),
  badge_url: z.string(),
  deleted_at: z.iso.datetime({offset: true}).optional(),
})

export const s_workflow_run_usage = z.object({
  billable: z.object({
    UBUNTU: z
      .object({
        total_ms: z.coerce.number(),
        jobs: z.coerce.number(),
        job_runs: z
          .array(
            z.object({
              job_id: z.coerce.number(),
              duration_ms: z.coerce.number(),
            }),
          )
          .optional(),
      })
      .optional(),
    MACOS: z
      .object({
        total_ms: z.coerce.number(),
        jobs: z.coerce.number(),
        job_runs: z
          .array(
            z.object({
              job_id: z.coerce.number(),
              duration_ms: z.coerce.number(),
            }),
          )
          .optional(),
      })
      .optional(),
    WINDOWS: z
      .object({
        total_ms: z.coerce.number(),
        jobs: z.coerce.number(),
        job_runs: z
          .array(
            z.object({
              job_id: z.coerce.number(),
              duration_ms: z.coerce.number(),
            }),
          )
          .optional(),
      })
      .optional(),
  }),
  run_duration_ms: z.coerce.number().optional(),
})

export const s_workflow_usage = z.object({
  billable: z.object({
    UBUNTU: z.object({total_ms: z.coerce.number().optional()}).optional(),
    MACOS: z.object({total_ms: z.coerce.number().optional()}).optional(),
    WINDOWS: z.object({total_ms: z.coerce.number().optional()}).optional(),
  }),
})

export const s_actions_get_default_workflow_permissions = z.object({
  default_workflow_permissions: s_actions_default_workflow_permissions,
  can_approve_pull_request_reviews: s_actions_can_approve_pull_request_reviews,
})

export const s_actions_hosted_runner = z.object({
  id: z.coerce.number(),
  name: z.string(),
  runner_group_id: z.coerce.number().optional(),
  image_details: s_nullable_actions_hosted_runner_pool_image,
  machine_size_details: s_actions_hosted_runner_machine_spec,
  status: z.enum(["Ready", "Provisioning", "Shutdown", "Deleting", "Stuck"]),
  platform: z.string(),
  maximum_runners: z.coerce.number().optional().default(10),
  public_ip_enabled: PermissiveBoolean,
  public_ips: z.array(s_public_ip).optional(),
  last_active_on: z.iso.datetime({offset: true}).nullable().optional(),
})

export const s_actions_organization_permissions = z.object({
  enabled_repositories: s_enabled_repositories,
  selected_repositories_url: z.string().optional(),
  allowed_actions: s_allowed_actions.optional(),
  selected_actions_url: s_selected_actions_url.optional(),
})

export const s_actions_repository_permissions = z.object({
  enabled: s_actions_enabled,
  allowed_actions: s_allowed_actions.optional(),
  selected_actions_url: s_selected_actions_url.optional(),
})

export const s_actions_set_default_workflow_permissions = z.object({
  default_workflow_permissions:
    s_actions_default_workflow_permissions.optional(),
  can_approve_pull_request_reviews:
    s_actions_can_approve_pull_request_reviews.optional(),
})

export const s_activity = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  before: z.string(),
  after: z.string(),
  ref: z.string(),
  timestamp: z.iso.datetime({offset: true}),
  activity_type: z.enum([
    "push",
    "force_push",
    "branch_deletion",
    "branch_creation",
    "pr_merge",
    "merge_queue_merge",
  ]),
  actor: s_nullable_simple_user,
})

export const s_auto_merge = z
  .object({
    enabled_by: s_simple_user,
    merge_method: z.enum(["merge", "squash", "rebase"]),
    commit_title: z.string(),
    commit_message: z.string(),
  })
  .nullable()

export const s_base_gist = z.object({
  url: z.string(),
  forks_url: z.string(),
  commits_url: z.string(),
  id: z.string(),
  node_id: z.string(),
  git_pull_url: z.string(),
  git_push_url: z.string(),
  html_url: z.string(),
  files: z.record(
    z.string(),
    z.object({
      filename: z.string().optional(),
      type: z.string().optional(),
      language: z.string().optional(),
      raw_url: z.string().optional(),
      size: z.coerce.number().optional(),
      encoding: z.string().optional().default("utf-8"),
    }),
  ),
  public: PermissiveBoolean,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  description: z.string().nullable(),
  comments: z.coerce.number(),
  comments_enabled: PermissiveBoolean.optional(),
  user: s_nullable_simple_user,
  comments_url: z.string(),
  owner: s_simple_user.optional(),
  truncated: PermissiveBoolean.optional(),
  forks: z.array(z.unknown()).optional(),
  history: z.array(z.unknown()).optional(),
})

export const s_classroom = z.object({
  id: z.coerce.number(),
  name: z.string(),
  archived: PermissiveBoolean,
  organization: s_simple_classroom_organization,
  url: z.string(),
})

export const s_clone_traffic = z.object({
  count: z.coerce.number(),
  uniques: z.coerce.number(),
  clones: z.array(s_traffic),
})

export const s_code_scanning_alert_instance = z.object({
  ref: s_code_scanning_ref.optional(),
  analysis_key: s_code_scanning_analysis_analysis_key.optional(),
  environment: s_code_scanning_alert_environment.optional(),
  category: s_code_scanning_analysis_category.optional(),
  state: s_code_scanning_alert_state.optional(),
  commit_sha: z.string().optional(),
  message: z.object({text: z.string().optional()}).optional(),
  location: s_code_scanning_alert_location.optional(),
  html_url: z.string().optional(),
  classifications: z.array(s_code_scanning_alert_classification).optional(),
})

export const s_code_scanning_analysis_tool = z.object({
  name: s_code_scanning_analysis_tool_name.optional(),
  version: s_code_scanning_analysis_tool_version.optional(),
  guid: s_code_scanning_analysis_tool_guid.optional(),
})

export const s_code_scanning_autofix = z.object({
  status: s_code_scanning_autofix_status,
  description: s_code_scanning_autofix_description,
  started_at: s_code_scanning_autofix_started_at,
})

export const s_code_scanning_codeql_database = z.object({
  id: z.coerce.number(),
  name: z.string(),
  language: z.string(),
  uploader: s_simple_user,
  content_type: z.string(),
  size: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  url: z.string(),
  commit_oid: z.string().nullable().optional(),
})

export const s_code_scanning_sarifs_receipt = z.object({
  id: s_code_scanning_analysis_sarif_id.optional(),
  url: z.string().optional(),
})

export const s_code_scanning_variant_analysis_skipped_repo_group = z.object({
  repository_count: z.coerce.number(),
  repositories: z.array(s_code_scanning_variant_analysis_repository),
})

export const s_code_security_configuration_for_repository = z.object({
  status: z
    .enum([
      "attached",
      "attaching",
      "detached",
      "removed",
      "enforced",
      "failed",
      "updating",
      "removed_by_enterprise",
    ])
    .optional(),
  configuration: s_code_security_configuration.optional(),
})

export const s_code_security_default_configurations = z.array(
  z.object({
    default_for_new_repos: z
      .enum(["public", "private_and_internal", "all"])
      .optional(),
    configuration: s_code_security_configuration.optional(),
  }),
)

export const s_commit = z.object({
  url: z.string(),
  sha: z.string(),
  node_id: z.string(),
  html_url: z.string(),
  comments_url: z.string(),
  commit: z.object({
    url: z.string(),
    author: s_nullable_git_user,
    committer: s_nullable_git_user,
    message: z.string(),
    comment_count: z.coerce.number(),
    tree: z.object({sha: z.string(), url: z.string()}),
    verification: s_verification.optional(),
  }),
  author: z.union([s_simple_user, s_empty_object]).nullable(),
  committer: z.union([s_simple_user, s_empty_object]).nullable(),
  parents: z.array(
    z.object({
      sha: z.string(),
      url: z.string(),
      html_url: z.string().optional(),
    }),
  ),
  stats: z
    .object({
      additions: z.coerce.number().optional(),
      deletions: z.coerce.number().optional(),
      total: z.coerce.number().optional(),
    })
    .optional(),
  files: z.array(s_diff_entry).optional(),
})

export const s_commit_comment = z.object({
  html_url: z.string(),
  url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  body: z.string(),
  path: z.string().nullable(),
  position: z.coerce.number().nullable(),
  line: z.coerce.number().nullable(),
  commit_id: z.string(),
  user: s_nullable_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  author_association: s_author_association,
  reactions: s_reaction_rollup.optional(),
})

export const s_community_profile = z.object({
  health_percentage: z.coerce.number(),
  description: z.string().nullable(),
  documentation: z.string().nullable(),
  files: z.object({
    code_of_conduct: s_nullable_code_of_conduct_simple,
    code_of_conduct_file: s_nullable_community_health_file,
    license: s_nullable_license_simple,
    contributing: s_nullable_community_health_file,
    readme: s_nullable_community_health_file,
    issue_template: s_nullable_community_health_file,
    pull_request_template: s_nullable_community_health_file,
  }),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  content_reports_enabled: PermissiveBoolean.optional(),
})

export const s_contributor_activity = z.object({
  author: s_nullable_simple_user,
  total: z.coerce.number(),
  weeks: z.array(
    z.object({
      w: z.coerce.number().optional(),
      a: z.coerce.number().optional(),
      d: z.coerce.number().optional(),
      c: z.coerce.number().optional(),
    }),
  ),
})

export const s_copilot_organization_details = z.intersection(
  z.object({
    seat_breakdown: s_copilot_organization_seat_breakdown,
    public_code_suggestions: z.enum(["allow", "block", "unconfigured"]),
    ide_chat: z.enum(["enabled", "disabled", "unconfigured"]).optional(),
    platform_chat: z.enum(["enabled", "disabled", "unconfigured"]).optional(),
    cli: z.enum(["enabled", "disabled", "unconfigured"]).optional(),
    seat_management_setting: z.enum([
      "assign_all",
      "assign_selected",
      "disabled",
      "unconfigured",
    ]),
    plan_type: z.enum(["business", "enterprise"]).optional(),
  }),
  z.record(z.string(), z.unknown()),
)

export const s_copilot_usage_metrics_day = z.intersection(
  z.object({
    date: z.string(),
    total_active_users: z.coerce.number().optional(),
    total_engaged_users: z.coerce.number().optional(),
    copilot_ide_code_completions: s_copilot_ide_code_completions.optional(),
    copilot_ide_chat: s_copilot_ide_chat.optional(),
    copilot_dotcom_chat: s_copilot_dotcom_chat.optional(),
    copilot_dotcom_pull_requests: s_copilot_dotcom_pull_requests.optional(),
  }),
  z.record(z.string(), z.unknown()),
)

export const s_dependabot_alert_security_vulnerability = z.object({
  package: s_dependabot_alert_package,
  severity: z.enum(["low", "medium", "high", "critical"]),
  vulnerable_version_range: z.string(),
  first_patched_version: z.object({identifier: z.string()}).nullable(),
})

export const s_dependency = z.object({
  package_url: z.string().regex(new RegExp("^pkg")).optional(),
  metadata: s_metadata.optional(),
  relationship: z.enum(["direct", "indirect"]).optional(),
  scope: z.enum(["runtime", "development"]).optional(),
  dependencies: z.array(z.string()).optional(),
})

export const s_deployment_protection_rule = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  enabled: PermissiveBoolean,
  app: s_custom_deployment_rule_app,
})

export const s_environment_approvals = z.object({
  environments: z.array(
    z.object({
      id: z.coerce.number().optional(),
      node_id: z.string().optional(),
      name: z.string().optional(),
      url: z.string().optional(),
      html_url: z.string().optional(),
      created_at: z.iso.datetime({offset: true}).optional(),
      updated_at: z.iso.datetime({offset: true}).optional(),
    }),
  ),
  state: z.enum(["approved", "rejected", "pending"]),
  user: s_simple_user,
  comment: z.string(),
})

export const s_feed = z.object({
  timeline_url: z.string(),
  user_url: z.string(),
  current_user_public_url: z.string().optional(),
  current_user_url: z.string().optional(),
  current_user_actor_url: z.string().optional(),
  current_user_organization_url: z.string().optional(),
  current_user_organization_urls: z.array(z.string()).optional(),
  security_advisories_url: z.string().optional(),
  repository_discussions_url: z.string().optional(),
  repository_discussions_category_url: z.string().optional(),
  _links: z.object({
    timeline: s_link_with_type,
    user: s_link_with_type,
    security_advisories: s_link_with_type.optional(),
    current_user: s_link_with_type.optional(),
    current_user_public: s_link_with_type.optional(),
    current_user_actor: s_link_with_type.optional(),
    current_user_organization: s_link_with_type.optional(),
    current_user_organizations: z.array(s_link_with_type).optional(),
    repository_discussions: s_link_with_type.optional(),
    repository_discussions_category: s_link_with_type.optional(),
  }),
})

export const s_gist_comment = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  body: z.string().max(65535),
  user: s_nullable_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  author_association: s_author_association,
})

export const s_gist_commit = z.object({
  url: z.string(),
  version: z.string(),
  user: s_nullable_simple_user,
  change_status: z.object({
    total: z.coerce.number().optional(),
    additions: z.coerce.number().optional(),
    deletions: z.coerce.number().optional(),
  }),
  committed_at: z.iso.datetime({offset: true}),
})

export const s_gist_history = z.object({
  user: s_nullable_simple_user.optional(),
  version: z.string().optional(),
  committed_at: z.iso.datetime({offset: true}).optional(),
  change_status: z
    .object({
      total: z.coerce.number().optional(),
      additions: z.coerce.number().optional(),
      deletions: z.coerce.number().optional(),
    })
    .optional(),
  url: z.string().optional(),
})

export const s_git_tag = z.object({
  node_id: z.string(),
  tag: z.string(),
  sha: z.string(),
  url: z.string(),
  message: z.string(),
  tagger: z.object({date: z.string(), email: z.string(), name: z.string()}),
  object: z.object({sha: z.string(), type: z.string(), url: z.string()}),
  verification: s_verification.optional(),
})

export const s_installation = z.object({
  id: z.coerce.number(),
  account: z.union([s_simple_user, s_enterprise]).nullable(),
  repository_selection: z.enum(["all", "selected"]),
  access_tokens_url: z.string(),
  repositories_url: z.string(),
  html_url: z.string(),
  app_id: z.coerce.number(),
  client_id: z.string().optional(),
  target_id: z.coerce.number(),
  target_type: z.string(),
  permissions: s_app_permissions,
  events: z.array(z.string()),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  single_file_name: z.string().nullable(),
  has_multiple_single_files: PermissiveBoolean.optional(),
  single_file_paths: z.array(z.string()).optional(),
  app_slug: z.string(),
  suspended_by: s_nullable_simple_user,
  suspended_at: z.iso.datetime({offset: true}).nullable(),
  contact_email: z.string().nullable().optional(),
})

export const s_integration = z
  .object({
    id: z.coerce.number(),
    slug: z.string().optional(),
    node_id: z.string(),
    client_id: z.string().optional(),
    owner: z.union([s_simple_user, s_enterprise]),
    name: z.string(),
    description: z.string().nullable(),
    external_url: z.string(),
    html_url: z.string(),
    created_at: z.iso.datetime({offset: true}),
    updated_at: z.iso.datetime({offset: true}),
    permissions: z.intersection(
      z.object({
        issues: z.string().optional(),
        checks: z.string().optional(),
        metadata: z.string().optional(),
        contents: z.string().optional(),
        deployments: z.string().optional(),
      }),
      z.record(z.string(), z.string()),
    ),
    events: z.array(z.string()),
    installations_count: z.coerce.number().optional(),
  })
  .nullable()

export const s_integration_installation_request = z.object({
  id: z.coerce.number(),
  node_id: z.string().optional(),
  account: z.union([s_simple_user, s_enterprise]),
  requester: s_simple_user,
  created_at: z.iso.datetime({offset: true}),
})

export const s_interaction_limit = z.object({
  limit: s_interaction_group,
  expiry: s_interaction_expiry.optional(),
})

export const s_interaction_limit_response = z.object({
  limit: s_interaction_group,
  origin: z.string(),
  expires_at: z.iso.datetime({offset: true}),
})

export const s_label_search_result_item = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  name: z.string(),
  color: z.string(),
  default: PermissiveBoolean,
  description: z.string().nullable(),
  score: z.coerce.number(),
  text_matches: s_search_result_text_matches.optional(),
})

export const s_license_content = z.object({
  name: z.string(),
  path: z.string(),
  sha: z.string(),
  size: z.coerce.number(),
  url: z.string(),
  html_url: z.string().nullable(),
  git_url: z.string().nullable(),
  download_url: z.string().nullable(),
  type: z.string(),
  content: z.string(),
  encoding: z.string(),
  _links: z.object({
    git: z.string().nullable(),
    html: z.string().nullable(),
    self: z.string(),
  }),
  license: s_nullable_license_simple,
})

export const s_marketplace_purchase = z.object({
  url: z.string(),
  type: z.string(),
  id: z.coerce.number(),
  login: z.string(),
  organization_billing_email: z.string().optional(),
  email: z.string().nullable().optional(),
  marketplace_pending_change: z
    .object({
      is_installed: PermissiveBoolean.optional(),
      effective_date: z.string().optional(),
      unit_count: z.coerce.number().nullable().optional(),
      id: z.coerce.number().optional(),
      plan: s_marketplace_listing_plan.optional(),
    })
    .nullable()
    .optional(),
  marketplace_purchase: z.object({
    billing_cycle: z.string().optional(),
    next_billing_date: z.string().nullable().optional(),
    is_installed: PermissiveBoolean.optional(),
    unit_count: z.coerce.number().nullable().optional(),
    on_free_trial: PermissiveBoolean.optional(),
    free_trial_ends_on: z.string().nullable().optional(),
    updated_at: z.string().optional(),
    plan: s_marketplace_listing_plan.optional(),
  }),
})

export const s_milestone = z.object({
  url: z.string(),
  html_url: z.string(),
  labels_url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  number: z.coerce.number(),
  state: z.enum(["open", "closed"]).default("open"),
  title: z.string(),
  description: z.string().nullable(),
  creator: s_nullable_simple_user,
  open_issues: z.coerce.number(),
  closed_issues: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  closed_at: z.iso.datetime({offset: true}).nullable(),
  due_on: z.iso.datetime({offset: true}).nullable(),
})

export const s_minimal_repository = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  full_name: z.string(),
  owner: s_simple_user,
  private: PermissiveBoolean,
  html_url: z.string(),
  description: z.string().nullable(),
  fork: PermissiveBoolean,
  url: z.string(),
  archive_url: z.string(),
  assignees_url: z.string(),
  blobs_url: z.string(),
  branches_url: z.string(),
  collaborators_url: z.string(),
  comments_url: z.string(),
  commits_url: z.string(),
  compare_url: z.string(),
  contents_url: z.string(),
  contributors_url: z.string(),
  deployments_url: z.string(),
  downloads_url: z.string(),
  events_url: z.string(),
  forks_url: z.string(),
  git_commits_url: z.string(),
  git_refs_url: z.string(),
  git_tags_url: z.string(),
  git_url: z.string().optional(),
  issue_comment_url: z.string(),
  issue_events_url: z.string(),
  issues_url: z.string(),
  keys_url: z.string(),
  labels_url: z.string(),
  languages_url: z.string(),
  merges_url: z.string(),
  milestones_url: z.string(),
  notifications_url: z.string(),
  pulls_url: z.string(),
  releases_url: z.string(),
  ssh_url: z.string().optional(),
  stargazers_url: z.string(),
  statuses_url: z.string(),
  subscribers_url: z.string(),
  subscription_url: z.string(),
  tags_url: z.string(),
  teams_url: z.string(),
  trees_url: z.string(),
  clone_url: z.string().optional(),
  mirror_url: z.string().nullable().optional(),
  hooks_url: z.string(),
  svn_url: z.string().optional(),
  homepage: z.string().nullable().optional(),
  language: z.string().nullable().optional(),
  forks_count: z.coerce.number().optional(),
  stargazers_count: z.coerce.number().optional(),
  watchers_count: z.coerce.number().optional(),
  size: z.coerce.number().optional(),
  default_branch: z.string().optional(),
  open_issues_count: z.coerce.number().optional(),
  is_template: PermissiveBoolean.optional(),
  topics: z.array(z.string()).optional(),
  has_issues: PermissiveBoolean.optional(),
  has_projects: PermissiveBoolean.optional(),
  has_wiki: PermissiveBoolean.optional(),
  has_pages: PermissiveBoolean.optional(),
  has_downloads: PermissiveBoolean.optional(),
  has_discussions: PermissiveBoolean.optional(),
  archived: PermissiveBoolean.optional(),
  disabled: PermissiveBoolean.optional(),
  visibility: z.string().optional(),
  pushed_at: z.iso.datetime({offset: true}).nullable().optional(),
  created_at: z.iso.datetime({offset: true}).nullable().optional(),
  updated_at: z.iso.datetime({offset: true}).nullable().optional(),
  permissions: z
    .object({
      admin: PermissiveBoolean.optional(),
      maintain: PermissiveBoolean.optional(),
      push: PermissiveBoolean.optional(),
      triage: PermissiveBoolean.optional(),
      pull: PermissiveBoolean.optional(),
    })
    .optional(),
  role_name: z.string().optional(),
  temp_clone_token: z.string().optional(),
  delete_branch_on_merge: PermissiveBoolean.optional(),
  subscribers_count: z.coerce.number().optional(),
  network_count: z.coerce.number().optional(),
  code_of_conduct: s_code_of_conduct.optional(),
  license: z
    .object({
      key: z.string().optional(),
      name: z.string().optional(),
      spdx_id: z.string().optional(),
      url: z.string().optional(),
      node_id: z.string().optional(),
    })
    .nullable()
    .optional(),
  forks: z.coerce.number().optional(),
  open_issues: z.coerce.number().optional(),
  watchers: z.coerce.number().optional(),
  allow_forking: PermissiveBoolean.optional(),
  web_commit_signoff_required: PermissiveBoolean.optional(),
  security_and_analysis: s_security_and_analysis.optional(),
  custom_properties: z.record(z.string(), z.unknown()).optional(),
})

export const s_nullable_integration = z
  .object({
    id: z.coerce.number(),
    slug: z.string().optional(),
    node_id: z.string(),
    client_id: z.string().optional(),
    owner: z.union([s_simple_user, s_enterprise]),
    name: z.string(),
    description: z.string().nullable(),
    external_url: z.string(),
    html_url: z.string(),
    created_at: z.iso.datetime({offset: true}),
    updated_at: z.iso.datetime({offset: true}),
    permissions: z.intersection(
      z.object({
        issues: z.string().optional(),
        checks: z.string().optional(),
        metadata: z.string().optional(),
        contents: z.string().optional(),
        deployments: z.string().optional(),
      }),
      z.record(z.string(), z.string()),
    ),
    events: z.array(z.string()),
    installations_count: z.coerce.number().optional(),
  })
  .nullable()

export const s_nullable_milestone = z
  .object({
    url: z.string(),
    html_url: z.string(),
    labels_url: z.string(),
    id: z.coerce.number(),
    node_id: z.string(),
    number: z.coerce.number(),
    state: z.enum(["open", "closed"]).default("open"),
    title: z.string(),
    description: z.string().nullable(),
    creator: s_nullable_simple_user,
    open_issues: z.coerce.number(),
    closed_issues: z.coerce.number(),
    created_at: z.iso.datetime({offset: true}),
    updated_at: z.iso.datetime({offset: true}),
    closed_at: z.iso.datetime({offset: true}).nullable(),
    due_on: z.iso.datetime({offset: true}).nullable(),
  })
  .nullable()

export const s_nullable_minimal_repository = z
  .object({
    id: z.coerce.number(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    owner: s_simple_user,
    private: PermissiveBoolean,
    html_url: z.string(),
    description: z.string().nullable(),
    fork: PermissiveBoolean,
    url: z.string(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.string(),
    deployments_url: z.string(),
    downloads_url: z.string(),
    events_url: z.string(),
    forks_url: z.string(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    git_url: z.string().optional(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.string(),
    merges_url: z.string(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    ssh_url: z.string().optional(),
    stargazers_url: z.string(),
    statuses_url: z.string(),
    subscribers_url: z.string(),
    subscription_url: z.string(),
    tags_url: z.string(),
    teams_url: z.string(),
    trees_url: z.string(),
    clone_url: z.string().optional(),
    mirror_url: z.string().nullable().optional(),
    hooks_url: z.string(),
    svn_url: z.string().optional(),
    homepage: z.string().nullable().optional(),
    language: z.string().nullable().optional(),
    forks_count: z.coerce.number().optional(),
    stargazers_count: z.coerce.number().optional(),
    watchers_count: z.coerce.number().optional(),
    size: z.coerce.number().optional(),
    default_branch: z.string().optional(),
    open_issues_count: z.coerce.number().optional(),
    is_template: PermissiveBoolean.optional(),
    topics: z.array(z.string()).optional(),
    has_issues: PermissiveBoolean.optional(),
    has_projects: PermissiveBoolean.optional(),
    has_wiki: PermissiveBoolean.optional(),
    has_pages: PermissiveBoolean.optional(),
    has_downloads: PermissiveBoolean.optional(),
    has_discussions: PermissiveBoolean.optional(),
    archived: PermissiveBoolean.optional(),
    disabled: PermissiveBoolean.optional(),
    visibility: z.string().optional(),
    pushed_at: z.iso.datetime({offset: true}).nullable().optional(),
    created_at: z.iso.datetime({offset: true}).nullable().optional(),
    updated_at: z.iso.datetime({offset: true}).nullable().optional(),
    permissions: z
      .object({
        admin: PermissiveBoolean.optional(),
        maintain: PermissiveBoolean.optional(),
        push: PermissiveBoolean.optional(),
        triage: PermissiveBoolean.optional(),
        pull: PermissiveBoolean.optional(),
      })
      .optional(),
    role_name: z.string().optional(),
    temp_clone_token: z.string().optional(),
    delete_branch_on_merge: PermissiveBoolean.optional(),
    subscribers_count: z.coerce.number().optional(),
    network_count: z.coerce.number().optional(),
    code_of_conduct: s_code_of_conduct.optional(),
    license: z
      .object({
        key: z.string().optional(),
        name: z.string().optional(),
        spdx_id: z.string().optional(),
        url: z.string().optional(),
        node_id: z.string().optional(),
      })
      .nullable()
      .optional(),
    forks: z.coerce.number().optional(),
    open_issues: z.coerce.number().optional(),
    watchers: z.coerce.number().optional(),
    allow_forking: PermissiveBoolean.optional(),
    web_commit_signoff_required: PermissiveBoolean.optional(),
    security_and_analysis: s_security_and_analysis.optional(),
    custom_properties: z.record(z.string(), z.unknown()).optional(),
  })
  .nullable()

export const s_nullable_repository = z
  .object({
    id: z.coerce.number(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    license: s_nullable_license_simple,
    forks: z.coerce.number(),
    permissions: z
      .object({
        admin: PermissiveBoolean,
        pull: PermissiveBoolean,
        triage: PermissiveBoolean.optional(),
        push: PermissiveBoolean,
        maintain: PermissiveBoolean.optional(),
      })
      .optional(),
    owner: s_simple_user,
    private: PermissiveBoolean.default(false),
    html_url: z.string(),
    description: z.string().nullable(),
    fork: PermissiveBoolean,
    url: z.string(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.string(),
    deployments_url: z.string(),
    downloads_url: z.string(),
    events_url: z.string(),
    forks_url: z.string(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    git_url: z.string(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.string(),
    merges_url: z.string(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    ssh_url: z.string(),
    stargazers_url: z.string(),
    statuses_url: z.string(),
    subscribers_url: z.string(),
    subscription_url: z.string(),
    tags_url: z.string(),
    teams_url: z.string(),
    trees_url: z.string(),
    clone_url: z.string(),
    mirror_url: z.string().nullable(),
    hooks_url: z.string(),
    svn_url: z.string(),
    homepage: z.string().nullable(),
    language: z.string().nullable(),
    forks_count: z.coerce.number(),
    stargazers_count: z.coerce.number(),
    watchers_count: z.coerce.number(),
    size: z.coerce.number(),
    default_branch: z.string(),
    open_issues_count: z.coerce.number(),
    is_template: PermissiveBoolean.optional().default(false),
    topics: z.array(z.string()).optional(),
    has_issues: PermissiveBoolean.default(true),
    has_projects: PermissiveBoolean.default(true),
    has_wiki: PermissiveBoolean.default(true),
    has_pages: PermissiveBoolean,
    has_downloads: PermissiveBoolean.default(true),
    has_discussions: PermissiveBoolean.optional().default(false),
    archived: PermissiveBoolean.default(false),
    disabled: PermissiveBoolean,
    visibility: z.string().optional().default("public"),
    pushed_at: z.iso.datetime({offset: true}).nullable(),
    created_at: z.iso.datetime({offset: true}).nullable(),
    updated_at: z.iso.datetime({offset: true}).nullable(),
    allow_rebase_merge: PermissiveBoolean.optional().default(true),
    temp_clone_token: z.string().optional(),
    allow_squash_merge: PermissiveBoolean.optional().default(true),
    allow_auto_merge: PermissiveBoolean.optional().default(false),
    delete_branch_on_merge: PermissiveBoolean.optional().default(false),
    allow_update_branch: PermissiveBoolean.optional().default(false),
    use_squash_pr_title_as_default: PermissiveBoolean.optional().default(false),
    squash_merge_commit_title: z
      .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
      .optional(),
    squash_merge_commit_message: z
      .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
      .optional(),
    merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
    merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
    allow_merge_commit: PermissiveBoolean.optional().default(true),
    allow_forking: PermissiveBoolean.optional(),
    web_commit_signoff_required: PermissiveBoolean.optional().default(false),
    open_issues: z.coerce.number(),
    watchers: z.coerce.number(),
    master_branch: z.string().optional(),
    starred_at: z.string().optional(),
    anonymous_access_enabled: PermissiveBoolean.optional(),
    code_search_index_status: z
      .object({
        lexical_search_ok: PermissiveBoolean.optional(),
        lexical_commit_sha: z.string().optional(),
      })
      .optional(),
  })
  .nullable()

export const s_nullable_scoped_installation = z
  .object({
    permissions: s_app_permissions,
    repository_selection: z.enum(["all", "selected"]),
    single_file_name: z.string().nullable(),
    has_multiple_single_files: PermissiveBoolean.optional(),
    single_file_paths: z.array(z.string()).optional(),
    repositories_url: z.string(),
    account: s_simple_user,
  })
  .nullable()

export const s_nullable_secret_scanning_first_detected_location = z
  .union([
    s_secret_scanning_location_commit,
    s_secret_scanning_location_wiki_commit,
    s_secret_scanning_location_issue_title,
    s_secret_scanning_location_issue_body,
    s_secret_scanning_location_issue_comment,
    s_secret_scanning_location_discussion_title,
    s_secret_scanning_location_discussion_body,
    s_secret_scanning_location_discussion_comment,
    s_secret_scanning_location_pull_request_title,
    s_secret_scanning_location_pull_request_body,
    s_secret_scanning_location_pull_request_comment,
    s_secret_scanning_location_pull_request_review,
    s_secret_scanning_location_pull_request_review_comment,
  ])
  .nullable()

export const s_nullable_simple_repository = z
  .object({
    id: z.coerce.number(),
    node_id: z.string(),
    name: z.string(),
    full_name: z.string(),
    owner: s_simple_user,
    private: PermissiveBoolean,
    html_url: z.string(),
    description: z.string().nullable(),
    fork: PermissiveBoolean,
    url: z.string(),
    archive_url: z.string(),
    assignees_url: z.string(),
    blobs_url: z.string(),
    branches_url: z.string(),
    collaborators_url: z.string(),
    comments_url: z.string(),
    commits_url: z.string(),
    compare_url: z.string(),
    contents_url: z.string(),
    contributors_url: z.string(),
    deployments_url: z.string(),
    downloads_url: z.string(),
    events_url: z.string(),
    forks_url: z.string(),
    git_commits_url: z.string(),
    git_refs_url: z.string(),
    git_tags_url: z.string(),
    issue_comment_url: z.string(),
    issue_events_url: z.string(),
    issues_url: z.string(),
    keys_url: z.string(),
    labels_url: z.string(),
    languages_url: z.string(),
    merges_url: z.string(),
    milestones_url: z.string(),
    notifications_url: z.string(),
    pulls_url: z.string(),
    releases_url: z.string(),
    stargazers_url: z.string(),
    statuses_url: z.string(),
    subscribers_url: z.string(),
    subscription_url: z.string(),
    tags_url: z.string(),
    teams_url: z.string(),
    trees_url: z.string(),
    hooks_url: z.string(),
  })
  .nullable()

export const s_org_membership = z.object({
  url: z.string(),
  state: z.enum(["active", "pending"]),
  role: z.enum(["admin", "member", "billing_manager"]),
  direct_membership: PermissiveBoolean.optional(),
  enterprise_teams_providing_indirect_membership: z
    .array(z.string())
    .max(100)
    .optional(),
  organization_url: z.string(),
  organization: s_organization_simple,
  user: s_nullable_simple_user,
  permissions: z.object({can_create_repository: PermissiveBoolean}).optional(),
})

export const s_org_repo_custom_property_values = z.object({
  repository_id: z.coerce.number(),
  repository_name: z.string(),
  repository_full_name: z.string(),
  properties: z.array(s_custom_property_value),
})

export const s_organization_invitation = z.object({
  id: z.coerce.number(),
  login: z.string().nullable(),
  email: z.string().nullable(),
  role: z.string(),
  created_at: z.string(),
  failed_at: z.string().nullable().optional(),
  failed_reason: z.string().nullable().optional(),
  inviter: s_simple_user,
  team_count: z.coerce.number(),
  node_id: z.string(),
  invitation_teams_url: z.string(),
  invitation_source: z.string().optional(),
})

export const s_organization_programmatic_access_grant = z.object({
  id: z.coerce.number(),
  owner: s_simple_user,
  repository_selection: z.enum(["none", "all", "subset"]),
  repositories_url: z.string(),
  permissions: z.object({
    organization: z.record(z.string(), z.string()).optional(),
    repository: z.record(z.string(), z.string()).optional(),
    other: z.record(z.string(), z.string()).optional(),
  }),
  access_granted_at: z.string(),
  token_id: z.coerce.number(),
  token_name: z.string(),
  token_expired: PermissiveBoolean,
  token_expires_at: z.string().nullable(),
  token_last_used_at: z.string().nullable(),
})

export const s_organization_programmatic_access_grant_request = z.object({
  id: z.coerce.number(),
  reason: z.string().nullable(),
  owner: s_simple_user,
  repository_selection: z.enum(["none", "all", "subset"]),
  repositories_url: z.string(),
  permissions: z.object({
    organization: z.record(z.string(), z.string()).optional(),
    repository: z.record(z.string(), z.string()).optional(),
    other: z.record(z.string(), z.string()).optional(),
  }),
  created_at: z.string(),
  token_id: z.coerce.number(),
  token_name: z.string(),
  token_expired: PermissiveBoolean,
  token_expires_at: z.string().nullable(),
  token_last_used_at: z.string().nullable(),
})

export const s_organization_role = z.object({
  id: z.coerce.number(),
  name: z.string(),
  description: z.string().nullable().optional(),
  base_role: z
    .enum(["read", "triage", "write", "maintain", "admin"])
    .nullable()
    .optional(),
  source: z
    .enum(["Organization", "Enterprise", "Predefined"])
    .nullable()
    .optional(),
  permissions: z.array(z.string()),
  organization: s_nullable_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_page = z.object({
  url: z.string(),
  status: z.enum(["built", "building", "errored"]).nullable(),
  cname: z.string().nullable(),
  protected_domain_state: z
    .enum(["pending", "verified", "unverified"])
    .nullable()
    .optional(),
  pending_domain_unverified_at: z.iso
    .datetime({offset: true})
    .nullable()
    .optional(),
  custom_404: PermissiveBoolean.default(false),
  html_url: z.string().optional(),
  build_type: z.enum(["legacy", "workflow"]).nullable().optional(),
  source: s_pages_source_hash.optional(),
  public: PermissiveBoolean,
  https_certificate: s_pages_https_certificate.optional(),
  https_enforced: PermissiveBoolean.optional(),
})

export const s_page_build = z.object({
  url: z.string(),
  status: z.string(),
  error: z.object({message: z.string().nullable()}),
  pusher: s_nullable_simple_user,
  commit: z.string(),
  duration: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_private_vulnerability_report_create = z.object({
  summary: z.string().max(1024),
  description: z.string().max(65535),
  vulnerabilities: z
    .array(
      z.object({
        package: z.object({
          ecosystem: s_security_advisory_ecosystems,
          name: z.string().nullable().optional(),
        }),
        vulnerable_version_range: z.string().nullable().optional(),
        patched_versions: z.string().nullable().optional(),
        vulnerable_functions: z.array(z.string()).nullable().optional(),
      }),
    )
    .nullable()
    .optional(),
  cwe_ids: z.array(z.string()).nullable().optional(),
  severity: z.enum(["critical", "high", "medium", "low"]).nullable().optional(),
  cvss_vector_string: z.string().nullable().optional(),
  start_private_fork: PermissiveBoolean.optional().default(false),
})

export const s_project = z.object({
  owner_url: z.string(),
  url: z.string(),
  html_url: z.string(),
  columns_url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  body: z.string().nullable(),
  number: z.coerce.number(),
  state: z.string(),
  creator: s_nullable_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  organization_permission: z
    .enum(["read", "write", "admin", "none"])
    .optional(),
  private: PermissiveBoolean.optional(),
})

export const s_project_card = z.object({
  url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  note: z.string().nullable(),
  creator: s_nullable_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  archived: PermissiveBoolean.optional(),
  column_name: z.string().optional(),
  project_id: z.string().optional(),
  column_url: z.string(),
  content_url: z.string().optional(),
  project_url: z.string(),
})

export const s_project_collaborator_permission = z.object({
  permission: z.string(),
  user: s_nullable_simple_user,
})

export const s_pull_request_review = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  user: s_nullable_simple_user,
  body: z.string(),
  state: z.string(),
  html_url: z.string(),
  pull_request_url: z.string(),
  _links: z.object({
    html: z.object({href: z.string()}),
    pull_request: z.object({href: z.string()}),
  }),
  submitted_at: z.iso.datetime({offset: true}).optional(),
  commit_id: z.string().nullable(),
  body_html: z.string().optional(),
  body_text: z.string().optional(),
  author_association: s_author_association,
})

export const s_pull_request_review_comment = z.object({
  url: z.string(),
  pull_request_review_id: z.coerce.number().nullable(),
  id: z.coerce.number(),
  node_id: z.string(),
  diff_hunk: z.string(),
  path: z.string(),
  position: z.coerce.number().optional(),
  original_position: z.coerce.number().optional(),
  commit_id: z.string(),
  original_commit_id: z.string(),
  in_reply_to_id: z.coerce.number().optional(),
  user: s_simple_user,
  body: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  html_url: z.string(),
  pull_request_url: z.string(),
  author_association: s_author_association,
  _links: z.object({
    self: z.object({href: z.string()}),
    html: z.object({href: z.string()}),
    pull_request: z.object({href: z.string()}),
  }),
  start_line: z.coerce.number().nullable().optional(),
  original_start_line: z.coerce.number().nullable().optional(),
  start_side: z.enum(["LEFT", "RIGHT"]).nullable().optional().default("RIGHT"),
  line: z.coerce.number().optional(),
  original_line: z.coerce.number().optional(),
  side: z.enum(["LEFT", "RIGHT"]).optional().default("RIGHT"),
  subject_type: z.enum(["line", "file"]).optional(),
  reactions: s_reaction_rollup.optional(),
  body_html: z.string().optional(),
  body_text: z.string().optional(),
})

export const s_rate_limit_overview = z.object({
  resources: z.object({
    core: s_rate_limit,
    graphql: s_rate_limit.optional(),
    search: s_rate_limit,
    code_search: s_rate_limit.optional(),
    source_import: s_rate_limit.optional(),
    integration_manifest: s_rate_limit.optional(),
    code_scanning_upload: s_rate_limit.optional(),
    actions_runner_registration: s_rate_limit.optional(),
    scim: s_rate_limit.optional(),
    dependency_snapshots: s_rate_limit.optional(),
    dependency_sbom: s_rate_limit.optional(),
    code_scanning_autofix: s_rate_limit.optional(),
  }),
  rate: s_rate_limit,
})

export const s_reaction = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  user: s_nullable_simple_user,
  content: z.enum([
    "+1",
    "-1",
    "laugh",
    "confused",
    "heart",
    "hooray",
    "rocket",
    "eyes",
  ]),
  created_at: z.iso.datetime({offset: true}),
})

export const s_release_asset = z.object({
  url: z.string(),
  browser_download_url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  label: z.string().nullable(),
  state: z.enum(["uploaded", "open"]),
  content_type: z.string(),
  size: z.coerce.number(),
  digest: z.string().nullable(),
  download_count: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  uploader: s_nullable_simple_user,
})

export const s_repo_search_result_item = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  full_name: z.string(),
  owner: s_nullable_simple_user,
  private: PermissiveBoolean,
  html_url: z.string(),
  description: z.string().nullable(),
  fork: PermissiveBoolean,
  url: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  pushed_at: z.iso.datetime({offset: true}),
  homepage: z.string().nullable(),
  size: z.coerce.number(),
  stargazers_count: z.coerce.number(),
  watchers_count: z.coerce.number(),
  language: z.string().nullable(),
  forks_count: z.coerce.number(),
  open_issues_count: z.coerce.number(),
  master_branch: z.string().optional(),
  default_branch: z.string(),
  score: z.coerce.number(),
  forks_url: z.string(),
  keys_url: z.string(),
  collaborators_url: z.string(),
  teams_url: z.string(),
  hooks_url: z.string(),
  issue_events_url: z.string(),
  events_url: z.string(),
  assignees_url: z.string(),
  branches_url: z.string(),
  tags_url: z.string(),
  blobs_url: z.string(),
  git_tags_url: z.string(),
  git_refs_url: z.string(),
  trees_url: z.string(),
  statuses_url: z.string(),
  languages_url: z.string(),
  stargazers_url: z.string(),
  contributors_url: z.string(),
  subscribers_url: z.string(),
  subscription_url: z.string(),
  commits_url: z.string(),
  git_commits_url: z.string(),
  comments_url: z.string(),
  issue_comment_url: z.string(),
  contents_url: z.string(),
  compare_url: z.string(),
  merges_url: z.string(),
  archive_url: z.string(),
  downloads_url: z.string(),
  issues_url: z.string(),
  pulls_url: z.string(),
  milestones_url: z.string(),
  notifications_url: z.string(),
  labels_url: z.string(),
  releases_url: z.string(),
  deployments_url: z.string(),
  git_url: z.string(),
  ssh_url: z.string(),
  clone_url: z.string(),
  svn_url: z.string(),
  forks: z.coerce.number(),
  open_issues: z.coerce.number(),
  watchers: z.coerce.number(),
  topics: z.array(z.string()).optional(),
  mirror_url: z.string().nullable(),
  has_issues: PermissiveBoolean,
  has_projects: PermissiveBoolean,
  has_pages: PermissiveBoolean,
  has_wiki: PermissiveBoolean,
  has_downloads: PermissiveBoolean,
  has_discussions: PermissiveBoolean.optional(),
  archived: PermissiveBoolean,
  disabled: PermissiveBoolean,
  visibility: z.string().optional(),
  license: s_nullable_license_simple,
  permissions: z
    .object({
      admin: PermissiveBoolean,
      maintain: PermissiveBoolean.optional(),
      push: PermissiveBoolean,
      triage: PermissiveBoolean.optional(),
      pull: PermissiveBoolean,
    })
    .optional(),
  text_matches: s_search_result_text_matches.optional(),
  temp_clone_token: z.string().optional(),
  allow_merge_commit: PermissiveBoolean.optional(),
  allow_squash_merge: PermissiveBoolean.optional(),
  allow_rebase_merge: PermissiveBoolean.optional(),
  allow_auto_merge: PermissiveBoolean.optional(),
  delete_branch_on_merge: PermissiveBoolean.optional(),
  allow_forking: PermissiveBoolean.optional(),
  is_template: PermissiveBoolean.optional(),
  web_commit_signoff_required: PermissiveBoolean.optional(),
})

export const s_repository = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  full_name: z.string(),
  license: s_nullable_license_simple,
  forks: z.coerce.number(),
  permissions: z
    .object({
      admin: PermissiveBoolean,
      pull: PermissiveBoolean,
      triage: PermissiveBoolean.optional(),
      push: PermissiveBoolean,
      maintain: PermissiveBoolean.optional(),
    })
    .optional(),
  owner: s_simple_user,
  private: PermissiveBoolean.default(false),
  html_url: z.string(),
  description: z.string().nullable(),
  fork: PermissiveBoolean,
  url: z.string(),
  archive_url: z.string(),
  assignees_url: z.string(),
  blobs_url: z.string(),
  branches_url: z.string(),
  collaborators_url: z.string(),
  comments_url: z.string(),
  commits_url: z.string(),
  compare_url: z.string(),
  contents_url: z.string(),
  contributors_url: z.string(),
  deployments_url: z.string(),
  downloads_url: z.string(),
  events_url: z.string(),
  forks_url: z.string(),
  git_commits_url: z.string(),
  git_refs_url: z.string(),
  git_tags_url: z.string(),
  git_url: z.string(),
  issue_comment_url: z.string(),
  issue_events_url: z.string(),
  issues_url: z.string(),
  keys_url: z.string(),
  labels_url: z.string(),
  languages_url: z.string(),
  merges_url: z.string(),
  milestones_url: z.string(),
  notifications_url: z.string(),
  pulls_url: z.string(),
  releases_url: z.string(),
  ssh_url: z.string(),
  stargazers_url: z.string(),
  statuses_url: z.string(),
  subscribers_url: z.string(),
  subscription_url: z.string(),
  tags_url: z.string(),
  teams_url: z.string(),
  trees_url: z.string(),
  clone_url: z.string(),
  mirror_url: z.string().nullable(),
  hooks_url: z.string(),
  svn_url: z.string(),
  homepage: z.string().nullable(),
  language: z.string().nullable(),
  forks_count: z.coerce.number(),
  stargazers_count: z.coerce.number(),
  watchers_count: z.coerce.number(),
  size: z.coerce.number(),
  default_branch: z.string(),
  open_issues_count: z.coerce.number(),
  is_template: PermissiveBoolean.optional().default(false),
  topics: z.array(z.string()).optional(),
  has_issues: PermissiveBoolean.default(true),
  has_projects: PermissiveBoolean.default(true),
  has_wiki: PermissiveBoolean.default(true),
  has_pages: PermissiveBoolean,
  has_downloads: PermissiveBoolean.default(true),
  has_discussions: PermissiveBoolean.optional().default(false),
  archived: PermissiveBoolean.default(false),
  disabled: PermissiveBoolean,
  visibility: z.string().optional().default("public"),
  pushed_at: z.iso.datetime({offset: true}).nullable(),
  created_at: z.iso.datetime({offset: true}).nullable(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  allow_rebase_merge: PermissiveBoolean.optional().default(true),
  temp_clone_token: z.string().optional(),
  allow_squash_merge: PermissiveBoolean.optional().default(true),
  allow_auto_merge: PermissiveBoolean.optional().default(false),
  delete_branch_on_merge: PermissiveBoolean.optional().default(false),
  allow_update_branch: PermissiveBoolean.optional().default(false),
  use_squash_pr_title_as_default: PermissiveBoolean.optional().default(false),
  squash_merge_commit_title: z
    .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
    .optional(),
  squash_merge_commit_message: z
    .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
    .optional(),
  merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
  merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
  allow_merge_commit: PermissiveBoolean.optional().default(true),
  allow_forking: PermissiveBoolean.optional(),
  web_commit_signoff_required: PermissiveBoolean.optional().default(false),
  open_issues: z.coerce.number(),
  watchers: z.coerce.number(),
  master_branch: z.string().optional(),
  starred_at: z.string().optional(),
  anonymous_access_enabled: PermissiveBoolean.optional(),
  code_search_index_status: z
    .object({
      lexical_search_ok: PermissiveBoolean.optional(),
      lexical_commit_sha: z.string().optional(),
    })
    .optional(),
})

export const s_repository_advisory_create = z.object({
  summary: z.string().max(1024),
  description: z.string().max(65535),
  cve_id: z.string().nullable().optional(),
  vulnerabilities: z.array(
    z.object({
      package: z.object({
        ecosystem: s_security_advisory_ecosystems,
        name: z.string().nullable().optional(),
      }),
      vulnerable_version_range: z.string().nullable().optional(),
      patched_versions: z.string().nullable().optional(),
      vulnerable_functions: z.array(z.string()).nullable().optional(),
    }),
  ),
  cwe_ids: z.array(z.string()).nullable().optional(),
  credits: z
    .array(
      z.object({login: z.string(), type: s_security_advisory_credit_types}),
    )
    .nullable()
    .optional(),
  severity: z.enum(["critical", "high", "medium", "low"]).nullable().optional(),
  cvss_vector_string: z.string().nullable().optional(),
  start_private_fork: PermissiveBoolean.optional().default(false),
})

export const s_repository_advisory_credit = z.object({
  user: s_simple_user,
  type: s_security_advisory_credit_types,
  state: z.enum(["accepted", "declined", "pending"]),
})

export const s_repository_advisory_update = z.object({
  summary: z.string().max(1024).optional(),
  description: z.string().max(65535).optional(),
  cve_id: z.string().nullable().optional(),
  vulnerabilities: z
    .array(
      z.object({
        package: z.object({
          ecosystem: s_security_advisory_ecosystems,
          name: z.string().nullable().optional(),
        }),
        vulnerable_version_range: z.string().nullable().optional(),
        patched_versions: z.string().nullable().optional(),
        vulnerable_functions: z.array(z.string()).nullable().optional(),
      }),
    )
    .optional(),
  cwe_ids: z.array(z.string()).nullable().optional(),
  credits: z
    .array(
      z.object({login: z.string(), type: s_security_advisory_credit_types}),
    )
    .nullable()
    .optional(),
  severity: z.enum(["critical", "high", "medium", "low"]).nullable().optional(),
  cvss_vector_string: z.string().nullable().optional(),
  state: z.enum(["published", "closed", "draft"]).optional(),
  collaborating_users: z.array(z.string()).nullable().optional(),
  collaborating_teams: z.array(z.string()).nullable().optional(),
})

export const s_repository_advisory_vulnerability = z.object({
  package: z
    .object({
      ecosystem: s_security_advisory_ecosystems,
      name: z.string().nullable(),
    })
    .nullable(),
  vulnerable_version_range: z.string().nullable(),
  patched_versions: z.string().nullable(),
  vulnerable_functions: z.array(z.string()).nullable(),
})

export const s_repository_collaborator_permission = z.object({
  permission: z.string(),
  role_name: z.string(),
  user: s_nullable_collaborator,
})

export const s_repository_rule_code_scanning = z.object({
  type: z.enum(["code_scanning"]),
  parameters: z
    .object({
      code_scanning_tools: z.array(s_repository_rule_params_code_scanning_tool),
    })
    .optional(),
})

export const s_repository_rule_required_status_checks = z.object({
  type: z.enum(["required_status_checks"]),
  parameters: z
    .object({
      do_not_enforce_on_create: PermissiveBoolean.optional(),
      required_status_checks: z.array(
        s_repository_rule_params_status_check_configuration,
      ),
      strict_required_status_checks_policy: PermissiveBoolean,
    })
    .optional(),
})

export const s_repository_rule_violation_error = z.object({
  message: z.string().optional(),
  documentation_url: z.string().optional(),
  status: z.string().optional(),
  metadata: z
    .object({
      secret_scanning: z
        .object({
          bypass_placeholders: z
            .array(
              z.object({
                placeholder_id:
                  s_secret_scanning_push_protection_bypass_placeholder_id.optional(),
                token_type: z.string().optional(),
              }),
            )
            .optional(),
        })
        .optional(),
    })
    .optional(),
})

export const s_repository_rule_workflows = z.object({
  type: z.enum(["workflows"]),
  parameters: z
    .object({
      do_not_enforce_on_create: PermissiveBoolean.optional(),
      workflows: z.array(s_repository_rule_params_workflow_file_reference),
    })
    .optional(),
})

export const s_repository_ruleset_conditions_repository_property_target =
  z.object({
    repository_property: z.object({
      include: z
        .array(s_repository_ruleset_conditions_repository_property_spec)
        .optional(),
      exclude: z
        .array(s_repository_ruleset_conditions_repository_property_spec)
        .optional(),
    }),
  })

export const s_review_comment = z.object({
  url: z.string(),
  pull_request_review_id: z.coerce.number().nullable(),
  id: z.coerce.number(),
  node_id: z.string(),
  diff_hunk: z.string(),
  path: z.string(),
  position: z.coerce.number().nullable(),
  original_position: z.coerce.number(),
  commit_id: z.string(),
  original_commit_id: z.string(),
  in_reply_to_id: z.coerce.number().optional(),
  user: s_nullable_simple_user,
  body: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  html_url: z.string(),
  pull_request_url: z.string(),
  author_association: s_author_association,
  _links: z.object({self: s_link, html: s_link, pull_request: s_link}),
  body_text: z.string().optional(),
  body_html: z.string().optional(),
  reactions: s_reaction_rollup.optional(),
  side: z.enum(["LEFT", "RIGHT"]).optional().default("RIGHT"),
  start_side: z.enum(["LEFT", "RIGHT"]).nullable().optional().default("RIGHT"),
  line: z.coerce.number().optional(),
  original_line: z.coerce.number().optional(),
  start_line: z.coerce.number().nullable().optional(),
  original_start_line: z.coerce.number().nullable().optional(),
  subject_type: z.enum(["line", "file"]).optional(),
})

export const s_ruleset_version_with_state = s_ruleset_version.merge(
  z.object({state: z.record(z.string(), z.unknown())}),
)

export const s_runner = z.object({
  id: z.coerce.number(),
  runner_group_id: z.coerce.number().optional(),
  name: z.string(),
  os: z.string(),
  status: z.string(),
  busy: PermissiveBoolean,
  labels: z.array(s_runner_label),
  ephemeral: PermissiveBoolean.optional(),
})

export const s_secret_scanning_location = z.object({
  type: z
    .enum([
      "commit",
      "wiki_commit",
      "issue_title",
      "issue_body",
      "issue_comment",
      "discussion_title",
      "discussion_body",
      "discussion_comment",
      "pull_request_title",
      "pull_request_body",
      "pull_request_comment",
      "pull_request_review",
      "pull_request_review_comment",
    ])
    .optional(),
  details: z
    .union([
      s_secret_scanning_location_commit,
      s_secret_scanning_location_wiki_commit,
      s_secret_scanning_location_issue_title,
      s_secret_scanning_location_issue_body,
      s_secret_scanning_location_issue_comment,
      s_secret_scanning_location_discussion_title,
      s_secret_scanning_location_discussion_body,
      s_secret_scanning_location_discussion_comment,
      s_secret_scanning_location_pull_request_title,
      s_secret_scanning_location_pull_request_body,
      s_secret_scanning_location_pull_request_comment,
      s_secret_scanning_location_pull_request_review,
      s_secret_scanning_location_pull_request_review_comment,
    ])
    .optional(),
})

export const s_secret_scanning_push_protection_bypass = z.object({
  reason: s_secret_scanning_push_protection_bypass_reason.optional(),
  expire_at: z.iso.datetime({offset: true}).nullable().optional(),
  token_type: z.string().optional(),
})

export const s_secret_scanning_scan_history = z.object({
  incremental_scans: z.array(s_secret_scanning_scan).optional(),
  pattern_update_scans: z.array(s_secret_scanning_scan).optional(),
  backfill_scans: z.array(s_secret_scanning_scan).optional(),
  custom_pattern_backfill_scans: z
    .array(
      s_secret_scanning_scan.merge(
        z.object({
          pattern_name: z.string().optional(),
          pattern_scope: z.string().optional(),
        }),
      ),
    )
    .optional(),
})

export const s_simple_classroom_assignment = z.object({
  id: z.coerce.number(),
  public_repo: PermissiveBoolean,
  title: z.string(),
  type: z.enum(["individual", "group"]),
  invite_link: z.string(),
  invitations_enabled: PermissiveBoolean,
  slug: z.string(),
  students_are_repo_admins: PermissiveBoolean,
  feedback_pull_requests_enabled: PermissiveBoolean,
  max_teams: z.coerce.number().nullable().optional(),
  max_members: z.coerce.number().nullable().optional(),
  editor: z.string(),
  accepted: z.coerce.number(),
  submitted: z.coerce.number(),
  passing: z.coerce.number(),
  language: z.string(),
  deadline: z.iso.datetime({offset: true}).nullable(),
  classroom: s_simple_classroom,
})

export const s_simple_repository = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  full_name: z.string(),
  owner: s_simple_user,
  private: PermissiveBoolean,
  html_url: z.string(),
  description: z.string().nullable(),
  fork: PermissiveBoolean,
  url: z.string(),
  archive_url: z.string(),
  assignees_url: z.string(),
  blobs_url: z.string(),
  branches_url: z.string(),
  collaborators_url: z.string(),
  comments_url: z.string(),
  commits_url: z.string(),
  compare_url: z.string(),
  contents_url: z.string(),
  contributors_url: z.string(),
  deployments_url: z.string(),
  downloads_url: z.string(),
  events_url: z.string(),
  forks_url: z.string(),
  git_commits_url: z.string(),
  git_refs_url: z.string(),
  git_tags_url: z.string(),
  issue_comment_url: z.string(),
  issue_events_url: z.string(),
  issues_url: z.string(),
  keys_url: z.string(),
  labels_url: z.string(),
  languages_url: z.string(),
  merges_url: z.string(),
  milestones_url: z.string(),
  notifications_url: z.string(),
  pulls_url: z.string(),
  releases_url: z.string(),
  stargazers_url: z.string(),
  statuses_url: z.string(),
  subscribers_url: z.string(),
  subscription_url: z.string(),
  tags_url: z.string(),
  teams_url: z.string(),
  trees_url: z.string(),
  hooks_url: z.string(),
})

export const s_stargazer = z.object({
  starred_at: z.iso.datetime({offset: true}),
  user: s_nullable_simple_user,
})

export const s_status = z.object({
  url: z.string(),
  avatar_url: z.string().nullable(),
  id: z.coerce.number(),
  node_id: z.string(),
  state: z.string(),
  description: z.string().nullable(),
  target_url: z.string().nullable(),
  context: z.string(),
  created_at: z.string(),
  updated_at: z.string(),
  creator: s_nullable_simple_user,
})

export const s_team = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  privacy: z.string().optional(),
  notification_setting: z.string().optional(),
  permission: z.string(),
  permissions: z
    .object({
      pull: PermissiveBoolean,
      triage: PermissiveBoolean,
      push: PermissiveBoolean,
      maintain: PermissiveBoolean,
      admin: PermissiveBoolean,
    })
    .optional(),
  url: z.string(),
  html_url: z.string(),
  members_url: z.string(),
  repositories_url: z.string(),
  parent: s_nullable_team_simple,
})

export const s_team_discussion = z.object({
  author: s_nullable_simple_user,
  body: z.string(),
  body_html: z.string(),
  body_version: z.string(),
  comments_count: z.coerce.number(),
  comments_url: z.string(),
  created_at: z.iso.datetime({offset: true}),
  last_edited_at: z.iso.datetime({offset: true}).nullable(),
  html_url: z.string(),
  node_id: z.string(),
  number: z.coerce.number(),
  pinned: PermissiveBoolean,
  private: PermissiveBoolean,
  team_url: z.string(),
  title: z.string(),
  updated_at: z.iso.datetime({offset: true}),
  url: z.string(),
  reactions: s_reaction_rollup.optional(),
})

export const s_team_discussion_comment = z.object({
  author: s_nullable_simple_user,
  body: z.string(),
  body_html: z.string(),
  body_version: z.string(),
  created_at: z.iso.datetime({offset: true}),
  last_edited_at: z.iso.datetime({offset: true}).nullable(),
  discussion_url: z.string(),
  html_url: z.string(),
  node_id: z.string(),
  number: z.coerce.number(),
  updated_at: z.iso.datetime({offset: true}),
  url: z.string(),
  reactions: s_reaction_rollup.optional(),
})

export const s_team_full = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  html_url: z.string(),
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  privacy: z.enum(["closed", "secret"]).optional(),
  notification_setting: z
    .enum(["notifications_enabled", "notifications_disabled"])
    .optional(),
  permission: z.string(),
  members_url: z.string(),
  repositories_url: z.string(),
  parent: s_nullable_team_simple.optional(),
  members_count: z.coerce.number(),
  repos_count: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  organization: s_team_organization,
  ldap_dn: z.string().optional(),
})

export const s_team_project = z.object({
  owner_url: z.string(),
  url: z.string(),
  html_url: z.string(),
  columns_url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  body: z.string().nullable(),
  number: z.coerce.number(),
  state: z.string(),
  creator: s_simple_user,
  created_at: z.string(),
  updated_at: z.string(),
  organization_permission: z.string().optional(),
  private: PermissiveBoolean.optional(),
  permissions: z.object({
    read: PermissiveBoolean,
    write: PermissiveBoolean,
    admin: PermissiveBoolean,
  }),
})

export const s_team_repository = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  full_name: z.string(),
  license: s_nullable_license_simple,
  forks: z.coerce.number(),
  permissions: z
    .object({
      admin: PermissiveBoolean,
      pull: PermissiveBoolean,
      triage: PermissiveBoolean.optional(),
      push: PermissiveBoolean,
      maintain: PermissiveBoolean.optional(),
    })
    .optional(),
  role_name: z.string().optional(),
  owner: s_nullable_simple_user,
  private: PermissiveBoolean.default(false),
  html_url: z.string(),
  description: z.string().nullable(),
  fork: PermissiveBoolean,
  url: z.string(),
  archive_url: z.string(),
  assignees_url: z.string(),
  blobs_url: z.string(),
  branches_url: z.string(),
  collaborators_url: z.string(),
  comments_url: z.string(),
  commits_url: z.string(),
  compare_url: z.string(),
  contents_url: z.string(),
  contributors_url: z.string(),
  deployments_url: z.string(),
  downloads_url: z.string(),
  events_url: z.string(),
  forks_url: z.string(),
  git_commits_url: z.string(),
  git_refs_url: z.string(),
  git_tags_url: z.string(),
  git_url: z.string(),
  issue_comment_url: z.string(),
  issue_events_url: z.string(),
  issues_url: z.string(),
  keys_url: z.string(),
  labels_url: z.string(),
  languages_url: z.string(),
  merges_url: z.string(),
  milestones_url: z.string(),
  notifications_url: z.string(),
  pulls_url: z.string(),
  releases_url: z.string(),
  ssh_url: z.string(),
  stargazers_url: z.string(),
  statuses_url: z.string(),
  subscribers_url: z.string(),
  subscription_url: z.string(),
  tags_url: z.string(),
  teams_url: z.string(),
  trees_url: z.string(),
  clone_url: z.string(),
  mirror_url: z.string().nullable(),
  hooks_url: z.string(),
  svn_url: z.string(),
  homepage: z.string().nullable(),
  language: z.string().nullable(),
  forks_count: z.coerce.number(),
  stargazers_count: z.coerce.number(),
  watchers_count: z.coerce.number(),
  size: z.coerce.number(),
  default_branch: z.string(),
  open_issues_count: z.coerce.number(),
  is_template: PermissiveBoolean.optional().default(false),
  topics: z.array(z.string()).optional(),
  has_issues: PermissiveBoolean.default(true),
  has_projects: PermissiveBoolean.default(true),
  has_wiki: PermissiveBoolean.default(true),
  has_pages: PermissiveBoolean,
  has_downloads: PermissiveBoolean.default(true),
  archived: PermissiveBoolean.default(false),
  disabled: PermissiveBoolean,
  visibility: z.string().optional().default("public"),
  pushed_at: z.iso.datetime({offset: true}).nullable(),
  created_at: z.iso.datetime({offset: true}).nullable(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  allow_rebase_merge: PermissiveBoolean.optional().default(true),
  temp_clone_token: z.string().optional(),
  allow_squash_merge: PermissiveBoolean.optional().default(true),
  allow_auto_merge: PermissiveBoolean.optional().default(false),
  delete_branch_on_merge: PermissiveBoolean.optional().default(false),
  allow_merge_commit: PermissiveBoolean.optional().default(true),
  allow_forking: PermissiveBoolean.optional().default(false),
  web_commit_signoff_required: PermissiveBoolean.optional().default(false),
  subscribers_count: z.coerce.number().optional(),
  network_count: z.coerce.number().optional(),
  open_issues: z.coerce.number(),
  watchers: z.coerce.number(),
  master_branch: z.string().optional(),
})

export const s_team_role_assignment = z.object({
  assignment: z.enum(["direct", "indirect", "mixed"]).optional(),
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  privacy: z.string().optional(),
  notification_setting: z.string().optional(),
  permission: z.string(),
  permissions: z
    .object({
      pull: PermissiveBoolean,
      triage: PermissiveBoolean,
      push: PermissiveBoolean,
      maintain: PermissiveBoolean,
      admin: PermissiveBoolean,
    })
    .optional(),
  url: z.string(),
  html_url: z.string(),
  members_url: z.string(),
  repositories_url: z.string(),
  parent: s_nullable_team_simple,
})

export const s_timeline_reviewed_event = z.object({
  event: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  user: s_simple_user,
  body: z.string().nullable(),
  state: z.string(),
  html_url: z.string(),
  pull_request_url: z.string(),
  _links: z.object({
    html: z.object({href: z.string()}),
    pull_request: z.object({href: z.string()}),
  }),
  submitted_at: z.iso.datetime({offset: true}).optional(),
  commit_id: z.string(),
  body_html: z.string().optional(),
  body_text: z.string().optional(),
  author_association: s_author_association,
})

export const s_topic_search_result_item = z.object({
  name: z.string(),
  display_name: z.string().nullable(),
  short_description: z.string().nullable(),
  description: z.string().nullable(),
  created_by: z.string().nullable(),
  released: z.string().nullable(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  featured: PermissiveBoolean,
  curated: PermissiveBoolean,
  score: z.coerce.number(),
  repository_count: z.coerce.number().nullable().optional(),
  logo_url: z.string().nullable().optional(),
  text_matches: s_search_result_text_matches.optional(),
  related: z
    .array(
      z.object({
        topic_relation: z
          .object({
            id: z.coerce.number().optional(),
            name: z.string().optional(),
            topic_id: z.coerce.number().optional(),
            relation_type: z.string().optional(),
          })
          .optional(),
      }),
    )
    .nullable()
    .optional(),
  aliases: z
    .array(
      z.object({
        topic_relation: z
          .object({
            id: z.coerce.number().optional(),
            name: z.string().optional(),
            topic_id: z.coerce.number().optional(),
            relation_type: z.string().optional(),
          })
          .optional(),
      }),
    )
    .nullable()
    .optional(),
})

export const s_user_marketplace_purchase = z.object({
  billing_cycle: z.string(),
  next_billing_date: z.iso.datetime({offset: true}).nullable(),
  unit_count: z.coerce.number().nullable(),
  on_free_trial: PermissiveBoolean,
  free_trial_ends_on: z.iso.datetime({offset: true}).nullable(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  account: s_marketplace_account,
  plan: s_marketplace_listing_plan,
})

export const s_user_role_assignment = z.object({
  assignment: z.enum(["direct", "indirect", "mixed"]).optional(),
  inherited_from: z.array(s_team_simple).optional(),
  name: z.string().nullable().optional(),
  email: z.string().nullable().optional(),
  login: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  avatar_url: z.string(),
  gravatar_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  followers_url: z.string(),
  following_url: z.string(),
  gists_url: z.string(),
  starred_url: z.string(),
  subscriptions_url: z.string(),
  organizations_url: z.string(),
  repos_url: z.string(),
  events_url: z.string(),
  received_events_url: z.string(),
  type: z.string(),
  site_admin: PermissiveBoolean,
  starred_at: z.string().optional(),
  user_view_type: z.string().optional(),
})

export const s_user_search_result_item = z.object({
  login: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  avatar_url: z.string(),
  gravatar_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  followers_url: z.string(),
  subscriptions_url: z.string(),
  organizations_url: z.string(),
  repos_url: z.string(),
  received_events_url: z.string(),
  type: z.string(),
  score: z.coerce.number(),
  following_url: z.string(),
  gists_url: z.string(),
  starred_url: z.string(),
  events_url: z.string(),
  public_repos: z.coerce.number().optional(),
  public_gists: z.coerce.number().optional(),
  followers: z.coerce.number().optional(),
  following: z.coerce.number().optional(),
  created_at: z.iso.datetime({offset: true}).optional(),
  updated_at: z.iso.datetime({offset: true}).optional(),
  name: z.string().nullable().optional(),
  bio: z.string().nullable().optional(),
  email: z.email().nullable().optional(),
  location: z.string().nullable().optional(),
  site_admin: PermissiveBoolean,
  hireable: PermissiveBoolean.nullable().optional(),
  text_matches: s_search_result_text_matches.optional(),
  blog: z.string().nullable().optional(),
  company: z.string().nullable().optional(),
  suspended_at: z.iso.datetime({offset: true}).nullable().optional(),
  user_view_type: z.string().optional(),
})

export const s_view_traffic = z.object({
  count: z.coerce.number(),
  uniques: z.coerce.number(),
  views: z.array(s_traffic),
})

export const s_vulnerability = z.object({
  package: z
    .object({
      ecosystem: s_security_advisory_ecosystems,
      name: z.string().nullable(),
    })
    .nullable(),
  vulnerable_version_range: z.string().nullable(),
  first_patched_version: z.string().nullable(),
  vulnerable_functions: z.array(z.string()).nullable(),
})

export const s_webhook_config = z.object({
  url: s_webhook_config_url.optional(),
  content_type: s_webhook_config_content_type.optional(),
  secret: s_webhook_config_secret.optional(),
  insecure_ssl: s_webhook_config_insecure_ssl.optional(),
})

export const s_added_to_project_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  project_card: z
    .object({
      id: z.coerce.number(),
      url: z.string(),
      project_id: z.coerce.number(),
      project_url: z.string(),
      column_name: z.string(),
      previous_column_name: z.string().optional(),
    })
    .optional(),
})

export const s_assigned_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_integration,
  assignee: s_simple_user,
  assigner: s_simple_user,
})

export const s_authentication_token = z.object({
  token: z.string(),
  expires_at: z.iso.datetime({offset: true}),
  permissions: z.record(z.string(), z.unknown()).optional(),
  repositories: z.array(s_repository).optional(),
  single_file: z.string().nullable().optional(),
  repository_selection: z.enum(["all", "selected"]).optional(),
})

export const s_authorization = z.object({
  id: z.coerce.number(),
  url: z.string(),
  scopes: z.array(z.string()).nullable(),
  token: z.string(),
  token_last_eight: z.string().nullable(),
  hashed_token: z.string().nullable(),
  app: z.object({client_id: z.string(), name: z.string(), url: z.string()}),
  note: z.string().nullable(),
  note_url: z.string().nullable(),
  updated_at: z.iso.datetime({offset: true}),
  created_at: z.iso.datetime({offset: true}),
  fingerprint: z.string().nullable(),
  user: s_nullable_simple_user.optional(),
  installation: s_nullable_scoped_installation.optional(),
  expires_at: z.iso.datetime({offset: true}).nullable(),
})

export const s_campaign_summary = z.object({
  number: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  name: z.string().optional(),
  description: z.string(),
  managers: z.array(s_simple_user),
  team_managers: z.array(s_team).optional(),
  published_at: z.iso.datetime({offset: true}).optional(),
  ends_at: z.iso.datetime({offset: true}),
  closed_at: z.iso.datetime({offset: true}).nullable().optional(),
  state: s_campaign_state,
  contact_link: z.string().nullable(),
  alert_stats: z
    .object({
      open_count: z.coerce.number(),
      closed_count: z.coerce.number(),
      in_progress_count: z.coerce.number(),
    })
    .optional(),
})

export const s_check_suite = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  head_branch: z.string().nullable(),
  head_sha: z.string(),
  status: z
    .enum([
      "queued",
      "in_progress",
      "completed",
      "waiting",
      "requested",
      "pending",
    ])
    .nullable(),
  conclusion: z
    .enum([
      "success",
      "failure",
      "neutral",
      "cancelled",
      "skipped",
      "timed_out",
      "action_required",
      "startup_failure",
      "stale",
    ])
    .nullable(),
  url: z.string().nullable(),
  before: z.string().nullable(),
  after: z.string().nullable(),
  pull_requests: z.array(s_pull_request_minimal).nullable(),
  app: s_nullable_integration,
  repository: s_minimal_repository,
  created_at: z.iso.datetime({offset: true}).nullable(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  head_commit: s_simple_commit,
  latest_check_runs_count: z.coerce.number(),
  check_runs_url: z.string(),
  rerequestable: PermissiveBoolean.optional(),
  runs_rerequestable: PermissiveBoolean.optional(),
})

export const s_check_suite_preference = z.object({
  preferences: z.object({
    auto_trigger_checks: z
      .array(z.object({app_id: z.coerce.number(), setting: PermissiveBoolean}))
      .optional(),
  }),
  repository: s_minimal_repository,
})

export const s_classroom_accepted_assignment = z.object({
  id: z.coerce.number(),
  submitted: PermissiveBoolean,
  passing: PermissiveBoolean,
  commit_count: z.coerce.number(),
  grade: z.string(),
  students: z.array(s_simple_classroom_user),
  repository: s_simple_classroom_repository,
  assignment: s_simple_classroom_assignment,
})

export const s_classroom_assignment = z.object({
  id: z.coerce.number(),
  public_repo: PermissiveBoolean,
  title: z.string(),
  type: z.enum(["individual", "group"]),
  invite_link: z.string(),
  invitations_enabled: PermissiveBoolean,
  slug: z.string(),
  students_are_repo_admins: PermissiveBoolean,
  feedback_pull_requests_enabled: PermissiveBoolean,
  max_teams: z.coerce.number().nullable(),
  max_members: z.coerce.number().nullable(),
  editor: z.string(),
  accepted: z.coerce.number(),
  submitted: z.coerce.number(),
  passing: z.coerce.number(),
  language: z.string(),
  deadline: z.iso.datetime({offset: true}).nullable(),
  starter_code_repository: s_simple_classroom_repository,
  classroom: s_classroom,
})

export const s_code_scanning_alert = z.object({
  number: s_alert_number,
  created_at: s_alert_created_at,
  updated_at: s_alert_updated_at.optional(),
  url: s_alert_url,
  html_url: s_alert_html_url,
  instances_url: s_alert_instances_url,
  state: s_code_scanning_alert_state,
  fixed_at: s_alert_fixed_at.optional(),
  dismissed_by: s_nullable_simple_user,
  dismissed_at: s_alert_dismissed_at,
  dismissed_reason: s_code_scanning_alert_dismissed_reason,
  dismissed_comment: s_code_scanning_alert_dismissed_comment.optional(),
  rule: s_code_scanning_alert_rule,
  tool: s_code_scanning_analysis_tool,
  most_recent_instance: s_code_scanning_alert_instance,
  dismissal_approved_by: s_nullable_simple_user.optional(),
})

export const s_code_scanning_alert_items = z.object({
  number: s_alert_number,
  created_at: s_alert_created_at,
  updated_at: s_alert_updated_at.optional(),
  url: s_alert_url,
  html_url: s_alert_html_url,
  instances_url: s_alert_instances_url,
  state: s_code_scanning_alert_state,
  fixed_at: s_alert_fixed_at.optional(),
  dismissed_by: s_nullable_simple_user,
  dismissed_at: s_alert_dismissed_at,
  dismissed_reason: s_code_scanning_alert_dismissed_reason,
  dismissed_comment: s_code_scanning_alert_dismissed_comment.optional(),
  rule: s_code_scanning_alert_rule_summary,
  tool: s_code_scanning_analysis_tool,
  most_recent_instance: s_code_scanning_alert_instance,
  dismissal_approved_by: s_nullable_simple_user.optional(),
})

export const s_code_scanning_analysis = z.object({
  ref: s_code_scanning_ref,
  commit_sha: s_code_scanning_analysis_commit_sha,
  analysis_key: s_code_scanning_analysis_analysis_key,
  environment: s_code_scanning_analysis_environment,
  category: s_code_scanning_analysis_category.optional(),
  error: z.string(),
  created_at: s_code_scanning_analysis_created_at,
  results_count: z.coerce.number(),
  rules_count: z.coerce.number(),
  id: z.coerce.number(),
  url: s_code_scanning_analysis_url,
  sarif_id: s_code_scanning_analysis_sarif_id,
  tool: s_code_scanning_analysis_tool,
  deletable: PermissiveBoolean,
  warning: z.string(),
})

export const s_code_scanning_organization_alert_items = z.object({
  number: s_alert_number,
  created_at: s_alert_created_at,
  updated_at: s_alert_updated_at.optional(),
  url: s_alert_url,
  html_url: s_alert_html_url,
  instances_url: s_alert_instances_url,
  state: s_code_scanning_alert_state,
  fixed_at: s_alert_fixed_at.optional(),
  dismissed_by: s_nullable_simple_user,
  dismissed_at: s_alert_dismissed_at,
  dismissed_reason: s_code_scanning_alert_dismissed_reason,
  dismissed_comment: s_code_scanning_alert_dismissed_comment.optional(),
  rule: s_code_scanning_alert_rule_summary,
  tool: s_code_scanning_analysis_tool,
  most_recent_instance: s_code_scanning_alert_instance,
  repository: s_simple_repository,
  dismissal_approved_by: s_nullable_simple_user.optional(),
})

export const s_code_scanning_variant_analysis = z.object({
  id: z.coerce.number(),
  controller_repo: s_simple_repository,
  actor: s_simple_user,
  query_language: s_code_scanning_variant_analysis_language,
  query_pack_url: z.string(),
  created_at: z.iso.datetime({offset: true}).optional(),
  updated_at: z.iso.datetime({offset: true}).optional(),
  completed_at: z.iso.datetime({offset: true}).nullable().optional(),
  status: z.enum(["in_progress", "succeeded", "failed", "cancelled"]),
  actions_workflow_run_id: z.coerce.number().optional(),
  failure_reason: z
    .enum(["no_repos_queried", "actions_workflow_run_failed", "internal_error"])
    .optional(),
  scanned_repositories: z
    .array(
      z.object({
        repository: s_code_scanning_variant_analysis_repository,
        analysis_status: s_code_scanning_variant_analysis_status,
        result_count: z.coerce.number().optional(),
        artifact_size_in_bytes: z.coerce.number().optional(),
        failure_message: z.string().optional(),
      }),
    )
    .optional(),
  skipped_repositories: z
    .object({
      access_mismatch_repos:
        s_code_scanning_variant_analysis_skipped_repo_group,
      not_found_repos: z.object({
        repository_count: z.coerce.number(),
        repository_full_names: z.array(z.string()),
      }),
      no_codeql_db_repos: s_code_scanning_variant_analysis_skipped_repo_group,
      over_limit_repos: s_code_scanning_variant_analysis_skipped_repo_group,
    })
    .optional(),
})

export const s_code_scanning_variant_analysis_repo_task = z.object({
  repository: s_simple_repository,
  analysis_status: s_code_scanning_variant_analysis_status,
  artifact_size_in_bytes: z.coerce.number().optional(),
  result_count: z.coerce.number().optional(),
  failure_message: z.string().optional(),
  database_commit_sha: z.string().optional(),
  source_location_prefix: z.string().optional(),
  artifact_url: z.string().optional(),
})

export const s_code_search_result_item = z.object({
  name: z.string(),
  path: z.string(),
  sha: z.string(),
  url: z.string(),
  git_url: z.string(),
  html_url: z.string(),
  repository: s_minimal_repository,
  score: z.coerce.number(),
  file_size: z.coerce.number().optional(),
  language: z.string().nullable().optional(),
  last_modified_at: z.iso.datetime({offset: true}).optional(),
  line_numbers: z.array(z.string()).optional(),
  text_matches: s_search_result_text_matches.optional(),
})

export const s_code_security_configuration_repositories = z.object({
  status: z
    .enum([
      "attached",
      "attaching",
      "detached",
      "removed",
      "enforced",
      "failed",
      "updating",
      "removed_by_enterprise",
    ])
    .optional(),
  repository: s_simple_repository.optional(),
})

export const s_codespace = z.object({
  id: z.coerce.number(),
  name: z.string(),
  display_name: z.string().nullable().optional(),
  environment_id: z.string().nullable(),
  owner: s_simple_user,
  billable_owner: s_simple_user,
  repository: s_minimal_repository,
  machine: s_nullable_codespace_machine,
  devcontainer_path: z.string().nullable().optional(),
  prebuild: PermissiveBoolean.nullable(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  last_used_at: z.iso.datetime({offset: true}),
  state: z.enum([
    "Unknown",
    "Created",
    "Queued",
    "Provisioning",
    "Available",
    "Awaiting",
    "Unavailable",
    "Deleted",
    "Moved",
    "Shutdown",
    "Archived",
    "Starting",
    "ShuttingDown",
    "Failed",
    "Exporting",
    "Updating",
    "Rebuilding",
  ]),
  url: z.string(),
  git_status: z.object({
    ahead: z.coerce.number().optional(),
    behind: z.coerce.number().optional(),
    has_unpushed_changes: PermissiveBoolean.optional(),
    has_uncommitted_changes: PermissiveBoolean.optional(),
    ref: z.string().optional(),
  }),
  location: z.enum(["EastUs", "SouthEastAsia", "WestEurope", "WestUs2"]),
  idle_timeout_minutes: z.coerce.number().nullable(),
  web_url: z.string(),
  machines_url: z.string(),
  start_url: z.string(),
  stop_url: z.string(),
  publish_url: z.string().nullable().optional(),
  pulls_url: z.string().nullable(),
  recent_folders: z.array(z.string()),
  runtime_constraints: z
    .object({
      allowed_port_privacy_settings: z.array(z.string()).nullable().optional(),
    })
    .optional(),
  pending_operation: PermissiveBoolean.nullable().optional(),
  pending_operation_disabled_reason: z.string().nullable().optional(),
  idle_timeout_notice: z.string().nullable().optional(),
  retention_period_minutes: z.coerce.number().nullable().optional(),
  retention_expires_at: z.iso.datetime({offset: true}).nullable().optional(),
  last_known_stop_notice: z.string().nullable().optional(),
})

export const s_combined_commit_status = z.object({
  state: z.string(),
  statuses: z.array(s_simple_commit_status),
  sha: z.string(),
  total_count: z.coerce.number(),
  repository: s_minimal_repository,
  commit_url: z.string(),
  url: z.string(),
})

export const s_commit_comparison = z.object({
  url: z.string(),
  html_url: z.string(),
  permalink_url: z.string(),
  diff_url: z.string(),
  patch_url: z.string(),
  base_commit: s_commit,
  merge_base_commit: s_commit,
  status: z.enum(["diverged", "ahead", "behind", "identical"]),
  ahead_by: z.coerce.number(),
  behind_by: z.coerce.number(),
  total_commits: z.coerce.number(),
  commits: z.array(s_commit),
  files: z.array(s_diff_entry).optional(),
})

export const s_commit_search_result_item = z.object({
  url: z.string(),
  sha: z.string(),
  html_url: z.string(),
  comments_url: z.string(),
  commit: z.object({
    author: z.object({
      name: z.string(),
      email: z.string(),
      date: z.iso.datetime({offset: true}),
    }),
    committer: s_nullable_git_user,
    comment_count: z.coerce.number(),
    message: z.string(),
    tree: z.object({sha: z.string(), url: z.string()}),
    url: z.string(),
    verification: s_verification.optional(),
  }),
  author: s_nullable_simple_user,
  committer: s_nullable_git_user,
  parents: z.array(
    z.object({
      url: z.string().optional(),
      html_url: z.string().optional(),
      sha: z.string().optional(),
    }),
  ),
  repository: s_minimal_repository,
  score: z.coerce.number(),
  node_id: z.string(),
  text_matches: s_search_result_text_matches.optional(),
})

export const s_converted_note_to_issue_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_integration,
  project_card: z
    .object({
      id: z.coerce.number(),
      url: z.string(),
      project_id: z.coerce.number(),
      project_url: z.string(),
      column_name: z.string(),
      previous_column_name: z.string().optional(),
    })
    .optional(),
})

export const s_copilot_seat_details = z.object({
  assignee: s_nullable_simple_user.optional(),
  organization: s_nullable_organization_simple.optional(),
  assigning_team: z.union([s_team, s_enterprise_team]).nullable().optional(),
  pending_cancellation_date: z.string().nullable().optional(),
  last_activity_at: z.iso.datetime({offset: true}).nullable().optional(),
  last_activity_editor: z.string().nullable().optional(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}).optional(),
  plan_type: z.enum(["business", "enterprise", "unknown"]).optional(),
})

export const s_demilestoned_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  milestone: z.object({title: z.string()}),
})

export const s_dependabot_alert_security_advisory = z.object({
  ghsa_id: z.string(),
  cve_id: z.string().nullable(),
  summary: z.string().max(1024),
  description: z.string(),
  vulnerabilities: z.array(s_dependabot_alert_security_vulnerability),
  severity: z.enum(["low", "medium", "high", "critical"]),
  cvss: z.object({
    score: z.coerce.number().min(0).max(10),
    vector_string: z.string().nullable(),
  }),
  cvss_severities: s_cvss_severities.optional(),
  epss: s_security_advisory_epss.optional(),
  cwes: z.array(z.object({cwe_id: z.string(), name: z.string()})),
  identifiers: z.array(
    z.object({type: z.enum(["CVE", "GHSA"]), value: z.string()}),
  ),
  references: z.array(z.object({url: z.string()})),
  published_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  withdrawn_at: z.iso.datetime({offset: true}).nullable(),
})

export const s_dependabot_repository_access_details = z.object({
  default_level: z.enum(["public", "internal"]).nullable().optional(),
  accessible_repositories: z.array(s_nullable_simple_repository).optional(),
})

export const s_deployment = z.object({
  url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  sha: z.string(),
  ref: z.string(),
  task: z.string(),
  payload: z.union([z.record(z.string(), z.unknown()), z.string()]),
  original_environment: z.string().optional(),
  environment: z.string(),
  description: z.string().nullable(),
  creator: s_nullable_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  statuses_url: z.string(),
  repository_url: z.string(),
  transient_environment: PermissiveBoolean.optional(),
  production_environment: PermissiveBoolean.optional(),
  performed_via_github_app: s_nullable_integration.optional(),
})

export const s_deployment_simple = z.object({
  url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  task: z.string(),
  original_environment: z.string().optional(),
  environment: z.string(),
  description: z.string().nullable(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  statuses_url: z.string(),
  repository_url: z.string(),
  transient_environment: PermissiveBoolean.optional(),
  production_environment: PermissiveBoolean.optional(),
  performed_via_github_app: s_nullable_integration.optional(),
})

export const s_deployment_status = z.object({
  url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  state: z.enum([
    "error",
    "failure",
    "inactive",
    "pending",
    "success",
    "queued",
    "in_progress",
  ]),
  creator: s_nullable_simple_user,
  description: z.string().max(140).default(""),
  environment: z.string().optional().default(""),
  target_url: z.string().default(""),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  deployment_url: z.string(),
  repository_url: z.string(),
  environment_url: z.string().optional().default(""),
  log_url: z.string().optional().default(""),
  performed_via_github_app: s_nullable_integration.optional(),
})

export const s_environment = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  url: z.string(),
  html_url: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  protection_rules: z
    .array(
      z.union([
        z.object({
          id: z.coerce.number(),
          node_id: z.string(),
          type: z.string(),
          wait_timer: s_wait_timer.optional(),
        }),
        z.object({
          id: z.coerce.number(),
          node_id: z.string(),
          prevent_self_review: PermissiveBoolean.optional(),
          type: z.string(),
          reviewers: z
            .array(
              z.object({
                type: s_deployment_reviewer_type.optional(),
                reviewer: z.union([s_simple_user, s_team]).optional(),
              }),
            )
            .optional(),
        }),
        z.object({
          id: z.coerce.number(),
          node_id: z.string(),
          type: z.string(),
        }),
      ]),
    )
    .optional(),
  deployment_branch_policy: s_deployment_branch_policy_settings.optional(),
})

export const s_full_repository = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  name: z.string(),
  full_name: z.string(),
  owner: s_simple_user,
  private: PermissiveBoolean,
  html_url: z.string(),
  description: z.string().nullable(),
  fork: PermissiveBoolean,
  url: z.string(),
  archive_url: z.string(),
  assignees_url: z.string(),
  blobs_url: z.string(),
  branches_url: z.string(),
  collaborators_url: z.string(),
  comments_url: z.string(),
  commits_url: z.string(),
  compare_url: z.string(),
  contents_url: z.string(),
  contributors_url: z.string(),
  deployments_url: z.string(),
  downloads_url: z.string(),
  events_url: z.string(),
  forks_url: z.string(),
  git_commits_url: z.string(),
  git_refs_url: z.string(),
  git_tags_url: z.string(),
  git_url: z.string(),
  issue_comment_url: z.string(),
  issue_events_url: z.string(),
  issues_url: z.string(),
  keys_url: z.string(),
  labels_url: z.string(),
  languages_url: z.string(),
  merges_url: z.string(),
  milestones_url: z.string(),
  notifications_url: z.string(),
  pulls_url: z.string(),
  releases_url: z.string(),
  ssh_url: z.string(),
  stargazers_url: z.string(),
  statuses_url: z.string(),
  subscribers_url: z.string(),
  subscription_url: z.string(),
  tags_url: z.string(),
  teams_url: z.string(),
  trees_url: z.string(),
  clone_url: z.string(),
  mirror_url: z.string().nullable(),
  hooks_url: z.string(),
  svn_url: z.string(),
  homepage: z.string().nullable(),
  language: z.string().nullable(),
  forks_count: z.coerce.number(),
  stargazers_count: z.coerce.number(),
  watchers_count: z.coerce.number(),
  size: z.coerce.number(),
  default_branch: z.string(),
  open_issues_count: z.coerce.number(),
  is_template: PermissiveBoolean.optional(),
  topics: z.array(z.string()).optional(),
  has_issues: PermissiveBoolean,
  has_projects: PermissiveBoolean,
  has_wiki: PermissiveBoolean,
  has_pages: PermissiveBoolean,
  has_downloads: PermissiveBoolean.optional(),
  has_discussions: PermissiveBoolean,
  archived: PermissiveBoolean,
  disabled: PermissiveBoolean,
  visibility: z.string().optional(),
  pushed_at: z.iso.datetime({offset: true}),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  permissions: z
    .object({
      admin: PermissiveBoolean,
      maintain: PermissiveBoolean.optional(),
      push: PermissiveBoolean,
      triage: PermissiveBoolean.optional(),
      pull: PermissiveBoolean,
    })
    .optional(),
  allow_rebase_merge: PermissiveBoolean.optional(),
  template_repository: s_nullable_repository.optional(),
  temp_clone_token: z.string().nullable().optional(),
  allow_squash_merge: PermissiveBoolean.optional(),
  allow_auto_merge: PermissiveBoolean.optional(),
  delete_branch_on_merge: PermissiveBoolean.optional(),
  allow_merge_commit: PermissiveBoolean.optional(),
  allow_update_branch: PermissiveBoolean.optional(),
  use_squash_pr_title_as_default: PermissiveBoolean.optional(),
  squash_merge_commit_title: z
    .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
    .optional(),
  squash_merge_commit_message: z
    .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
    .optional(),
  merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
  merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
  allow_forking: PermissiveBoolean.optional(),
  web_commit_signoff_required: PermissiveBoolean.optional(),
  subscribers_count: z.coerce.number(),
  network_count: z.coerce.number(),
  license: s_nullable_license_simple,
  organization: s_nullable_simple_user.optional(),
  parent: s_repository.optional(),
  source: s_repository.optional(),
  forks: z.coerce.number(),
  master_branch: z.string().optional(),
  open_issues: z.coerce.number(),
  watchers: z.coerce.number(),
  anonymous_access_enabled: PermissiveBoolean.optional().default(true),
  code_of_conduct: s_code_of_conduct_simple.optional(),
  security_and_analysis: s_security_and_analysis.optional(),
  custom_properties: z.record(z.string(), z.unknown()).optional(),
})

export const s_gist_simple = z.object({
  forks: z
    .array(
      z.object({
        id: z.string().optional(),
        url: z.string().optional(),
        user: s_public_user.optional(),
        created_at: z.iso.datetime({offset: true}).optional(),
        updated_at: z.iso.datetime({offset: true}).optional(),
      }),
    )
    .nullable()
    .optional(),
  history: z.array(s_gist_history).nullable().optional(),
  fork_of: z
    .object({
      url: z.string(),
      forks_url: z.string(),
      commits_url: z.string(),
      id: z.string(),
      node_id: z.string(),
      git_pull_url: z.string(),
      git_push_url: z.string(),
      html_url: z.string(),
      files: z.record(
        z.string(),
        z.object({
          filename: z.string().optional(),
          type: z.string().optional(),
          language: z.string().optional(),
          raw_url: z.string().optional(),
          size: z.coerce.number().optional(),
        }),
      ),
      public: PermissiveBoolean,
      created_at: z.iso.datetime({offset: true}),
      updated_at: z.iso.datetime({offset: true}),
      description: z.string().nullable(),
      comments: z.coerce.number(),
      comments_enabled: PermissiveBoolean.optional(),
      user: s_nullable_simple_user,
      comments_url: z.string(),
      owner: s_nullable_simple_user.optional(),
      truncated: PermissiveBoolean.optional(),
      forks: z.array(z.unknown()).optional(),
      history: z.array(z.unknown()).optional(),
    })
    .nullable()
    .optional(),
  url: z.string().optional(),
  forks_url: z.string().optional(),
  commits_url: z.string().optional(),
  id: z.string().optional(),
  node_id: z.string().optional(),
  git_pull_url: z.string().optional(),
  git_push_url: z.string().optional(),
  html_url: z.string().optional(),
  files: z
    .record(
      z.string(),
      z
        .object({
          filename: z.string().optional(),
          type: z.string().optional(),
          language: z.string().optional(),
          raw_url: z.string().optional(),
          size: z.coerce.number().optional(),
          truncated: PermissiveBoolean.optional(),
          content: z.string().optional(),
          encoding: z.string().optional().default("utf-8"),
        })
        .nullable(),
    )
    .optional(),
  public: PermissiveBoolean.optional(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
  description: z.string().nullable().optional(),
  comments: z.coerce.number().optional(),
  comments_enabled: PermissiveBoolean.optional(),
  user: z.string().nullable().optional(),
  comments_url: z.string().optional(),
  owner: s_simple_user.optional(),
  truncated: PermissiveBoolean.optional(),
})

export const s_global_advisory = z.object({
  ghsa_id: z.string(),
  cve_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  repository_advisory_url: z.string().nullable(),
  summary: z.string().max(1024),
  description: z.string().max(65535).nullable(),
  type: z.enum(["reviewed", "unreviewed", "malware"]),
  severity: z.enum(["critical", "high", "medium", "low", "unknown"]),
  source_code_location: z.string().nullable(),
  identifiers: z
    .array(z.object({type: z.enum(["CVE", "GHSA"]), value: z.string()}))
    .nullable(),
  references: z.array(z.string()).nullable(),
  published_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  github_reviewed_at: z.iso.datetime({offset: true}).nullable(),
  nvd_published_at: z.iso.datetime({offset: true}).nullable(),
  withdrawn_at: z.iso.datetime({offset: true}).nullable(),
  vulnerabilities: z.array(s_vulnerability).nullable(),
  cvss: z
    .object({
      vector_string: z.string().nullable(),
      score: z.coerce.number().min(0).max(10).nullable(),
    })
    .nullable(),
  cvss_severities: s_cvss_severities.optional(),
  epss: s_security_advisory_epss.optional(),
  cwes: z.array(z.object({cwe_id: z.string(), name: z.string()})).nullable(),
  credits: z
    .array(
      z.object({user: s_simple_user, type: s_security_advisory_credit_types}),
    )
    .nullable(),
})

export const s_hook = z.object({
  type: z.string(),
  id: z.coerce.number(),
  name: z.string(),
  active: PermissiveBoolean,
  events: z.array(z.string()),
  config: s_webhook_config,
  updated_at: z.iso.datetime({offset: true}),
  created_at: z.iso.datetime({offset: true}),
  url: z.string(),
  test_url: z.string(),
  ping_url: z.string(),
  deliveries_url: z.string().optional(),
  last_response: s_hook_response,
})

export const s_installation_token = z.object({
  token: z.string(),
  expires_at: z.string(),
  permissions: s_app_permissions.optional(),
  repository_selection: z.enum(["all", "selected"]).optional(),
  repositories: z.array(s_repository).optional(),
  single_file: z.string().optional(),
  has_multiple_single_files: PermissiveBoolean.optional(),
  single_file_paths: z.array(z.string()).optional(),
})

export const s_issue = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  repository_url: z.string(),
  labels_url: z.string(),
  comments_url: z.string(),
  events_url: z.string(),
  html_url: z.string(),
  number: z.coerce.number(),
  state: z.string(),
  state_reason: z
    .enum(["completed", "reopened", "not_planned", "duplicate"])
    .nullable()
    .optional(),
  title: z.string(),
  body: z.string().nullable().optional(),
  user: s_nullable_simple_user,
  labels: z.array(
    z.union([
      z.string(),
      z.object({
        id: z.coerce.number().optional(),
        node_id: z.string().optional(),
        url: z.string().optional(),
        name: z.string().optional(),
        description: z.string().nullable().optional(),
        color: z.string().nullable().optional(),
        default: PermissiveBoolean.optional(),
      }),
    ]),
  ),
  assignee: s_nullable_simple_user,
  assignees: z.array(s_simple_user).nullable().optional(),
  milestone: s_nullable_milestone,
  locked: PermissiveBoolean,
  active_lock_reason: z.string().nullable().optional(),
  comments: z.coerce.number(),
  pull_request: z
    .object({
      merged_at: z.iso.datetime({offset: true}).nullable().optional(),
      diff_url: z.string().nullable(),
      html_url: z.string().nullable(),
      patch_url: z.string().nullable(),
      url: z.string().nullable(),
    })
    .optional(),
  closed_at: z.iso.datetime({offset: true}).nullable(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  draft: PermissiveBoolean.optional(),
  closed_by: s_nullable_simple_user.optional(),
  body_html: z.string().optional(),
  body_text: z.string().optional(),
  timeline_url: z.string().optional(),
  type: s_issue_type.optional(),
  repository: s_repository.optional(),
  performed_via_github_app: s_nullable_integration.optional(),
  author_association: s_author_association,
  reactions: s_reaction_rollup.optional(),
  sub_issues_summary: s_sub_issues_summary.optional(),
})

export const s_issue_comment = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  body: z.string().optional(),
  body_text: z.string().optional(),
  body_html: z.string().optional(),
  html_url: z.string(),
  user: s_nullable_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  issue_url: z.string(),
  author_association: s_author_association,
  performed_via_github_app: s_nullable_integration.optional(),
  reactions: s_reaction_rollup.optional(),
})

export const s_issue_search_result_item = z.object({
  url: z.string(),
  repository_url: z.string(),
  labels_url: z.string(),
  comments_url: z.string(),
  events_url: z.string(),
  html_url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  number: z.coerce.number(),
  title: z.string(),
  locked: PermissiveBoolean,
  active_lock_reason: z.string().nullable().optional(),
  assignees: z.array(s_simple_user).nullable().optional(),
  user: s_nullable_simple_user,
  labels: z.array(
    z.object({
      id: z.coerce.number().optional(),
      node_id: z.string().optional(),
      url: z.string().optional(),
      name: z.string().optional(),
      color: z.string().optional(),
      default: PermissiveBoolean.optional(),
      description: z.string().nullable().optional(),
    }),
  ),
  sub_issues_summary: s_sub_issues_summary.optional(),
  state: z.string(),
  state_reason: z.string().nullable().optional(),
  assignee: s_nullable_simple_user,
  milestone: s_nullable_milestone,
  comments: z.coerce.number(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  closed_at: z.iso.datetime({offset: true}).nullable(),
  text_matches: s_search_result_text_matches.optional(),
  pull_request: z
    .object({
      merged_at: z.iso.datetime({offset: true}).nullable().optional(),
      diff_url: z.string().nullable(),
      html_url: z.string().nullable(),
      patch_url: z.string().nullable(),
      url: z.string().nullable(),
    })
    .optional(),
  body: z.string().optional(),
  score: z.coerce.number(),
  author_association: s_author_association,
  draft: PermissiveBoolean.optional(),
  repository: s_repository.optional(),
  body_html: z.string().optional(),
  body_text: z.string().optional(),
  timeline_url: z.string().optional(),
  type: s_issue_type.optional(),
  performed_via_github_app: s_nullable_integration.optional(),
  reactions: s_reaction_rollup.optional(),
})

export const s_labeled_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  label: z.object({name: z.string(), color: z.string()}),
})

export const s_locked_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  lock_reason: z.string().nullable(),
})

export const s_manifest = z.object({
  name: z.string(),
  file: z.object({source_location: z.string().optional()}).optional(),
  metadata: s_metadata.optional(),
  resolved: z.record(z.string(), s_dependency).optional(),
})

export const s_migration = z.object({
  id: z.coerce.number(),
  owner: s_nullable_simple_user,
  guid: z.string(),
  state: z.string(),
  lock_repositories: PermissiveBoolean,
  exclude_metadata: PermissiveBoolean,
  exclude_git_data: PermissiveBoolean,
  exclude_attachments: PermissiveBoolean,
  exclude_releases: PermissiveBoolean,
  exclude_owner_projects: PermissiveBoolean,
  org_metadata_only: PermissiveBoolean,
  repositories: z.array(s_repository),
  url: z.string(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  node_id: z.string(),
  archive_url: z.string().optional(),
  exclude: z.array(z.string()).optional(),
})

export const s_milestoned_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  milestone: z.object({title: z.string()}),
})

export const s_moved_column_in_project_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  project_card: z
    .object({
      id: z.coerce.number(),
      url: z.string(),
      project_id: z.coerce.number(),
      project_url: z.string(),
      column_name: z.string(),
      previous_column_name: z.string().optional(),
    })
    .optional(),
})

export const s_nullable_issue = z
  .object({
    id: z.coerce.number(),
    node_id: z.string(),
    url: z.string(),
    repository_url: z.string(),
    labels_url: z.string(),
    comments_url: z.string(),
    events_url: z.string(),
    html_url: z.string(),
    number: z.coerce.number(),
    state: z.string(),
    state_reason: z
      .enum(["completed", "reopened", "not_planned", "duplicate"])
      .nullable()
      .optional(),
    title: z.string(),
    body: z.string().nullable().optional(),
    user: s_nullable_simple_user,
    labels: z.array(
      z.union([
        z.string(),
        z.object({
          id: z.coerce.number().optional(),
          node_id: z.string().optional(),
          url: z.string().optional(),
          name: z.string().optional(),
          description: z.string().nullable().optional(),
          color: z.string().nullable().optional(),
          default: PermissiveBoolean.optional(),
        }),
      ]),
    ),
    assignee: s_nullable_simple_user,
    assignees: z.array(s_simple_user).nullable().optional(),
    milestone: s_nullable_milestone,
    locked: PermissiveBoolean,
    active_lock_reason: z.string().nullable().optional(),
    comments: z.coerce.number(),
    pull_request: z
      .object({
        merged_at: z.iso.datetime({offset: true}).nullable().optional(),
        diff_url: z.string().nullable(),
        html_url: z.string().nullable(),
        patch_url: z.string().nullable(),
        url: z.string().nullable(),
      })
      .optional(),
    closed_at: z.iso.datetime({offset: true}).nullable(),
    created_at: z.iso.datetime({offset: true}),
    updated_at: z.iso.datetime({offset: true}),
    draft: PermissiveBoolean.optional(),
    closed_by: s_nullable_simple_user.optional(),
    body_html: z.string().optional(),
    body_text: z.string().optional(),
    timeline_url: z.string().optional(),
    type: s_issue_type.optional(),
    repository: s_repository.optional(),
    performed_via_github_app: s_nullable_integration.optional(),
    author_association: s_author_association,
    reactions: s_reaction_rollup.optional(),
    sub_issues_summary: s_sub_issues_summary.optional(),
  })
  .nullable()

export const s_org_rules = z.union([
  s_repository_rule_creation,
  s_repository_rule_update,
  s_repository_rule_deletion,
  s_repository_rule_required_linear_history,
  s_repository_rule_required_deployments,
  s_repository_rule_required_signatures,
  s_repository_rule_pull_request,
  s_repository_rule_required_status_checks,
  s_repository_rule_non_fast_forward,
  s_repository_rule_commit_message_pattern,
  s_repository_rule_commit_author_email_pattern,
  s_repository_rule_committer_email_pattern,
  s_repository_rule_branch_name_pattern,
  s_repository_rule_tag_name_pattern,
  s_repository_rule_file_path_restriction,
  s_repository_rule_max_file_path_length,
  s_repository_rule_file_extension_restriction,
  s_repository_rule_max_file_size,
  s_repository_rule_workflows,
  s_repository_rule_code_scanning,
])

export const s_org_ruleset_conditions = z.union([
  s_repository_ruleset_conditions.merge(
    s_repository_ruleset_conditions_repository_name_target,
  ),
  s_repository_ruleset_conditions.merge(
    s_repository_ruleset_conditions_repository_id_target,
  ),
  s_repository_ruleset_conditions.merge(
    s_repository_ruleset_conditions_repository_property_target,
  ),
])

export const s_organization_secret_scanning_alert = z.object({
  number: s_alert_number.optional(),
  created_at: s_alert_created_at.optional(),
  updated_at: s_nullable_alert_updated_at.optional(),
  url: s_alert_url.optional(),
  html_url: s_alert_html_url.optional(),
  locations_url: z.string().optional(),
  state: s_secret_scanning_alert_state.optional(),
  resolution: s_secret_scanning_alert_resolution.optional(),
  resolved_at: z.iso.datetime({offset: true}).nullable().optional(),
  resolved_by: s_nullable_simple_user.optional(),
  secret_type: z.string().optional(),
  secret_type_display_name: z.string().optional(),
  secret: z.string().optional(),
  repository: s_simple_repository.optional(),
  push_protection_bypassed: PermissiveBoolean.nullable().optional(),
  push_protection_bypassed_by: s_nullable_simple_user.optional(),
  push_protection_bypassed_at: z.iso
    .datetime({offset: true})
    .nullable()
    .optional(),
  push_protection_bypass_request_reviewer: s_nullable_simple_user.optional(),
  push_protection_bypass_request_reviewer_comment: z
    .string()
    .nullable()
    .optional(),
  push_protection_bypass_request_comment: z.string().nullable().optional(),
  push_protection_bypass_request_html_url: z.string().nullable().optional(),
  resolution_comment: z.string().nullable().optional(),
  validity: z.enum(["active", "inactive", "unknown"]).optional(),
  publicly_leaked: PermissiveBoolean.nullable().optional(),
  multi_repo: PermissiveBoolean.nullable().optional(),
  is_base64_encoded: PermissiveBoolean.nullable().optional(),
  first_location_detected:
    s_nullable_secret_scanning_first_detected_location.optional(),
  has_more_locations: PermissiveBoolean.optional(),
})

export const s_package = z.object({
  id: z.coerce.number(),
  name: z.string(),
  package_type: z.enum([
    "npm",
    "maven",
    "rubygems",
    "docker",
    "nuget",
    "container",
  ]),
  url: z.string(),
  html_url: z.string(),
  version_count: z.coerce.number(),
  visibility: z.enum(["private", "public"]),
  owner: s_nullable_simple_user.optional(),
  repository: s_nullable_minimal_repository.optional(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
})

export const s_pending_deployment = z.object({
  environment: z.object({
    id: z.coerce.number().optional(),
    node_id: z.string().optional(),
    name: z.string().optional(),
    url: z.string().optional(),
    html_url: z.string().optional(),
  }),
  wait_timer: z.coerce.number(),
  wait_timer_started_at: z.iso.datetime({offset: true}).nullable(),
  current_user_can_approve: PermissiveBoolean,
  reviewers: z.array(
    z.object({
      type: s_deployment_reviewer_type.optional(),
      reviewer: z.union([s_simple_user, s_team]).optional(),
    }),
  ),
})

export const s_protected_branch = z.object({
  url: z.string(),
  required_status_checks: s_status_check_policy.optional(),
  required_pull_request_reviews: z
    .object({
      url: z.string(),
      dismiss_stale_reviews: PermissiveBoolean.optional(),
      require_code_owner_reviews: PermissiveBoolean.optional(),
      required_approving_review_count: z.coerce.number().optional(),
      require_last_push_approval: PermissiveBoolean.optional().default(false),
      dismissal_restrictions: z
        .object({
          url: z.string(),
          users_url: z.string(),
          teams_url: z.string(),
          users: z.array(s_simple_user),
          teams: z.array(s_team),
          apps: z.array(s_integration).optional(),
        })
        .optional(),
      bypass_pull_request_allowances: z
        .object({
          users: z.array(s_simple_user),
          teams: z.array(s_team),
          apps: z.array(s_integration).optional(),
        })
        .optional(),
    })
    .optional(),
  required_signatures: z
    .object({url: z.string(), enabled: PermissiveBoolean})
    .optional(),
  enforce_admins: z
    .object({url: z.string(), enabled: PermissiveBoolean})
    .optional(),
  required_linear_history: z.object({enabled: PermissiveBoolean}).optional(),
  allow_force_pushes: z.object({enabled: PermissiveBoolean}).optional(),
  allow_deletions: z.object({enabled: PermissiveBoolean}).optional(),
  restrictions: s_branch_restriction_policy.optional(),
  required_conversation_resolution: z
    .object({enabled: PermissiveBoolean.optional()})
    .optional(),
  block_creations: z.object({enabled: PermissiveBoolean}).optional(),
  lock_branch: z
    .object({enabled: PermissiveBoolean.optional().default(false)})
    .optional(),
  allow_fork_syncing: z
    .object({enabled: PermissiveBoolean.optional().default(false)})
    .optional(),
})

export const s_protected_branch_pull_request_review = z.object({
  url: z.string().optional(),
  dismissal_restrictions: z
    .object({
      users: z.array(s_simple_user).optional(),
      teams: z.array(s_team).optional(),
      apps: z.array(s_integration).optional(),
      url: z.string().optional(),
      users_url: z.string().optional(),
      teams_url: z.string().optional(),
    })
    .optional(),
  bypass_pull_request_allowances: z
    .object({
      users: z.array(s_simple_user).optional(),
      teams: z.array(s_team).optional(),
      apps: z.array(s_integration).optional(),
    })
    .optional(),
  dismiss_stale_reviews: PermissiveBoolean,
  require_code_owner_reviews: PermissiveBoolean,
  required_approving_review_count: z.coerce.number().min(0).max(6).optional(),
  require_last_push_approval: PermissiveBoolean.optional().default(false),
})

export const s_pull_request = z.object({
  url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  html_url: z.string(),
  diff_url: z.string(),
  patch_url: z.string(),
  issue_url: z.string(),
  commits_url: z.string(),
  review_comments_url: z.string(),
  review_comment_url: z.string(),
  comments_url: z.string(),
  statuses_url: z.string(),
  number: z.coerce.number(),
  state: z.enum(["open", "closed"]),
  locked: PermissiveBoolean,
  title: z.string(),
  user: s_simple_user,
  body: z.string().nullable(),
  labels: z.array(
    z.object({
      id: z.coerce.number(),
      node_id: z.string(),
      url: z.string(),
      name: z.string(),
      description: z.string().nullable(),
      color: z.string(),
      default: PermissiveBoolean,
    }),
  ),
  milestone: s_nullable_milestone,
  active_lock_reason: z.string().nullable().optional(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  closed_at: z.iso.datetime({offset: true}).nullable(),
  merged_at: z.iso.datetime({offset: true}).nullable(),
  merge_commit_sha: z.string().nullable(),
  assignee: s_nullable_simple_user,
  assignees: z.array(s_simple_user).nullable().optional(),
  requested_reviewers: z.array(s_simple_user).nullable().optional(),
  requested_teams: z.array(s_team_simple).nullable().optional(),
  head: z.object({
    label: z.string(),
    ref: z.string(),
    repo: s_repository,
    sha: z.string(),
    user: s_simple_user,
  }),
  base: z.object({
    label: z.string(),
    ref: z.string(),
    repo: s_repository,
    sha: z.string(),
    user: s_simple_user,
  }),
  _links: z.object({
    comments: s_link,
    commits: s_link,
    statuses: s_link,
    html: s_link,
    issue: s_link,
    review_comments: s_link,
    review_comment: s_link,
    self: s_link,
  }),
  author_association: s_author_association,
  auto_merge: s_auto_merge,
  draft: PermissiveBoolean.optional(),
  merged: PermissiveBoolean,
  mergeable: PermissiveBoolean.nullable(),
  rebaseable: PermissiveBoolean.nullable().optional(),
  mergeable_state: z.string(),
  merged_by: s_nullable_simple_user,
  comments: z.coerce.number(),
  review_comments: z.coerce.number(),
  maintainer_can_modify: PermissiveBoolean,
  commits: z.coerce.number(),
  additions: z.coerce.number(),
  deletions: z.coerce.number(),
  changed_files: z.coerce.number(),
})

export const s_pull_request_review_request = z.object({
  users: z.array(s_simple_user),
  teams: z.array(s_team),
})

export const s_pull_request_simple = z.object({
  url: z.string(),
  id: z.coerce.number(),
  node_id: z.string(),
  html_url: z.string(),
  diff_url: z.string(),
  patch_url: z.string(),
  issue_url: z.string(),
  commits_url: z.string(),
  review_comments_url: z.string(),
  review_comment_url: z.string(),
  comments_url: z.string(),
  statuses_url: z.string(),
  number: z.coerce.number(),
  state: z.string(),
  locked: PermissiveBoolean,
  title: z.string(),
  user: s_nullable_simple_user,
  body: z.string().nullable(),
  labels: z.array(
    z.object({
      id: z.coerce.number(),
      node_id: z.string(),
      url: z.string(),
      name: z.string(),
      description: z.string(),
      color: z.string(),
      default: PermissiveBoolean,
    }),
  ),
  milestone: s_nullable_milestone,
  active_lock_reason: z.string().nullable().optional(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  closed_at: z.iso.datetime({offset: true}).nullable(),
  merged_at: z.iso.datetime({offset: true}).nullable(),
  merge_commit_sha: z.string().nullable(),
  assignee: s_nullable_simple_user,
  assignees: z.array(s_simple_user).nullable().optional(),
  requested_reviewers: z.array(s_simple_user).nullable().optional(),
  requested_teams: z.array(s_team).nullable().optional(),
  head: z.object({
    label: z.string(),
    ref: z.string(),
    repo: s_repository,
    sha: z.string(),
    user: s_nullable_simple_user,
  }),
  base: z.object({
    label: z.string(),
    ref: z.string(),
    repo: s_repository,
    sha: z.string(),
    user: s_nullable_simple_user,
  }),
  _links: z.object({
    comments: s_link,
    commits: s_link,
    statuses: s_link,
    html: s_link,
    issue: s_link,
    review_comments: s_link,
    review_comment: s_link,
    self: s_link,
  }),
  author_association: s_author_association,
  auto_merge: s_auto_merge,
  draft: PermissiveBoolean.optional(),
})

export const s_release = z.object({
  url: z.string(),
  html_url: z.string(),
  assets_url: z.string(),
  upload_url: z.string(),
  tarball_url: z.string().nullable(),
  zipball_url: z.string().nullable(),
  id: z.coerce.number(),
  node_id: z.string(),
  tag_name: z.string(),
  target_commitish: z.string(),
  name: z.string().nullable(),
  body: z.string().nullable().optional(),
  draft: PermissiveBoolean,
  prerelease: PermissiveBoolean,
  immutable: PermissiveBoolean.optional(),
  created_at: z.iso.datetime({offset: true}),
  published_at: z.iso.datetime({offset: true}).nullable(),
  author: s_simple_user,
  assets: z.array(s_release_asset),
  body_html: z.string().optional(),
  body_text: z.string().optional(),
  mentions_count: z.coerce.number().optional(),
  discussion_url: z.string().optional(),
  reactions: s_reaction_rollup.optional(),
})

export const s_removed_from_project_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  project_card: z
    .object({
      id: z.coerce.number(),
      url: z.string(),
      project_id: z.coerce.number(),
      project_url: z.string(),
      column_name: z.string(),
      previous_column_name: z.string().optional(),
    })
    .optional(),
})

export const s_renamed_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  rename: z.object({from: z.string(), to: z.string()}),
})

export const s_repository_advisory = z.object({
  ghsa_id: z.string(),
  cve_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string(),
  summary: z.string().max(1024),
  description: z.string().max(65535).nullable(),
  severity: z.enum(["critical", "high", "medium", "low"]).nullable(),
  author: s_simple_user.nullable(),
  publisher: s_simple_user.nullable(),
  identifiers: z.array(
    z.object({type: z.enum(["CVE", "GHSA"]), value: z.string()}),
  ),
  state: z.enum(["published", "closed", "withdrawn", "draft", "triage"]),
  created_at: z.iso.datetime({offset: true}).nullable(),
  updated_at: z.iso.datetime({offset: true}).nullable(),
  published_at: z.iso.datetime({offset: true}).nullable(),
  closed_at: z.iso.datetime({offset: true}).nullable(),
  withdrawn_at: z.iso.datetime({offset: true}).nullable(),
  submission: z.object({accepted: PermissiveBoolean}).nullable(),
  vulnerabilities: z.array(s_repository_advisory_vulnerability).nullable(),
  cvss: z
    .object({
      vector_string: z.string().nullable(),
      score: z.coerce.number().min(0).max(10).nullable(),
    })
    .nullable(),
  cvss_severities: s_cvss_severities.optional(),
  cwes: z.array(z.object({cwe_id: z.string(), name: z.string()})).nullable(),
  cwe_ids: z.array(z.string()).nullable(),
  credits: z
    .array(
      z.object({
        login: z.string().optional(),
        type: s_security_advisory_credit_types.optional(),
      }),
    )
    .nullable(),
  credits_detailed: z.array(s_repository_advisory_credit).nullable(),
  collaborating_users: z.array(s_simple_user).nullable(),
  collaborating_teams: z.array(s_team).nullable(),
  private_fork: s_simple_repository.nullable(),
})

export const s_repository_invitation = z.object({
  id: z.coerce.number(),
  repository: s_minimal_repository,
  invitee: s_nullable_simple_user,
  inviter: s_nullable_simple_user,
  permissions: z.enum(["read", "write", "admin", "triage", "maintain"]),
  created_at: z.iso.datetime({offset: true}),
  expired: PermissiveBoolean.optional(),
  url: z.string(),
  html_url: z.string(),
  node_id: z.string(),
})

export const s_repository_rule = z.union([
  s_repository_rule_creation,
  s_repository_rule_update,
  s_repository_rule_deletion,
  s_repository_rule_required_linear_history,
  s_repository_rule_merge_queue,
  s_repository_rule_required_deployments,
  s_repository_rule_required_signatures,
  s_repository_rule_pull_request,
  s_repository_rule_required_status_checks,
  s_repository_rule_non_fast_forward,
  s_repository_rule_commit_message_pattern,
  s_repository_rule_commit_author_email_pattern,
  s_repository_rule_committer_email_pattern,
  s_repository_rule_branch_name_pattern,
  s_repository_rule_tag_name_pattern,
  s_repository_rule_file_path_restriction,
  s_repository_rule_max_file_path_length,
  s_repository_rule_file_extension_restriction,
  s_repository_rule_max_file_size,
  s_repository_rule_workflows,
  s_repository_rule_code_scanning,
])

export const s_repository_rule_detailed = z.union([
  s_repository_rule_creation.merge(s_repository_rule_ruleset_info),
  s_repository_rule_update.merge(s_repository_rule_ruleset_info),
  s_repository_rule_deletion.merge(s_repository_rule_ruleset_info),
  s_repository_rule_required_linear_history.merge(
    s_repository_rule_ruleset_info,
  ),
  s_repository_rule_merge_queue.merge(s_repository_rule_ruleset_info),
  s_repository_rule_required_deployments.merge(s_repository_rule_ruleset_info),
  s_repository_rule_required_signatures.merge(s_repository_rule_ruleset_info),
  s_repository_rule_pull_request.merge(s_repository_rule_ruleset_info),
  s_repository_rule_required_status_checks.merge(
    s_repository_rule_ruleset_info,
  ),
  s_repository_rule_non_fast_forward.merge(s_repository_rule_ruleset_info),
  s_repository_rule_commit_message_pattern.merge(
    s_repository_rule_ruleset_info,
  ),
  s_repository_rule_commit_author_email_pattern.merge(
    s_repository_rule_ruleset_info,
  ),
  s_repository_rule_committer_email_pattern.merge(
    s_repository_rule_ruleset_info,
  ),
  s_repository_rule_branch_name_pattern.merge(s_repository_rule_ruleset_info),
  s_repository_rule_tag_name_pattern.merge(s_repository_rule_ruleset_info),
  s_repository_rule_file_path_restriction.merge(s_repository_rule_ruleset_info),
  s_repository_rule_max_file_path_length.merge(s_repository_rule_ruleset_info),
  s_repository_rule_file_extension_restriction.merge(
    s_repository_rule_ruleset_info,
  ),
  s_repository_rule_max_file_size.merge(s_repository_rule_ruleset_info),
  s_repository_rule_workflows.merge(s_repository_rule_ruleset_info),
  s_repository_rule_code_scanning.merge(s_repository_rule_ruleset_info),
])

export const s_review_dismissed_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  dismissed_review: z.object({
    state: z.string(),
    review_id: z.coerce.number(),
    dismissal_message: z.string().nullable(),
    dismissal_commit_id: z.string().optional(),
  }),
})

export const s_review_request_removed_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  review_requester: s_simple_user,
  requested_team: s_team.optional(),
  requested_reviewer: s_simple_user.optional(),
})

export const s_review_requested_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  review_requester: s_simple_user,
  requested_team: s_team.optional(),
  requested_reviewer: s_simple_user.optional(),
})

export const s_secret_scanning_alert = z.object({
  number: s_alert_number.optional(),
  created_at: s_alert_created_at.optional(),
  updated_at: s_nullable_alert_updated_at.optional(),
  url: s_alert_url.optional(),
  html_url: s_alert_html_url.optional(),
  locations_url: z.string().optional(),
  state: s_secret_scanning_alert_state.optional(),
  resolution: s_secret_scanning_alert_resolution.optional(),
  resolved_at: z.iso.datetime({offset: true}).nullable().optional(),
  resolved_by: s_nullable_simple_user.optional(),
  resolution_comment: z.string().nullable().optional(),
  secret_type: z.string().optional(),
  secret_type_display_name: z.string().optional(),
  secret: z.string().optional(),
  push_protection_bypassed: PermissiveBoolean.nullable().optional(),
  push_protection_bypassed_by: s_nullable_simple_user.optional(),
  push_protection_bypassed_at: z.iso
    .datetime({offset: true})
    .nullable()
    .optional(),
  push_protection_bypass_request_reviewer: s_nullable_simple_user.optional(),
  push_protection_bypass_request_reviewer_comment: z
    .string()
    .nullable()
    .optional(),
  push_protection_bypass_request_comment: z.string().nullable().optional(),
  push_protection_bypass_request_html_url: z.string().nullable().optional(),
  validity: z.enum(["active", "inactive", "unknown"]).optional(),
  publicly_leaked: PermissiveBoolean.nullable().optional(),
  multi_repo: PermissiveBoolean.nullable().optional(),
  is_base64_encoded: PermissiveBoolean.nullable().optional(),
  first_location_detected:
    s_nullable_secret_scanning_first_detected_location.optional(),
  has_more_locations: PermissiveBoolean.optional(),
})

export const s_starred_repository = z.object({
  starred_at: z.iso.datetime({offset: true}),
  repo: s_repository,
})

export const s_state_change_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  state_reason: z.string().nullable().optional(),
})

export const s_thread = z.object({
  id: z.string(),
  repository: s_minimal_repository,
  subject: z.object({
    title: z.string(),
    url: z.string(),
    latest_comment_url: z.string(),
    type: z.string(),
  }),
  reason: z.string(),
  unread: PermissiveBoolean,
  updated_at: z.string(),
  last_read_at: z.string().nullable(),
  url: z.string(),
  subscription_url: z.string(),
})

export const s_timeline_assigned_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  assignee: s_simple_user,
})

export const s_timeline_comment_event = z.object({
  event: z.string(),
  actor: s_simple_user,
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  body: z.string().optional(),
  body_text: z.string().optional(),
  body_html: z.string().optional(),
  html_url: z.string(),
  user: s_simple_user,
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  issue_url: z.string(),
  author_association: s_author_association,
  performed_via_github_app: s_nullable_integration.optional(),
  reactions: s_reaction_rollup.optional(),
})

export const s_timeline_commit_commented_event = z.object({
  event: z.string().optional(),
  node_id: z.string().optional(),
  commit_id: z.string().optional(),
  comments: z.array(s_commit_comment).optional(),
})

export const s_timeline_line_commented_event = z.object({
  event: z.string().optional(),
  node_id: z.string().optional(),
  comments: z.array(s_pull_request_review_comment).optional(),
})

export const s_timeline_unassigned_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  assignee: s_simple_user,
})

export const s_unassigned_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  assignee: s_simple_user,
  assigner: s_simple_user,
})

export const s_unlabeled_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.string(),
  performed_via_github_app: s_nullable_integration,
  label: z.object({name: z.string(), color: z.string()}),
})

export const s_workflow_run = z.object({
  id: z.coerce.number(),
  name: z.string().nullable().optional(),
  node_id: z.string(),
  check_suite_id: z.coerce.number().optional(),
  check_suite_node_id: z.string().optional(),
  head_branch: z.string().nullable(),
  head_sha: z.string(),
  path: z.string(),
  run_number: z.coerce.number(),
  run_attempt: z.coerce.number().optional(),
  referenced_workflows: z.array(s_referenced_workflow).nullable().optional(),
  event: z.string(),
  status: z.string().nullable(),
  conclusion: z.string().nullable(),
  workflow_id: z.coerce.number(),
  url: z.string(),
  html_url: z.string(),
  pull_requests: z.array(s_pull_request_minimal).nullable(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  actor: s_simple_user.optional(),
  triggering_actor: s_simple_user.optional(),
  run_started_at: z.iso.datetime({offset: true}).optional(),
  jobs_url: z.string(),
  logs_url: z.string(),
  check_suite_url: z.string(),
  artifacts_url: z.string(),
  cancel_url: z.string(),
  rerun_url: z.string(),
  previous_attempt_url: z.string().nullable().optional(),
  workflow_url: z.string(),
  head_commit: s_nullable_simple_commit,
  repository: s_minimal_repository,
  head_repository: s_minimal_repository,
  head_repository_id: z.coerce.number().optional(),
  display_title: z.string(),
})

export const s_branch_protection = z.object({
  url: z.string().optional(),
  enabled: PermissiveBoolean.optional(),
  required_status_checks: s_protected_branch_required_status_check.optional(),
  enforce_admins: s_protected_branch_admin_enforced.optional(),
  required_pull_request_reviews:
    s_protected_branch_pull_request_review.optional(),
  restrictions: s_branch_restriction_policy.optional(),
  required_linear_history: z
    .object({enabled: PermissiveBoolean.optional()})
    .optional(),
  allow_force_pushes: z
    .object({enabled: PermissiveBoolean.optional()})
    .optional(),
  allow_deletions: z.object({enabled: PermissiveBoolean.optional()}).optional(),
  block_creations: z.object({enabled: PermissiveBoolean.optional()}).optional(),
  required_conversation_resolution: z
    .object({enabled: PermissiveBoolean.optional()})
    .optional(),
  name: z.string().optional(),
  protection_url: z.string().optional(),
  required_signatures: z
    .object({url: z.string(), enabled: PermissiveBoolean})
    .optional(),
  lock_branch: z
    .object({enabled: PermissiveBoolean.optional().default(false)})
    .optional(),
  allow_fork_syncing: z
    .object({enabled: PermissiveBoolean.optional().default(false)})
    .optional(),
})

export const s_check_run = z.object({
  id: z.coerce.number(),
  head_sha: z.string(),
  node_id: z.string(),
  external_id: z.string().nullable(),
  url: z.string(),
  html_url: z.string().nullable(),
  details_url: z.string().nullable(),
  status: z.enum([
    "queued",
    "in_progress",
    "completed",
    "waiting",
    "requested",
    "pending",
  ]),
  conclusion: z
    .enum([
      "success",
      "failure",
      "neutral",
      "cancelled",
      "skipped",
      "timed_out",
      "action_required",
    ])
    .nullable(),
  started_at: z.iso.datetime({offset: true}).nullable(),
  completed_at: z.iso.datetime({offset: true}).nullable(),
  output: z.object({
    title: z.string().nullable(),
    summary: z.string().nullable(),
    text: z.string().nullable(),
    annotations_count: z.coerce.number(),
    annotations_url: z.string(),
  }),
  name: z.string(),
  check_suite: z.object({id: z.coerce.number()}).nullable(),
  app: s_nullable_integration,
  pull_requests: z.array(s_pull_request_minimal),
  deployment: s_deployment_simple.optional(),
})

export const s_codespace_with_full_repository = z.object({
  id: z.coerce.number(),
  name: z.string(),
  display_name: z.string().nullable().optional(),
  environment_id: z.string().nullable(),
  owner: s_simple_user,
  billable_owner: s_simple_user,
  repository: s_full_repository,
  machine: s_nullable_codespace_machine,
  devcontainer_path: z.string().nullable().optional(),
  prebuild: PermissiveBoolean.nullable(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  last_used_at: z.iso.datetime({offset: true}),
  state: z.enum([
    "Unknown",
    "Created",
    "Queued",
    "Provisioning",
    "Available",
    "Awaiting",
    "Unavailable",
    "Deleted",
    "Moved",
    "Shutdown",
    "Archived",
    "Starting",
    "ShuttingDown",
    "Failed",
    "Exporting",
    "Updating",
    "Rebuilding",
  ]),
  url: z.string(),
  git_status: z.object({
    ahead: z.coerce.number().optional(),
    behind: z.coerce.number().optional(),
    has_unpushed_changes: PermissiveBoolean.optional(),
    has_uncommitted_changes: PermissiveBoolean.optional(),
    ref: z.string().optional(),
  }),
  location: z.enum(["EastUs", "SouthEastAsia", "WestEurope", "WestUs2"]),
  idle_timeout_minutes: z.coerce.number().nullable(),
  web_url: z.string(),
  machines_url: z.string(),
  start_url: z.string(),
  stop_url: z.string(),
  publish_url: z.string().nullable().optional(),
  pulls_url: z.string().nullable(),
  recent_folders: z.array(z.string()),
  runtime_constraints: z
    .object({
      allowed_port_privacy_settings: z.array(z.string()).nullable().optional(),
    })
    .optional(),
  pending_operation: PermissiveBoolean.nullable().optional(),
  pending_operation_disabled_reason: z.string().nullable().optional(),
  idle_timeout_notice: z.string().nullable().optional(),
  retention_period_minutes: z.coerce.number().nullable().optional(),
  retention_expires_at: z.iso.datetime({offset: true}).nullable().optional(),
})

export const s_dependabot_alert = z.object({
  number: s_alert_number,
  state: z.enum(["auto_dismissed", "dismissed", "fixed", "open"]),
  dependency: z.object({
    package: s_dependabot_alert_package.optional(),
    manifest_path: z.string().optional(),
    scope: z.enum(["development", "runtime"]).nullable().optional(),
    relationship: z
      .enum(["unknown", "direct", "transitive"])
      .nullable()
      .optional(),
  }),
  security_advisory: s_dependabot_alert_security_advisory,
  security_vulnerability: s_dependabot_alert_security_vulnerability,
  url: s_alert_url,
  html_url: s_alert_html_url,
  created_at: s_alert_created_at,
  updated_at: s_alert_updated_at,
  dismissed_at: s_alert_dismissed_at,
  dismissed_by: s_nullable_simple_user,
  dismissed_reason: z
    .enum([
      "fix_started",
      "inaccurate",
      "no_bandwidth",
      "not_used",
      "tolerable_risk",
    ])
    .nullable(),
  dismissed_comment: z.string().max(280).nullable(),
  fixed_at: s_alert_fixed_at,
  auto_dismissed_at: s_alert_auto_dismissed_at.optional(),
})

export const s_dependabot_alert_with_repository = z.object({
  number: s_alert_number,
  state: z.enum(["auto_dismissed", "dismissed", "fixed", "open"]),
  dependency: z.object({
    package: s_dependabot_alert_package.optional(),
    manifest_path: z.string().optional(),
    scope: z.enum(["development", "runtime"]).nullable().optional(),
    relationship: z
      .enum(["unknown", "direct", "transitive"])
      .nullable()
      .optional(),
  }),
  security_advisory: s_dependabot_alert_security_advisory,
  security_vulnerability: s_dependabot_alert_security_vulnerability,
  url: s_alert_url,
  html_url: s_alert_html_url,
  created_at: s_alert_created_at,
  updated_at: s_alert_updated_at,
  dismissed_at: s_alert_dismissed_at,
  dismissed_by: s_nullable_simple_user,
  dismissed_reason: z
    .enum([
      "fix_started",
      "inaccurate",
      "no_bandwidth",
      "not_used",
      "tolerable_risk",
    ])
    .nullable(),
  dismissed_comment: z.string().max(280).nullable(),
  fixed_at: s_alert_fixed_at,
  auto_dismissed_at: s_alert_auto_dismissed_at.optional(),
  repository: s_simple_repository,
})

export const s_event = z.object({
  id: z.string(),
  type: z.string().nullable(),
  actor: s_actor,
  repo: z.object({id: z.coerce.number(), name: z.string(), url: z.string()}),
  org: s_actor.optional(),
  payload: z.object({
    action: z.string().optional(),
    issue: s_issue.optional(),
    comment: s_issue_comment.optional(),
    pages: z
      .array(
        z.object({
          page_name: z.string().optional(),
          title: z.string().optional(),
          summary: z.string().nullable().optional(),
          action: z.string().optional(),
          sha: z.string().optional(),
          html_url: z.string().optional(),
        }),
      )
      .optional(),
  }),
  public: PermissiveBoolean,
  created_at: z.iso.datetime({offset: true}).nullable(),
})

export const s_issue_event = z.object({
  id: z.coerce.number(),
  node_id: z.string(),
  url: z.string(),
  actor: s_nullable_simple_user,
  event: z.string(),
  commit_id: z.string().nullable(),
  commit_url: z.string().nullable(),
  created_at: z.iso.datetime({offset: true}),
  issue: s_nullable_issue.optional(),
  label: s_issue_event_label.optional(),
  assignee: s_nullable_simple_user.optional(),
  assigner: s_nullable_simple_user.optional(),
  review_requester: s_nullable_simple_user.optional(),
  requested_reviewer: s_nullable_simple_user.optional(),
  requested_team: s_team.optional(),
  dismissed_review: s_issue_event_dismissed_review.optional(),
  milestone: s_issue_event_milestone.optional(),
  project_card: s_issue_event_project_card.optional(),
  rename: s_issue_event_rename.optional(),
  author_association: s_author_association.optional(),
  lock_reason: z.string().nullable().optional(),
  performed_via_github_app: s_nullable_integration.optional(),
})

export const s_issue_event_for_issue = z.union([
  s_labeled_issue_event,
  s_unlabeled_issue_event,
  s_assigned_issue_event,
  s_unassigned_issue_event,
  s_milestoned_issue_event,
  s_demilestoned_issue_event,
  s_renamed_issue_event,
  s_review_requested_issue_event,
  s_review_request_removed_issue_event,
  s_review_dismissed_issue_event,
  s_locked_issue_event,
  s_added_to_project_issue_event,
  s_moved_column_in_project_issue_event,
  s_removed_from_project_issue_event,
  s_converted_note_to_issue_issue_event,
])

export const s_repository_ruleset = z.object({
  id: z.coerce.number(),
  name: z.string(),
  target: z.enum(["branch", "tag", "push", "repository"]).optional(),
  source_type: z.enum(["Repository", "Organization", "Enterprise"]).optional(),
  source: z.string(),
  enforcement: s_repository_rule_enforcement,
  bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
  current_user_can_bypass: z
    .enum(["always", "pull_requests_only", "never"])
    .optional(),
  node_id: z.string().optional(),
  _links: z
    .object({
      self: z.object({href: z.string().optional()}).optional(),
      html: z.object({href: z.string().optional()}).nullable().optional(),
    })
    .optional(),
  conditions: z
    .union([s_repository_ruleset_conditions, s_org_ruleset_conditions])
    .nullable()
    .optional(),
  rules: z.array(s_repository_rule).optional(),
  created_at: z.iso.datetime({offset: true}).optional(),
  updated_at: z.iso.datetime({offset: true}).optional(),
})

export const s_snapshot = z.object({
  version: z.coerce.number(),
  job: z.object({
    id: z.string(),
    correlator: z.string(),
    html_url: z.string().optional(),
  }),
  sha: z.string().min(40).max(40),
  ref: z.string().regex(new RegExp("^refs/")),
  detector: z.object({name: z.string(), version: z.string(), url: z.string()}),
  metadata: s_metadata.optional(),
  manifests: z.record(z.string(), s_manifest).optional(),
  scanned: z.iso.datetime({offset: true}),
})

export const s_timeline_cross_referenced_event = z.object({
  event: z.string(),
  actor: s_simple_user.optional(),
  created_at: z.iso.datetime({offset: true}),
  updated_at: z.iso.datetime({offset: true}),
  source: z.object({type: z.string().optional(), issue: s_issue.optional()}),
})

export const s_branch_with_protection = z.object({
  name: z.string(),
  commit: s_commit,
  _links: z.object({html: z.string(), self: z.string()}),
  protected: PermissiveBoolean,
  protection: s_branch_protection,
  protection_url: z.string(),
  pattern: z.string().optional(),
  required_approving_review_count: z.coerce.number().optional(),
})

export const s_short_branch = z.object({
  name: z.string(),
  commit: z.object({sha: z.string(), url: z.string()}),
  protected: PermissiveBoolean,
  protection: s_branch_protection.optional(),
  protection_url: z.string().optional(),
})

export const s_timeline_issue_events = z.union([
  s_labeled_issue_event,
  s_unlabeled_issue_event,
  s_milestoned_issue_event,
  s_demilestoned_issue_event,
  s_renamed_issue_event,
  s_review_requested_issue_event,
  s_review_request_removed_issue_event,
  s_review_dismissed_issue_event,
  s_locked_issue_event,
  s_added_to_project_issue_event,
  s_moved_column_in_project_issue_event,
  s_removed_from_project_issue_event,
  s_converted_note_to_issue_issue_event,
  s_timeline_comment_event,
  s_timeline_cross_referenced_event,
  s_timeline_committed_event,
  s_timeline_reviewed_event,
  s_timeline_line_commented_event,
  s_timeline_commit_commented_event,
  s_timeline_assigned_issue_event,
  s_timeline_unassigned_issue_event,
  s_state_change_issue_event,
])

export const s_AppsUpdateWebhookConfigForAppRequestBody = z.object({
  url: s_webhook_config_url.optional(),
  content_type: s_webhook_config_content_type.optional(),
  secret: s_webhook_config_secret.optional(),
  insecure_ssl: s_webhook_config_insecure_ssl.optional(),
})

export const s_AppsCreateInstallationAccessTokenRequestBody = z.object({
  repositories: z.array(z.string()).optional(),
  repository_ids: z.array(z.coerce.number()).optional(),
  permissions: s_app_permissions.optional(),
})

export const s_AppsDeleteAuthorizationRequestBody = z.object({
  access_token: z.string(),
})

export const s_AppsCheckTokenRequestBody = z.object({access_token: z.string()})

export const s_AppsResetTokenRequestBody = z.object({access_token: z.string()})

export const s_AppsDeleteTokenRequestBody = z.object({access_token: z.string()})

export const s_AppsScopeTokenRequestBody = z.object({
  access_token: z.string(),
  target: z.string().optional(),
  target_id: z.coerce.number().optional(),
  repositories: z.array(z.string()).optional(),
  repository_ids: z.array(z.coerce.number()).optional(),
  permissions: s_app_permissions.optional(),
})

export const s_CredentialsRevokeRequestBody = z.object({
  credentials: z.array(z.string()).min(1).max(1000),
})

export const s_CodeSecurityCreateConfigurationForEnterpriseRequestBody =
  z.object({
    name: z.string(),
    description: z.string().max(255),
    advanced_security: z
      .enum(["enabled", "disabled", "code_security", "secret_protection"])
      .optional()
      .default("disabled"),
    code_security: z.enum(["enabled", "disabled", "not_set"]).optional(),
    dependency_graph: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("enabled"),
    dependency_graph_autosubmit_action: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    dependency_graph_autosubmit_action_options: z
      .object({labeled_runners: PermissiveBoolean.optional().default(false)})
      .optional(),
    dependabot_alerts: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    dependabot_security_updates: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    code_scanning_options: s_code_scanning_options.optional(),
    code_scanning_default_setup: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    code_scanning_default_setup_options:
      s_code_scanning_default_setup_options.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_protection: z.enum(["enabled", "disabled", "not_set"]).optional(),
    secret_scanning: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_push_protection: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_validity_checks: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_non_provider_patterns: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_generic_secrets: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    private_vulnerability_reporting: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    enforcement: z
      .enum(["enforced", "unenforced"])
      .optional()
      .default("enforced"),
  })

export const s_CodeSecurityUpdateEnterpriseConfigurationRequestBody = z.object({
  name: z.string().optional(),
  description: z.string().max(255).optional(),
  advanced_security: z
    .enum(["enabled", "disabled", "code_security", "secret_protection"])
    .optional(),
  code_security: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependency_graph: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependency_graph_autosubmit_action: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  dependency_graph_autosubmit_action_options: z
    .object({labeled_runners: PermissiveBoolean.optional()})
    .optional(),
  dependabot_alerts: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependabot_security_updates: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  code_scanning_default_setup: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  code_scanning_default_setup_options:
    s_code_scanning_default_setup_options.optional(),
  code_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_protection: z.enum(["enabled", "disabled", "not_set"]).optional(),
  secret_scanning: z.enum(["enabled", "disabled", "not_set"]).optional(),
  secret_scanning_push_protection: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_validity_checks: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_non_provider_patterns: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_generic_secrets: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  private_vulnerability_reporting: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  enforcement: z.enum(["enforced", "unenforced"]).optional(),
})

export const s_CodeSecurityAttachEnterpriseConfigurationRequestBody = z.object({
  scope: z.enum(["all", "all_without_configurations"]),
})

export const s_CodeSecuritySetConfigurationAsDefaultForEnterpriseRequestBody =
  z.object({
    default_for_new_repos: z
      .enum(["all", "none", "private_and_internal", "public"])
      .optional(),
  })

export const s_GistsCreateRequestBody = z.object({
  description: z.string().optional(),
  files: z.record(z.string(), z.object({content: z.string()})),
  public: z
    .union([
      PermissiveBoolean.default(false),
      z.enum(["true", "false"]).default("false"),
    ])
    .optional(),
})

export const s_GistsUpdateRequestBody = z
  .object({
    description: z.string().optional(),
    files: z
      .record(
        z.string(),
        z
          .object({
            content: z.string().optional(),
            filename: z.string().nullable().optional(),
          })
          .nullable(),
      )
      .optional(),
  })
  .nullable()

export const s_GistsCreateCommentRequestBody = z.object({
  body: z.string().max(65535),
})

export const s_GistsUpdateCommentRequestBody = z.object({
  body: z.string().max(65535),
})

export const s_MarkdownRenderRequestBody = z.object({
  text: z.string(),
  mode: z.enum(["markdown", "gfm"]).optional().default("markdown"),
  context: z.string().optional(),
})

export const s_ActivityMarkNotificationsAsReadRequestBody = z.object({
  last_read_at: z.iso.datetime({offset: true}).optional(),
  read: PermissiveBoolean.optional(),
})

export const s_ActivitySetThreadSubscriptionRequestBody = z.object({
  ignored: PermissiveBoolean.optional().default(false),
})

export const s_DependabotUpdateRepositoryAccessForOrgRequestBody = z.object({
  repository_ids_to_add: z.array(z.coerce.number()).optional(),
  repository_ids_to_remove: z.array(z.coerce.number()).optional(),
})

export const s_DependabotSetRepositoryAccessDefaultLevelRequestBody = z.object({
  default_level: z.enum(["public", "internal"]),
})

export const s_OrgsUpdateRequestBody = z.object({
  billing_email: z.string().optional(),
  company: z.string().optional(),
  email: z.string().optional(),
  twitter_username: z.string().optional(),
  location: z.string().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  has_organization_projects: PermissiveBoolean.optional(),
  has_repository_projects: PermissiveBoolean.optional(),
  default_repository_permission: z
    .enum(["read", "write", "admin", "none"])
    .optional()
    .default("read"),
  members_can_create_repositories: PermissiveBoolean.optional().default(true),
  members_can_create_internal_repositories: PermissiveBoolean.optional(),
  members_can_create_private_repositories: PermissiveBoolean.optional(),
  members_can_create_public_repositories: PermissiveBoolean.optional(),
  members_allowed_repository_creation_type: z
    .enum(["all", "private", "none"])
    .optional(),
  members_can_create_pages: PermissiveBoolean.optional().default(true),
  members_can_create_public_pages: PermissiveBoolean.optional().default(true),
  members_can_create_private_pages: PermissiveBoolean.optional().default(true),
  members_can_fork_private_repositories:
    PermissiveBoolean.optional().default(false),
  web_commit_signoff_required: PermissiveBoolean.optional().default(false),
  blog: z.string().optional(),
  advanced_security_enabled_for_new_repositories: PermissiveBoolean.optional(),
  dependabot_alerts_enabled_for_new_repositories: PermissiveBoolean.optional(),
  dependabot_security_updates_enabled_for_new_repositories:
    PermissiveBoolean.optional(),
  dependency_graph_enabled_for_new_repositories: PermissiveBoolean.optional(),
  secret_scanning_enabled_for_new_repositories: PermissiveBoolean.optional(),
  secret_scanning_push_protection_enabled_for_new_repositories:
    PermissiveBoolean.optional(),
  secret_scanning_push_protection_custom_link_enabled:
    PermissiveBoolean.optional(),
  secret_scanning_push_protection_custom_link: z.string().optional(),
  deploy_keys_enabled_for_repositories: PermissiveBoolean.optional(),
})

export const s_ActionsCreateHostedRunnerForOrgRequestBody = z.object({
  name: z.string(),
  image: z.object({
    id: z.string().optional(),
    source: z.enum(["github", "partner", "custom"]).optional(),
  }),
  size: z.string(),
  runner_group_id: z.coerce.number(),
  maximum_runners: z.coerce.number().optional(),
  enable_static_ip: PermissiveBoolean.optional(),
})

export const s_ActionsUpdateHostedRunnerForOrgRequestBody = z.object({
  name: z.string().optional(),
  runner_group_id: z.coerce.number().optional(),
  maximum_runners: z.coerce.number().optional(),
  enable_static_ip: PermissiveBoolean.optional(),
})

export const s_ActionsSetGithubActionsPermissionsOrganizationRequestBody =
  z.object({
    enabled_repositories: s_enabled_repositories,
    allowed_actions: s_allowed_actions.optional(),
  })

export const s_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody =
  z.object({selected_repository_ids: z.array(z.coerce.number())})

export const s_ActionsCreateSelfHostedRunnerGroupForOrgRequestBody = z.object({
  name: z.string(),
  visibility: z.enum(["selected", "all", "private"]).optional().default("all"),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
  runners: z.array(z.coerce.number()).optional(),
  allows_public_repositories: PermissiveBoolean.optional().default(false),
  restricted_to_workflows: PermissiveBoolean.optional().default(false),
  selected_workflows: z.array(z.string()).optional(),
  network_configuration_id: z.string().optional(),
})

export const s_ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody = z.object({
  name: z.string(),
  visibility: z.enum(["selected", "all", "private"]).optional(),
  allows_public_repositories: PermissiveBoolean.optional().default(false),
  restricted_to_workflows: PermissiveBoolean.optional().default(false),
  selected_workflows: z.array(z.string()).optional(),
  network_configuration_id: z.string().nullable().optional(),
})

export const s_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody =
  z.object({selected_repository_ids: z.array(z.coerce.number())})

export const s_ActionsSetSelfHostedRunnersInGroupForOrgRequestBody = z.object({
  runners: z.array(z.coerce.number()),
})

export const s_ActionsGenerateRunnerJitconfigForOrgRequestBody = z.object({
  name: z.string(),
  runner_group_id: z.coerce.number(),
  labels: z.array(z.string()).min(1).max(100),
  work_folder: z.string().optional().default("_work"),
})

export const s_ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody =
  z.object({labels: z.array(z.string()).min(1).max(100)})

export const s_ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody =
  z.object({labels: z.array(z.string()).min(0).max(100)})

export const s_ActionsCreateOrUpdateOrgSecretRequestBody = z.object({
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    ),
  key_id: z.string(),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
})

export const s_ActionsSetSelectedReposForOrgSecretRequestBody = z.object({
  selected_repository_ids: z.array(z.coerce.number()),
})

export const s_ActionsCreateOrgVariableRequestBody = z.object({
  name: z.string(),
  value: z.string(),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
})

export const s_ActionsUpdateOrgVariableRequestBody = z.object({
  name: z.string().optional(),
  value: z.string().optional(),
  visibility: z.enum(["all", "private", "selected"]).optional(),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
})

export const s_ActionsSetSelectedReposForOrgVariableRequestBody = z.object({
  selected_repository_ids: z.array(z.coerce.number()),
})

export const s_OrgsListAttestationsBulkRequestBody = z.object({
  subject_digests: z.array(z.string()).min(1).max(1024),
  predicate_type: z.string().optional(),
})

export const s_OrgsDeleteAttestationsBulkRequestBody = z.union([
  z.object({subject_digests: z.array(z.string()).min(1).max(1024)}),
  z.object({attestation_ids: z.array(z.coerce.number()).min(1).max(1024)}),
])

export const s_CampaignsCreateCampaignRequestBody = z.object({
  name: z.string().min(1).max(50),
  description: z.string().min(1).max(255),
  managers: z.array(z.string()).max(10).optional(),
  team_managers: z.array(z.string()).max(10).optional(),
  ends_at: z.iso.datetime({offset: true}),
  contact_link: z.string().nullable().optional(),
  code_scanning_alerts: z
    .array(
      z.object({
        repository_id: z.coerce.number(),
        alert_numbers: z.array(z.coerce.number()).min(1),
      }),
    )
    .min(1),
  generate_issues: PermissiveBoolean.optional().default(false),
})

export const s_CampaignsUpdateCampaignRequestBody = z.object({
  name: z.string().min(1).max(50).optional(),
  description: z.string().min(1).max(255).optional(),
  managers: z.array(z.string()).max(10).optional(),
  team_managers: z.array(z.string()).max(10).optional(),
  ends_at: z.iso.datetime({offset: true}).optional(),
  contact_link: z.string().nullable().optional(),
  state: s_campaign_state.optional(),
})

export const s_CodeSecurityCreateConfigurationRequestBody = z.object({
  name: z.string(),
  description: z.string().max(255),
  advanced_security: z
    .enum(["enabled", "disabled", "code_security", "secret_protection"])
    .optional()
    .default("disabled"),
  code_security: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependency_graph: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("enabled"),
  dependency_graph_autosubmit_action: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  dependency_graph_autosubmit_action_options: z
    .object({labeled_runners: PermissiveBoolean.optional().default(false)})
    .optional(),
  dependabot_alerts: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  dependabot_security_updates: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  code_scanning_options: s_code_scanning_options.optional(),
  code_scanning_default_setup: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  code_scanning_default_setup_options:
    s_code_scanning_default_setup_options.optional(),
  code_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("not_set"),
  secret_protection: z.enum(["enabled", "disabled", "not_set"]).optional(),
  secret_scanning: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_scanning_push_protection: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_scanning_delegated_bypass: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_scanning_delegated_bypass_options: z
    .object({
      reviewers: z
        .array(
          z.object({
            reviewer_id: z.coerce.number(),
            reviewer_type: z.enum(["TEAM", "ROLE"]),
          }),
        )
        .optional(),
    })
    .optional(),
  secret_scanning_validity_checks: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_scanning_non_provider_patterns: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_scanning_generic_secrets: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  private_vulnerability_reporting: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  enforcement: z
    .enum(["enforced", "unenforced"])
    .optional()
    .default("enforced"),
})

export const s_CodeSecurityDetachConfigurationRequestBody = z.object({
  selected_repository_ids: z
    .array(z.coerce.number())
    .min(1)
    .max(1000)
    .optional(),
})

export const s_CodeSecurityUpdateConfigurationRequestBody = z.object({
  name: z.string().optional(),
  description: z.string().max(255).optional(),
  advanced_security: z
    .enum(["enabled", "disabled", "code_security", "secret_protection"])
    .optional(),
  code_security: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependency_graph: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependency_graph_autosubmit_action: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  dependency_graph_autosubmit_action_options: z
    .object({labeled_runners: PermissiveBoolean.optional()})
    .optional(),
  dependabot_alerts: z.enum(["enabled", "disabled", "not_set"]).optional(),
  dependabot_security_updates: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  code_scanning_default_setup: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  code_scanning_default_setup_options:
    s_code_scanning_default_setup_options.optional(),
  code_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional()
    .default("disabled"),
  secret_protection: z.enum(["enabled", "disabled", "not_set"]).optional(),
  secret_scanning: z.enum(["enabled", "disabled", "not_set"]).optional(),
  secret_scanning_push_protection: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_delegated_bypass: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_delegated_bypass_options: z
    .object({
      reviewers: z
        .array(
          z.object({
            reviewer_id: z.coerce.number(),
            reviewer_type: z.enum(["TEAM", "ROLE"]),
          }),
        )
        .optional(),
    })
    .optional(),
  secret_scanning_validity_checks: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_non_provider_patterns: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_generic_secrets: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  secret_scanning_delegated_alert_dismissal: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  private_vulnerability_reporting: z
    .enum(["enabled", "disabled", "not_set"])
    .optional(),
  enforcement: z.enum(["enforced", "unenforced"]).optional(),
})

export const s_CodeSecurityAttachConfigurationRequestBody = z.object({
  scope: z.enum([
    "all",
    "all_without_configurations",
    "public",
    "private_or_internal",
    "selected",
  ]),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
})

export const s_CodeSecuritySetConfigurationAsDefaultRequestBody = z.object({
  default_for_new_repos: z
    .enum(["all", "none", "private_and_internal", "public"])
    .optional(),
})

export const s_CodespacesSetCodespacesAccessRequestBody = z.object({
  visibility: z.enum([
    "disabled",
    "selected_members",
    "all_members",
    "all_members_and_outside_collaborators",
  ]),
  selected_usernames: z.array(z.string()).max(100).optional(),
})

export const s_CodespacesSetCodespacesAccessUsersRequestBody = z.object({
  selected_usernames: z.array(z.string()).max(100),
})

export const s_CodespacesDeleteCodespacesAccessUsersRequestBody = z.object({
  selected_usernames: z.array(z.string()).max(100),
})

export const s_CodespacesCreateOrUpdateOrgSecretRequestBody = z.object({
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    )
    .optional(),
  key_id: z.string().optional(),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
})

export const s_CodespacesSetSelectedReposForOrgSecretRequestBody = z.object({
  selected_repository_ids: z.array(z.coerce.number()),
})

export const s_CopilotAddCopilotSeatsForTeamsRequestBody = z.object({
  selected_teams: z.array(z.string()).min(1),
})

export const s_CopilotCancelCopilotSeatAssignmentForTeamsRequestBody = z.object(
  {selected_teams: z.array(z.string()).min(1)},
)

export const s_CopilotAddCopilotSeatsForUsersRequestBody = z.object({
  selected_usernames: z.array(z.string()).min(1),
})

export const s_CopilotCancelCopilotSeatAssignmentForUsersRequestBody = z.object(
  {selected_usernames: z.array(z.string()).min(1)},
)

export const s_DependabotCreateOrUpdateOrgSecretRequestBody = z.object({
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    )
    .optional(),
  key_id: z.string().optional(),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repository_ids: z.array(z.string()).optional(),
})

export const s_DependabotSetSelectedReposForOrgSecretRequestBody = z.object({
  selected_repository_ids: z.array(z.coerce.number()),
})

export const s_OrgsCreateWebhookRequestBody = z.object({
  name: z.string(),
  config: z.object({
    url: s_webhook_config_url,
    content_type: s_webhook_config_content_type.optional(),
    secret: s_webhook_config_secret.optional(),
    insecure_ssl: s_webhook_config_insecure_ssl.optional(),
    username: z.string().optional(),
    password: z.string().optional(),
  }),
  events: z.array(z.string()).optional().default(["push"]),
  active: PermissiveBoolean.optional().default(true),
})

export const s_OrgsUpdateWebhookRequestBody = z.object({
  config: z
    .object({
      url: s_webhook_config_url,
      content_type: s_webhook_config_content_type.optional(),
      secret: s_webhook_config_secret.optional(),
      insecure_ssl: s_webhook_config_insecure_ssl.optional(),
    })
    .optional(),
  events: z.array(z.string()).optional().default(["push"]),
  active: PermissiveBoolean.optional().default(true),
  name: z.string().optional(),
})

export const s_OrgsUpdateWebhookConfigForOrgRequestBody = z.object({
  url: s_webhook_config_url.optional(),
  content_type: s_webhook_config_content_type.optional(),
  secret: s_webhook_config_secret.optional(),
  insecure_ssl: s_webhook_config_insecure_ssl.optional(),
})

export const s_OrgsCreateInvitationRequestBody = z.object({
  invitee_id: z.coerce.number().optional(),
  email: z.string().optional(),
  role: z
    .enum(["admin", "direct_member", "billing_manager", "reinstate"])
    .optional()
    .default("direct_member"),
  team_ids: z.array(z.coerce.number()).optional(),
})

export const s_OrgsSetMembershipForUserRequestBody = z.object({
  role: z.enum(["admin", "member"]).optional().default("member"),
})

export const s_MigrationsStartForOrgRequestBody = z.object({
  repositories: z.array(z.string()),
  lock_repositories: PermissiveBoolean.optional().default(false),
  exclude_metadata: PermissiveBoolean.optional().default(false),
  exclude_git_data: PermissiveBoolean.optional().default(false),
  exclude_attachments: PermissiveBoolean.optional().default(false),
  exclude_releases: PermissiveBoolean.optional().default(false),
  exclude_owner_projects: PermissiveBoolean.optional().default(false),
  org_metadata_only: PermissiveBoolean.optional().default(false),
  exclude: z.array(z.enum(["repositories"])).optional(),
})

export const s_OrgsConvertMemberToOutsideCollaboratorRequestBody = z.object({
  async: PermissiveBoolean.optional().default(false),
})

export const s_OrgsReviewPatGrantRequestsInBulkRequestBody = z.object({
  pat_request_ids: z.array(z.coerce.number()).min(1).max(100).optional(),
  action: z.enum(["approve", "deny"]),
  reason: z.string().max(1024).nullable().optional(),
})

export const s_OrgsReviewPatGrantRequestRequestBody = z.object({
  action: z.enum(["approve", "deny"]),
  reason: z.string().max(1024).nullable().optional(),
})

export const s_OrgsUpdatePatAccessesRequestBody = z.object({
  action: z.enum(["revoke"]),
  pat_ids: z.array(z.coerce.number()).min(1).max(100),
})

export const s_OrgsUpdatePatAccessRequestBody = z.object({
  action: z.enum(["revoke"]),
})

export const s_PrivateRegistriesCreateOrgPrivateRegistryRequestBody = z.object({
  registry_type: z.enum([
    "maven_repository",
    "nuget_feed",
    "goproxy_server",
    "npm_registry",
    "rubygems_server",
    "cargo_registry",
    "composer_repository",
    "docker_registry",
    "git_source",
    "helm_registry",
    "hex_organization",
    "hex_repository",
    "pub_repository",
    "python_index",
    "terraform_registry",
  ]),
  url: z.string(),
  username: z.string().nullable().optional(),
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    ),
  key_id: z.string(),
  visibility: z.enum(["all", "private", "selected"]),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
})

export const s_PrivateRegistriesUpdateOrgPrivateRegistryRequestBody = z.object({
  registry_type: z
    .enum([
      "maven_repository",
      "nuget_feed",
      "goproxy_server",
      "npm_registry",
      "rubygems_server",
      "cargo_registry",
      "composer_repository",
      "docker_registry",
      "git_source",
      "helm_registry",
      "hex_organization",
      "hex_repository",
      "pub_repository",
      "python_index",
      "terraform_registry",
    ])
    .optional(),
  url: z.string().optional(),
  username: z.string().nullable().optional(),
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    )
    .optional(),
  key_id: z.string().optional(),
  visibility: z.enum(["all", "private", "selected"]).optional(),
  selected_repository_ids: z.array(z.coerce.number()).optional(),
})

export const s_ProjectsClassicCreateForOrgRequestBody = z.object({
  name: z.string(),
  body: z.string().optional(),
})

export const s_OrgsCreateOrUpdateCustomPropertiesRequestBody = z.object({
  properties: z.array(s_custom_property).min(1).max(100),
})

export const s_OrgsCreateOrUpdateCustomPropertiesValuesForReposRequestBody =
  z.object({
    repository_names: z.array(z.string()).min(1).max(30),
    properties: z.array(s_custom_property_value),
  })

export const s_ReposCreateInOrgRequestBody = z.object({
  name: z.string(),
  description: z.string().optional(),
  homepage: z.string().optional(),
  private: PermissiveBoolean.optional().default(false),
  visibility: z.enum(["public", "private"]).optional(),
  has_issues: PermissiveBoolean.optional().default(true),
  has_projects: PermissiveBoolean.optional().default(true),
  has_wiki: PermissiveBoolean.optional().default(true),
  has_downloads: PermissiveBoolean.optional().default(true),
  is_template: PermissiveBoolean.optional().default(false),
  team_id: z.coerce.number().optional(),
  auto_init: PermissiveBoolean.optional().default(false),
  gitignore_template: z.string().optional(),
  license_template: z.string().optional(),
  allow_squash_merge: PermissiveBoolean.optional().default(true),
  allow_merge_commit: PermissiveBoolean.optional().default(true),
  allow_rebase_merge: PermissiveBoolean.optional().default(true),
  allow_auto_merge: PermissiveBoolean.optional().default(false),
  delete_branch_on_merge: PermissiveBoolean.optional().default(false),
  use_squash_pr_title_as_default: PermissiveBoolean.optional().default(false),
  squash_merge_commit_title: z
    .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
    .optional(),
  squash_merge_commit_message: z
    .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
    .optional(),
  merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
  merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
  custom_properties: z.record(z.string(), z.unknown()).optional(),
})

export const s_ReposCreateOrgRulesetRequestBody = z.object({
  name: z.string(),
  target: z
    .enum(["branch", "tag", "push", "repository"])
    .optional()
    .default("branch"),
  enforcement: s_repository_rule_enforcement,
  bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
  conditions: s_org_ruleset_conditions.optional(),
  rules: z.array(s_org_rules).optional(),
})

export const s_ReposUpdateOrgRulesetRequestBody = z.object({
  name: z.string().optional(),
  target: z.enum(["branch", "tag", "push", "repository"]).optional(),
  enforcement: s_repository_rule_enforcement.optional(),
  bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
  conditions: s_org_ruleset_conditions.optional(),
  rules: z.array(s_org_rules).optional(),
})

export const s_HostedComputeCreateNetworkConfigurationForOrgRequestBody =
  z.object({
    name: z.string(),
    compute_service: z.enum(["none", "actions"]).optional(),
    network_settings_ids: z.array(z.string()).min(1).max(1),
  })

export const s_HostedComputeUpdateNetworkConfigurationForOrgRequestBody =
  z.object({
    name: z.string().optional(),
    compute_service: z.enum(["none", "actions"]).optional(),
    network_settings_ids: z.array(z.string()).min(0).max(1).optional(),
  })

export const s_TeamsCreateRequestBody = z.object({
  name: z.string(),
  description: z.string().optional(),
  maintainers: z.array(z.string()).optional(),
  repo_names: z.array(z.string()).optional(),
  privacy: z.enum(["secret", "closed"]).optional(),
  notification_setting: z
    .enum(["notifications_enabled", "notifications_disabled"])
    .optional(),
  permission: z.enum(["pull", "push"]).optional().default("pull"),
  parent_team_id: z.coerce.number().optional(),
})

export const s_TeamsUpdateInOrgRequestBody = z.object({
  name: z.string().optional(),
  description: z.string().optional(),
  privacy: z.enum(["secret", "closed"]).optional(),
  notification_setting: z
    .enum(["notifications_enabled", "notifications_disabled"])
    .optional(),
  permission: z.enum(["pull", "push", "admin"]).optional().default("pull"),
  parent_team_id: z.coerce.number().nullable().optional(),
})

export const s_TeamsCreateDiscussionInOrgRequestBody = z.object({
  title: z.string(),
  body: z.string(),
  private: PermissiveBoolean.optional().default(false),
})

export const s_TeamsUpdateDiscussionInOrgRequestBody = z.object({
  title: z.string().optional(),
  body: z.string().optional(),
})

export const s_TeamsCreateDiscussionCommentInOrgRequestBody = z.object({
  body: z.string(),
})

export const s_TeamsUpdateDiscussionCommentInOrgRequestBody = z.object({
  body: z.string(),
})

export const s_ReactionsCreateForTeamDiscussionCommentInOrgRequestBody =
  z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

export const s_ReactionsCreateForTeamDiscussionInOrgRequestBody = z.object({
  content: z.enum([
    "+1",
    "-1",
    "laugh",
    "confused",
    "heart",
    "hooray",
    "rocket",
    "eyes",
  ]),
})

export const s_TeamsAddOrUpdateMembershipForUserInOrgRequestBody = z.object({
  role: z.enum(["member", "maintainer"]).optional().default("member"),
})

export const s_TeamsAddOrUpdateProjectPermissionsInOrgRequestBody = z
  .object({permission: z.enum(["read", "write", "admin"]).optional()})
  .nullable()

export const s_TeamsAddOrUpdateRepoPermissionsInOrgRequestBody = z.object({
  permission: z.string().optional(),
})

export const s_OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestBody =
  z.object({query_suite: z.enum(["default", "extended"]).optional()})

export const s_ProjectsClassicUpdateCardRequestBody = z.object({
  note: z.string().nullable().optional(),
  archived: PermissiveBoolean.optional(),
})

export const s_ProjectsClassicMoveCardRequestBody = z.object({
  position: z.string().regex(new RegExp("^(?:top|bottom|after:\\d+)$")),
  column_id: z.coerce.number().optional(),
})

export const s_ProjectsClassicUpdateColumnRequestBody = z.object({
  name: z.string(),
})

export const s_ProjectsClassicCreateCardRequestBody = z.union([
  z.object({note: z.string().nullable()}),
  z.object({content_id: z.coerce.number(), content_type: z.string()}),
])

export const s_ProjectsClassicMoveColumnRequestBody = z.object({
  position: z.string().regex(new RegExp("^(?:first|last|after:\\d+)$")),
})

export const s_ProjectsClassicUpdateRequestBody = z.object({
  name: z.string().optional(),
  body: z.string().nullable().optional(),
  state: z.string().optional(),
  organization_permission: z
    .enum(["read", "write", "admin", "none"])
    .optional(),
  private: PermissiveBoolean.optional(),
})

export const s_ProjectsClassicAddCollaboratorRequestBody = z
  .object({
    permission: z.enum(["read", "write", "admin"]).optional().default("write"),
  })
  .nullable()

export const s_ProjectsClassicCreateColumnRequestBody = z.object({
  name: z.string(),
})

export const s_ReposUpdateRequestBody = z.object({
  name: z.string().optional(),
  description: z.string().optional(),
  homepage: z.string().optional(),
  private: PermissiveBoolean.optional().default(false),
  visibility: z.enum(["public", "private"]).optional(),
  security_and_analysis: z
    .object({
      advanced_security: z.object({status: z.string().optional()}).optional(),
      code_security: z.object({status: z.string().optional()}).optional(),
      secret_scanning: z.object({status: z.string().optional()}).optional(),
      secret_scanning_push_protection: z
        .object({status: z.string().optional()})
        .optional(),
      secret_scanning_ai_detection: z
        .object({status: z.string().optional()})
        .optional(),
      secret_scanning_non_provider_patterns: z
        .object({status: z.string().optional()})
        .optional(),
    })
    .nullable()
    .optional(),
  has_issues: PermissiveBoolean.optional().default(true),
  has_projects: PermissiveBoolean.optional().default(true),
  has_wiki: PermissiveBoolean.optional().default(true),
  is_template: PermissiveBoolean.optional().default(false),
  default_branch: z.string().optional(),
  allow_squash_merge: PermissiveBoolean.optional().default(true),
  allow_merge_commit: PermissiveBoolean.optional().default(true),
  allow_rebase_merge: PermissiveBoolean.optional().default(true),
  allow_auto_merge: PermissiveBoolean.optional().default(false),
  delete_branch_on_merge: PermissiveBoolean.optional().default(false),
  allow_update_branch: PermissiveBoolean.optional().default(false),
  use_squash_pr_title_as_default: PermissiveBoolean.optional().default(false),
  squash_merge_commit_title: z
    .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
    .optional(),
  squash_merge_commit_message: z
    .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
    .optional(),
  merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
  merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
  archived: PermissiveBoolean.optional().default(false),
  allow_forking: PermissiveBoolean.optional().default(false),
  web_commit_signoff_required: PermissiveBoolean.optional().default(false),
})

export const s_ActionsReRunJobForWorkflowRunRequestBody = z
  .object({enable_debug_logging: PermissiveBoolean.optional().default(false)})
  .nullable()

export const s_ActionsSetCustomOidcSubClaimForRepoRequestBody = z.object({
  use_default: PermissiveBoolean,
  include_claim_keys: z.array(z.string()).optional(),
})

export const s_ActionsSetGithubActionsPermissionsRepositoryRequestBody =
  z.object({
    enabled: s_actions_enabled,
    allowed_actions: s_allowed_actions.optional(),
  })

export const s_ActionsGenerateRunnerJitconfigForRepoRequestBody = z.object({
  name: z.string(),
  runner_group_id: z.coerce.number(),
  labels: z.array(z.string()).min(1).max(100),
  work_folder: z.string().optional().default("_work"),
})

export const s_ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody =
  z.object({labels: z.array(z.string()).min(1).max(100)})

export const s_ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody =
  z.object({labels: z.array(z.string()).min(0).max(100)})

export const s_ActionsReviewCustomGatesForRunRequestBody = z.union([
  s_review_custom_gates_comment_required,
  s_review_custom_gates_state_required,
])

export const s_ActionsReviewPendingDeploymentsForRunRequestBody = z.object({
  environment_ids: z.array(z.coerce.number()),
  state: z.enum(["approved", "rejected"]),
  comment: z.string(),
})

export const s_ActionsReRunWorkflowRequestBody = z
  .object({enable_debug_logging: PermissiveBoolean.optional().default(false)})
  .nullable()

export const s_ActionsReRunWorkflowFailedJobsRequestBody = z
  .object({enable_debug_logging: PermissiveBoolean.optional().default(false)})
  .nullable()

export const s_ActionsCreateOrUpdateRepoSecretRequestBody = z.object({
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    ),
  key_id: z.string(),
})

export const s_ActionsCreateRepoVariableRequestBody = z.object({
  name: z.string(),
  value: z.string(),
})

export const s_ActionsUpdateRepoVariableRequestBody = z.object({
  name: z.string().optional(),
  value: z.string().optional(),
})

export const s_ActionsCreateWorkflowDispatchRequestBody = z.object({
  ref: z.string(),
  inputs: z.record(z.string(), z.unknown()).optional(),
})

export const s_ReposCreateAttestationRequestBody = z.object({
  bundle: z.object({
    mediaType: z.string().optional(),
    verificationMaterial: z.record(z.string(), z.unknown()).optional(),
    dsseEnvelope: z.record(z.string(), z.unknown()).optional(),
  }),
})

export const s_ReposCreateAutolinkRequestBody = z.object({
  key_prefix: z.string(),
  url_template: z.string(),
  is_alphanumeric: PermissiveBoolean.optional().default(true),
})

export const s_ReposUpdateBranchProtectionRequestBody = z.object({
  required_status_checks: z
    .object({
      strict: PermissiveBoolean,
      contexts: z.array(z.string()),
      checks: z
        .array(
          z.object({context: z.string(), app_id: z.coerce.number().optional()}),
        )
        .optional(),
    })
    .nullable(),
  enforce_admins: PermissiveBoolean.nullable(),
  required_pull_request_reviews: z
    .object({
      dismissal_restrictions: z
        .object({
          users: z.array(z.string()).optional(),
          teams: z.array(z.string()).optional(),
          apps: z.array(z.string()).optional(),
        })
        .optional(),
      dismiss_stale_reviews: PermissiveBoolean.optional(),
      require_code_owner_reviews: PermissiveBoolean.optional(),
      required_approving_review_count: z.coerce.number().optional(),
      require_last_push_approval: PermissiveBoolean.optional().default(false),
      bypass_pull_request_allowances: z
        .object({
          users: z.array(z.string()).optional(),
          teams: z.array(z.string()).optional(),
          apps: z.array(z.string()).optional(),
        })
        .optional(),
    })
    .nullable(),
  restrictions: z
    .object({
      users: z.array(z.string()),
      teams: z.array(z.string()),
      apps: z.array(z.string()).optional(),
    })
    .nullable(),
  required_linear_history: PermissiveBoolean.optional(),
  allow_force_pushes: PermissiveBoolean.nullable().optional(),
  allow_deletions: PermissiveBoolean.optional(),
  block_creations: PermissiveBoolean.optional(),
  required_conversation_resolution: PermissiveBoolean.optional(),
  lock_branch: PermissiveBoolean.optional().default(false),
  allow_fork_syncing: PermissiveBoolean.optional().default(false),
})

export const s_ReposUpdatePullRequestReviewProtectionRequestBody = z.object({
  dismissal_restrictions: z
    .object({
      users: z.array(z.string()).optional(),
      teams: z.array(z.string()).optional(),
      apps: z.array(z.string()).optional(),
    })
    .optional(),
  dismiss_stale_reviews: PermissiveBoolean.optional(),
  require_code_owner_reviews: PermissiveBoolean.optional(),
  required_approving_review_count: z.coerce.number().optional(),
  require_last_push_approval: PermissiveBoolean.optional().default(false),
  bypass_pull_request_allowances: z
    .object({
      users: z.array(z.string()).optional(),
      teams: z.array(z.string()).optional(),
      apps: z.array(z.string()).optional(),
    })
    .optional(),
})

export const s_ReposUpdateStatusCheckProtectionRequestBody = z.object({
  strict: PermissiveBoolean.optional(),
  contexts: z.array(z.string()).optional(),
  checks: z
    .array(
      z.object({context: z.string(), app_id: z.coerce.number().optional()}),
    )
    .optional(),
})

export const s_ReposAddStatusCheckContextsRequestBody = z.union([
  z.object({contexts: z.array(z.string())}),
  z.array(z.string()),
])

export const s_ReposSetStatusCheckContextsRequestBody = z.union([
  z.object({contexts: z.array(z.string())}),
  z.array(z.string()),
])

export const s_ReposRemoveStatusCheckContextsRequestBody = z.union([
  z.object({contexts: z.array(z.string())}),
  z.array(z.string()),
])

export const s_ReposAddAppAccessRestrictionsRequestBody = z.object({
  apps: z.array(z.string()),
})

export const s_ReposSetAppAccessRestrictionsRequestBody = z.object({
  apps: z.array(z.string()),
})

export const s_ReposRemoveAppAccessRestrictionsRequestBody = z.object({
  apps: z.array(z.string()),
})

export const s_ReposAddTeamAccessRestrictionsRequestBody = z.union([
  z.object({teams: z.array(z.string())}),
  z.array(z.string()),
])

export const s_ReposSetTeamAccessRestrictionsRequestBody = z.union([
  z.object({teams: z.array(z.string())}),
  z.array(z.string()),
])

export const s_ReposRemoveTeamAccessRestrictionsRequestBody = z.union([
  z.object({teams: z.array(z.string())}),
  z.array(z.string()),
])

export const s_ReposAddUserAccessRestrictionsRequestBody = z.object({
  users: z.array(z.string()),
})

export const s_ReposSetUserAccessRestrictionsRequestBody = z.object({
  users: z.array(z.string()),
})

export const s_ReposRemoveUserAccessRestrictionsRequestBody = z.object({
  users: z.array(z.string()),
})

export const s_ReposRenameBranchRequestBody = z.object({new_name: z.string()})

export const s_ChecksCreateRequestBody = z.union([
  z.intersection(
    z.object({status: z.enum(["completed"])}),
    z.record(z.string(), z.unknown()),
  ),
  z.intersection(
    z.object({status: z.enum(["queued", "in_progress"]).optional()}),
    z.record(z.string(), z.unknown()),
  ),
])

export const s_ChecksUpdateRequestBody = z.object({
  name: z.string().optional(),
  details_url: z.string().optional(),
  external_id: z.string().optional(),
  started_at: z.iso.datetime({offset: true}).optional(),
  status: z
    .enum([
      "queued",
      "in_progress",
      "completed",
      "waiting",
      "requested",
      "pending",
    ])
    .optional(),
  conclusion: z
    .enum([
      "action_required",
      "cancelled",
      "failure",
      "neutral",
      "success",
      "skipped",
      "stale",
      "timed_out",
    ])
    .optional(),
  completed_at: z.iso.datetime({offset: true}).optional(),
  output: z
    .object({
      title: z.string().optional(),
      summary: z.string().max(65535),
      text: z.string().max(65535).optional(),
      annotations: z
        .array(
          z.object({
            path: z.string(),
            start_line: z.coerce.number(),
            end_line: z.coerce.number(),
            start_column: z.coerce.number().optional(),
            end_column: z.coerce.number().optional(),
            annotation_level: z.enum(["notice", "warning", "failure"]),
            message: z.string(),
            title: z.string().optional(),
            raw_details: z.string().optional(),
          }),
        )
        .max(50)
        .optional(),
      images: z
        .array(
          z.object({
            alt: z.string(),
            image_url: z.string(),
            caption: z.string().optional(),
          }),
        )
        .optional(),
    })
    .optional(),
  actions: z
    .array(
      z.object({
        label: z.string().max(20),
        description: z.string().max(40),
        identifier: z.string().max(20),
      }),
    )
    .max(3)
    .optional(),
})

export const s_ChecksCreateSuiteRequestBody = z.object({head_sha: z.string()})

export const s_ChecksSetSuitesPreferencesRequestBody = z.object({
  auto_trigger_checks: z
    .array(
      z.object({
        app_id: z.coerce.number(),
        setting: PermissiveBoolean.default(true),
      }),
    )
    .optional(),
})

export const s_CodeScanningUpdateAlertRequestBody = z.object({
  state: s_code_scanning_alert_set_state,
  dismissed_reason: s_code_scanning_alert_dismissed_reason.optional(),
  dismissed_comment: s_code_scanning_alert_dismissed_comment.optional(),
  create_request: s_code_scanning_alert_create_request.optional(),
})

export const s_CodeScanningCreateVariantAnalysisRequestBody = z.union([
  z.record(z.string(), z.unknown()),
  z.record(z.string(), z.unknown()),
  z.record(z.string(), z.unknown()),
])

export const s_CodeScanningUploadSarifRequestBody = z.object({
  commit_sha: s_code_scanning_analysis_commit_sha,
  ref: s_code_scanning_ref_full,
  sarif: s_code_scanning_analysis_sarif_file,
  checkout_uri: z.string().optional(),
  started_at: z.iso.datetime({offset: true}).optional(),
  tool_name: z.string().optional(),
  validate: PermissiveBoolean.optional(),
})

export const s_CodespacesCreateWithRepoForAuthenticatedUserRequestBody = z
  .object({
    ref: z.string().optional(),
    location: z.string().optional(),
    geo: z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).optional(),
    client_ip: z.string().optional(),
    machine: z.string().optional(),
    devcontainer_path: z.string().optional(),
    multi_repo_permissions_opt_out: PermissiveBoolean.optional(),
    working_directory: z.string().optional(),
    idle_timeout_minutes: z.coerce.number().optional(),
    display_name: z.string().optional(),
    retention_period_minutes: z.coerce.number().optional(),
  })
  .nullable()

export const s_CodespacesCreateOrUpdateRepoSecretRequestBody = z.object({
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    )
    .optional(),
  key_id: z.string().optional(),
})

export const s_ReposAddCollaboratorRequestBody = z.object({
  permission: z.string().optional().default("push"),
})

export const s_ReposUpdateCommitCommentRequestBody = z.object({
  body: z.string(),
})

export const s_ReactionsCreateForCommitCommentRequestBody = z.object({
  content: z.enum([
    "+1",
    "-1",
    "laugh",
    "confused",
    "heart",
    "hooray",
    "rocket",
    "eyes",
  ]),
})

export const s_ReposCreateCommitCommentRequestBody = z.object({
  body: z.string(),
  path: z.string().optional(),
  position: z.coerce.number().optional(),
  line: z.coerce.number().optional(),
})

export const s_ReposCreateOrUpdateFileContentsRequestBody = z.object({
  message: z.string(),
  content: z.string(),
  sha: z.string().optional(),
  branch: z.string().optional(),
  committer: z
    .object({name: z.string(), email: z.string(), date: z.string().optional()})
    .optional(),
  author: z
    .object({name: z.string(), email: z.string(), date: z.string().optional()})
    .optional(),
})

export const s_ReposDeleteFileRequestBody = z.object({
  message: z.string(),
  sha: z.string(),
  branch: z.string().optional(),
  committer: z
    .object({name: z.string().optional(), email: z.string().optional()})
    .optional(),
  author: z
    .object({name: z.string().optional(), email: z.string().optional()})
    .optional(),
})

export const s_DependabotUpdateAlertRequestBody = z.object({
  state: z.enum(["dismissed", "open"]),
  dismissed_reason: z
    .enum([
      "fix_started",
      "inaccurate",
      "no_bandwidth",
      "not_used",
      "tolerable_risk",
    ])
    .optional(),
  dismissed_comment: z.string().max(280).optional(),
})

export const s_DependabotCreateOrUpdateRepoSecretRequestBody = z.object({
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    )
    .optional(),
  key_id: z.string().optional(),
})

export const s_ReposCreateDeploymentRequestBody = z.object({
  ref: z.string(),
  task: z.string().optional().default("deploy"),
  auto_merge: PermissiveBoolean.optional().default(true),
  required_contexts: z.array(z.string()).optional(),
  payload: z
    .union([z.record(z.string(), z.unknown()), z.string().default("")])
    .optional(),
  environment: z.string().optional().default("production"),
  description: z.string().nullable().optional().default(""),
  transient_environment: PermissiveBoolean.optional().default(false),
  production_environment: PermissiveBoolean.optional(),
})

export const s_ReposCreateDeploymentStatusRequestBody = z.object({
  state: z.enum([
    "error",
    "failure",
    "inactive",
    "in_progress",
    "queued",
    "pending",
    "success",
  ]),
  target_url: z.string().optional().default(""),
  log_url: z.string().optional().default(""),
  description: z.string().optional().default(""),
  environment: z.string().optional(),
  environment_url: z.string().optional().default(""),
  auto_inactive: PermissiveBoolean.optional(),
})

export const s_ReposCreateDispatchEventRequestBody = z.object({
  event_type: z.string().min(1).max(100),
  client_payload: z.record(z.string(), z.unknown()).optional(),
})

export const s_ReposCreateOrUpdateEnvironmentRequestBody = z
  .object({
    wait_timer: s_wait_timer.optional(),
    prevent_self_review: s_prevent_self_review.optional(),
    reviewers: z
      .array(
        z.object({
          type: s_deployment_reviewer_type.optional(),
          id: z.coerce.number().optional(),
        }),
      )
      .nullable()
      .optional(),
    deployment_branch_policy: s_deployment_branch_policy_settings.optional(),
  })
  .nullable()

export const s_ReposCreateDeploymentProtectionRuleRequestBody = z.object({
  integration_id: z.coerce.number().optional(),
})

export const s_ActionsCreateOrUpdateEnvironmentSecretRequestBody = z.object({
  encrypted_value: z
    .string()
    .regex(
      new RegExp(
        "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
      ),
    ),
  key_id: z.string(),
})

export const s_ActionsCreateEnvironmentVariableRequestBody = z.object({
  name: z.string(),
  value: z.string(),
})

export const s_ActionsUpdateEnvironmentVariableRequestBody = z.object({
  name: z.string().optional(),
  value: z.string().optional(),
})

export const s_ReposCreateForkRequestBody = z
  .object({
    organization: z.string().optional(),
    name: z.string().optional(),
    default_branch_only: PermissiveBoolean.optional(),
  })
  .nullable()

export const s_GitCreateBlobRequestBody = z.object({
  content: z.string(),
  encoding: z.string().optional().default("utf-8"),
})

export const s_GitCreateCommitRequestBody = z.object({
  message: z.string(),
  tree: z.string(),
  parents: z.array(z.string()).optional(),
  author: z
    .object({
      name: z.string(),
      email: z.string(),
      date: z.iso.datetime({offset: true}).optional(),
    })
    .optional(),
  committer: z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      date: z.iso.datetime({offset: true}).optional(),
    })
    .optional(),
  signature: z.string().optional(),
})

export const s_GitCreateRefRequestBody = z.object({
  ref: z.string(),
  sha: z.string(),
})

export const s_GitUpdateRefRequestBody = z.object({
  sha: z.string(),
  force: PermissiveBoolean.optional().default(false),
})

export const s_GitCreateTagRequestBody = z.object({
  tag: z.string(),
  message: z.string(),
  object: z.string(),
  type: z.enum(["commit", "tree", "blob"]),
  tagger: z
    .object({
      name: z.string(),
      email: z.string(),
      date: z.iso.datetime({offset: true}).optional(),
    })
    .optional(),
})

export const s_GitCreateTreeRequestBody = z.object({
  tree: z.array(
    z.object({
      path: z.string().optional(),
      mode: z
        .enum(["100644", "100755", "040000", "160000", "120000"])
        .optional(),
      type: z.enum(["blob", "tree", "commit"]).optional(),
      sha: z.string().nullable().optional(),
      content: z.string().optional(),
    }),
  ),
  base_tree: z.string().optional(),
})

export const s_ReposCreateWebhookRequestBody = z
  .object({
    name: z.string().optional(),
    config: z
      .object({
        url: s_webhook_config_url.optional(),
        content_type: s_webhook_config_content_type.optional(),
        secret: s_webhook_config_secret.optional(),
        insecure_ssl: s_webhook_config_insecure_ssl.optional(),
      })
      .optional(),
    events: z.array(z.string()).optional().default(["push"]),
    active: PermissiveBoolean.optional().default(true),
  })
  .nullable()

export const s_ReposUpdateWebhookRequestBody = z.object({
  config: s_webhook_config.optional(),
  events: z.array(z.string()).optional().default(["push"]),
  add_events: z.array(z.string()).optional(),
  remove_events: z.array(z.string()).optional(),
  active: PermissiveBoolean.optional().default(true),
})

export const s_ReposUpdateWebhookConfigForRepoRequestBody = z.object({
  url: s_webhook_config_url.optional(),
  content_type: s_webhook_config_content_type.optional(),
  secret: s_webhook_config_secret.optional(),
  insecure_ssl: s_webhook_config_insecure_ssl.optional(),
})

export const s_MigrationsStartImportRequestBody = z.object({
  vcs_url: z.string(),
  vcs: z.enum(["subversion", "git", "mercurial", "tfvc"]).optional(),
  vcs_username: z.string().optional(),
  vcs_password: z.string().optional(),
  tfvc_project: z.string().optional(),
})

export const s_MigrationsUpdateImportRequestBody = z
  .object({
    vcs_username: z.string().optional(),
    vcs_password: z.string().optional(),
    vcs: z.enum(["subversion", "tfvc", "git", "mercurial"]).optional(),
    tfvc_project: z.string().optional(),
  })
  .nullable()

export const s_MigrationsMapCommitAuthorRequestBody = z.object({
  email: z.string().optional(),
  name: z.string().optional(),
})

export const s_MigrationsSetLfsPreferenceRequestBody = z.object({
  use_lfs: z.enum(["opt_in", "opt_out"]),
})

export const s_ReposUpdateInvitationRequestBody = z.object({
  permissions: z
    .enum(["read", "write", "maintain", "triage", "admin"])
    .optional(),
})

export const s_IssuesCreateRequestBody = z.object({
  title: z.union([z.string(), z.coerce.number()]),
  body: z.string().optional(),
  assignee: z.string().nullable().optional(),
  milestone: z.union([z.string(), z.coerce.number()]).nullable().optional(),
  labels: z
    .array(
      z.union([
        z.string(),
        z.object({
          id: z.coerce.number().optional(),
          name: z.string().optional(),
          description: z.string().nullable().optional(),
          color: z.string().nullable().optional(),
        }),
      ]),
    )
    .optional(),
  assignees: z.array(z.string()).optional(),
  type: z.string().nullable().optional(),
})

export const s_IssuesUpdateCommentRequestBody = z.object({body: z.string()})

export const s_ReactionsCreateForIssueCommentRequestBody = z.object({
  content: z.enum([
    "+1",
    "-1",
    "laugh",
    "confused",
    "heart",
    "hooray",
    "rocket",
    "eyes",
  ]),
})

export const s_IssuesUpdateRequestBody = z.object({
  title: z.union([z.string(), z.coerce.number()]).nullable().optional(),
  body: z.string().nullable().optional(),
  assignee: z.string().nullable().optional(),
  state: z.enum(["open", "closed"]).optional(),
  state_reason: z
    .enum(["completed", "not_planned", "duplicate", "reopened"])
    .nullable()
    .optional(),
  milestone: z.union([z.string(), z.coerce.number()]).nullable().optional(),
  labels: z
    .array(
      z.union([
        z.string(),
        z.object({
          id: z.coerce.number().optional(),
          name: z.string().optional(),
          description: z.string().nullable().optional(),
          color: z.string().nullable().optional(),
        }),
      ]),
    )
    .optional(),
  assignees: z.array(z.string()).optional(),
  type: z.string().nullable().optional(),
})

export const s_IssuesAddAssigneesRequestBody = z.object({
  assignees: z.array(z.string()).optional(),
})

export const s_IssuesRemoveAssigneesRequestBody = z.object({
  assignees: z.array(z.string()).optional(),
})

export const s_IssuesCreateCommentRequestBody = z.object({body: z.string()})

export const s_IssuesAddLabelsRequestBody = z.union([
  z.object({labels: z.array(z.string()).min(1).optional()}),
  z.array(z.string()).min(1),
  z.object({
    labels: z
      .array(z.object({name: z.string()}))
      .min(1)
      .optional(),
  }),
  z.array(z.object({name: z.string()})).min(1),
  z.string(),
])

export const s_IssuesSetLabelsRequestBody = z.union([
  z.object({labels: z.array(z.string()).min(1).optional()}),
  z.array(z.string()).min(1),
  z.object({
    labels: z
      .array(z.object({name: z.string()}))
      .min(1)
      .optional(),
  }),
  z.array(z.object({name: z.string()})).min(1),
  z.string(),
])

export const s_IssuesLockRequestBody = z
  .object({
    lock_reason: z
      .enum(["off-topic", "too heated", "resolved", "spam"])
      .optional(),
  })
  .nullable()

export const s_ReactionsCreateForIssueRequestBody = z.object({
  content: z.enum([
    "+1",
    "-1",
    "laugh",
    "confused",
    "heart",
    "hooray",
    "rocket",
    "eyes",
  ]),
})

export const s_IssuesRemoveSubIssueRequestBody = z.object({
  sub_issue_id: z.coerce.number(),
})

export const s_IssuesAddSubIssueRequestBody = z.object({
  sub_issue_id: z.coerce.number(),
  replace_parent: PermissiveBoolean.optional(),
})

export const s_IssuesReprioritizeSubIssueRequestBody = z.object({
  sub_issue_id: z.coerce.number(),
  after_id: z.coerce.number().optional(),
  before_id: z.coerce.number().optional(),
})

export const s_ReposCreateDeployKeyRequestBody = z.object({
  title: z.string().optional(),
  key: z.string(),
  read_only: PermissiveBoolean.optional(),
})

export const s_IssuesCreateLabelRequestBody = z.object({
  name: z.string(),
  color: z.string().optional(),
  description: z.string().optional(),
})

export const s_IssuesUpdateLabelRequestBody = z.object({
  new_name: z.string().optional(),
  color: z.string().optional(),
  description: z.string().optional(),
})

export const s_ReposMergeUpstreamRequestBody = z.object({branch: z.string()})

export const s_ReposMergeRequestBody = z.object({
  base: z.string(),
  head: z.string(),
  commit_message: z.string().optional(),
})

export const s_IssuesCreateMilestoneRequestBody = z.object({
  title: z.string(),
  state: z.enum(["open", "closed"]).optional().default("open"),
  description: z.string().optional(),
  due_on: z.iso.datetime({offset: true}).optional(),
})

export const s_IssuesUpdateMilestoneRequestBody = z.object({
  title: z.string().optional(),
  state: z.enum(["open", "closed"]).optional().default("open"),
  description: z.string().optional(),
  due_on: z.iso.datetime({offset: true}).optional(),
})

export const s_ActivityMarkRepoNotificationsAsReadRequestBody = z.object({
  last_read_at: z.iso.datetime({offset: true}).optional(),
})

export const s_ReposCreatePagesSiteRequestBody = z
  .object({
    build_type: z.enum(["legacy", "workflow"]).optional(),
    source: z
      .object({
        branch: z.string(),
        path: z.enum(["/", "/docs"]).optional().default("/"),
      })
      .optional(),
  })
  .nullable()

export const s_ReposUpdateInformationAboutPagesSiteRequestBody = z.object({
  cname: z.string().nullable().optional(),
  https_enforced: PermissiveBoolean.optional(),
  build_type: z.enum(["legacy", "workflow"]).optional(),
  source: z
    .union([
      z.enum(["gh-pages", "master", "master /docs"]),
      z.object({branch: z.string(), path: z.enum(["/", "/docs"])}),
    ])
    .optional(),
})

export const s_ReposCreatePagesDeploymentRequestBody = z.object({
  artifact_id: z.coerce.number().optional(),
  artifact_url: z.string().optional(),
  environment: z.string().optional().default("github-pages"),
  pages_build_version: z.string().default("GITHUB_SHA"),
  oidc_token: z.string(),
})

export const s_ProjectsClassicCreateForRepoRequestBody = z.object({
  name: z.string(),
  body: z.string().optional(),
})

export const s_ReposCreateOrUpdateCustomPropertiesValuesRequestBody = z.object({
  properties: z.array(s_custom_property_value),
})

export const s_PullsCreateRequestBody = z.object({
  title: z.string().optional(),
  head: z.string(),
  head_repo: z.string().optional(),
  base: z.string(),
  body: z.string().optional(),
  maintainer_can_modify: PermissiveBoolean.optional(),
  draft: PermissiveBoolean.optional(),
  issue: z.coerce.number().optional(),
})

export const s_PullsUpdateReviewCommentRequestBody = z.object({
  body: z.string(),
})

export const s_ReactionsCreateForPullRequestReviewCommentRequestBody = z.object(
  {
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  },
)

export const s_PullsUpdateRequestBody = z.object({
  title: z.string().optional(),
  body: z.string().optional(),
  state: z.enum(["open", "closed"]).optional(),
  base: z.string().optional(),
  maintainer_can_modify: PermissiveBoolean.optional(),
})

export const s_CodespacesCreateWithPrForAuthenticatedUserRequestBody = z
  .object({
    location: z.string().optional(),
    geo: z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).optional(),
    client_ip: z.string().optional(),
    machine: z.string().optional(),
    devcontainer_path: z.string().optional(),
    multi_repo_permissions_opt_out: PermissiveBoolean.optional(),
    working_directory: z.string().optional(),
    idle_timeout_minutes: z.coerce.number().optional(),
    display_name: z.string().optional(),
    retention_period_minutes: z.coerce.number().optional(),
  })
  .nullable()

export const s_PullsCreateReviewCommentRequestBody = z.object({
  body: z.string(),
  commit_id: z.string(),
  path: z.string(),
  position: z.coerce.number().optional(),
  side: z.enum(["LEFT", "RIGHT"]).optional(),
  line: z.coerce.number().optional(),
  start_line: z.coerce.number().optional(),
  start_side: z.enum(["LEFT", "RIGHT", "side"]).optional(),
  in_reply_to: z.coerce.number().optional(),
  subject_type: z.enum(["line", "file"]).optional(),
})

export const s_PullsCreateReplyForReviewCommentRequestBody = z.object({
  body: z.string(),
})

export const s_PullsMergeRequestBody = z
  .object({
    commit_title: z.string().optional(),
    commit_message: z.string().optional(),
    sha: z.string().optional(),
    merge_method: z.enum(["merge", "squash", "rebase"]).optional(),
  })
  .nullable()

export const s_PullsRequestReviewersRequestBody = z.object({
  reviewers: z.array(z.string()).optional(),
  team_reviewers: z.array(z.string()).optional(),
})

export const s_PullsRemoveRequestedReviewersRequestBody = z.object({
  reviewers: z.array(z.string()),
  team_reviewers: z.array(z.string()).optional(),
})

export const s_PullsCreateReviewRequestBody = z.object({
  commit_id: z.string().optional(),
  body: z.string().optional(),
  event: z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]).optional(),
  comments: z
    .array(
      z.object({
        path: z.string(),
        position: z.coerce.number().optional(),
        body: z.string(),
        line: z.coerce.number().optional(),
        side: z.string().optional(),
        start_line: z.coerce.number().optional(),
        start_side: z.string().optional(),
      }),
    )
    .optional(),
})

export const s_PullsUpdateReviewRequestBody = z.object({body: z.string()})

export const s_PullsDismissReviewRequestBody = z.object({
  message: z.string(),
  event: z.enum(["DISMISS"]).optional(),
})

export const s_PullsSubmitReviewRequestBody = z.object({
  body: z.string().optional(),
  event: z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]),
})

export const s_PullsUpdateBranchRequestBody = z
  .object({expected_head_sha: z.string().optional()})
  .nullable()

export const s_ReposCreateReleaseRequestBody = z.object({
  tag_name: z.string(),
  target_commitish: z.string().optional(),
  name: z.string().optional(),
  body: z.string().optional(),
  draft: PermissiveBoolean.optional().default(false),
  prerelease: PermissiveBoolean.optional().default(false),
  discussion_category_name: z.string().optional(),
  generate_release_notes: PermissiveBoolean.optional().default(false),
  make_latest: z.enum(["true", "false", "legacy"]).optional().default("true"),
})

export const s_ReposUpdateReleaseAssetRequestBody = z.object({
  name: z.string().optional(),
  label: z.string().optional(),
  state: z.string().optional(),
})

export const s_ReposGenerateReleaseNotesRequestBody = z.object({
  tag_name: z.string(),
  target_commitish: z.string().optional(),
  previous_tag_name: z.string().optional(),
  configuration_file_path: z.string().optional(),
})

export const s_ReposUpdateReleaseRequestBody = z.object({
  tag_name: z.string().optional(),
  target_commitish: z.string().optional(),
  name: z.string().optional(),
  body: z.string().optional(),
  draft: PermissiveBoolean.optional(),
  prerelease: PermissiveBoolean.optional(),
  make_latest: z.enum(["true", "false", "legacy"]).optional().default("true"),
  discussion_category_name: z.string().optional(),
})

export const s_ReactionsCreateForReleaseRequestBody = z.object({
  content: z.enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"]),
})

export const s_ReposCreateRepoRulesetRequestBody = z.object({
  name: z.string(),
  target: z.enum(["branch", "tag", "push"]).optional().default("branch"),
  enforcement: s_repository_rule_enforcement,
  bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
  conditions: s_repository_ruleset_conditions.optional(),
  rules: z.array(s_repository_rule).optional(),
})

export const s_ReposUpdateRepoRulesetRequestBody = z.object({
  name: z.string().optional(),
  target: z.enum(["branch", "tag", "push"]).optional(),
  enforcement: s_repository_rule_enforcement.optional(),
  bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
  conditions: s_repository_ruleset_conditions.optional(),
  rules: z.array(s_repository_rule).optional(),
})

export const s_SecretScanningUpdateAlertRequestBody = z.object({
  state: s_secret_scanning_alert_state,
  resolution: s_secret_scanning_alert_resolution.optional(),
  resolution_comment: s_secret_scanning_alert_resolution_comment.optional(),
})

export const s_SecretScanningCreatePushProtectionBypassRequestBody = z.object({
  reason: s_secret_scanning_push_protection_bypass_reason,
  placeholder_id: s_secret_scanning_push_protection_bypass_placeholder_id,
})

export const s_ReposCreateCommitStatusRequestBody = z.object({
  state: z.enum(["error", "failure", "pending", "success"]),
  target_url: z.string().nullable().optional(),
  description: z.string().nullable().optional(),
  context: z.string().optional().default("default"),
})

export const s_ActivitySetRepoSubscriptionRequestBody = z.object({
  subscribed: PermissiveBoolean.optional(),
  ignored: PermissiveBoolean.optional(),
})

export const s_ReposCreateTagProtectionRequestBody = z.object({
  pattern: z.string(),
})

export const s_ReposReplaceAllTopicsRequestBody = z.object({
  names: z.array(z.string()),
})

export const s_ReposTransferRequestBody = z.object({
  new_owner: z.string(),
  new_name: z.string().optional(),
  team_ids: z.array(z.coerce.number()).optional(),
})

export const s_ReposCreateUsingTemplateRequestBody = z.object({
  owner: z.string().optional(),
  name: z.string(),
  description: z.string().optional(),
  include_all_branches: PermissiveBoolean.optional().default(false),
  private: PermissiveBoolean.optional().default(false),
})

export const s_TeamsUpdateLegacyRequestBody = z.object({
  name: z.string(),
  description: z.string().optional(),
  privacy: z.enum(["secret", "closed"]).optional(),
  notification_setting: z
    .enum(["notifications_enabled", "notifications_disabled"])
    .optional(),
  permission: z.enum(["pull", "push", "admin"]).optional().default("pull"),
  parent_team_id: z.coerce.number().nullable().optional(),
})

export const s_TeamsCreateDiscussionLegacyRequestBody = z.object({
  title: z.string(),
  body: z.string(),
  private: PermissiveBoolean.optional().default(false),
})

export const s_TeamsUpdateDiscussionLegacyRequestBody = z.object({
  title: z.string().optional(),
  body: z.string().optional(),
})

export const s_TeamsCreateDiscussionCommentLegacyRequestBody = z.object({
  body: z.string(),
})

export const s_TeamsUpdateDiscussionCommentLegacyRequestBody = z.object({
  body: z.string(),
})

export const s_ReactionsCreateForTeamDiscussionCommentLegacyRequestBody =
  z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

export const s_ReactionsCreateForTeamDiscussionLegacyRequestBody = z.object({
  content: z.enum([
    "+1",
    "-1",
    "laugh",
    "confused",
    "heart",
    "hooray",
    "rocket",
    "eyes",
  ]),
})

export const s_TeamsAddOrUpdateMembershipForUserLegacyRequestBody = z.object({
  role: z.enum(["member", "maintainer"]).optional().default("member"),
})

export const s_TeamsAddOrUpdateProjectPermissionsLegacyRequestBody = z.object({
  permission: z.enum(["read", "write", "admin"]).optional(),
})

export const s_TeamsAddOrUpdateRepoPermissionsLegacyRequestBody = z.object({
  permission: z.enum(["pull", "push", "admin"]).optional(),
})

export const s_UsersUpdateAuthenticatedRequestBody = z.object({
  name: z.string().optional(),
  email: z.string().optional(),
  blog: z.string().optional(),
  twitter_username: z.string().nullable().optional(),
  company: z.string().optional(),
  location: z.string().optional(),
  hireable: PermissiveBoolean.optional(),
  bio: z.string().optional(),
})

export const s_CodespacesCreateForAuthenticatedUserRequestBody = z.union([
  z.object({
    repository_id: z.coerce.number(),
    ref: z.string().optional(),
    location: z.string().optional(),
    geo: z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).optional(),
    client_ip: z.string().optional(),
    machine: z.string().optional(),
    devcontainer_path: z.string().optional(),
    multi_repo_permissions_opt_out: PermissiveBoolean.optional(),
    working_directory: z.string().optional(),
    idle_timeout_minutes: z.coerce.number().optional(),
    display_name: z.string().optional(),
    retention_period_minutes: z.coerce.number().optional(),
  }),
  z.object({
    pull_request: z.object({
      pull_request_number: z.coerce.number(),
      repository_id: z.coerce.number(),
    }),
    location: z.string().optional(),
    geo: z.enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"]).optional(),
    machine: z.string().optional(),
    devcontainer_path: z.string().optional(),
    working_directory: z.string().optional(),
    idle_timeout_minutes: z.coerce.number().optional(),
  }),
])

export const s_CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody =
  z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      )
      .optional(),
    key_id: z.string(),
    selected_repository_ids: z
      .array(z.union([z.coerce.number(), z.string()]))
      .optional(),
  })

export const s_CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody =
  z.object({selected_repository_ids: z.array(z.coerce.number())})

export const s_CodespacesUpdateForAuthenticatedUserRequestBody = z.object({
  machine: z.string().optional(),
  display_name: z.string().optional(),
  recent_folders: z.array(z.string()).optional(),
})

export const s_CodespacesPublishForAuthenticatedUserRequestBody = z.object({
  name: z.string().optional(),
  private: PermissiveBoolean.optional().default(false),
})

export const s_UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody =
  z.object({visibility: z.enum(["public", "private"])})

export const s_UsersAddEmailForAuthenticatedUserRequestBody = z.union([
  z.object({emails: z.array(z.string()).min(1)}),
  z.array(z.string()).min(1),
  z.string(),
])

export const s_UsersDeleteEmailForAuthenticatedUserRequestBody = z.union([
  z.object({emails: z.array(z.string()).min(1)}),
  z.array(z.string()).min(1),
  z.string(),
])

export const s_UsersCreateGpgKeyForAuthenticatedUserRequestBody = z.object({
  name: z.string().optional(),
  armored_public_key: z.string(),
})

export const s_UsersCreatePublicSshKeyForAuthenticatedUserRequestBody =
  z.object({
    title: z.string().optional(),
    key: z
      .string()
      .regex(
        new RegExp("^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) "),
      ),
  })

export const s_OrgsUpdateMembershipForAuthenticatedUserRequestBody = z.object({
  state: z.enum(["active"]),
})

export const s_MigrationsStartForAuthenticatedUserRequestBody = z.object({
  lock_repositories: PermissiveBoolean.optional(),
  exclude_metadata: PermissiveBoolean.optional(),
  exclude_git_data: PermissiveBoolean.optional(),
  exclude_attachments: PermissiveBoolean.optional(),
  exclude_releases: PermissiveBoolean.optional(),
  exclude_owner_projects: PermissiveBoolean.optional(),
  org_metadata_only: PermissiveBoolean.optional().default(false),
  exclude: z.array(z.enum(["repositories"])).optional(),
  repositories: z.array(z.string()),
})

export const s_ProjectsClassicCreateForAuthenticatedUserRequestBody = z.object({
  name: z.string(),
  body: z.string().nullable().optional(),
})

export const s_ReposCreateForAuthenticatedUserRequestBody = z.object({
  name: z.string(),
  description: z.string().optional(),
  homepage: z.string().optional(),
  private: PermissiveBoolean.optional().default(false),
  has_issues: PermissiveBoolean.optional().default(true),
  has_projects: PermissiveBoolean.optional().default(true),
  has_wiki: PermissiveBoolean.optional().default(true),
  has_discussions: PermissiveBoolean.optional().default(false),
  team_id: z.coerce.number().optional(),
  auto_init: PermissiveBoolean.optional().default(false),
  gitignore_template: z.string().optional(),
  license_template: z.string().optional(),
  allow_squash_merge: PermissiveBoolean.optional().default(true),
  allow_merge_commit: PermissiveBoolean.optional().default(true),
  allow_rebase_merge: PermissiveBoolean.optional().default(true),
  allow_auto_merge: PermissiveBoolean.optional().default(false),
  delete_branch_on_merge: PermissiveBoolean.optional().default(false),
  squash_merge_commit_title: z
    .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
    .optional(),
  squash_merge_commit_message: z
    .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
    .optional(),
  merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
  merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
  has_downloads: PermissiveBoolean.optional().default(true),
  is_template: PermissiveBoolean.optional().default(false),
})

export const s_UsersAddSocialAccountForAuthenticatedUserRequestBody = z.object({
  account_urls: z.array(z.string()),
})

export const s_UsersDeleteSocialAccountForAuthenticatedUserRequestBody =
  z.object({account_urls: z.array(z.string())})

export const s_UsersCreateSshSigningKeyForAuthenticatedUserRequestBody =
  z.object({
    title: z.string().optional(),
    key: z
      .string()
      .regex(
        new RegExp(
          "^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com ",
        ),
      ),
  })

export const s_UsersListAttestationsBulkRequestBody = z.object({
  subject_digests: z.array(z.string()).min(1).max(1024),
  predicate_type: z.string().optional(),
})

export const s_UsersDeleteAttestationsBulkRequestBody = z.union([
  z.object({subject_digests: z.array(z.string()).min(1).max(1024)}),
  z.object({attestation_ids: z.array(z.coerce.number()).min(1).max(1024)}),
])
