/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AppAuthenticatorEnrollment,
  t_Authenticator,
  t_AuthenticatorEnrollment,
  t_CreateAppAuthenticatorEnrollmentRequestBodySchema,
  t_CreateEmailRequestBodySchema,
  t_CreatePasswordRequestBodySchema,
  t_CreatePhoneRequestBodySchema,
  t_DeleteAppAuthenticatorEnrollmentParamSchema,
  t_DeleteEmailParamSchema,
  t_DeletePhoneParamSchema,
  t_Email,
  t_Error,
  t_GetAuthenticatorParamSchema,
  t_GetAuthenticatorQuerySchema,
  t_GetEmailParamSchema,
  t_GetEnrollmentParamSchema,
  t_GetPhoneParamSchema,
  t_ListAppAuthenticatorPendingPushNotificationChallengesParamSchema,
  t_ListAuthenticatorsQuerySchema,
  t_ListEnrollmentsParamSchema,
  t_OktaApplication,
  t_Organization,
  t_PasswordResponse,
  t_Phone,
  t_PollChallengeForEmailMagicLinkParamSchema,
  t_Profile,
  t_PushNotificationChallenge,
  t_ReplacePasswordRequestBodySchema,
  t_ReplaceProfileRequestBodySchema,
  t_Schema,
  t_SendEmailChallengeParamSchema,
  t_SendEmailChallengeRequestBodySchema,
  t_SendPhoneChallengeParamSchema,
  t_SendPhoneChallengeRequestBodySchema,
  t_UpdateAppAuthenticatorEnrollmentParamSchema,
  t_UpdateAppAuthenticatorEnrollmentRequestBodySchema,
  t_UpdateEnrollmentParamSchema,
  t_UpdateEnrollmentRequestBodySchema,
  t_VerifyAppAuthenticatorPushNotificationChallengeParamSchema,
  t_VerifyAppAuthenticatorPushNotificationChallengeRequestBodySchema,
  t_VerifyEmailOtpParamSchema,
  t_VerifyEmailOtpRequestBodySchema,
  t_VerifyPhoneChallengeParamSchema,
  t_VerifyPhoneChallengeRequestBodySchema,
} from "./models"
import {
  PermissiveBoolean,
  s_AppAuthenticatorEnrollment,
  s_AppAuthenticatorEnrollmentRequest,
  s_Authenticator,
  s_AuthenticatorEnrollment,
  s_Email,
  s_Error,
  s_OktaApplication,
  s_Organization,
  s_PasswordResponse,
  s_Phone,
  s_Profile,
  s_PushNotificationChallenge,
  s_PushNotificationVerification,
  s_Schema,
  s_UpdateAppAuthenticatorEnrollmentRequest,
  s_UpdateAuthenticatorEnrollmentRequest,
} from "./schemas"
import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  Params,
  ServerConfig,
  SkipResponse,
  StatusCode,
  sendResponse,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod"
import {NextFunction, Request, Response, Router} from "express"
import {z} from "zod"

export type CreateAppAuthenticatorEnrollmentResponder = {
  with200(): ExpressRuntimeResponse<t_AppAuthenticatorEnrollment>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type CreateAppAuthenticatorEnrollment = (
  params: Params<
    void,
    void,
    t_CreateAppAuthenticatorEnrollmentRequestBodySchema,
    void
  >,
  respond: CreateAppAuthenticatorEnrollmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type VerifyAppAuthenticatorPushNotificationChallengeResponder = {
  with200(): ExpressRuntimeResponse<void>
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type VerifyAppAuthenticatorPushNotificationChallenge = (
  params: Params<
    t_VerifyAppAuthenticatorPushNotificationChallengeParamSchema,
    void,
    t_VerifyAppAuthenticatorPushNotificationChallengeRequestBodySchema,
    void
  >,
  respond: VerifyAppAuthenticatorPushNotificationChallengeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UpdateAppAuthenticatorEnrollmentResponder = {
  with200(): ExpressRuntimeResponse<t_AppAuthenticatorEnrollment>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type UpdateAppAuthenticatorEnrollment = (
  params: Params<
    t_UpdateAppAuthenticatorEnrollmentParamSchema,
    void,
    t_UpdateAppAuthenticatorEnrollmentRequestBodySchema,
    void
  >,
  respond: UpdateAppAuthenticatorEnrollmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteAppAuthenticatorEnrollmentResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeleteAppAuthenticatorEnrollment = (
  params: Params<
    t_DeleteAppAuthenticatorEnrollmentParamSchema,
    void,
    void,
    void
  >,
  respond: DeleteAppAuthenticatorEnrollmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListAppAuthenticatorPendingPushNotificationChallengesResponder = {
  with200(): ExpressRuntimeResponse<t_PushNotificationChallenge[]>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListAppAuthenticatorPendingPushNotificationChallenges = (
  params: Params<
    t_ListAppAuthenticatorPendingPushNotificationChallengesParamSchema,
    void,
    void,
    void
  >,
  respond: ListAppAuthenticatorPendingPushNotificationChallengesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListAuthenticatorsResponder = {
  with200(): ExpressRuntimeResponse<t_Authenticator[]>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListAuthenticators = (
  params: Params<void, t_ListAuthenticatorsQuerySchema, void, void>,
  respond: ListAuthenticatorsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetAuthenticatorResponder = {
  with200(): ExpressRuntimeResponse<t_Authenticator>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetAuthenticator = (
  params: Params<
    t_GetAuthenticatorParamSchema,
    t_GetAuthenticatorQuerySchema,
    void,
    void
  >,
  respond: GetAuthenticatorResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListEnrollmentsResponder = {
  with200(): ExpressRuntimeResponse<t_AuthenticatorEnrollment[]>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListEnrollments = (
  params: Params<t_ListEnrollmentsParamSchema, void, void, void>,
  respond: ListEnrollmentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEnrollmentResponder = {
  with200(): ExpressRuntimeResponse<t_AuthenticatorEnrollment>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetEnrollment = (
  params: Params<t_GetEnrollmentParamSchema, void, void, void>,
  respond: GetEnrollmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UpdateEnrollmentResponder = {
  with200(): ExpressRuntimeResponse<t_AuthenticatorEnrollment>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type UpdateEnrollment = (
  params: Params<
    t_UpdateEnrollmentParamSchema,
    void,
    t_UpdateEnrollmentRequestBodySchema,
    void
  >,
  respond: UpdateEnrollmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListEmailsResponder = {
  with200(): ExpressRuntimeResponse<t_Email[]>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListEmails = (
  params: Params<void, void, void, void>,
  respond: ListEmailsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CreateEmailResponder = {
  with201(): ExpressRuntimeResponse<t_Email>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with409(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type CreateEmail = (
  params: Params<void, void, t_CreateEmailRequestBodySchema, void>,
  respond: CreateEmailResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetEmailResponder = {
  with200(): ExpressRuntimeResponse<t_Email>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetEmail = (
  params: Params<t_GetEmailParamSchema, void, void, void>,
  respond: GetEmailResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteEmailResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeleteEmail = (
  params: Params<t_DeleteEmailParamSchema, void, void, void>,
  respond: DeleteEmailResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SendEmailChallengeResponder = {
  with201(): ExpressRuntimeResponse<{
    _links: {
      poll: {
        hints: {
          allow: "GET"[]
        }
        href: string
      }
      verify: {
        hints: {
          allow: "POST"[]
        }
        href: string
      }
    }
    expiresAt: string
    id: string
    profile: {
      email: string
    }
    status: "VERIFIED" | "UNVERIFIED"
  }>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type SendEmailChallenge = (
  params: Params<
    t_SendEmailChallengeParamSchema,
    void,
    t_SendEmailChallengeRequestBodySchema,
    void
  >,
  respond: SendEmailChallengeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type PollChallengeForEmailMagicLinkResponder = {
  with200(): ExpressRuntimeResponse<{
    _links: {
      poll: {
        hints: {
          allow: ("DELETE" | "GET" | "POST" | "PUT")[]
        }
        href: string
      }
      verify: {
        hints: {
          allow: ("DELETE" | "GET" | "POST" | "PUT")[]
        }
        href: string
      }
    }
    expiresAt: string
    id: string
    profile: {
      email: string
    }
    status: "VERIFIED" | "UNVERIFIED"
  }>
  with401(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type PollChallengeForEmailMagicLink = (
  params: Params<t_PollChallengeForEmailMagicLinkParamSchema, void, void, void>,
  respond: PollChallengeForEmailMagicLinkResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type VerifyEmailOtpResponder = {
  with200(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type VerifyEmailOtp = (
  params: Params<
    t_VerifyEmailOtpParamSchema,
    void,
    t_VerifyEmailOtpRequestBodySchema,
    void
  >,
  respond: VerifyEmailOtpResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListOktaApplicationsResponder = {
  with200(): ExpressRuntimeResponse<t_OktaApplication[]>
  with400(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListOktaApplications = (
  params: Params<void, void, void, void>,
  respond: ListOktaApplicationsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetOrganizationResponder = {
  with200(): ExpressRuntimeResponse<t_Organization>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetOrganization = (
  params: Params<void, void, void, void>,
  respond: GetOrganizationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPasswordResponder = {
  with200(): ExpressRuntimeResponse<t_PasswordResponse>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetPassword = (
  params: Params<void, void, void, void>,
  respond: GetPasswordResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CreatePasswordResponder = {
  with201(): ExpressRuntimeResponse<t_PasswordResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type CreatePassword = (
  params: Params<void, void, t_CreatePasswordRequestBodySchema, void>,
  respond: CreatePasswordResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReplacePasswordResponder = {
  with201(): ExpressRuntimeResponse<t_PasswordResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReplacePassword = (
  params: Params<void, void, t_ReplacePasswordRequestBodySchema, void>,
  respond: ReplacePasswordResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeletePasswordResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeletePassword = (
  params: Params<void, void, void, void>,
  respond: DeletePasswordResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListPhonesResponder = {
  with200(): ExpressRuntimeResponse<t_Phone[]>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListPhones = (
  params: Params<void, void, void, void>,
  respond: ListPhonesResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CreatePhoneResponder = {
  with201(): ExpressRuntimeResponse<t_Phone>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with409(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type CreatePhone = (
  params: Params<void, void, t_CreatePhoneRequestBodySchema, void>,
  respond: CreatePhoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetPhoneResponder = {
  with200(): ExpressRuntimeResponse<t_Phone>
  with401(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetPhone = (
  params: Params<t_GetPhoneParamSchema, void, void, void>,
  respond: GetPhoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeletePhoneResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeletePhone = (
  params: Params<t_DeletePhoneParamSchema, void, void, void>,
  respond: DeletePhoneResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SendPhoneChallengeResponder = {
  with200(): ExpressRuntimeResponse<{
    _links?:
      | {
          verify?:
            | {
                hints: {
                  allow: "GET"[]
                }
                href: string
              }
            | undefined
        }
      | undefined
  }>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type SendPhoneChallenge = (
  params: Params<
    t_SendPhoneChallengeParamSchema,
    void,
    t_SendPhoneChallengeRequestBodySchema,
    void
  >,
  respond: SendPhoneChallengeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type VerifyPhoneChallengeResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with409(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type VerifyPhoneChallenge = (
  params: Params<
    t_VerifyPhoneChallengeParamSchema,
    void,
    t_VerifyPhoneChallengeRequestBodySchema,
    void
  >,
  respond: VerifyPhoneChallengeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetProfileResponder = {
  with200(): ExpressRuntimeResponse<t_Profile>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetProfile = (
  params: Params<void, void, void, void>,
  respond: GetProfileResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReplaceProfileResponder = {
  with200(): ExpressRuntimeResponse<t_Profile>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReplaceProfile = (
  params: Params<void, void, t_ReplaceProfileRequestBodySchema, void>,
  respond: ReplaceProfileResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetProfileSchemaResponder = {
  with200(): ExpressRuntimeResponse<t_Schema>
  with401(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetProfileSchema = (
  params: Params<void, void, void, void>,
  respond: GetProfileSchemaResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteSessionsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with401(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeleteSessions = (
  params: Params<void, void, void, void>,
  respond: DeleteSessionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  createAppAuthenticatorEnrollment: CreateAppAuthenticatorEnrollment
  verifyAppAuthenticatorPushNotificationChallenge: VerifyAppAuthenticatorPushNotificationChallenge
  updateAppAuthenticatorEnrollment: UpdateAppAuthenticatorEnrollment
  deleteAppAuthenticatorEnrollment: DeleteAppAuthenticatorEnrollment
  listAppAuthenticatorPendingPushNotificationChallenges: ListAppAuthenticatorPendingPushNotificationChallenges
  listAuthenticators: ListAuthenticators
  getAuthenticator: GetAuthenticator
  listEnrollments: ListEnrollments
  getEnrollment: GetEnrollment
  updateEnrollment: UpdateEnrollment
  listEmails: ListEmails
  createEmail: CreateEmail
  getEmail: GetEmail
  deleteEmail: DeleteEmail
  sendEmailChallenge: SendEmailChallenge
  pollChallengeForEmailMagicLink: PollChallengeForEmailMagicLink
  verifyEmailOtp: VerifyEmailOtp
  listOktaApplications: ListOktaApplications
  getOrganization: GetOrganization
  getPassword: GetPassword
  createPassword: CreatePassword
  replacePassword: ReplacePassword
  deletePassword: DeletePassword
  listPhones: ListPhones
  createPhone: CreatePhone
  getPhone: GetPhone
  deletePhone: DeletePhone
  sendPhoneChallenge: SendPhoneChallenge
  verifyPhoneChallenge: VerifyPhoneChallenge
  getProfile: GetProfile
  replaceProfile: ReplaceProfile
  getProfileSchema: GetProfileSchema
  deleteSessions: DeleteSessions
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const createAppAuthenticatorEnrollmentRequestBodySchema =
    s_AppAuthenticatorEnrollmentRequest

  const createAppAuthenticatorEnrollmentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_AppAuthenticatorEnrollment],
        ["400", s_Error],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // createAppAuthenticatorEnrollment
  router.post(
    `/idp/myaccount/app-authenticators`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            createAppAuthenticatorEnrollmentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_AppAuthenticatorEnrollment>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .createAppAuthenticatorEnrollment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          createAppAuthenticatorEnrollmentResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const verifyAppAuthenticatorPushNotificationChallengeParamSchema = z.object({
    challengeId: z.string(),
  })

  const verifyAppAuthenticatorPushNotificationChallengeRequestBodySchema =
    s_PushNotificationVerification

  const verifyAppAuthenticatorPushNotificationChallengeResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["204", z.undefined()],
        ["400", z.undefined()],
      ],
      undefined,
    )

  // verifyAppAuthenticatorPushNotificationChallenge
  router.post(
    `/idp/myaccount/app-authenticators/challenge/:challengeId/verify`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            verifyAppAuthenticatorPushNotificationChallengeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            verifyAppAuthenticatorPushNotificationChallengeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .verifyAppAuthenticatorPushNotificationChallenge(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          verifyAppAuthenticatorPushNotificationChallengeResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const updateAppAuthenticatorEnrollmentParamSchema = z.object({
    enrollmentId: z.string(),
  })

  const updateAppAuthenticatorEnrollmentRequestBodySchema =
    s_UpdateAppAuthenticatorEnrollmentRequest

  const updateAppAuthenticatorEnrollmentResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_AppAuthenticatorEnrollment],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // updateAppAuthenticatorEnrollment
  router.patch(
    `/idp/myaccount/app-authenticators/:enrollmentId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            updateAppAuthenticatorEnrollmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            updateAppAuthenticatorEnrollmentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_AppAuthenticatorEnrollment>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .updateAppAuthenticatorEnrollment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          updateAppAuthenticatorEnrollmentResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteAppAuthenticatorEnrollmentParamSchema = z.object({
    enrollmentId: z.string(),
  })

  const deleteAppAuthenticatorEnrollmentResponseBodyValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // deleteAppAuthenticatorEnrollment
  router.delete(
    `/idp/myaccount/app-authenticators/:enrollmentId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteAppAuthenticatorEnrollmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteAppAuthenticatorEnrollment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          deleteAppAuthenticatorEnrollmentResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const listAppAuthenticatorPendingPushNotificationChallengesParamSchema =
    z.object({enrollmentId: z.string()})

  const listAppAuthenticatorPendingPushNotificationChallengesResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_PushNotificationChallenge)],
        ["401", s_Error],
      ],
      undefined,
    )

  // listAppAuthenticatorPendingPushNotificationChallenges
  router.get(
    `/idp/myaccount/app-authenticators/:enrollmentId/push/notifications`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            listAppAuthenticatorPendingPushNotificationChallengesParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_PushNotificationChallenge[]>(
              200,
            )
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listAppAuthenticatorPendingPushNotificationChallenges(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          listAppAuthenticatorPendingPushNotificationChallengesResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const listAuthenticatorsQuerySchema = z.object({
    expand: z.string().optional(),
  })

  const listAuthenticatorsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_Authenticator)],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // listAuthenticators
  router.get(
    `/idp/myaccount/authenticators`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            listAuthenticatorsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Authenticator[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listAuthenticators(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          listAuthenticatorsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const getAuthenticatorParamSchema = z.object({authenticatorId: z.string()})

  const getAuthenticatorQuerySchema = z.object({expand: z.string().optional()})

  const getAuthenticatorResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Authenticator],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // getAuthenticator
  router.get(
    `/idp/myaccount/authenticators/:authenticatorId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getAuthenticatorParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getAuthenticatorQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Authenticator>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getAuthenticator(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          getAuthenticatorResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const listEnrollmentsParamSchema = z.object({authenticatorId: z.string()})

  const listEnrollmentsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_AuthenticatorEnrollment)],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // listEnrollments
  router.get(
    `/idp/myaccount/authenticators/:authenticatorId/enrollments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            listEnrollmentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_AuthenticatorEnrollment[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listEnrollments(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          listEnrollmentsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const getEnrollmentParamSchema = z.object({
    authenticatorId: z.string(),
    enrollmentId: z.string(),
  })

  const getEnrollmentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_AuthenticatorEnrollment],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // getEnrollment
  router.get(
    `/idp/myaccount/authenticators/:authenticatorId/enrollments/:enrollmentId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getEnrollmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_AuthenticatorEnrollment>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEnrollment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          getEnrollmentResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const updateEnrollmentParamSchema = z.object({
    authenticatorId: z.string(),
    enrollmentId: z.string(),
  })

  const updateEnrollmentRequestBodySchema =
    s_UpdateAuthenticatorEnrollmentRequest

  const updateEnrollmentResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_AuthenticatorEnrollment],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // updateEnrollment
  router.patch(
    `/idp/myaccount/authenticators/:authenticatorId/enrollments/:enrollmentId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            updateEnrollmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            updateEnrollmentRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_AuthenticatorEnrollment>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .updateEnrollment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          updateEnrollmentResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const listEmailsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_Email)],
      ["401", s_Error],
    ],
    undefined,
  )

  // listEmails
  router.get(
    `/idp/myaccount/emails`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Email[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listEmails(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, listEmailsResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const createEmailRequestBodySchema = z.object({
    profile: z.object({email: z.string().email()}),
    sendEmail: PermissiveBoolean.optional().default(true),
    state: z.string().optional(),
    role: z.enum(["PRIMARY", "SECONDARY"]).optional(),
  })

  const createEmailResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_Email],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["409", s_Error],
    ],
    undefined,
  )

  // createEmail
  router.post(
    `/idp/myaccount/emails`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            createEmailRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_Email>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with409() {
            return new ExpressRuntimeResponse<t_Error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .createEmail(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, createEmailResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const getEmailParamSchema = z.object({id: z.string()})

  const getEmailResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Email],
      ["401", s_Error],
    ],
    undefined,
  )

  // getEmail
  router.get(
    `/idp/myaccount/emails/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getEmailParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Email>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEmail(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, getEmailResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteEmailParamSchema = z.object({id: z.string()})

  const deleteEmailResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", s_Error],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // deleteEmail
  router.delete(
    `/idp/myaccount/emails/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteEmailParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteEmail(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, deleteEmailResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const sendEmailChallengeParamSchema = z.object({id: z.string()})

  const sendEmailChallengeRequestBodySchema = z.object({state: z.string()})

  const sendEmailChallengeResponseBodyValidator = responseValidationFactory(
    [
      [
        "201",
        z.object({
          id: z.string().min(1),
          status: z.enum(["VERIFIED", "UNVERIFIED"]),
          expiresAt: z.string().min(1),
          profile: z.object({email: z.string().min(1)}),
          _links: z.object({
            verify: z.object({
              href: z.string().min(1),
              hints: z.object({allow: z.array(z.enum(["POST"]))}),
            }),
            poll: z.object({
              href: z.string().min(1),
              hints: z.object({allow: z.array(z.enum(["GET"]))}),
            }),
          }),
        }),
      ],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // sendEmailChallenge
  router.post(
    `/idp/myaccount/emails/:id/challenge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            sendEmailChallengeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            sendEmailChallengeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<{
              _links: {
                poll: {
                  hints: {
                    allow: "GET"[]
                  }
                  href: string
                }
                verify: {
                  hints: {
                    allow: "POST"[]
                  }
                  href: string
                }
              }
              expiresAt: string
              id: string
              profile: {
                email: string
              }
              status: "VERIFIED" | "UNVERIFIED"
            }>(201)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .sendEmailChallenge(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          sendEmailChallengeResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const pollChallengeForEmailMagicLinkParamSchema = z.object({
    id: z.string(),
    challengeId: z.string(),
  })

  const pollChallengeForEmailMagicLinkResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            id: z.string().min(1),
            status: z.enum(["VERIFIED", "UNVERIFIED"]),
            expiresAt: z.string().min(1),
            profile: z.object({email: z.string().min(1)}),
            _links: z.object({
              verify: z.object({
                href: z.string().min(1),
                hints: z.object({
                  allow: z.array(z.enum(["DELETE", "GET", "POST", "PUT"])),
                }),
              }),
              poll: z.object({
                href: z.string().min(1),
                hints: z.object({
                  allow: z.array(z.enum(["DELETE", "GET", "POST", "PUT"])),
                }),
              }),
            }),
          }),
        ],
        ["401", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // pollChallengeForEmailMagicLink
  router.get(
    `/idp/myaccount/emails/:id/challenge/:challengeId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            pollChallengeForEmailMagicLinkParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              _links: {
                poll: {
                  hints: {
                    allow: ("DELETE" | "GET" | "POST" | "PUT")[]
                  }
                  href: string
                }
                verify: {
                  hints: {
                    allow: ("DELETE" | "GET" | "POST" | "PUT")[]
                  }
                  href: string
                }
              }
              expiresAt: string
              id: string
              profile: {
                email: string
              }
              status: "VERIFIED" | "UNVERIFIED"
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .pollChallengeForEmailMagicLink(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          pollChallengeForEmailMagicLinkResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const verifyEmailOtpParamSchema = z.object({
    id: z.string(),
    challengeId: z.string(),
  })

  const verifyEmailOtpRequestBodySchema = z.object({
    verificationCode: z.string(),
  })

  const verifyEmailOtpResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // verifyEmailOtp
  router.post(
    `/idp/myaccount/emails/:id/challenge/:challengeId/verify`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            verifyEmailOtpParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            verifyEmailOtpRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .verifyEmailOtp(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          verifyEmailOtpResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const listOktaApplicationsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_OktaApplication)],
      ["400", s_Error],
    ],
    undefined,
  )

  // listOktaApplications
  router.get(
    `/idp/myaccount/okta-applications`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OktaApplication[]>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listOktaApplications(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          listOktaApplicationsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const getOrganizationResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Organization],
      ["401", s_Error],
    ],
    undefined,
  )

  // getOrganization
  router.get(
    `/idp/myaccount/organization`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Organization>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getOrganization(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          getOrganizationResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const getPasswordResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_PasswordResponse],
      ["401", s_Error],
    ],
    undefined,
  )

  // getPassword
  router.get(
    `/idp/myaccount/password`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_PasswordResponse>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPassword(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, getPasswordResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const createPasswordRequestBodySchema = z.object({
    profile: z.object({password: z.string()}),
  })

  const createPasswordResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_PasswordResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  // createPassword
  router.post(
    `/idp/myaccount/password`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            createPasswordRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_PasswordResponse>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .createPassword(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          createPasswordResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const replacePasswordRequestBodySchema = z.object({
    profile: z.object({password: z.string()}),
  })

  const replacePasswordResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_PasswordResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  // replacePassword
  router.put(
    `/idp/myaccount/password`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            replacePasswordRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_PasswordResponse>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .replacePassword(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          replacePasswordResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const deletePasswordResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // deletePassword
  router.delete(
    `/idp/myaccount/password`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deletePassword(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          deletePasswordResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const listPhonesResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_Phone)],
      ["401", s_Error],
    ],
    undefined,
  )

  // listPhones
  router.get(
    `/idp/myaccount/phones`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Phone[]>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listPhones(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, listPhonesResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const createPhoneRequestBodySchema = z.object({
    profile: z.object({phoneNumber: z.string().optional()}),
    sendCode: PermissiveBoolean.optional().default(true),
    method: z.enum(["SMS", "CALL"]).optional(),
  })

  const createPhoneResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_Phone],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["409", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // createPhone
  router.post(
    `/idp/myaccount/phones`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            createPhoneRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_Phone>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with409() {
            return new ExpressRuntimeResponse<t_Error>(409)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .createPhone(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, createPhoneResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const getPhoneParamSchema = z.object({id: z.string()})

  const getPhoneResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Phone],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // getPhone
  router.get(
    `/idp/myaccount/phones/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getPhoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Phone>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getPhone(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, getPhoneResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const deletePhoneParamSchema = z.object({id: z.string()})

  const deletePhoneResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // deletePhone
  router.delete(
    `/idp/myaccount/phones/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deletePhoneParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deletePhone(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, deletePhoneResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const sendPhoneChallengeParamSchema = z.object({id: z.string()})

  const sendPhoneChallengeRequestBodySchema = z.object({
    method: z.enum(["SMS", "CALL"]),
    retry: PermissiveBoolean.optional().default(false),
  })

  const sendPhoneChallengeResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          _links: z
            .object({
              verify: z
                .object({
                  href: z.string().min(1),
                  hints: z.object({allow: z.array(z.enum(["GET"]))}),
                })
                .optional(),
            })
            .optional(),
        }),
      ],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // sendPhoneChallenge
  router.post(
    `/idp/myaccount/phones/:id/challenge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            sendPhoneChallengeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            sendPhoneChallengeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              _links?:
                | {
                    verify?:
                      | {
                          hints: {
                            allow: "GET"[]
                          }
                          href: string
                        }
                      | undefined
                  }
                | undefined
            }>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .sendPhoneChallenge(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          sendPhoneChallengeResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const verifyPhoneChallengeParamSchema = z.object({id: z.string()})

  const verifyPhoneChallengeRequestBodySchema = z.object({
    verificationCode: z.string(),
  })

  const verifyPhoneChallengeResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["409", s_Error],
    ],
    undefined,
  )

  // verifyPhoneChallenge
  router.post(
    `/idp/myaccount/phones/:id/verify`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            verifyPhoneChallengeParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            verifyPhoneChallengeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with409() {
            return new ExpressRuntimeResponse<t_Error>(409)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .verifyPhoneChallenge(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          verifyPhoneChallengeResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const getProfileResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Profile],
      ["401", s_Error],
    ],
    undefined,
  )

  // getProfile
  router.get(
    `/idp/myaccount/profile`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Profile>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getProfile(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, getProfileResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const replaceProfileRequestBodySchema = z.object({
    profile: z.object({}).optional(),
  })

  const replaceProfileResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Profile],
      ["400", s_Error],
      ["401", s_Error],
    ],
    undefined,
  )

  // replaceProfile
  router.put(
    `/idp/myaccount/profile`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            replaceProfileRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Profile>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .replaceProfile(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          replaceProfileResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const getProfileSchemaResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Schema],
      ["401", s_Error],
    ],
    undefined,
  )

  // getProfileSchema
  router.get(
    `/idp/myaccount/profile/schema`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Schema>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getProfileSchema(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          getProfileSchemaResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteSessionsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  // deleteSessions
  router.delete(
    `/idp/myaccount/sessions`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteSessions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          deleteSessionsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // MyAccount Management
  return startServer(config)
}
