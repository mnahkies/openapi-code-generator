/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  EmptyObject,
  t_account,
  t_account_link,
  t_apple_pay_domain,
  t_application_fee,
  t_apps_secret,
  t_balance,
  t_balance_transaction,
  t_bank_account,
  t_billing_portal_configuration,
  t_billing_portal_session,
  t_capability,
  t_card,
  t_cash_balance,
  t_charge,
  t_checkout_session,
  t_country_spec,
  t_coupon,
  t_credit_note,
  t_credit_note_line_item,
  t_customer,
  t_customer_balance_transaction,
  t_customer_cash_balance_transaction,
  t_deleted_account,
  t_deleted_apple_pay_domain,
  t_deleted_coupon,
  t_deleted_customer,
  t_deleted_discount,
  t_deleted_external_account,
  t_deleted_invoice,
  t_deleted_invoiceitem,
  t_deleted_payment_source,
  t_deleted_person,
  t_deleted_plan,
  t_deleted_product,
  t_deleted_radar_value_list,
  t_deleted_radar_value_list_item,
  t_deleted_subscription_item,
  t_deleted_tax_id,
  t_deleted_terminal_configuration,
  t_deleted_terminal_location,
  t_deleted_terminal_reader,
  t_deleted_test_helpers_test_clock,
  t_deleted_webhook_endpoint,
  t_discount,
  t_dispute,
  t_ephemeral_key,
  t_error,
  t_event,
  t_exchange_rate,
  t_external_account,
  t_fee_refund,
  t_file,
  t_file_link,
  t_financial_connections_account,
  t_financial_connections_account_owner,
  t_financial_connections_session,
  t_funding_instructions,
  t_identity_verification_report,
  t_identity_verification_session,
  t_invoice,
  t_invoiceitem,
  t_issuing_authorization,
  t_issuing_card,
  t_issuing_cardholder,
  t_issuing_dispute,
  t_issuing_settlement,
  t_issuing_transaction,
  t_item,
  t_line_item,
  t_login_link,
  t_mandate,
  t_payment_intent,
  t_payment_link,
  t_payment_method,
  t_payment_source,
  t_payout,
  t_person,
  t_plan,
  t_price,
  t_product,
  t_promotion_code,
  t_quote,
  t_radar_early_fraud_warning,
  t_radar_value_list,
  t_radar_value_list_item,
  t_refund,
  t_reporting_report_run,
  t_reporting_report_type,
  t_review,
  t_scheduled_query_run,
  t_setup_attempt,
  t_setup_intent,
  t_shipping_rate,
  t_source,
  t_source_mandate_notification,
  t_source_transaction,
  t_subscription,
  t_subscription_item,
  t_subscription_schedule,
  t_tax_calculation,
  t_tax_calculation_line_item,
  t_tax_code,
  t_tax_id,
  t_tax_rate,
  t_tax_transaction,
  t_tax_transaction_line_item,
  t_terminal_configuration,
  t_terminal_connection_token,
  t_terminal_location,
  t_terminal_reader,
  t_test_helpers_test_clock,
  t_token,
  t_topup,
  t_transfer,
  t_transfer_reversal,
  t_treasury_credit_reversal,
  t_treasury_debit_reversal,
  t_treasury_financial_account,
  t_treasury_financial_account_features,
  t_treasury_inbound_transfer,
  t_treasury_outbound_payment,
  t_treasury_outbound_transfer,
  t_treasury_received_credit,
  t_treasury_received_debit,
  t_treasury_transaction,
  t_treasury_transaction_entry,
  t_usage_record,
  t_usage_record_summary,
  t_webhook_endpoint,
} from "./models"
import {
  AbstractFetchClient,
  AbstractFetchClientConfig,
  Res,
  StatusCode,
  StatusCode2xx,
  StatusCode3xx,
  StatusCode4xx,
  StatusCode5xx,
  TypedFetchResponse,
} from "@nahkies/typescript-fetch-runtime/main"

export interface ApiClientConfig extends AbstractFetchClientConfig {}

export class ApiClient extends AbstractFetchClient {
  constructor(config: ApiClientConfig) {
    super(config)
  }

  async getAccount(
    p: {
      expand?: string[]
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/account`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountLinks(
    p: {
      requestBody: {
        account: string
        collect?: "currently_due" | "eventually_due"
        expand?: string[]
        refresh_url?: string
        return_url?: string
        type: "account_onboarding" | "account_update"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_account_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/account_links`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccounts(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_account[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccounts(
    p: {
      requestBody?: {
        account_token?: string
        bank_account?:
          | {
              account_holder_name?: string
              account_holder_type?: "company" | "individual"
              account_number: string
              account_type?: "checking" | "futsu" | "savings" | "toza"
              country: string
              currency?: string
              documents?: {
                bank_account_ownership_verification?: {
                  files?: string[]
                }
              }
              object?: "bank_account"
              routing_number?: string
            }
          | string
        business_profile?: {
          mcc?: string
          name?: string
          product_description?: string
          support_address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          support_email?: string
          support_phone?: string
          support_url?: string | ""
          url?: string
        }
        business_type?:
          | "company"
          | "government_entity"
          | "individual"
          | "non_profit"
        capabilities?: {
          acss_debit_payments?: {
            requested?: boolean
          }
          affirm_payments?: {
            requested?: boolean
          }
          afterpay_clearpay_payments?: {
            requested?: boolean
          }
          au_becs_debit_payments?: {
            requested?: boolean
          }
          bacs_debit_payments?: {
            requested?: boolean
          }
          bancontact_payments?: {
            requested?: boolean
          }
          bank_transfer_payments?: {
            requested?: boolean
          }
          blik_payments?: {
            requested?: boolean
          }
          boleto_payments?: {
            requested?: boolean
          }
          card_issuing?: {
            requested?: boolean
          }
          card_payments?: {
            requested?: boolean
          }
          cartes_bancaires_payments?: {
            requested?: boolean
          }
          cashapp_payments?: {
            requested?: boolean
          }
          eps_payments?: {
            requested?: boolean
          }
          fpx_payments?: {
            requested?: boolean
          }
          giropay_payments?: {
            requested?: boolean
          }
          grabpay_payments?: {
            requested?: boolean
          }
          ideal_payments?: {
            requested?: boolean
          }
          india_international_payments?: {
            requested?: boolean
          }
          jcb_payments?: {
            requested?: boolean
          }
          klarna_payments?: {
            requested?: boolean
          }
          konbini_payments?: {
            requested?: boolean
          }
          legacy_payments?: {
            requested?: boolean
          }
          link_payments?: {
            requested?: boolean
          }
          oxxo_payments?: {
            requested?: boolean
          }
          p24_payments?: {
            requested?: boolean
          }
          paynow_payments?: {
            requested?: boolean
          }
          promptpay_payments?: {
            requested?: boolean
          }
          sepa_debit_payments?: {
            requested?: boolean
          }
          sofort_payments?: {
            requested?: boolean
          }
          tax_reporting_us_1099_k?: {
            requested?: boolean
          }
          tax_reporting_us_1099_misc?: {
            requested?: boolean
          }
          transfers?: {
            requested?: boolean
          }
          treasury?: {
            requested?: boolean
          }
          us_bank_account_ach_payments?: {
            requested?: boolean
          }
        }
        company?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          address_kana?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          address_kanji?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          directors_provided?: boolean
          executives_provided?: boolean
          export_license_id?: string
          export_purpose_code?: string
          name?: string
          name_kana?: string
          name_kanji?: string
          owners_provided?: boolean
          ownership_declaration?: {
            date?: number
            ip?: string
            user_agent?: string
          }
          phone?: string
          registration_number?: string
          structure?:
            | ""
            | "free_zone_establishment"
            | "free_zone_llc"
            | "government_instrumentality"
            | "governmental_unit"
            | "incorporated_non_profit"
            | "limited_liability_partnership"
            | "llc"
            | "multi_member_llc"
            | "private_company"
            | "private_corporation"
            | "private_partnership"
            | "public_company"
            | "public_corporation"
            | "public_partnership"
            | "single_member_llc"
            | "sole_establishment"
            | "sole_proprietorship"
            | "tax_exempt_government_instrumentality"
            | "unincorporated_association"
            | "unincorporated_non_profit"
          tax_id?: string
          tax_id_registrar?: string
          vat_id?: string
          verification?: {
            document?: {
              back?: string
              front?: string
            }
          }
        }
        country?: string
        default_currency?: string
        documents?: {
          bank_account_ownership_verification?: {
            files?: string[]
          }
          company_license?: {
            files?: string[]
          }
          company_memorandum_of_association?: {
            files?: string[]
          }
          company_ministerial_decree?: {
            files?: string[]
          }
          company_registration_verification?: {
            files?: string[]
          }
          company_tax_id_verification?: {
            files?: string[]
          }
          proof_of_registration?: {
            files?: string[]
          }
        }
        email?: string
        expand?: string[]
        external_account?: string
        individual?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          address_kana?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          address_kanji?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          dob?:
            | {
                day: number
                month: number
                year: number
              }
            | ""
          email?: string
          first_name?: string
          first_name_kana?: string
          first_name_kanji?: string
          full_name_aliases?: string[] | ""
          gender?: string
          id_number?: string
          id_number_secondary?: string
          last_name?: string
          last_name_kana?: string
          last_name_kanji?: string
          maiden_name?: string
          metadata?:
            | {
                [key: string]: string
              }
            | ""
          phone?: string
          political_exposure?: "existing" | "none"
          registered_address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          ssn_last_4?: string
          verification?: {
            additional_document?: {
              back?: string
              front?: string
            }
            document?: {
              back?: string
              front?: string
            }
          }
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        settings?: {
          branding?: {
            icon?: string
            logo?: string
            primary_color?: string
            secondary_color?: string
          }
          card_issuing?: {
            tos_acceptance?: {
              date?: number
              ip?: string
              user_agent?: string
            }
          }
          card_payments?: {
            decline_on?: {
              avs_failure?: boolean
              cvc_failure?: boolean
            }
            statement_descriptor_prefix?: string
            statement_descriptor_prefix_kana?: string | ""
            statement_descriptor_prefix_kanji?: string | ""
          }
          payments?: {
            statement_descriptor?: string
            statement_descriptor_kana?: string
            statement_descriptor_kanji?: string
          }
          payouts?: {
            debit_negative_balances?: boolean
            schedule?: {
              delay_days?: "minimum" | number
              interval?: "daily" | "manual" | "monthly" | "weekly"
              monthly_anchor?: number
              weekly_anchor?:
                | "friday"
                | "monday"
                | "saturday"
                | "sunday"
                | "thursday"
                | "tuesday"
                | "wednesday"
            }
            statement_descriptor?: string
          }
          treasury?: {
            tos_acceptance?: {
              date?: number
              ip?: string
              user_agent?: string
            }
          }
        }
        tos_acceptance?: {
          date?: number
          ip?: string
          service_agreement?: string
          user_agent?: string
        }
        type?: "custom" | "express" | "standard"
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteAccountsAccount(
    p: {
      account: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccount(
    p: {
      account: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccount(
    p: {
      account: string
      requestBody?: {
        account_token?: string
        business_profile?: {
          mcc?: string
          name?: string
          product_description?: string
          support_address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          support_email?: string
          support_phone?: string
          support_url?: string | ""
          url?: string
        }
        business_type?:
          | "company"
          | "government_entity"
          | "individual"
          | "non_profit"
        capabilities?: {
          acss_debit_payments?: {
            requested?: boolean
          }
          affirm_payments?: {
            requested?: boolean
          }
          afterpay_clearpay_payments?: {
            requested?: boolean
          }
          au_becs_debit_payments?: {
            requested?: boolean
          }
          bacs_debit_payments?: {
            requested?: boolean
          }
          bancontact_payments?: {
            requested?: boolean
          }
          bank_transfer_payments?: {
            requested?: boolean
          }
          blik_payments?: {
            requested?: boolean
          }
          boleto_payments?: {
            requested?: boolean
          }
          card_issuing?: {
            requested?: boolean
          }
          card_payments?: {
            requested?: boolean
          }
          cartes_bancaires_payments?: {
            requested?: boolean
          }
          cashapp_payments?: {
            requested?: boolean
          }
          eps_payments?: {
            requested?: boolean
          }
          fpx_payments?: {
            requested?: boolean
          }
          giropay_payments?: {
            requested?: boolean
          }
          grabpay_payments?: {
            requested?: boolean
          }
          ideal_payments?: {
            requested?: boolean
          }
          india_international_payments?: {
            requested?: boolean
          }
          jcb_payments?: {
            requested?: boolean
          }
          klarna_payments?: {
            requested?: boolean
          }
          konbini_payments?: {
            requested?: boolean
          }
          legacy_payments?: {
            requested?: boolean
          }
          link_payments?: {
            requested?: boolean
          }
          oxxo_payments?: {
            requested?: boolean
          }
          p24_payments?: {
            requested?: boolean
          }
          paynow_payments?: {
            requested?: boolean
          }
          promptpay_payments?: {
            requested?: boolean
          }
          sepa_debit_payments?: {
            requested?: boolean
          }
          sofort_payments?: {
            requested?: boolean
          }
          tax_reporting_us_1099_k?: {
            requested?: boolean
          }
          tax_reporting_us_1099_misc?: {
            requested?: boolean
          }
          transfers?: {
            requested?: boolean
          }
          treasury?: {
            requested?: boolean
          }
          us_bank_account_ach_payments?: {
            requested?: boolean
          }
        }
        company?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          address_kana?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          address_kanji?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          directors_provided?: boolean
          executives_provided?: boolean
          export_license_id?: string
          export_purpose_code?: string
          name?: string
          name_kana?: string
          name_kanji?: string
          owners_provided?: boolean
          ownership_declaration?: {
            date?: number
            ip?: string
            user_agent?: string
          }
          phone?: string
          registration_number?: string
          structure?:
            | ""
            | "free_zone_establishment"
            | "free_zone_llc"
            | "government_instrumentality"
            | "governmental_unit"
            | "incorporated_non_profit"
            | "limited_liability_partnership"
            | "llc"
            | "multi_member_llc"
            | "private_company"
            | "private_corporation"
            | "private_partnership"
            | "public_company"
            | "public_corporation"
            | "public_partnership"
            | "single_member_llc"
            | "sole_establishment"
            | "sole_proprietorship"
            | "tax_exempt_government_instrumentality"
            | "unincorporated_association"
            | "unincorporated_non_profit"
          tax_id?: string
          tax_id_registrar?: string
          vat_id?: string
          verification?: {
            document?: {
              back?: string
              front?: string
            }
          }
        }
        default_currency?: string
        documents?: {
          bank_account_ownership_verification?: {
            files?: string[]
          }
          company_license?: {
            files?: string[]
          }
          company_memorandum_of_association?: {
            files?: string[]
          }
          company_ministerial_decree?: {
            files?: string[]
          }
          company_registration_verification?: {
            files?: string[]
          }
          company_tax_id_verification?: {
            files?: string[]
          }
          proof_of_registration?: {
            files?: string[]
          }
        }
        email?: string
        expand?: string[]
        external_account?: string
        individual?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          address_kana?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          address_kanji?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          dob?:
            | {
                day: number
                month: number
                year: number
              }
            | ""
          email?: string
          first_name?: string
          first_name_kana?: string
          first_name_kanji?: string
          full_name_aliases?: string[] | ""
          gender?: string
          id_number?: string
          id_number_secondary?: string
          last_name?: string
          last_name_kana?: string
          last_name_kanji?: string
          maiden_name?: string
          metadata?:
            | {
                [key: string]: string
              }
            | ""
          phone?: string
          political_exposure?: "existing" | "none"
          registered_address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          ssn_last_4?: string
          verification?: {
            additional_document?: {
              back?: string
              front?: string
            }
            document?: {
              back?: string
              front?: string
            }
          }
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        settings?: {
          branding?: {
            icon?: string
            logo?: string
            primary_color?: string
            secondary_color?: string
          }
          card_issuing?: {
            tos_acceptance?: {
              date?: number
              ip?: string
              user_agent?: string
            }
          }
          card_payments?: {
            decline_on?: {
              avs_failure?: boolean
              cvc_failure?: boolean
            }
            statement_descriptor_prefix?: string
            statement_descriptor_prefix_kana?: string | ""
            statement_descriptor_prefix_kanji?: string | ""
          }
          payments?: {
            statement_descriptor?: string
            statement_descriptor_kana?: string
            statement_descriptor_kanji?: string
          }
          payouts?: {
            debit_negative_balances?: boolean
            schedule?: {
              delay_days?: "minimum" | number
              interval?: "daily" | "manual" | "monthly" | "weekly"
              monthly_anchor?: number
              weekly_anchor?:
                | "friday"
                | "monday"
                | "saturday"
                | "sunday"
                | "thursday"
                | "tuesday"
                | "wednesday"
            }
            statement_descriptor?: string
          }
          treasury?: {
            tos_acceptance?: {
              date?: number
              ip?: string
              user_agent?: string
            }
          }
        }
        tos_acceptance?: {
          date?: number
          ip?: string
          service_agreement?: string
          user_agent?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountBankAccounts(
    p: {
      account: string
      requestBody?: {
        bank_account?:
          | {
              account_holder_name?: string
              account_holder_type?: "company" | "individual"
              account_number: string
              account_type?: "checking" | "futsu" | "savings" | "toza"
              country: string
              currency?: string
              documents?: {
                bank_account_ownership_verification?: {
                  files?: string[]
                }
              }
              object?: "bank_account"
              routing_number?: string
            }
          | string
        default_for_currency?: boolean
        expand?: string[]
        external_account?: string
        metadata?: {
          [key: string]: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_external_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/bank_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteAccountsAccountBankAccountsId(
    p: {
      account: string
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_external_account> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountBankAccountsId(
    p: {
      account: string
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_external_account> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountBankAccountsId(
    p: {
      account: string
      id: string
      requestBody?: {
        account_holder_name?: string
        account_holder_type?: "" | "company" | "individual"
        account_type?: "checking" | "futsu" | "savings" | "toza"
        address_city?: string
        address_country?: string
        address_line1?: string
        address_line2?: string
        address_state?: string
        address_zip?: string
        default_for_currency?: boolean
        documents?: {
          bank_account_ownership_verification?: {
            files?: string[]
          }
        }
        exp_month?: string
        exp_year?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_external_account> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountCapabilities(
    p: {
      account: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_capability[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/capabilities`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountCapabilitiesCapability(
    p: {
      account: string
      capability: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_capability> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/capabilities/${p["capability"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountCapabilitiesCapability(
    p: {
      account: string
      capability: string
      requestBody?: {
        expand?: string[]
        requested?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_capability> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/capabilities/${p["capability"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountExternalAccounts(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: (t_bank_account | t_card)[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/external_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountExternalAccounts(
    p: {
      account: string
      requestBody?: {
        bank_account?:
          | {
              account_holder_name?: string
              account_holder_type?: "company" | "individual"
              account_number: string
              account_type?: "checking" | "futsu" | "savings" | "toza"
              country: string
              currency?: string
              documents?: {
                bank_account_ownership_verification?: {
                  files?: string[]
                }
              }
              object?: "bank_account"
              routing_number?: string
            }
          | string
        default_for_currency?: boolean
        expand?: string[]
        external_account?: string
        metadata?: {
          [key: string]: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_external_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/external_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteAccountsAccountExternalAccountsId(
    p: {
      account: string
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_external_account> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/external_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountExternalAccountsId(
    p: {
      account: string
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_external_account> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/external_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountExternalAccountsId(
    p: {
      account: string
      id: string
      requestBody?: {
        account_holder_name?: string
        account_holder_type?: "" | "company" | "individual"
        account_type?: "checking" | "futsu" | "savings" | "toza"
        address_city?: string
        address_country?: string
        address_line1?: string
        address_line2?: string
        address_state?: string
        address_zip?: string
        default_for_currency?: boolean
        documents?: {
          bank_account_ownership_verification?: {
            files?: string[]
          }
        }
        exp_month?: string
        exp_year?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_external_account> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/external_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountLoginLinks(
    p: {
      account: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_login_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/login_links`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountPeople(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      relationship?: {
        director?: boolean
        executive?: boolean
        owner?: boolean
        representative?: boolean
      }
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_person[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/people`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      relationship: p["relationship"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountPeople(
    p: {
      account: string
      requestBody?: {
        address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        address_kana?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        address_kanji?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        dob?:
          | {
              day: number
              month: number
              year: number
            }
          | ""
        documents?: {
          company_authorization?: {
            files?: string[]
          }
          passport?: {
            files?: string[]
          }
          visa?: {
            files?: string[]
          }
        }
        email?: string
        expand?: string[]
        first_name?: string
        first_name_kana?: string
        first_name_kanji?: string
        full_name_aliases?: string[] | ""
        gender?: string
        id_number?: string
        id_number_secondary?: string
        last_name?: string
        last_name_kana?: string
        last_name_kanji?: string
        maiden_name?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        nationality?: string
        person_token?: string
        phone?: string
        political_exposure?: string
        registered_address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        relationship?: {
          director?: boolean
          executive?: boolean
          owner?: boolean
          percent_ownership?: number | ""
          representative?: boolean
          title?: string
        }
        ssn_last_4?: string
        verification?: {
          additional_document?: {
            back?: string
            front?: string
          }
          document?: {
            back?: string
            front?: string
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_person> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/people`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteAccountsAccountPeoplePerson(
    p: {
      account: string
      person: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_person> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/people/${p["person"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountPeoplePerson(
    p: {
      account: string
      expand?: string[]
      person: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_person> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/people/${p["person"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountPeoplePerson(
    p: {
      account: string
      person: string
      requestBody?: {
        address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        address_kana?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        address_kanji?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        dob?:
          | {
              day: number
              month: number
              year: number
            }
          | ""
        documents?: {
          company_authorization?: {
            files?: string[]
          }
          passport?: {
            files?: string[]
          }
          visa?: {
            files?: string[]
          }
        }
        email?: string
        expand?: string[]
        first_name?: string
        first_name_kana?: string
        first_name_kanji?: string
        full_name_aliases?: string[] | ""
        gender?: string
        id_number?: string
        id_number_secondary?: string
        last_name?: string
        last_name_kana?: string
        last_name_kanji?: string
        maiden_name?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        nationality?: string
        person_token?: string
        phone?: string
        political_exposure?: string
        registered_address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        relationship?: {
          director?: boolean
          executive?: boolean
          owner?: boolean
          percent_ownership?: number | ""
          representative?: boolean
          title?: string
        }
        ssn_last_4?: string
        verification?: {
          additional_document?: {
            back?: string
            front?: string
          }
          document?: {
            back?: string
            front?: string
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_person> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/people/${p["person"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountPersons(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      relationship?: {
        director?: boolean
        executive?: boolean
        owner?: boolean
        representative?: boolean
      }
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_person[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/persons`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      relationship: p["relationship"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountPersons(
    p: {
      account: string
      requestBody?: {
        address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        address_kana?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        address_kanji?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        dob?:
          | {
              day: number
              month: number
              year: number
            }
          | ""
        documents?: {
          company_authorization?: {
            files?: string[]
          }
          passport?: {
            files?: string[]
          }
          visa?: {
            files?: string[]
          }
        }
        email?: string
        expand?: string[]
        first_name?: string
        first_name_kana?: string
        first_name_kanji?: string
        full_name_aliases?: string[] | ""
        gender?: string
        id_number?: string
        id_number_secondary?: string
        last_name?: string
        last_name_kana?: string
        last_name_kanji?: string
        maiden_name?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        nationality?: string
        person_token?: string
        phone?: string
        political_exposure?: string
        registered_address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        relationship?: {
          director?: boolean
          executive?: boolean
          owner?: boolean
          percent_ownership?: number | ""
          representative?: boolean
          title?: string
        }
        ssn_last_4?: string
        verification?: {
          additional_document?: {
            back?: string
            front?: string
          }
          document?: {
            back?: string
            front?: string
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_person> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/persons`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteAccountsAccountPersonsPerson(
    p: {
      account: string
      person: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_person> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/persons/${p["person"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAccountsAccountPersonsPerson(
    p: {
      account: string
      expand?: string[]
      person: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_person> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/persons/${p["person"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountPersonsPerson(
    p: {
      account: string
      person: string
      requestBody?: {
        address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        address_kana?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        address_kanji?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
          town?: string
        }
        dob?:
          | {
              day: number
              month: number
              year: number
            }
          | ""
        documents?: {
          company_authorization?: {
            files?: string[]
          }
          passport?: {
            files?: string[]
          }
          visa?: {
            files?: string[]
          }
        }
        email?: string
        expand?: string[]
        first_name?: string
        first_name_kana?: string
        first_name_kanji?: string
        full_name_aliases?: string[] | ""
        gender?: string
        id_number?: string
        id_number_secondary?: string
        last_name?: string
        last_name_kana?: string
        last_name_kanji?: string
        maiden_name?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        nationality?: string
        person_token?: string
        phone?: string
        political_exposure?: string
        registered_address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        relationship?: {
          director?: boolean
          executive?: boolean
          owner?: boolean
          percent_ownership?: number | ""
          representative?: boolean
          title?: string
        }
        ssn_last_4?: string
        verification?: {
          additional_document?: {
            back?: string
            front?: string
          }
          document?: {
            back?: string
            front?: string
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_person> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/persons/${p["person"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAccountsAccountReject(
    p: {
      account: string
      requestBody: {
        expand?: string[]
        reason: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_account> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/reject`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getApplePayDomains(
    p: {
      domainName?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_apple_pay_domain[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/apple_pay/domains`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      domain_name: p["domainName"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postApplePayDomains(
    p: {
      requestBody: {
        domain_name: string
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_apple_pay_domain> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/apple_pay/domains`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteApplePayDomainsDomain(
    p: {
      domain: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_apple_pay_domain> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/apple_pay/domains/${p["domain"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getApplePayDomainsDomain(
    p: {
      domain: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_apple_pay_domain> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/apple_pay/domains/${p["domain"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getApplicationFees(
    p: {
      charge?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_application_fee[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/application_fees`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      charge: p["charge"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getApplicationFeesFeeRefundsId(
    p: {
      expand?: string[]
      fee: string
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_fee_refund> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/application_fees/${p["fee"]}/refunds/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postApplicationFeesFeeRefundsId(
    p: {
      fee: string
      id: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_fee_refund> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/application_fees/${p["fee"]}/refunds/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getApplicationFeesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_application_fee> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/application_fees/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postApplicationFeesIdRefund(
    p: {
      id: string
      requestBody?: {
        amount?: number
        directive?: string
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_application_fee> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/application_fees/${p["id"]}/refund`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getApplicationFeesIdRefunds(
    p: {
      endingBefore?: string
      expand?: string[]
      id: string
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_fee_refund[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/application_fees/${p["id"]}/refunds`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postApplicationFeesIdRefunds(
    p: {
      id: string
      requestBody?: {
        amount?: number
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_fee_refund> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/application_fees/${p["id"]}/refunds`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAppsSecrets(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      scope: {
        type: "account" | "user"
        user?: string
      }
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_apps_secret[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/apps/secrets`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      scope: p["scope"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAppsSecrets(
    p: {
      requestBody: {
        expand?: string[]
        expires_at?: number
        name: string
        payload: string
        scope: {
          type: "account" | "user"
          user?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_apps_secret> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/apps/secrets`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postAppsSecretsDelete(
    p: {
      requestBody: {
        expand?: string[]
        name: string
        scope: {
          type: "account" | "user"
          user?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_apps_secret> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/apps/secrets/delete`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getAppsSecretsFind(
    p: {
      expand?: string[]
      name: string
      scope: {
        type: "account" | "user"
        user?: string
      }
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_apps_secret> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/apps/secrets/find`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      name: p["name"],
      scope: p["scope"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getBalance(
    p: {
      expand?: string[]
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_balance> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/balance`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getBalanceHistory(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      payout?: string
      source?: string
      startingAfter?: string
      type?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/balance/history`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payout: p["payout"],
      source: p["source"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getBalanceHistoryId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_balance_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/balance/history/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getBalanceTransactions(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      payout?: string
      source?: string
      startingAfter?: string
      type?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/balance_transactions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payout: p["payout"],
      source: p["source"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getBalanceTransactionsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_balance_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/balance_transactions/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getBillingPortalConfigurations(
    p: {
      active?: boolean
      endingBefore?: string
      expand?: string[]
      isDefault?: boolean
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_billing_portal_configuration[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/billing_portal/configurations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      is_default: p["isDefault"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postBillingPortalConfigurations(
    p: {
      requestBody: {
        business_profile: {
          headline?: string
          privacy_policy_url?: string
          terms_of_service_url?: string
        }
        default_return_url?: string | ""
        expand?: string[]
        features: {
          customer_update?: {
            allowed_updates?:
              | (
                  | "address"
                  | "email"
                  | "name"
                  | "phone"
                  | "shipping"
                  | "tax_id"
                )[]
              | ""
            enabled: boolean
          }
          invoice_history?: {
            enabled: boolean
          }
          payment_method_update?: {
            enabled: boolean
          }
          subscription_cancel?: {
            cancellation_reason?: {
              enabled: boolean
              options:
                | (
                    | "customer_service"
                    | "low_quality"
                    | "missing_features"
                    | "other"
                    | "switched_service"
                    | "too_complex"
                    | "too_expensive"
                    | "unused"
                  )[]
                | ""
            }
            enabled: boolean
            mode?: "at_period_end" | "immediately"
            proration_behavior?: "always_invoice" | "create_prorations" | "none"
          }
          subscription_pause?: {
            enabled?: boolean
          }
          subscription_update?: {
            default_allowed_updates:
              | ("price" | "promotion_code" | "quantity")[]
              | ""
            enabled: boolean
            products:
              | {
                  prices: string[]
                  product: string
                }[]
              | ""
            proration_behavior?: "always_invoice" | "create_prorations" | "none"
          }
        }
        login_page?: {
          enabled: boolean
        }
        metadata?: {
          [key: string]: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_billing_portal_configuration> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/billing_portal/configurations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getBillingPortalConfigurationsConfiguration(
    p: {
      configuration: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_billing_portal_configuration> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/billing_portal/configurations/${p["configuration"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postBillingPortalConfigurationsConfiguration(
    p: {
      configuration: string
      requestBody?: {
        active?: boolean
        business_profile?: {
          headline?: string
          privacy_policy_url?: string | ""
          terms_of_service_url?: string | ""
        }
        default_return_url?: string | ""
        expand?: string[]
        features?: {
          customer_update?: {
            allowed_updates?:
              | (
                  | "address"
                  | "email"
                  | "name"
                  | "phone"
                  | "shipping"
                  | "tax_id"
                )[]
              | ""
            enabled?: boolean
          }
          invoice_history?: {
            enabled: boolean
          }
          payment_method_update?: {
            enabled: boolean
          }
          subscription_cancel?: {
            cancellation_reason?: {
              enabled: boolean
              options?:
                | (
                    | "customer_service"
                    | "low_quality"
                    | "missing_features"
                    | "other"
                    | "switched_service"
                    | "too_complex"
                    | "too_expensive"
                    | "unused"
                  )[]
                | ""
            }
            enabled?: boolean
            mode?: "at_period_end" | "immediately"
            proration_behavior?: "always_invoice" | "create_prorations" | "none"
          }
          subscription_pause?: {
            enabled?: boolean
          }
          subscription_update?: {
            default_allowed_updates?:
              | ("price" | "promotion_code" | "quantity")[]
              | ""
            enabled?: boolean
            products?:
              | {
                  prices: string[]
                  product: string
                }[]
              | ""
            proration_behavior?: "always_invoice" | "create_prorations" | "none"
          }
        }
        login_page?: {
          enabled: boolean
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_billing_portal_configuration> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/billing_portal/configurations/${p["configuration"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postBillingPortalSessions(
    p: {
      requestBody: {
        configuration?: string
        customer: string
        expand?: string[]
        flow_data?: {
          after_completion?: {
            hosted_confirmation?: {
              custom_message?: string
            }
            redirect?: {
              return_url: string
            }
            type: "hosted_confirmation" | "portal_homepage" | "redirect"
          }
          subscription_cancel?: {
            subscription: string
          }
          type: "payment_method_update" | "subscription_cancel"
        }
        locale?:
          | "auto"
          | "bg"
          | "cs"
          | "da"
          | "de"
          | "el"
          | "en"
          | "en-AU"
          | "en-CA"
          | "en-GB"
          | "en-IE"
          | "en-IN"
          | "en-NZ"
          | "en-SG"
          | "es"
          | "es-419"
          | "et"
          | "fi"
          | "fil"
          | "fr"
          | "fr-CA"
          | "hr"
          | "hu"
          | "id"
          | "it"
          | "ja"
          | "ko"
          | "lt"
          | "lv"
          | "ms"
          | "mt"
          | "nb"
          | "nl"
          | "pl"
          | "pt"
          | "pt-BR"
          | "ro"
          | "ru"
          | "sk"
          | "sl"
          | "sv"
          | "th"
          | "tr"
          | "vi"
          | "zh"
          | "zh-HK"
          | "zh-TW"
        on_behalf_of?: string
        return_url?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_billing_portal_session> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/billing_portal/sessions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCharges(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      transferGroup?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_charge[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/charges`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
      transfer_group: p["transferGroup"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCharges(
    p: {
      requestBody?: {
        amount?: number
        application_fee?: number
        application_fee_amount?: number
        capture?: boolean
        card?:
          | {
              address_city?: string
              address_country?: string
              address_line1?: string
              address_line2?: string
              address_state?: string
              address_zip?: string
              cvc?: string
              exp_month: number
              exp_year: number
              metadata?: {
                [key: string]: string
              }
              name?: string
              number: string
              object?: "card"
            }
          | string
        currency?: string
        customer?: string
        description?: string
        destination?:
          | {
              account: string
              amount?: number
            }
          | string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        on_behalf_of?: string
        radar_options?: {
          session?: string
        }
        receipt_email?: string
        shipping?: {
          address: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          carrier?: string
          name: string
          phone?: string
          tracking_number?: string
        }
        source?: string
        statement_descriptor?: string
        statement_descriptor_suffix?: string
        transfer_data?: {
          amount?: number
          destination: string
        }
        transfer_group?: string
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_charge> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getChargesSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_charge[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/charges/search`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getChargesCharge(
    p: {
      charge: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_charge> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postChargesCharge(
    p: {
      charge: string
      requestBody?: {
        customer?: string
        description?: string
        expand?: string[]
        fraud_details?: {
          user_report: "" | "fraudulent" | "safe"
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        receipt_email?: string
        shipping?: {
          address: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          carrier?: string
          name: string
          phone?: string
          tracking_number?: string
        }
        transfer_group?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_charge> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postChargesChargeCapture(
    p: {
      charge: string
      requestBody?: {
        amount?: number
        application_fee?: number
        application_fee_amount?: number
        expand?: string[]
        receipt_email?: string
        statement_descriptor?: string
        statement_descriptor_suffix?: string
        transfer_data?: {
          amount?: number
        }
        transfer_group?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_charge> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/capture`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getChargesChargeDispute(
    p: {
      charge: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/dispute`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postChargesChargeDispute(
    p: {
      charge: string
      requestBody?: {
        evidence?: {
          access_activity_log?: string
          billing_address?: string
          cancellation_policy?: string
          cancellation_policy_disclosure?: string
          cancellation_rebuttal?: string
          customer_communication?: string
          customer_email_address?: string
          customer_name?: string
          customer_purchase_ip?: string
          customer_signature?: string
          duplicate_charge_documentation?: string
          duplicate_charge_explanation?: string
          duplicate_charge_id?: string
          product_description?: string
          receipt?: string
          refund_policy?: string
          refund_policy_disclosure?: string
          refund_refusal_explanation?: string
          service_date?: string
          service_documentation?: string
          shipping_address?: string
          shipping_carrier?: string
          shipping_date?: string
          shipping_documentation?: string
          shipping_tracking_number?: string
          uncategorized_file?: string
          uncategorized_text?: string
        }
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        submit?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/dispute`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postChargesChargeDisputeClose(
    p: {
      charge: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/dispute/close`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postChargesChargeRefund(
    p: {
      charge: string
      requestBody?: {
        amount?: number
        expand?: string[]
        instructions_email?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        payment_intent?: string
        reason?: "duplicate" | "fraudulent" | "requested_by_customer"
        refund_application_fee?: boolean
        reverse_transfer?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_charge> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/refund`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getChargesChargeRefunds(
    p: {
      charge: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_refund[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/refunds`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postChargesChargeRefunds(
    p: {
      charge: string
      requestBody?: {
        amount?: number
        currency?: string
        customer?: string
        expand?: string[]
        instructions_email?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        origin?: "customer_balance"
        payment_intent?: string
        reason?: "duplicate" | "fraudulent" | "requested_by_customer"
        refund_application_fee?: boolean
        reverse_transfer?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/refunds`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getChargesChargeRefundsRefund(
    p: {
      charge: string
      expand?: string[]
      refund: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/charges/${p["charge"]}/refunds/${p["refund"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postChargesChargeRefundsRefund(
    p: {
      charge: string
      refund: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/charges/${p["charge"]}/refunds/${p["refund"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCheckoutSessions(
    p: {
      customer?: string
      customerDetails?: {
        email: string
      }
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      paymentLink?: string
      startingAfter?: string
      subscription?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_checkout_session[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/checkout/sessions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      customer: p["customer"],
      customer_details: p["customerDetails"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      payment_link: p["paymentLink"],
      starting_after: p["startingAfter"],
      subscription: p["subscription"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCheckoutSessions(
    p: {
      requestBody: {
        after_expiration?: {
          recovery?: {
            allow_promotion_codes?: boolean
            enabled: boolean
          }
        }
        allow_promotion_codes?: boolean
        automatic_tax?: {
          enabled: boolean
        }
        billing_address_collection?: "auto" | "required"
        cancel_url?: string
        client_reference_id?: string
        consent_collection?: {
          promotions?: "auto" | "none"
          terms_of_service?: "none" | "required"
        }
        currency?: string
        custom_fields?: {
          dropdown?: {
            options: {
              label: string
              value: string
            }[]
          }
          key: string
          label: {
            custom: string
            type: "custom"
          }
          optional?: boolean
          type: "dropdown" | "numeric" | "text"
        }[]
        custom_text?: {
          shipping_address?:
            | {
                message: string
              }
            | ""
          submit?:
            | {
                message: string
              }
            | ""
        }
        customer?: string
        customer_creation?: "always" | "if_required"
        customer_email?: string
        customer_update?: {
          address?: "auto" | "never"
          name?: "auto" | "never"
          shipping?: "auto" | "never"
        }
        discounts?: {
          coupon?: string
          promotion_code?: string
        }[]
        expand?: string[]
        expires_at?: number
        invoice_creation?: {
          enabled: boolean
          invoice_data?: {
            account_tax_ids?: string[] | ""
            custom_fields?:
              | {
                  name: string
                  value: string
                }[]
              | ""
            description?: string
            footer?: string
            metadata?: {
              [key: string]: string
            }
            rendering_options?:
              | {
                  amount_tax_display?:
                    | ""
                    | "exclude_tax"
                    | "include_inclusive_tax"
                }
              | ""
          }
        }
        line_items?: {
          adjustable_quantity?: {
            enabled: boolean
            maximum?: number
            minimum?: number
          }
          dynamic_tax_rates?: string[]
          price?: string
          price_data?: {
            currency: string
            product?: string
            product_data?: {
              description?: string
              images?: string[]
              metadata?: {
                [key: string]: string
              }
              name: string
              tax_code?: string
            }
            recurring?: {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[]
        }[]
        locale?:
          | "auto"
          | "bg"
          | "cs"
          | "da"
          | "de"
          | "el"
          | "en"
          | "en-GB"
          | "es"
          | "es-419"
          | "et"
          | "fi"
          | "fil"
          | "fr"
          | "fr-CA"
          | "hr"
          | "hu"
          | "id"
          | "it"
          | "ja"
          | "ko"
          | "lt"
          | "lv"
          | "ms"
          | "mt"
          | "nb"
          | "nl"
          | "pl"
          | "pt"
          | "pt-BR"
          | "ro"
          | "ru"
          | "sk"
          | "sl"
          | "sv"
          | "th"
          | "tr"
          | "vi"
          | "zh"
          | "zh-HK"
          | "zh-TW"
        metadata?: {
          [key: string]: string
        }
        mode?: "payment" | "setup" | "subscription"
        payment_intent_data?: {
          application_fee_amount?: number
          capture_method?: "automatic" | "automatic_async" | "manual"
          description?: string
          metadata?: {
            [key: string]: string
          }
          on_behalf_of?: string
          receipt_email?: string
          setup_future_usage?: "off_session" | "on_session"
          shipping?: {
            address: {
              city?: string
              country?: string
              line1: string
              line2?: string
              postal_code?: string
              state?: string
            }
            carrier?: string
            name: string
            phone?: string
            tracking_number?: string
          }
          statement_descriptor?: string
          statement_descriptor_suffix?: string
          transfer_data?: {
            amount?: number
            destination: string
          }
          transfer_group?: string
        }
        payment_method_collection?: "always" | "if_required"
        payment_method_options?: {
          acss_debit?: {
            currency?: "cad" | "usd"
            mandate_options?: {
              custom_mandate_url?: string | ""
              default_for?: ("invoice" | "subscription")[]
              interval_description?: string
              payment_schedule?: "combined" | "interval" | "sporadic"
              transaction_type?: "business" | "personal"
            }
            setup_future_usage?: "none" | "off_session" | "on_session"
            verification_method?: "automatic" | "instant" | "microdeposits"
          }
          affirm?: {
            setup_future_usage?: "none"
          }
          afterpay_clearpay?: {
            setup_future_usage?: "none"
          }
          alipay?: {
            setup_future_usage?: "none"
          }
          au_becs_debit?: {
            setup_future_usage?: "none"
          }
          bacs_debit?: {
            setup_future_usage?: "none" | "off_session" | "on_session"
          }
          bancontact?: {
            setup_future_usage?: "none"
          }
          boleto?: {
            expires_after_days?: number
            setup_future_usage?: "none" | "off_session" | "on_session"
          }
          card?: {
            installments?: {
              enabled?: boolean
            }
            setup_future_usage?: "off_session" | "on_session"
            statement_descriptor_suffix_kana?: string
            statement_descriptor_suffix_kanji?: string
          }
          cashapp?: {
            setup_future_usage?: "none" | "off_session" | "on_session"
          }
          customer_balance?: {
            bank_transfer?: {
              eu_bank_transfer?: {
                country: string
              }
              requested_address_types?: (
                | "iban"
                | "sepa"
                | "sort_code"
                | "spei"
                | "zengin"
              )[]
              type:
                | "eu_bank_transfer"
                | "gb_bank_transfer"
                | "jp_bank_transfer"
                | "mx_bank_transfer"
            }
            funding_type?: "bank_transfer"
            setup_future_usage?: "none"
          }
          eps?: {
            setup_future_usage?: "none"
          }
          fpx?: {
            setup_future_usage?: "none"
          }
          giropay?: {
            setup_future_usage?: "none"
          }
          grabpay?: {
            setup_future_usage?: "none"
          }
          ideal?: {
            setup_future_usage?: "none"
          }
          klarna?: {
            setup_future_usage?: "none"
          }
          konbini?: {
            expires_after_days?: number
            setup_future_usage?: "none"
          }
          link?: {
            setup_future_usage?: "none" | "off_session"
          }
          oxxo?: {
            expires_after_days?: number
            setup_future_usage?: "none"
          }
          p24?: {
            setup_future_usage?: "none"
            tos_shown_and_accepted?: boolean
          }
          paynow?: {
            setup_future_usage?: "none"
          }
          pix?: {
            expires_after_seconds?: number
          }
          sepa_debit?: {
            setup_future_usage?: "none" | "off_session" | "on_session"
          }
          sofort?: {
            setup_future_usage?: "none"
          }
          us_bank_account?: {
            financial_connections?: {
              permissions?: (
                | "balances"
                | "ownership"
                | "payment_method"
                | "transactions"
              )[]
            }
            setup_future_usage?: "none" | "off_session" | "on_session"
            verification_method?: "automatic" | "instant"
          }
          wechat_pay?: {
            app_id?: string
            client: "android" | "ios" | "web"
            setup_future_usage?: "none"
          }
        }
        payment_method_types?: (
          | "acss_debit"
          | "affirm"
          | "afterpay_clearpay"
          | "alipay"
          | "au_becs_debit"
          | "bacs_debit"
          | "bancontact"
          | "blik"
          | "boleto"
          | "card"
          | "cashapp"
          | "customer_balance"
          | "eps"
          | "fpx"
          | "giropay"
          | "grabpay"
          | "ideal"
          | "klarna"
          | "konbini"
          | "link"
          | "oxxo"
          | "p24"
          | "paynow"
          | "pix"
          | "promptpay"
          | "sepa_debit"
          | "sofort"
          | "us_bank_account"
          | "wechat_pay"
        )[]
        phone_number_collection?: {
          enabled: boolean
        }
        setup_intent_data?: {
          description?: string
          metadata?: {
            [key: string]: string
          }
          on_behalf_of?: string
        }
        shipping_address_collection?: {
          allowed_countries: (
            | "AC"
            | "AD"
            | "AE"
            | "AF"
            | "AG"
            | "AI"
            | "AL"
            | "AM"
            | "AO"
            | "AQ"
            | "AR"
            | "AT"
            | "AU"
            | "AW"
            | "AX"
            | "AZ"
            | "BA"
            | "BB"
            | "BD"
            | "BE"
            | "BF"
            | "BG"
            | "BH"
            | "BI"
            | "BJ"
            | "BL"
            | "BM"
            | "BN"
            | "BO"
            | "BQ"
            | "BR"
            | "BS"
            | "BT"
            | "BV"
            | "BW"
            | "BY"
            | "BZ"
            | "CA"
            | "CD"
            | "CF"
            | "CG"
            | "CH"
            | "CI"
            | "CK"
            | "CL"
            | "CM"
            | "CN"
            | "CO"
            | "CR"
            | "CV"
            | "CW"
            | "CY"
            | "CZ"
            | "DE"
            | "DJ"
            | "DK"
            | "DM"
            | "DO"
            | "DZ"
            | "EC"
            | "EE"
            | "EG"
            | "EH"
            | "ER"
            | "ES"
            | "ET"
            | "FI"
            | "FJ"
            | "FK"
            | "FO"
            | "FR"
            | "GA"
            | "GB"
            | "GD"
            | "GE"
            | "GF"
            | "GG"
            | "GH"
            | "GI"
            | "GL"
            | "GM"
            | "GN"
            | "GP"
            | "GQ"
            | "GR"
            | "GS"
            | "GT"
            | "GU"
            | "GW"
            | "GY"
            | "HK"
            | "HN"
            | "HR"
            | "HT"
            | "HU"
            | "ID"
            | "IE"
            | "IL"
            | "IM"
            | "IN"
            | "IO"
            | "IQ"
            | "IS"
            | "IT"
            | "JE"
            | "JM"
            | "JO"
            | "JP"
            | "KE"
            | "KG"
            | "KH"
            | "KI"
            | "KM"
            | "KN"
            | "KR"
            | "KW"
            | "KY"
            | "KZ"
            | "LA"
            | "LB"
            | "LC"
            | "LI"
            | "LK"
            | "LR"
            | "LS"
            | "LT"
            | "LU"
            | "LV"
            | "LY"
            | "MA"
            | "MC"
            | "MD"
            | "ME"
            | "MF"
            | "MG"
            | "MK"
            | "ML"
            | "MM"
            | "MN"
            | "MO"
            | "MQ"
            | "MR"
            | "MS"
            | "MT"
            | "MU"
            | "MV"
            | "MW"
            | "MX"
            | "MY"
            | "MZ"
            | "NA"
            | "NC"
            | "NE"
            | "NG"
            | "NI"
            | "NL"
            | "NO"
            | "NP"
            | "NR"
            | "NU"
            | "NZ"
            | "OM"
            | "PA"
            | "PE"
            | "PF"
            | "PG"
            | "PH"
            | "PK"
            | "PL"
            | "PM"
            | "PN"
            | "PR"
            | "PS"
            | "PT"
            | "PY"
            | "QA"
            | "RE"
            | "RO"
            | "RS"
            | "RU"
            | "RW"
            | "SA"
            | "SB"
            | "SC"
            | "SE"
            | "SG"
            | "SH"
            | "SI"
            | "SJ"
            | "SK"
            | "SL"
            | "SM"
            | "SN"
            | "SO"
            | "SR"
            | "SS"
            | "ST"
            | "SV"
            | "SX"
            | "SZ"
            | "TA"
            | "TC"
            | "TD"
            | "TF"
            | "TG"
            | "TH"
            | "TJ"
            | "TK"
            | "TL"
            | "TM"
            | "TN"
            | "TO"
            | "TR"
            | "TT"
            | "TV"
            | "TW"
            | "TZ"
            | "UA"
            | "UG"
            | "US"
            | "UY"
            | "UZ"
            | "VA"
            | "VC"
            | "VE"
            | "VG"
            | "VN"
            | "VU"
            | "WF"
            | "WS"
            | "XK"
            | "YE"
            | "YT"
            | "ZA"
            | "ZM"
            | "ZW"
            | "ZZ"
          )[]
        }
        shipping_options?: {
          shipping_rate?: string
          shipping_rate_data?: {
            delivery_estimate?: {
              maximum?: {
                unit: "business_day" | "day" | "hour" | "month" | "week"
                value: number
              }
              minimum?: {
                unit: "business_day" | "day" | "hour" | "month" | "week"
                value: number
              }
            }
            display_name: string
            fixed_amount?: {
              amount: number
              currency: string
              currency_options?: {
                [key: string]: {
                  amount: number
                  tax_behavior?: "exclusive" | "inclusive" | "unspecified"
                }
              }
            }
            metadata?: {
              [key: string]: string
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            tax_code?: string
            type?: "fixed_amount"
          }
        }[]
        submit_type?: "auto" | "book" | "donate" | "pay"
        subscription_data?: {
          application_fee_percent?: number
          billing_cycle_anchor?: number
          default_tax_rates?: string[]
          description?: string
          metadata?: {
            [key: string]: string
          }
          on_behalf_of?: string
          proration_behavior?: "create_prorations" | "none"
          transfer_data?: {
            amount_percent?: number
            destination: string
          }
          trial_end?: number
          trial_period_days?: number
          trial_settings?: {
            end_behavior: {
              missing_payment_method: "cancel" | "create_invoice" | "pause"
            }
          }
        }
        success_url: string
        tax_id_collection?: {
          enabled: boolean
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_checkout_session> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/checkout/sessions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCheckoutSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_checkout_session> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/checkout/sessions/${p["session"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCheckoutSessionsSessionExpire(
    p: {
      session: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_checkout_session> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/checkout/sessions/${p["session"]}/expire`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCheckoutSessionsSessionLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      session: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/checkout/sessions/${p["session"]}/line_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCountrySpecs(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_country_spec[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/country_specs`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCountrySpecsCountry(
    p: {
      country: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_country_spec> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/country_specs/${p["country"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCoupons(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_coupon[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/coupons`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCoupons(
    p: {
      requestBody?: {
        amount_off?: number
        applies_to?: {
          products?: string[]
        }
        currency?: string
        currency_options?: {
          [key: string]: {
            amount_off: number
          }
        }
        duration?: "forever" | "once" | "repeating"
        duration_in_months?: number
        expand?: string[]
        id?: string
        max_redemptions?: number
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
        percent_off?: number
        redeem_by?: number
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_coupon> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/coupons`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCouponsCoupon(
    p: {
      coupon: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_coupon> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/coupons/${p["coupon"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCouponsCoupon(
    p: {
      coupon: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_coupon> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/coupons/${p["coupon"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCouponsCoupon(
    p: {
      coupon: string
      requestBody?: {
        currency_options?: {
          [key: string]: {
            amount_off: number
          }
        }
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_coupon> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/coupons/${p["coupon"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCreditNotes(
    p: {
      customer?: string
      endingBefore?: string
      expand?: string[]
      invoice?: string
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_credit_note[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/credit_notes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice: p["invoice"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCreditNotes(
    p: {
      requestBody: {
        amount?: number
        credit_amount?: number
        expand?: string[]
        invoice: string
        lines?: {
          amount?: number
          description?: string
          invoice_line_item?: string
          quantity?: number
          tax_rates?: string[] | ""
          type: "custom_line_item" | "invoice_line_item"
          unit_amount?: number
          unit_amount_decimal?: string
        }[]
        memo?: string
        metadata?: {
          [key: string]: string
        }
        out_of_band_amount?: number
        reason?:
          | "duplicate"
          | "fraudulent"
          | "order_change"
          | "product_unsatisfactory"
        refund?: string
        refund_amount?: number
        shipping_cost?: {
          shipping_rate?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_credit_note> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/credit_notes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCreditNotesPreview(
    p: {
      amount?: number
      creditAmount?: number
      expand?: string[]
      invoice: string
      lines?: {
        amount?: number
        description?: string
        invoice_line_item?: string
        quantity?: number
        tax_rates?: string[] | ""
        type: "custom_line_item" | "invoice_line_item"
        unit_amount?: number
        unit_amount_decimal?: string
      }[]
      memo?: string
      metadata?: {
        [key: string]: string
      }
      outOfBandAmount?: number
      reason?:
        | "duplicate"
        | "fraudulent"
        | "order_change"
        | "product_unsatisfactory"
      refund?: string
      refundAmount?: number
      shippingCost?: {
        shipping_rate?: string
      }
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_credit_note> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/credit_notes/preview`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      amount: p["amount"],
      credit_amount: p["creditAmount"],
      expand: p["expand"],
      invoice: p["invoice"],
      lines: p["lines"],
      memo: p["memo"],
      metadata: p["metadata"],
      out_of_band_amount: p["outOfBandAmount"],
      reason: p["reason"],
      refund: p["refund"],
      refund_amount: p["refundAmount"],
      shipping_cost: p["shippingCost"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCreditNotesPreviewLines(
    p: {
      amount?: number
      creditAmount?: number
      endingBefore?: string
      expand?: string[]
      invoice: string
      limit?: number
      lines?: {
        amount?: number
        description?: string
        invoice_line_item?: string
        quantity?: number
        tax_rates?: string[] | ""
        type: "custom_line_item" | "invoice_line_item"
        unit_amount?: number
        unit_amount_decimal?: string
      }[]
      memo?: string
      metadata?: {
        [key: string]: string
      }
      outOfBandAmount?: number
      reason?:
        | "duplicate"
        | "fraudulent"
        | "order_change"
        | "product_unsatisfactory"
      refund?: string
      refundAmount?: number
      shippingCost?: {
        shipping_rate?: string
      }
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_credit_note_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/credit_notes/preview/lines`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      amount: p["amount"],
      credit_amount: p["creditAmount"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice: p["invoice"],
      limit: p["limit"],
      lines: p["lines"],
      memo: p["memo"],
      metadata: p["metadata"],
      out_of_band_amount: p["outOfBandAmount"],
      reason: p["reason"],
      refund: p["refund"],
      refund_amount: p["refundAmount"],
      shipping_cost: p["shippingCost"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCreditNotesCreditNoteLines(
    p: {
      creditNote: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_credit_note_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/credit_notes/${p["creditNote"]}/lines`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCreditNotesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_credit_note> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/credit_notes/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCreditNotesId(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
        memo?: string
        metadata?: {
          [key: string]: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_credit_note> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/credit_notes/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCreditNotesIdVoid(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_credit_note> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/credit_notes/${p["id"]}/void`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomers(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      email?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      testClock?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_customer[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      email: p["email"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      test_clock: p["testClock"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomers(
    p: {
      requestBody?: {
        address?:
          | {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
            }
          | ""
        balance?: number
        cash_balance?: {
          settings?: {
            reconciliation_mode?: "automatic" | "manual" | "merchant_default"
          }
        }
        coupon?: string
        description?: string
        email?: string
        expand?: string[]
        invoice_prefix?: string
        invoice_settings?: {
          custom_fields?:
            | {
                name: string
                value: string
              }[]
            | ""
          default_payment_method?: string
          footer?: string
          rendering_options?:
            | {
                amount_tax_display?:
                  | ""
                  | "exclude_tax"
                  | "include_inclusive_tax"
              }
            | ""
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
        next_invoice_sequence?: number
        payment_method?: string
        phone?: string
        preferred_locales?: string[]
        promotion_code?: string
        shipping?:
          | {
              address: {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
              name: string
              phone?: string
            }
          | ""
        source?: string
        tax?: {
          ip_address?: string | ""
        }
        tax_exempt?: "" | "exempt" | "none" | "reverse"
        tax_id_data?: {
          type:
            | "ae_trn"
            | "au_abn"
            | "au_arn"
            | "bg_uic"
            | "br_cnpj"
            | "br_cpf"
            | "ca_bn"
            | "ca_gst_hst"
            | "ca_pst_bc"
            | "ca_pst_mb"
            | "ca_pst_sk"
            | "ca_qst"
            | "ch_vat"
            | "cl_tin"
            | "eg_tin"
            | "es_cif"
            | "eu_oss_vat"
            | "eu_vat"
            | "gb_vat"
            | "ge_vat"
            | "hk_br"
            | "hu_tin"
            | "id_npwp"
            | "il_vat"
            | "in_gst"
            | "is_vat"
            | "jp_cn"
            | "jp_rn"
            | "jp_trn"
            | "ke_pin"
            | "kr_brn"
            | "li_uid"
            | "mx_rfc"
            | "my_frp"
            | "my_itn"
            | "my_sst"
            | "no_vat"
            | "nz_gst"
            | "ph_tin"
            | "ru_inn"
            | "ru_kpp"
            | "sa_vat"
            | "sg_gst"
            | "sg_uen"
            | "si_tin"
            | "th_vat"
            | "tr_tin"
            | "tw_vat"
            | "ua_vat"
            | "us_ein"
            | "za_vat"
          value: string
        }[]
        test_clock?: string
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_customer> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_customer[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/search`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomer(
    p: {
      customer: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_customer> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomer(
    p: {
      customer: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_customer | t_deleted_customer> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomer(
    p: {
      customer: string
      requestBody?: {
        address?:
          | {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
            }
          | ""
        balance?: number
        bank_account?:
          | {
              account_holder_name?: string
              account_holder_type?: "company" | "individual"
              account_number: string
              country: string
              currency?: string
              object?: "bank_account"
              routing_number?: string
            }
          | string
        card?:
          | {
              address_city?: string
              address_country?: string
              address_line1?: string
              address_line2?: string
              address_state?: string
              address_zip?: string
              cvc?: string
              exp_month: number
              exp_year: number
              metadata?: {
                [key: string]: string
              }
              name?: string
              number: string
              object?: "card"
            }
          | string
        cash_balance?: {
          settings?: {
            reconciliation_mode?: "automatic" | "manual" | "merchant_default"
          }
        }
        coupon?: string
        default_alipay_account?: string
        default_bank_account?: string
        default_card?: string
        default_source?: string
        description?: string
        email?: string
        expand?: string[]
        invoice_prefix?: string
        invoice_settings?: {
          custom_fields?:
            | {
                name: string
                value: string
              }[]
            | ""
          default_payment_method?: string
          footer?: string
          rendering_options?:
            | {
                amount_tax_display?:
                  | ""
                  | "exclude_tax"
                  | "include_inclusive_tax"
              }
            | ""
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
        next_invoice_sequence?: number
        phone?: string
        preferred_locales?: string[]
        promotion_code?: string
        shipping?:
          | {
              address: {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
              name: string
              phone?: string
            }
          | ""
        source?: string
        tax?: {
          ip_address?: string | ""
        }
        tax_exempt?: "" | "exempt" | "none" | "reverse"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_customer> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerBalanceTransactions(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_customer_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/balance_transactions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerBalanceTransactions(
    p: {
      customer: string
      requestBody: {
        amount: number
        currency: string
        description?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_customer_balance_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/balance_transactions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerBalanceTransactionsTransaction(
    p: {
      customer: string
      expand?: string[]
      transaction: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_customer_balance_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/balance_transactions/${p["transaction"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerBalanceTransactionsTransaction(
    p: {
      customer: string
      transaction: string
      requestBody?: {
        description?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_customer_balance_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/balance_transactions/${p["transaction"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerBankAccounts(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_bank_account[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/bank_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerBankAccounts(
    p: {
      customer: string
      requestBody?: {
        alipay_account?: string
        bank_account?:
          | {
              account_holder_name?: string
              account_holder_type?: "company" | "individual"
              account_number: string
              country: string
              currency?: string
              object?: "bank_account"
              routing_number?: string
            }
          | string
        card?:
          | {
              address_city?: string
              address_country?: string
              address_line1?: string
              address_line2?: string
              address_state?: string
              address_zip?: string
              cvc?: string
              exp_month: number
              exp_year: number
              metadata?: {
                [key: string]: string
              }
              name?: string
              number: string
              object?: "card"
            }
          | string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        source?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_source> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/bank_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomerBankAccountsId(
    p: {
      customer: string
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_payment_source | t_deleted_payment_source>
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerBankAccountsId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_bank_account> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerBankAccountsId(
    p: {
      customer: string
      id: string
      requestBody?: {
        account_holder_name?: string
        account_holder_type?: "company" | "individual"
        address_city?: string
        address_country?: string
        address_line1?: string
        address_line2?: string
        address_state?: string
        address_zip?: string
        exp_month?: string
        exp_year?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
        owner?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          email?: string
          name?: string
          phone?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_card | t_bank_account | t_source> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerBankAccountsIdVerify(
    p: {
      customer: string
      id: string
      requestBody?: {
        amounts?: number[]
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_bank_account> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}/verify`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerCards(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_card[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cards`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerCards(
    p: {
      customer: string
      requestBody?: {
        alipay_account?: string
        bank_account?:
          | {
              account_holder_name?: string
              account_holder_type?: "company" | "individual"
              account_number: string
              country: string
              currency?: string
              object?: "bank_account"
              routing_number?: string
            }
          | string
        card?:
          | {
              address_city?: string
              address_country?: string
              address_line1?: string
              address_line2?: string
              address_state?: string
              address_zip?: string
              cvc?: string
              exp_month: number
              exp_year: number
              metadata?: {
                [key: string]: string
              }
              name?: string
              number: string
              object?: "card"
            }
          | string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        source?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_source> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cards`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomerCardsId(
    p: {
      customer: string
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_payment_source | t_deleted_payment_source>
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cards/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerCardsId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_card> | Res<StatusCode, t_error>>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cards/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerCardsId(
    p: {
      customer: string
      id: string
      requestBody?: {
        account_holder_name?: string
        account_holder_type?: "company" | "individual"
        address_city?: string
        address_country?: string
        address_line1?: string
        address_line2?: string
        address_state?: string
        address_zip?: string
        exp_month?: string
        exp_year?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
        owner?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          email?: string
          name?: string
          phone?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_card | t_bank_account | t_source> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cards/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerCashBalance(
    p: {
      customer: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_cash_balance> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cash_balance`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerCashBalance(
    p: {
      customer: string
      requestBody?: {
        expand?: string[]
        settings?: {
          reconciliation_mode?: "automatic" | "manual" | "merchant_default"
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_cash_balance> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cash_balance`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerCashBalanceTransactions(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_customer_cash_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cash_balance_transactions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerCashBalanceTransactionsTransaction(
    p: {
      customer: string
      expand?: string[]
      transaction: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_customer_cash_balance_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/cash_balance_transactions/${p["transaction"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomerDiscount(
    p: {
      customer: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_discount> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/discount`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerDiscount(
    p: {
      customer: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_discount> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/discount`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerFundingInstructions(
    p: {
      customer: string
      requestBody: {
        bank_transfer: {
          eu_bank_transfer?: {
            country: string
          }
          requested_address_types?: ("iban" | "sort_code" | "spei" | "zengin")[]
          type:
            | "eu_bank_transfer"
            | "gb_bank_transfer"
            | "jp_bank_transfer"
            | "mx_bank_transfer"
        }
        currency: string
        expand?: string[]
        funding_type: "bank_transfer"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_funding_instructions> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/funding_instructions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerPaymentMethods(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?:
        | "acss_debit"
        | "affirm"
        | "afterpay_clearpay"
        | "alipay"
        | "au_becs_debit"
        | "bacs_debit"
        | "bancontact"
        | "blik"
        | "boleto"
        | "card"
        | "cashapp"
        | "customer_balance"
        | "eps"
        | "fpx"
        | "giropay"
        | "grabpay"
        | "ideal"
        | "klarna"
        | "konbini"
        | "link"
        | "oxxo"
        | "p24"
        | "paynow"
        | "pix"
        | "promptpay"
        | "sepa_debit"
        | "sofort"
        | "us_bank_account"
        | "wechat_pay"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_payment_method[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/payment_methods`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerPaymentMethodsPaymentMethod(
    p: {
      customer: string
      expand?: string[]
      paymentMethod: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_method> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/payment_methods/${p["paymentMethod"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerSources(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      object?: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: (t_bank_account | t_card | t_source)[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/sources`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      object: p["object"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerSources(
    p: {
      customer: string
      requestBody?: {
        alipay_account?: string
        bank_account?:
          | {
              account_holder_name?: string
              account_holder_type?: "company" | "individual"
              account_number: string
              country: string
              currency?: string
              object?: "bank_account"
              routing_number?: string
            }
          | string
        card?:
          | {
              address_city?: string
              address_country?: string
              address_line1?: string
              address_line2?: string
              address_state?: string
              address_zip?: string
              cvc?: string
              exp_month: number
              exp_year: number
              metadata?: {
                [key: string]: string
              }
              name?: string
              number: string
              object?: "card"
            }
          | string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        source?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_source> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/sources`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomerSourcesId(
    p: {
      customer: string
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_payment_source | t_deleted_payment_source>
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerSourcesId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_source> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerSourcesId(
    p: {
      customer: string
      id: string
      requestBody?: {
        account_holder_name?: string
        account_holder_type?: "company" | "individual"
        address_city?: string
        address_country?: string
        address_line1?: string
        address_line2?: string
        address_state?: string
        address_zip?: string
        exp_month?: string
        exp_year?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
        owner?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          email?: string
          name?: string
          phone?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_card | t_bank_account | t_source> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerSourcesIdVerify(
    p: {
      customer: string
      id: string
      requestBody?: {
        amounts?: number[]
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_bank_account> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}/verify`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerSubscriptions(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_subscription[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/subscriptions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerSubscriptions(
    p: {
      customer: string
      requestBody?: {
        add_invoice_items?: {
          price?: string
          price_data?: {
            currency: string
            product: string
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        application_fee_percent?: number
        automatic_tax?: {
          enabled: boolean
        }
        backdate_start_date?: number
        billing_cycle_anchor?: number
        billing_thresholds?:
          | {
              amount_gte?: number
              reset_billing_cycle_anchor?: boolean
            }
          | ""
        cancel_at?: number
        cancel_at_period_end?: boolean
        collection_method?: "charge_automatically" | "send_invoice"
        coupon?: string
        currency?: string
        days_until_due?: number
        default_payment_method?: string
        default_source?: string
        default_tax_rates?: string[] | ""
        expand?: string[]
        items?: {
          billing_thresholds?:
            | {
                usage_gte: number
              }
            | ""
          metadata?: {
            [key: string]: string
          }
          price?: string
          price_data?: {
            currency: string
            product: string
            recurring: {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        off_session?: boolean
        payment_behavior?:
          | "allow_incomplete"
          | "default_incomplete"
          | "error_if_incomplete"
          | "pending_if_incomplete"
        payment_settings?: {
          payment_method_options?: {
            acss_debit?:
              | {
                  mandate_options?: {
                    transaction_type?: "business" | "personal"
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
            bancontact?:
              | {
                  preferred_language?: "de" | "en" | "fr" | "nl"
                }
              | ""
            card?:
              | {
                  mandate_options?: {
                    amount?: number
                    amount_type?: "fixed" | "maximum"
                    description?: string
                  }
                  network?:
                    | "amex"
                    | "cartes_bancaires"
                    | "diners"
                    | "discover"
                    | "interac"
                    | "jcb"
                    | "mastercard"
                    | "unionpay"
                    | "unknown"
                    | "visa"
                  request_three_d_secure?: "any" | "automatic"
                }
              | ""
            customer_balance?:
              | {
                  bank_transfer?: {
                    eu_bank_transfer?: {
                      country: string
                    }
                    type?: string
                  }
                  funding_type?: string
                }
              | ""
            konbini?: EmptyObject | ""
            us_bank_account?:
              | {
                  financial_connections?: {
                    permissions?: (
                      | "balances"
                      | "ownership"
                      | "payment_method"
                      | "transactions"
                    )[]
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
          }
          payment_method_types?:
            | (
                | "ach_credit_transfer"
                | "ach_debit"
                | "acss_debit"
                | "au_becs_debit"
                | "bacs_debit"
                | "bancontact"
                | "boleto"
                | "card"
                | "cashapp"
                | "customer_balance"
                | "fpx"
                | "giropay"
                | "grabpay"
                | "ideal"
                | "konbini"
                | "link"
                | "paynow"
                | "promptpay"
                | "sepa_debit"
                | "sofort"
                | "us_bank_account"
                | "wechat_pay"
              )[]
            | ""
          save_default_payment_method?: "off" | "on_subscription"
        }
        pending_invoice_item_interval?:
          | {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
          | ""
        promotion_code?: string
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        transfer_data?: {
          amount_percent?: number
          destination: string
        }
        trial_end?: "now" | number
        trial_from_plan?: boolean
        trial_period_days?: number
        trial_settings?: {
          end_behavior: {
            missing_payment_method: "cancel" | "create_invoice" | "pause"
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/subscriptions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomerSubscriptionsSubscriptionExposedId(
    p: {
      customer: string
      subscriptionExposedId: string
      requestBody?: {
        expand?: string[]
        invoice_now?: boolean
        prorate?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerSubscriptionsSubscriptionExposedId(
    p: {
      customer: string
      expand?: string[]
      subscriptionExposedId: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerSubscriptionsSubscriptionExposedId(
    p: {
      customer: string
      subscriptionExposedId: string
      requestBody?: {
        add_invoice_items?: {
          price?: string
          price_data?: {
            currency: string
            product: string
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        application_fee_percent?: number
        automatic_tax?: {
          enabled: boolean
        }
        billing_cycle_anchor?: "now" | "unchanged"
        billing_thresholds?:
          | {
              amount_gte?: number
              reset_billing_cycle_anchor?: boolean
            }
          | ""
        cancel_at?: number | ""
        cancel_at_period_end?: boolean
        cancellation_details?: {
          comment?: string
          feedback?:
            | ""
            | "customer_service"
            | "low_quality"
            | "missing_features"
            | "other"
            | "switched_service"
            | "too_complex"
            | "too_expensive"
            | "unused"
        }
        collection_method?: "charge_automatically" | "send_invoice"
        coupon?: string
        days_until_due?: number
        default_payment_method?: string
        default_source?: string
        default_tax_rates?: string[] | ""
        expand?: string[]
        items?: {
          billing_thresholds?:
            | {
                usage_gte: number
              }
            | ""
          clear_usage?: boolean
          deleted?: boolean
          id?: string
          metadata?:
            | {
                [key: string]: string
              }
            | ""
          price?: string
          price_data?: {
            currency: string
            product: string
            recurring: {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        off_session?: boolean
        pause_collection?:
          | {
              behavior: "keep_as_draft" | "mark_uncollectible" | "void"
              resumes_at?: number
            }
          | ""
        payment_behavior?:
          | "allow_incomplete"
          | "default_incomplete"
          | "error_if_incomplete"
          | "pending_if_incomplete"
        payment_settings?: {
          payment_method_options?: {
            acss_debit?:
              | {
                  mandate_options?: {
                    transaction_type?: "business" | "personal"
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
            bancontact?:
              | {
                  preferred_language?: "de" | "en" | "fr" | "nl"
                }
              | ""
            card?:
              | {
                  mandate_options?: {
                    amount?: number
                    amount_type?: "fixed" | "maximum"
                    description?: string
                  }
                  network?:
                    | "amex"
                    | "cartes_bancaires"
                    | "diners"
                    | "discover"
                    | "interac"
                    | "jcb"
                    | "mastercard"
                    | "unionpay"
                    | "unknown"
                    | "visa"
                  request_three_d_secure?: "any" | "automatic"
                }
              | ""
            customer_balance?:
              | {
                  bank_transfer?: {
                    eu_bank_transfer?: {
                      country: string
                    }
                    type?: string
                  }
                  funding_type?: string
                }
              | ""
            konbini?: EmptyObject | ""
            us_bank_account?:
              | {
                  financial_connections?: {
                    permissions?: (
                      | "balances"
                      | "ownership"
                      | "payment_method"
                      | "transactions"
                    )[]
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
          }
          payment_method_types?:
            | (
                | "ach_credit_transfer"
                | "ach_debit"
                | "acss_debit"
                | "au_becs_debit"
                | "bacs_debit"
                | "bancontact"
                | "boleto"
                | "card"
                | "cashapp"
                | "customer_balance"
                | "fpx"
                | "giropay"
                | "grabpay"
                | "ideal"
                | "konbini"
                | "link"
                | "paynow"
                | "promptpay"
                | "sepa_debit"
                | "sofort"
                | "us_bank_account"
                | "wechat_pay"
              )[]
            | ""
          save_default_payment_method?: "off" | "on_subscription"
        }
        pending_invoice_item_interval?:
          | {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
          | ""
        promotion_code?: string
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        proration_date?: number
        transfer_data?:
          | {
              amount_percent?: number
              destination: string
            }
          | ""
        trial_end?: "now" | number
        trial_from_plan?: boolean
        trial_settings?: {
          end_behavior: {
            missing_payment_method: "cancel" | "create_invoice" | "pause"
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
    p: {
      customer: string
      subscriptionExposedId: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_discount> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}/discount`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
    p: {
      customer: string
      expand?: string[]
      subscriptionExposedId: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_discount> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}/discount`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerTaxIds(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_tax_id[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/tax_ids`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postCustomersCustomerTaxIds(
    p: {
      customer: string
      requestBody: {
        expand?: string[]
        type:
          | "ae_trn"
          | "au_abn"
          | "au_arn"
          | "bg_uic"
          | "br_cnpj"
          | "br_cpf"
          | "ca_bn"
          | "ca_gst_hst"
          | "ca_pst_bc"
          | "ca_pst_mb"
          | "ca_pst_sk"
          | "ca_qst"
          | "ch_vat"
          | "cl_tin"
          | "eg_tin"
          | "es_cif"
          | "eu_oss_vat"
          | "eu_vat"
          | "gb_vat"
          | "ge_vat"
          | "hk_br"
          | "hu_tin"
          | "id_npwp"
          | "il_vat"
          | "in_gst"
          | "is_vat"
          | "jp_cn"
          | "jp_rn"
          | "jp_trn"
          | "ke_pin"
          | "kr_brn"
          | "li_uid"
          | "mx_rfc"
          | "my_frp"
          | "my_itn"
          | "my_sst"
          | "no_vat"
          | "nz_gst"
          | "ph_tin"
          | "ru_inn"
          | "ru_kpp"
          | "sa_vat"
          | "sg_gst"
          | "sg_uen"
          | "si_tin"
          | "th_vat"
          | "tr_tin"
          | "tw_vat"
          | "ua_vat"
          | "us_ein"
          | "za_vat"
        value: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_id> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/tax_ids`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteCustomersCustomerTaxIdsId(
    p: {
      customer: string
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_tax_id> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/tax_ids/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getCustomersCustomerTaxIdsId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_id> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/tax_ids/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getDisputes(
    p: {
      charge?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_dispute[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/disputes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      charge: p["charge"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getDisputesDispute(
    p: {
      dispute: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/disputes/${p["dispute"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postDisputesDispute(
    p: {
      dispute: string
      requestBody?: {
        evidence?: {
          access_activity_log?: string
          billing_address?: string
          cancellation_policy?: string
          cancellation_policy_disclosure?: string
          cancellation_rebuttal?: string
          customer_communication?: string
          customer_email_address?: string
          customer_name?: string
          customer_purchase_ip?: string
          customer_signature?: string
          duplicate_charge_documentation?: string
          duplicate_charge_explanation?: string
          duplicate_charge_id?: string
          product_description?: string
          receipt?: string
          refund_policy?: string
          refund_policy_disclosure?: string
          refund_refusal_explanation?: string
          service_date?: string
          service_documentation?: string
          shipping_address?: string
          shipping_carrier?: string
          shipping_date?: string
          shipping_documentation?: string
          shipping_tracking_number?: string
          uncategorized_file?: string
          uncategorized_text?: string
        }
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        submit?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/disputes/${p["dispute"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postDisputesDisputeClose(
    p: {
      dispute: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/disputes/${p["dispute"]}/close`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postEphemeralKeys(
    p: {
      requestBody?: {
        customer?: string
        expand?: string[]
        issuing_card?: string
        verification_session?: string
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_ephemeral_key> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/ephemeral_keys`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteEphemeralKeysKey(
    p: {
      key: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_ephemeral_key> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/ephemeral_keys/${p["key"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getEvents(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      deliverySuccess?: boolean
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?: string
      types?: string[]
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_event[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/events`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      delivery_success: p["deliverySuccess"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
      types: p["types"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getEventsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/events/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getExchangeRates(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_exchange_rate[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/exchange_rates`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getExchangeRatesRateId(
    p: {
      expand?: string[]
      rateId: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_exchange_rate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/exchange_rates/${p["rateId"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFileLinks(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      expired?: boolean
      file?: string
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_file_link[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/file_links`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      expired: p["expired"],
      file: p["file"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postFileLinks(
    p: {
      requestBody: {
        expand?: string[]
        expires_at?: number
        file: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_file_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/file_links`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFileLinksLink(
    p: {
      expand?: string[]
      link: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_file_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/file_links/${p["link"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postFileLinksLink(
    p: {
      link: string
      requestBody?: {
        expand?: string[]
        expires_at?: "now" | number | ""
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_file_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/file_links/${p["link"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFiles(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      purpose?:
        | "account_requirement"
        | "additional_verification"
        | "business_icon"
        | "business_logo"
        | "customer_signature"
        | "dispute_evidence"
        | "document_provider_identity_document"
        | "finance_report_run"
        | "identity_document"
        | "identity_document_downloadable"
        | "pci_document"
        | "selfie"
        | "sigma_scheduled_query"
        | "tax_document_user_upload"
        | "terminal_reader_splashscreen"
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_file[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/files`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      purpose: p["purpose"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postFiles(
    p: {
      requestBody: {
        expand?: string[]
        file: string
        file_link_data?: {
          create: boolean
          expires_at?: number
          metadata?:
            | {
                [key: string]: string
              }
            | ""
        }
        purpose:
          | "account_requirement"
          | "additional_verification"
          | "business_icon"
          | "business_logo"
          | "customer_signature"
          | "dispute_evidence"
          | "identity_document"
          | "pci_document"
          | "tax_document_user_upload"
          | "terminal_reader_splashscreen"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_file> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/files`
    const headers = this._headers({ "Content-Type": "multipart/form-data" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFilesFile(
    p: {
      expand?: string[]
      file: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_file> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/files/${p["file"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFinancialConnectionsAccounts(
    p: {
      accountHolder?: {
        account?: string
        customer?: string
      }
      endingBefore?: string
      expand?: string[]
      limit?: number
      session?: string
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_financial_connections_account[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/financial_connections/accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      account_holder: p["accountHolder"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      session: p["session"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFinancialConnectionsAccountsAccount(
    p: {
      account: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/financial_connections/accounts/${p["account"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postFinancialConnectionsAccountsAccountDisconnect(
    p: {
      account: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/disconnect`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFinancialConnectionsAccountsAccountOwners(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      ownership: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_financial_connections_account_owner[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/owners`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      ownership: p["ownership"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postFinancialConnectionsAccountsAccountRefresh(
    p: {
      account: string
      requestBody: {
        expand?: string[]
        features: ("balance" | "ownership")[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/refresh`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postFinancialConnectionsSessions(
    p: {
      requestBody: {
        account_holder: {
          account?: string
          customer?: string
          type: "account" | "customer"
        }
        expand?: string[]
        filters?: {
          countries: string[]
        }
        permissions: (
          | "balances"
          | "ownership"
          | "payment_method"
          | "transactions"
        )[]
        return_url?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/financial_connections/sessions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getFinancialConnectionsSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/financial_connections/sessions/${p["session"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIdentityVerificationReports(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?: "document" | "id_number"
      verificationSession?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_identity_verification_report[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/identity/verification_reports`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
      verification_session: p["verificationSession"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIdentityVerificationReportsReport(
    p: {
      expand?: string[]
      report: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_identity_verification_report> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/identity/verification_reports/${p["report"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIdentityVerificationSessions(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "canceled" | "processing" | "requires_input" | "verified"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_identity_verification_session[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/identity/verification_sessions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIdentityVerificationSessions(
    p: {
      requestBody: {
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        options?: {
          document?:
            | {
                allowed_types?: ("driving_license" | "id_card" | "passport")[]
                require_id_number?: boolean
                require_live_capture?: boolean
                require_matching_selfie?: boolean
              }
            | ""
        }
        return_url?: string
        type: "document" | "id_number"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/identity/verification_sessions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIdentityVerificationSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/identity/verification_sessions/${p["session"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIdentityVerificationSessionsSession(
    p: {
      session: string
      requestBody?: {
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        options?: {
          document?:
            | {
                allowed_types?: ("driving_license" | "id_card" | "passport")[]
                require_id_number?: boolean
                require_live_capture?: boolean
                require_matching_selfie?: boolean
              }
            | ""
        }
        type?: "document" | "id_number"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/identity/verification_sessions/${p["session"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIdentityVerificationSessionsSessionCancel(
    p: {
      session: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/identity/verification_sessions/${p["session"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIdentityVerificationSessionsSessionRedact(
    p: {
      session: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/identity/verification_sessions/${p["session"]}/redact`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoiceitems(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      invoice?: string
      limit?: number
      pending?: boolean
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_invoiceitem[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/invoiceitems`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice: p["invoice"],
      limit: p["limit"],
      pending: p["pending"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoiceitems(
    p: {
      requestBody: {
        amount?: number
        currency?: string
        customer: string
        description?: string
        discountable?: boolean
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        expand?: string[]
        invoice?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        period?: {
          end: number
          start: number
        }
        price?: string
        price_data?: {
          currency: string
          product: string
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        quantity?: number
        subscription?: string
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
        tax_code?: string | ""
        tax_rates?: string[]
        unit_amount?: number
        unit_amount_decimal?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoiceitem> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoiceitems`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteInvoiceitemsInvoiceitem(
    p: {
      invoiceitem: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_invoiceitem> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/invoiceitems/${p["invoiceitem"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoiceitemsInvoiceitem(
    p: {
      expand?: string[]
      invoiceitem: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoiceitem> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoiceitems/${p["invoiceitem"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoiceitemsInvoiceitem(
    p: {
      invoiceitem: string
      requestBody?: {
        amount?: number
        description?: string
        discountable?: boolean
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        period?: {
          end: number
          start: number
        }
        price?: string
        price_data?: {
          currency: string
          product: string
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        quantity?: number
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
        tax_code?: string | ""
        tax_rates?: string[] | ""
        unit_amount?: number
        unit_amount_decimal?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoiceitem> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoiceitems/${p["invoiceitem"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoices(
    p: {
      collectionMethod?: "charge_automatically" | "send_invoice"
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      dueDate?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "draft" | "open" | "paid" | "uncollectible" | "void"
      subscription?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_invoice[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/invoices`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      collection_method: p["collectionMethod"],
      created: p["created"],
      customer: p["customer"],
      due_date: p["dueDate"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      subscription: p["subscription"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoices(
    p: {
      requestBody?: {
        account_tax_ids?: string[] | ""
        application_fee_amount?: number
        auto_advance?: boolean
        automatic_tax?: {
          enabled: boolean
        }
        collection_method?: "charge_automatically" | "send_invoice"
        currency?: string
        custom_fields?:
          | {
              name: string
              value: string
            }[]
          | ""
        customer?: string
        days_until_due?: number
        default_payment_method?: string
        default_source?: string
        default_tax_rates?: string[]
        description?: string
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        due_date?: number
        expand?: string[]
        footer?: string
        from_invoice?: {
          action: "revision"
          invoice: string
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        on_behalf_of?: string
        payment_settings?: {
          default_mandate?: string
          payment_method_options?: {
            acss_debit?:
              | {
                  mandate_options?: {
                    transaction_type?: "business" | "personal"
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
            bancontact?:
              | {
                  preferred_language?: "de" | "en" | "fr" | "nl"
                }
              | ""
            card?:
              | {
                  installments?: {
                    enabled?: boolean
                    plan?:
                      | {
                          count: number
                          interval: "month"
                          type: "fixed_count"
                        }
                      | ""
                  }
                  request_three_d_secure?: "any" | "automatic"
                }
              | ""
            customer_balance?:
              | {
                  bank_transfer?: {
                    eu_bank_transfer?: {
                      country: string
                    }
                    type?: string
                  }
                  funding_type?: string
                }
              | ""
            konbini?: EmptyObject | ""
            us_bank_account?:
              | {
                  financial_connections?: {
                    permissions?: (
                      | "balances"
                      | "ownership"
                      | "payment_method"
                      | "transactions"
                    )[]
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
          }
          payment_method_types?:
            | (
                | "ach_credit_transfer"
                | "ach_debit"
                | "acss_debit"
                | "au_becs_debit"
                | "bacs_debit"
                | "bancontact"
                | "boleto"
                | "card"
                | "cashapp"
                | "customer_balance"
                | "fpx"
                | "giropay"
                | "grabpay"
                | "ideal"
                | "konbini"
                | "link"
                | "paynow"
                | "promptpay"
                | "sepa_debit"
                | "sofort"
                | "us_bank_account"
                | "wechat_pay"
              )[]
            | ""
        }
        pending_invoice_items_behavior?:
          | "exclude"
          | "include"
          | "include_and_require"
        rendering_options?:
          | {
              amount_tax_display?: "" | "exclude_tax" | "include_inclusive_tax"
            }
          | ""
        shipping_cost?: {
          shipping_rate?: string
          shipping_rate_data?: {
            delivery_estimate?: {
              maximum?: {
                unit: "business_day" | "day" | "hour" | "month" | "week"
                value: number
              }
              minimum?: {
                unit: "business_day" | "day" | "hour" | "month" | "week"
                value: number
              }
            }
            display_name: string
            fixed_amount?: {
              amount: number
              currency: string
              currency_options?: {
                [key: string]: {
                  amount: number
                  tax_behavior?: "exclusive" | "inclusive" | "unspecified"
                }
              }
            }
            metadata?: {
              [key: string]: string
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            tax_code?: string
            type?: "fixed_amount"
          }
        }
        shipping_details?: {
          address: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          name: string
          phone?: string
        }
        statement_descriptor?: string
        subscription?: string
        transfer_data?: {
          amount?: number
          destination: string
        }
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoicesSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_invoice[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/invoices/search`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoicesUpcoming(
    p: {
      automaticTax?: {
        enabled: boolean
      }
      coupon?: string
      currency?: string
      customer?: string
      customerDetails?: {
        address?:
          | {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
            }
          | ""
        shipping?:
          | {
              address: {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
              name: string
              phone?: string
            }
          | ""
        tax?: {
          ip_address?: string | ""
        }
        tax_exempt?: "" | "exempt" | "none" | "reverse"
        tax_ids?: {
          type:
            | "ae_trn"
            | "au_abn"
            | "au_arn"
            | "bg_uic"
            | "br_cnpj"
            | "br_cpf"
            | "ca_bn"
            | "ca_gst_hst"
            | "ca_pst_bc"
            | "ca_pst_mb"
            | "ca_pst_sk"
            | "ca_qst"
            | "ch_vat"
            | "cl_tin"
            | "eg_tin"
            | "es_cif"
            | "eu_oss_vat"
            | "eu_vat"
            | "gb_vat"
            | "ge_vat"
            | "hk_br"
            | "hu_tin"
            | "id_npwp"
            | "il_vat"
            | "in_gst"
            | "is_vat"
            | "jp_cn"
            | "jp_rn"
            | "jp_trn"
            | "ke_pin"
            | "kr_brn"
            | "li_uid"
            | "mx_rfc"
            | "my_frp"
            | "my_itn"
            | "my_sst"
            | "no_vat"
            | "nz_gst"
            | "ph_tin"
            | "ru_inn"
            | "ru_kpp"
            | "sa_vat"
            | "sg_gst"
            | "sg_uen"
            | "si_tin"
            | "th_vat"
            | "tr_tin"
            | "tw_vat"
            | "ua_vat"
            | "us_ein"
            | "za_vat"
          value: string
        }[]
      }
      discounts?:
        | {
            coupon?: string
            discount?: string
          }[]
        | ""
      expand?: string[]
      invoiceItems?: {
        amount?: number
        currency?: string
        description?: string
        discountable?: boolean
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        invoiceitem?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        period?: {
          end: number
          start: number
        }
        price?: string
        price_data?: {
          currency: string
          product: string
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        quantity?: number
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
        tax_code?: string | ""
        tax_rates?: string[] | ""
        unit_amount?: number
        unit_amount_decimal?: string
      }[]
      schedule?: string
      subscription?: string
      subscriptionBillingCycleAnchor?: "now" | "unchanged" | number
      subscriptionCancelAt?: number | ""
      subscriptionCancelAtPeriodEnd?: boolean
      subscriptionCancelNow?: boolean
      subscriptionDefaultTaxRates?: string[] | ""
      subscriptionItems?: {
        billing_thresholds?:
          | {
              usage_gte: number
            }
          | ""
        clear_usage?: boolean
        deleted?: boolean
        id?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        price?: string
        price_data?: {
          currency: string
          product: string
          recurring: {
            interval: "day" | "month" | "week" | "year"
            interval_count?: number
          }
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        quantity?: number
        tax_rates?: string[] | ""
      }[]
      subscriptionProrationBehavior?:
        | "always_invoice"
        | "create_prorations"
        | "none"
      subscriptionProrationDate?: number
      subscriptionResumeAt?: "now"
      subscriptionStartDate?: number
      subscriptionTrialEnd?: "now" | number
      subscriptionTrialFromPlan?: boolean
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/upcoming`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      automatic_tax: p["automaticTax"],
      coupon: p["coupon"],
      currency: p["currency"],
      customer: p["customer"],
      customer_details: p["customerDetails"],
      discounts: p["discounts"],
      expand: p["expand"],
      invoice_items: p["invoiceItems"],
      schedule: p["schedule"],
      subscription: p["subscription"],
      subscription_billing_cycle_anchor: p["subscriptionBillingCycleAnchor"],
      subscription_cancel_at: p["subscriptionCancelAt"],
      subscription_cancel_at_period_end: p["subscriptionCancelAtPeriodEnd"],
      subscription_cancel_now: p["subscriptionCancelNow"],
      subscription_default_tax_rates: p["subscriptionDefaultTaxRates"],
      subscription_items: p["subscriptionItems"],
      subscription_proration_behavior: p["subscriptionProrationBehavior"],
      subscription_proration_date: p["subscriptionProrationDate"],
      subscription_resume_at: p["subscriptionResumeAt"],
      subscription_start_date: p["subscriptionStartDate"],
      subscription_trial_end: p["subscriptionTrialEnd"],
      subscription_trial_from_plan: p["subscriptionTrialFromPlan"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoicesUpcomingLines(
    p: {
      automaticTax?: {
        enabled: boolean
      }
      coupon?: string
      currency?: string
      customer?: string
      customerDetails?: {
        address?:
          | {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
            }
          | ""
        shipping?:
          | {
              address: {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
              name: string
              phone?: string
            }
          | ""
        tax?: {
          ip_address?: string | ""
        }
        tax_exempt?: "" | "exempt" | "none" | "reverse"
        tax_ids?: {
          type:
            | "ae_trn"
            | "au_abn"
            | "au_arn"
            | "bg_uic"
            | "br_cnpj"
            | "br_cpf"
            | "ca_bn"
            | "ca_gst_hst"
            | "ca_pst_bc"
            | "ca_pst_mb"
            | "ca_pst_sk"
            | "ca_qst"
            | "ch_vat"
            | "cl_tin"
            | "eg_tin"
            | "es_cif"
            | "eu_oss_vat"
            | "eu_vat"
            | "gb_vat"
            | "ge_vat"
            | "hk_br"
            | "hu_tin"
            | "id_npwp"
            | "il_vat"
            | "in_gst"
            | "is_vat"
            | "jp_cn"
            | "jp_rn"
            | "jp_trn"
            | "ke_pin"
            | "kr_brn"
            | "li_uid"
            | "mx_rfc"
            | "my_frp"
            | "my_itn"
            | "my_sst"
            | "no_vat"
            | "nz_gst"
            | "ph_tin"
            | "ru_inn"
            | "ru_kpp"
            | "sa_vat"
            | "sg_gst"
            | "sg_uen"
            | "si_tin"
            | "th_vat"
            | "tr_tin"
            | "tw_vat"
            | "ua_vat"
            | "us_ein"
            | "za_vat"
          value: string
        }[]
      }
      discounts?:
        | {
            coupon?: string
            discount?: string
          }[]
        | ""
      endingBefore?: string
      expand?: string[]
      invoiceItems?: {
        amount?: number
        currency?: string
        description?: string
        discountable?: boolean
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        invoiceitem?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        period?: {
          end: number
          start: number
        }
        price?: string
        price_data?: {
          currency: string
          product: string
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        quantity?: number
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
        tax_code?: string | ""
        tax_rates?: string[] | ""
        unit_amount?: number
        unit_amount_decimal?: string
      }[]
      limit?: number
      schedule?: string
      startingAfter?: string
      subscription?: string
      subscriptionBillingCycleAnchor?: "now" | "unchanged" | number
      subscriptionCancelAt?: number | ""
      subscriptionCancelAtPeriodEnd?: boolean
      subscriptionCancelNow?: boolean
      subscriptionDefaultTaxRates?: string[] | ""
      subscriptionItems?: {
        billing_thresholds?:
          | {
              usage_gte: number
            }
          | ""
        clear_usage?: boolean
        deleted?: boolean
        id?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        price?: string
        price_data?: {
          currency: string
          product: string
          recurring: {
            interval: "day" | "month" | "week" | "year"
            interval_count?: number
          }
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        quantity?: number
        tax_rates?: string[] | ""
      }[]
      subscriptionProrationBehavior?:
        | "always_invoice"
        | "create_prorations"
        | "none"
      subscriptionProrationDate?: number
      subscriptionResumeAt?: "now"
      subscriptionStartDate?: number
      subscriptionTrialEnd?: "now" | number
      subscriptionTrialFromPlan?: boolean
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/invoices/upcoming/lines`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      automatic_tax: p["automaticTax"],
      coupon: p["coupon"],
      currency: p["currency"],
      customer: p["customer"],
      customer_details: p["customerDetails"],
      discounts: p["discounts"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice_items: p["invoiceItems"],
      limit: p["limit"],
      schedule: p["schedule"],
      starting_after: p["startingAfter"],
      subscription: p["subscription"],
      subscription_billing_cycle_anchor: p["subscriptionBillingCycleAnchor"],
      subscription_cancel_at: p["subscriptionCancelAt"],
      subscription_cancel_at_period_end: p["subscriptionCancelAtPeriodEnd"],
      subscription_cancel_now: p["subscriptionCancelNow"],
      subscription_default_tax_rates: p["subscriptionDefaultTaxRates"],
      subscription_items: p["subscriptionItems"],
      subscription_proration_behavior: p["subscriptionProrationBehavior"],
      subscription_proration_date: p["subscriptionProrationDate"],
      subscription_resume_at: p["subscriptionResumeAt"],
      subscription_start_date: p["subscriptionStartDate"],
      subscription_trial_end: p["subscriptionTrialEnd"],
      subscription_trial_from_plan: p["subscriptionTrialFromPlan"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteInvoicesInvoice(
    p: {
      invoice: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoicesInvoice(
    p: {
      expand?: string[]
      invoice: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoicesInvoice(
    p: {
      invoice: string
      requestBody?: {
        account_tax_ids?: string[] | ""
        application_fee_amount?: number
        auto_advance?: boolean
        automatic_tax?: {
          enabled: boolean
        }
        collection_method?: "charge_automatically" | "send_invoice"
        custom_fields?:
          | {
              name: string
              value: string
            }[]
          | ""
        days_until_due?: number
        default_payment_method?: string
        default_source?: string
        default_tax_rates?: string[] | ""
        description?: string
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        due_date?: number
        expand?: string[]
        footer?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        on_behalf_of?: string | ""
        payment_settings?: {
          default_mandate?: string
          payment_method_options?: {
            acss_debit?:
              | {
                  mandate_options?: {
                    transaction_type?: "business" | "personal"
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
            bancontact?:
              | {
                  preferred_language?: "de" | "en" | "fr" | "nl"
                }
              | ""
            card?:
              | {
                  installments?: {
                    enabled?: boolean
                    plan?:
                      | {
                          count: number
                          interval: "month"
                          type: "fixed_count"
                        }
                      | ""
                  }
                  request_three_d_secure?: "any" | "automatic"
                }
              | ""
            customer_balance?:
              | {
                  bank_transfer?: {
                    eu_bank_transfer?: {
                      country: string
                    }
                    type?: string
                  }
                  funding_type?: string
                }
              | ""
            konbini?: EmptyObject | ""
            us_bank_account?:
              | {
                  financial_connections?: {
                    permissions?: (
                      | "balances"
                      | "ownership"
                      | "payment_method"
                      | "transactions"
                    )[]
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
          }
          payment_method_types?:
            | (
                | "ach_credit_transfer"
                | "ach_debit"
                | "acss_debit"
                | "au_becs_debit"
                | "bacs_debit"
                | "bancontact"
                | "boleto"
                | "card"
                | "cashapp"
                | "customer_balance"
                | "fpx"
                | "giropay"
                | "grabpay"
                | "ideal"
                | "konbini"
                | "link"
                | "paynow"
                | "promptpay"
                | "sepa_debit"
                | "sofort"
                | "us_bank_account"
                | "wechat_pay"
              )[]
            | ""
        }
        rendering_options?:
          | {
              amount_tax_display?: "" | "exclude_tax" | "include_inclusive_tax"
            }
          | ""
        shipping_cost?:
          | {
              shipping_rate?: string
              shipping_rate_data?: {
                delivery_estimate?: {
                  maximum?: {
                    unit: "business_day" | "day" | "hour" | "month" | "week"
                    value: number
                  }
                  minimum?: {
                    unit: "business_day" | "day" | "hour" | "month" | "week"
                    value: number
                  }
                }
                display_name: string
                fixed_amount?: {
                  amount: number
                  currency: string
                  currency_options?: {
                    [key: string]: {
                      amount: number
                      tax_behavior?: "exclusive" | "inclusive" | "unspecified"
                    }
                  }
                }
                metadata?: {
                  [key: string]: string
                }
                tax_behavior?: "exclusive" | "inclusive" | "unspecified"
                tax_code?: string
                type?: "fixed_amount"
              }
            }
          | ""
        shipping_details?:
          | {
              address: {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
              name: string
              phone?: string
            }
          | ""
        statement_descriptor?: string
        transfer_data?:
          | {
              amount?: number
              destination: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoicesInvoiceFinalize(
    p: {
      invoice: string
      requestBody?: {
        auto_advance?: boolean
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/finalize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getInvoicesInvoiceLines(
    p: {
      endingBefore?: string
      expand?: string[]
      invoice: string
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/lines`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoicesInvoiceMarkUncollectible(
    p: {
      invoice: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/invoices/${p["invoice"]}/mark_uncollectible`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoicesInvoicePay(
    p: {
      invoice: string
      requestBody?: {
        expand?: string[]
        forgive?: boolean
        mandate?: string
        off_session?: boolean
        paid_out_of_band?: boolean
        payment_method?: string
        source?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/pay`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoicesInvoiceSend(
    p: {
      invoice: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/send`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postInvoicesInvoiceVoid(
    p: {
      invoice: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_invoice> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/void`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingAuthorizations(
    p: {
      card?: string
      cardholder?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "closed" | "pending" | "reversed"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_issuing_authorization[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/authorizations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      card: p["card"],
      cardholder: p["cardholder"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingAuthorizationsAuthorization(
    p: {
      authorization: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_authorization> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingAuthorizationsAuthorization(
    p: {
      authorization: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_authorization> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingAuthorizationsAuthorizationApprove(
    p: {
      authorization: string
      requestBody?: {
        amount?: number
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_authorization> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}/approve`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingAuthorizationsAuthorizationDecline(
    p: {
      authorization: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_authorization> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}/decline`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingCardholders(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      email?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      phoneNumber?: string
      startingAfter?: string
      status?: "active" | "blocked" | "inactive"
      type?: "company" | "individual"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_issuing_cardholder[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/cardholders`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      email: p["email"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      phone_number: p["phoneNumber"],
      starting_after: p["startingAfter"],
      status: p["status"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingCardholders(
    p: {
      requestBody: {
        billing: {
          address: {
            city: string
            country: string
            line1: string
            line2?: string
            postal_code: string
            state?: string
          }
        }
        company?: {
          tax_id?: string
        }
        email?: string
        expand?: string[]
        individual?: {
          card_issuing?: {
            user_terms_acceptance?: {
              date?: number
              ip?: string
              user_agent?: string
            }
          }
          dob?: {
            day: number
            month: number
            year: number
          }
          first_name?: string
          last_name?: string
          verification?: {
            document?: {
              back?: string
              front?: string
            }
          }
        }
        metadata?: {
          [key: string]: string
        }
        name: string
        phone_number?: string
        spending_controls?: {
          allowed_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          blocked_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          spending_limits?: {
            amount: number
            categories?: (
              | "ac_refrigeration_repair"
              | "accounting_bookkeeping_services"
              | "advertising_services"
              | "agricultural_cooperative"
              | "airlines_air_carriers"
              | "airports_flying_fields"
              | "ambulance_services"
              | "amusement_parks_carnivals"
              | "antique_reproductions"
              | "antique_shops"
              | "aquariums"
              | "architectural_surveying_services"
              | "art_dealers_and_galleries"
              | "artists_supply_and_craft_shops"
              | "auto_and_home_supply_stores"
              | "auto_body_repair_shops"
              | "auto_paint_shops"
              | "auto_service_shops"
              | "automated_cash_disburse"
              | "automated_fuel_dispensers"
              | "automobile_associations"
              | "automotive_parts_and_accessories_stores"
              | "automotive_tire_stores"
              | "bail_and_bond_payments"
              | "bakeries"
              | "bands_orchestras"
              | "barber_and_beauty_shops"
              | "betting_casino_gambling"
              | "bicycle_shops"
              | "billiard_pool_establishments"
              | "boat_dealers"
              | "boat_rentals_and_leases"
              | "book_stores"
              | "books_periodicals_and_newspapers"
              | "bowling_alleys"
              | "bus_lines"
              | "business_secretarial_schools"
              | "buying_shopping_services"
              | "cable_satellite_and_other_pay_television_and_radio"
              | "camera_and_photographic_supply_stores"
              | "candy_nut_and_confectionery_stores"
              | "car_and_truck_dealers_new_used"
              | "car_and_truck_dealers_used_only"
              | "car_rental_agencies"
              | "car_washes"
              | "carpentry_services"
              | "carpet_upholstery_cleaning"
              | "caterers"
              | "charitable_and_social_service_organizations_fundraising"
              | "chemicals_and_allied_products"
              | "child_care_services"
              | "childrens_and_infants_wear_stores"
              | "chiropodists_podiatrists"
              | "chiropractors"
              | "cigar_stores_and_stands"
              | "civic_social_fraternal_associations"
              | "cleaning_and_maintenance"
              | "clothing_rental"
              | "colleges_universities"
              | "commercial_equipment"
              | "commercial_footwear"
              | "commercial_photography_art_and_graphics"
              | "commuter_transport_and_ferries"
              | "computer_network_services"
              | "computer_programming"
              | "computer_repair"
              | "computer_software_stores"
              | "computers_peripherals_and_software"
              | "concrete_work_services"
              | "construction_materials"
              | "consulting_public_relations"
              | "correspondence_schools"
              | "cosmetic_stores"
              | "counseling_services"
              | "country_clubs"
              | "courier_services"
              | "court_costs"
              | "credit_reporting_agencies"
              | "cruise_lines"
              | "dairy_products_stores"
              | "dance_hall_studios_schools"
              | "dating_escort_services"
              | "dentists_orthodontists"
              | "department_stores"
              | "detective_agencies"
              | "digital_goods_applications"
              | "digital_goods_games"
              | "digital_goods_large_volume"
              | "digital_goods_media"
              | "direct_marketing_catalog_merchant"
              | "direct_marketing_combination_catalog_and_retail_merchant"
              | "direct_marketing_inbound_telemarketing"
              | "direct_marketing_insurance_services"
              | "direct_marketing_other"
              | "direct_marketing_outbound_telemarketing"
              | "direct_marketing_subscription"
              | "direct_marketing_travel"
              | "discount_stores"
              | "doctors"
              | "door_to_door_sales"
              | "drapery_window_covering_and_upholstery_stores"
              | "drinking_places"
              | "drug_stores_and_pharmacies"
              | "drugs_drug_proprietaries_and_druggist_sundries"
              | "dry_cleaners"
              | "durable_goods"
              | "duty_free_stores"
              | "eating_places_restaurants"
              | "educational_services"
              | "electric_razor_stores"
              | "electric_vehicle_charging"
              | "electrical_parts_and_equipment"
              | "electrical_services"
              | "electronics_repair_shops"
              | "electronics_stores"
              | "elementary_secondary_schools"
              | "emergency_services_gcas_visa_use_only"
              | "employment_temp_agencies"
              | "equipment_rental"
              | "exterminating_services"
              | "family_clothing_stores"
              | "fast_food_restaurants"
              | "financial_institutions"
              | "fines_government_administrative_entities"
              | "fireplace_fireplace_screens_and_accessories_stores"
              | "floor_covering_stores"
              | "florists"
              | "florists_supplies_nursery_stock_and_flowers"
              | "freezer_and_locker_meat_provisioners"
              | "fuel_dealers_non_automotive"
              | "funeral_services_crematories"
              | "furniture_home_furnishings_and_equipment_stores_except_appliances"
              | "furniture_repair_refinishing"
              | "furriers_and_fur_shops"
              | "general_services"
              | "gift_card_novelty_and_souvenir_shops"
              | "glass_paint_and_wallpaper_stores"
              | "glassware_crystal_stores"
              | "golf_courses_public"
              | "government_licensed_horse_dog_racing_us_region_only"
              | "government_licensed_online_casions_online_gambling_us_region_only"
              | "government_owned_lotteries_non_us_region"
              | "government_owned_lotteries_us_region_only"
              | "government_services"
              | "grocery_stores_supermarkets"
              | "hardware_equipment_and_supplies"
              | "hardware_stores"
              | "health_and_beauty_spas"
              | "hearing_aids_sales_and_supplies"
              | "heating_plumbing_a_c"
              | "hobby_toy_and_game_shops"
              | "home_supply_warehouse_stores"
              | "hospitals"
              | "hotels_motels_and_resorts"
              | "household_appliance_stores"
              | "industrial_supplies"
              | "information_retrieval_services"
              | "insurance_default"
              | "insurance_underwriting_premiums"
              | "intra_company_purchases"
              | "jewelry_stores_watches_clocks_and_silverware_stores"
              | "landscaping_services"
              | "laundries"
              | "laundry_cleaning_services"
              | "legal_services_attorneys"
              | "luggage_and_leather_goods_stores"
              | "lumber_building_materials_stores"
              | "manual_cash_disburse"
              | "marinas_service_and_supplies"
              | "marketplaces"
              | "masonry_stonework_and_plaster"
              | "massage_parlors"
              | "medical_and_dental_labs"
              | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
              | "medical_services"
              | "membership_organizations"
              | "mens_and_boys_clothing_and_accessories_stores"
              | "mens_womens_clothing_stores"
              | "metal_service_centers"
              | "miscellaneous"
              | "miscellaneous_apparel_and_accessory_shops"
              | "miscellaneous_auto_dealers"
              | "miscellaneous_business_services"
              | "miscellaneous_food_stores"
              | "miscellaneous_general_merchandise"
              | "miscellaneous_general_services"
              | "miscellaneous_home_furnishing_specialty_stores"
              | "miscellaneous_publishing_and_printing"
              | "miscellaneous_recreation_services"
              | "miscellaneous_repair_shops"
              | "miscellaneous_specialty_retail"
              | "mobile_home_dealers"
              | "motion_picture_theaters"
              | "motor_freight_carriers_and_trucking"
              | "motor_homes_dealers"
              | "motor_vehicle_supplies_and_new_parts"
              | "motorcycle_shops_and_dealers"
              | "motorcycle_shops_dealers"
              | "music_stores_musical_instruments_pianos_and_sheet_music"
              | "news_dealers_and_newsstands"
              | "non_fi_money_orders"
              | "non_fi_stored_value_card_purchase_load"
              | "nondurable_goods"
              | "nurseries_lawn_and_garden_supply_stores"
              | "nursing_personal_care"
              | "office_and_commercial_furniture"
              | "opticians_eyeglasses"
              | "optometrists_ophthalmologist"
              | "orthopedic_goods_prosthetic_devices"
              | "osteopaths"
              | "package_stores_beer_wine_and_liquor"
              | "paints_varnishes_and_supplies"
              | "parking_lots_garages"
              | "passenger_railways"
              | "pawn_shops"
              | "pet_shops_pet_food_and_supplies"
              | "petroleum_and_petroleum_products"
              | "photo_developing"
              | "photographic_photocopy_microfilm_equipment_and_supplies"
              | "photographic_studios"
              | "picture_video_production"
              | "piece_goods_notions_and_other_dry_goods"
              | "plumbing_heating_equipment_and_supplies"
              | "political_organizations"
              | "postal_services_government_only"
              | "precious_stones_and_metals_watches_and_jewelry"
              | "professional_services"
              | "public_warehousing_and_storage"
              | "quick_copy_repro_and_blueprint"
              | "railroads"
              | "real_estate_agents_and_managers_rentals"
              | "record_stores"
              | "recreational_vehicle_rentals"
              | "religious_goods_stores"
              | "religious_organizations"
              | "roofing_siding_sheet_metal"
              | "secretarial_support_services"
              | "security_brokers_dealers"
              | "service_stations"
              | "sewing_needlework_fabric_and_piece_goods_stores"
              | "shoe_repair_hat_cleaning"
              | "shoe_stores"
              | "small_appliance_repair"
              | "snowmobile_dealers"
              | "special_trade_services"
              | "specialty_cleaning"
              | "sporting_goods_stores"
              | "sporting_recreation_camps"
              | "sports_and_riding_apparel_stores"
              | "sports_clubs_fields"
              | "stamp_and_coin_stores"
              | "stationary_office_supplies_printing_and_writing_paper"
              | "stationery_stores_office_and_school_supply_stores"
              | "swimming_pools_sales"
              | "t_ui_travel_germany"
              | "tailors_alterations"
              | "tax_payments_government_agencies"
              | "tax_preparation_services"
              | "taxicabs_limousines"
              | "telecommunication_equipment_and_telephone_sales"
              | "telecommunication_services"
              | "telegraph_services"
              | "tent_and_awning_shops"
              | "testing_laboratories"
              | "theatrical_ticket_agencies"
              | "timeshares"
              | "tire_retreading_and_repair"
              | "tolls_bridge_fees"
              | "tourist_attractions_and_exhibits"
              | "towing_services"
              | "trailer_parks_campgrounds"
              | "transportation_services"
              | "travel_agencies_tour_operators"
              | "truck_stop_iteration"
              | "truck_utility_trailer_rentals"
              | "typesetting_plate_making_and_related_services"
              | "typewriter_stores"
              | "u_s_federal_government_agencies_or_departments"
              | "uniforms_commercial_clothing"
              | "used_merchandise_and_secondhand_stores"
              | "utilities"
              | "variety_stores"
              | "veterinary_services"
              | "video_amusement_game_supplies"
              | "video_game_arcades"
              | "video_tape_rental_stores"
              | "vocational_trade_schools"
              | "watch_jewelry_repair"
              | "welding_repair"
              | "wholesale_clubs"
              | "wig_and_toupee_stores"
              | "wires_money_orders"
              | "womens_accessory_and_specialty_shops"
              | "womens_ready_to_wear_stores"
              | "wrecking_and_salvage_yards"
            )[]
            interval:
              | "all_time"
              | "daily"
              | "monthly"
              | "per_authorization"
              | "weekly"
              | "yearly"
          }[]
          spending_limits_currency?: string
        }
        status?: "active" | "inactive"
        type?: "company" | "individual"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_cardholder> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/cardholders`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingCardholdersCardholder(
    p: {
      cardholder: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_cardholder> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/cardholders/${p["cardholder"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingCardholdersCardholder(
    p: {
      cardholder: string
      requestBody?: {
        billing?: {
          address: {
            city: string
            country: string
            line1: string
            line2?: string
            postal_code: string
            state?: string
          }
        }
        company?: {
          tax_id?: string
        }
        email?: string
        expand?: string[]
        individual?: {
          card_issuing?: {
            user_terms_acceptance?: {
              date?: number
              ip?: string
              user_agent?: string
            }
          }
          dob?: {
            day: number
            month: number
            year: number
          }
          first_name?: string
          last_name?: string
          verification?: {
            document?: {
              back?: string
              front?: string
            }
          }
        }
        metadata?: {
          [key: string]: string
        }
        phone_number?: string
        spending_controls?: {
          allowed_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          blocked_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          spending_limits?: {
            amount: number
            categories?: (
              | "ac_refrigeration_repair"
              | "accounting_bookkeeping_services"
              | "advertising_services"
              | "agricultural_cooperative"
              | "airlines_air_carriers"
              | "airports_flying_fields"
              | "ambulance_services"
              | "amusement_parks_carnivals"
              | "antique_reproductions"
              | "antique_shops"
              | "aquariums"
              | "architectural_surveying_services"
              | "art_dealers_and_galleries"
              | "artists_supply_and_craft_shops"
              | "auto_and_home_supply_stores"
              | "auto_body_repair_shops"
              | "auto_paint_shops"
              | "auto_service_shops"
              | "automated_cash_disburse"
              | "automated_fuel_dispensers"
              | "automobile_associations"
              | "automotive_parts_and_accessories_stores"
              | "automotive_tire_stores"
              | "bail_and_bond_payments"
              | "bakeries"
              | "bands_orchestras"
              | "barber_and_beauty_shops"
              | "betting_casino_gambling"
              | "bicycle_shops"
              | "billiard_pool_establishments"
              | "boat_dealers"
              | "boat_rentals_and_leases"
              | "book_stores"
              | "books_periodicals_and_newspapers"
              | "bowling_alleys"
              | "bus_lines"
              | "business_secretarial_schools"
              | "buying_shopping_services"
              | "cable_satellite_and_other_pay_television_and_radio"
              | "camera_and_photographic_supply_stores"
              | "candy_nut_and_confectionery_stores"
              | "car_and_truck_dealers_new_used"
              | "car_and_truck_dealers_used_only"
              | "car_rental_agencies"
              | "car_washes"
              | "carpentry_services"
              | "carpet_upholstery_cleaning"
              | "caterers"
              | "charitable_and_social_service_organizations_fundraising"
              | "chemicals_and_allied_products"
              | "child_care_services"
              | "childrens_and_infants_wear_stores"
              | "chiropodists_podiatrists"
              | "chiropractors"
              | "cigar_stores_and_stands"
              | "civic_social_fraternal_associations"
              | "cleaning_and_maintenance"
              | "clothing_rental"
              | "colleges_universities"
              | "commercial_equipment"
              | "commercial_footwear"
              | "commercial_photography_art_and_graphics"
              | "commuter_transport_and_ferries"
              | "computer_network_services"
              | "computer_programming"
              | "computer_repair"
              | "computer_software_stores"
              | "computers_peripherals_and_software"
              | "concrete_work_services"
              | "construction_materials"
              | "consulting_public_relations"
              | "correspondence_schools"
              | "cosmetic_stores"
              | "counseling_services"
              | "country_clubs"
              | "courier_services"
              | "court_costs"
              | "credit_reporting_agencies"
              | "cruise_lines"
              | "dairy_products_stores"
              | "dance_hall_studios_schools"
              | "dating_escort_services"
              | "dentists_orthodontists"
              | "department_stores"
              | "detective_agencies"
              | "digital_goods_applications"
              | "digital_goods_games"
              | "digital_goods_large_volume"
              | "digital_goods_media"
              | "direct_marketing_catalog_merchant"
              | "direct_marketing_combination_catalog_and_retail_merchant"
              | "direct_marketing_inbound_telemarketing"
              | "direct_marketing_insurance_services"
              | "direct_marketing_other"
              | "direct_marketing_outbound_telemarketing"
              | "direct_marketing_subscription"
              | "direct_marketing_travel"
              | "discount_stores"
              | "doctors"
              | "door_to_door_sales"
              | "drapery_window_covering_and_upholstery_stores"
              | "drinking_places"
              | "drug_stores_and_pharmacies"
              | "drugs_drug_proprietaries_and_druggist_sundries"
              | "dry_cleaners"
              | "durable_goods"
              | "duty_free_stores"
              | "eating_places_restaurants"
              | "educational_services"
              | "electric_razor_stores"
              | "electric_vehicle_charging"
              | "electrical_parts_and_equipment"
              | "electrical_services"
              | "electronics_repair_shops"
              | "electronics_stores"
              | "elementary_secondary_schools"
              | "emergency_services_gcas_visa_use_only"
              | "employment_temp_agencies"
              | "equipment_rental"
              | "exterminating_services"
              | "family_clothing_stores"
              | "fast_food_restaurants"
              | "financial_institutions"
              | "fines_government_administrative_entities"
              | "fireplace_fireplace_screens_and_accessories_stores"
              | "floor_covering_stores"
              | "florists"
              | "florists_supplies_nursery_stock_and_flowers"
              | "freezer_and_locker_meat_provisioners"
              | "fuel_dealers_non_automotive"
              | "funeral_services_crematories"
              | "furniture_home_furnishings_and_equipment_stores_except_appliances"
              | "furniture_repair_refinishing"
              | "furriers_and_fur_shops"
              | "general_services"
              | "gift_card_novelty_and_souvenir_shops"
              | "glass_paint_and_wallpaper_stores"
              | "glassware_crystal_stores"
              | "golf_courses_public"
              | "government_licensed_horse_dog_racing_us_region_only"
              | "government_licensed_online_casions_online_gambling_us_region_only"
              | "government_owned_lotteries_non_us_region"
              | "government_owned_lotteries_us_region_only"
              | "government_services"
              | "grocery_stores_supermarkets"
              | "hardware_equipment_and_supplies"
              | "hardware_stores"
              | "health_and_beauty_spas"
              | "hearing_aids_sales_and_supplies"
              | "heating_plumbing_a_c"
              | "hobby_toy_and_game_shops"
              | "home_supply_warehouse_stores"
              | "hospitals"
              | "hotels_motels_and_resorts"
              | "household_appliance_stores"
              | "industrial_supplies"
              | "information_retrieval_services"
              | "insurance_default"
              | "insurance_underwriting_premiums"
              | "intra_company_purchases"
              | "jewelry_stores_watches_clocks_and_silverware_stores"
              | "landscaping_services"
              | "laundries"
              | "laundry_cleaning_services"
              | "legal_services_attorneys"
              | "luggage_and_leather_goods_stores"
              | "lumber_building_materials_stores"
              | "manual_cash_disburse"
              | "marinas_service_and_supplies"
              | "marketplaces"
              | "masonry_stonework_and_plaster"
              | "massage_parlors"
              | "medical_and_dental_labs"
              | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
              | "medical_services"
              | "membership_organizations"
              | "mens_and_boys_clothing_and_accessories_stores"
              | "mens_womens_clothing_stores"
              | "metal_service_centers"
              | "miscellaneous"
              | "miscellaneous_apparel_and_accessory_shops"
              | "miscellaneous_auto_dealers"
              | "miscellaneous_business_services"
              | "miscellaneous_food_stores"
              | "miscellaneous_general_merchandise"
              | "miscellaneous_general_services"
              | "miscellaneous_home_furnishing_specialty_stores"
              | "miscellaneous_publishing_and_printing"
              | "miscellaneous_recreation_services"
              | "miscellaneous_repair_shops"
              | "miscellaneous_specialty_retail"
              | "mobile_home_dealers"
              | "motion_picture_theaters"
              | "motor_freight_carriers_and_trucking"
              | "motor_homes_dealers"
              | "motor_vehicle_supplies_and_new_parts"
              | "motorcycle_shops_and_dealers"
              | "motorcycle_shops_dealers"
              | "music_stores_musical_instruments_pianos_and_sheet_music"
              | "news_dealers_and_newsstands"
              | "non_fi_money_orders"
              | "non_fi_stored_value_card_purchase_load"
              | "nondurable_goods"
              | "nurseries_lawn_and_garden_supply_stores"
              | "nursing_personal_care"
              | "office_and_commercial_furniture"
              | "opticians_eyeglasses"
              | "optometrists_ophthalmologist"
              | "orthopedic_goods_prosthetic_devices"
              | "osteopaths"
              | "package_stores_beer_wine_and_liquor"
              | "paints_varnishes_and_supplies"
              | "parking_lots_garages"
              | "passenger_railways"
              | "pawn_shops"
              | "pet_shops_pet_food_and_supplies"
              | "petroleum_and_petroleum_products"
              | "photo_developing"
              | "photographic_photocopy_microfilm_equipment_and_supplies"
              | "photographic_studios"
              | "picture_video_production"
              | "piece_goods_notions_and_other_dry_goods"
              | "plumbing_heating_equipment_and_supplies"
              | "political_organizations"
              | "postal_services_government_only"
              | "precious_stones_and_metals_watches_and_jewelry"
              | "professional_services"
              | "public_warehousing_and_storage"
              | "quick_copy_repro_and_blueprint"
              | "railroads"
              | "real_estate_agents_and_managers_rentals"
              | "record_stores"
              | "recreational_vehicle_rentals"
              | "religious_goods_stores"
              | "religious_organizations"
              | "roofing_siding_sheet_metal"
              | "secretarial_support_services"
              | "security_brokers_dealers"
              | "service_stations"
              | "sewing_needlework_fabric_and_piece_goods_stores"
              | "shoe_repair_hat_cleaning"
              | "shoe_stores"
              | "small_appliance_repair"
              | "snowmobile_dealers"
              | "special_trade_services"
              | "specialty_cleaning"
              | "sporting_goods_stores"
              | "sporting_recreation_camps"
              | "sports_and_riding_apparel_stores"
              | "sports_clubs_fields"
              | "stamp_and_coin_stores"
              | "stationary_office_supplies_printing_and_writing_paper"
              | "stationery_stores_office_and_school_supply_stores"
              | "swimming_pools_sales"
              | "t_ui_travel_germany"
              | "tailors_alterations"
              | "tax_payments_government_agencies"
              | "tax_preparation_services"
              | "taxicabs_limousines"
              | "telecommunication_equipment_and_telephone_sales"
              | "telecommunication_services"
              | "telegraph_services"
              | "tent_and_awning_shops"
              | "testing_laboratories"
              | "theatrical_ticket_agencies"
              | "timeshares"
              | "tire_retreading_and_repair"
              | "tolls_bridge_fees"
              | "tourist_attractions_and_exhibits"
              | "towing_services"
              | "trailer_parks_campgrounds"
              | "transportation_services"
              | "travel_agencies_tour_operators"
              | "truck_stop_iteration"
              | "truck_utility_trailer_rentals"
              | "typesetting_plate_making_and_related_services"
              | "typewriter_stores"
              | "u_s_federal_government_agencies_or_departments"
              | "uniforms_commercial_clothing"
              | "used_merchandise_and_secondhand_stores"
              | "utilities"
              | "variety_stores"
              | "veterinary_services"
              | "video_amusement_game_supplies"
              | "video_game_arcades"
              | "video_tape_rental_stores"
              | "vocational_trade_schools"
              | "watch_jewelry_repair"
              | "welding_repair"
              | "wholesale_clubs"
              | "wig_and_toupee_stores"
              | "wires_money_orders"
              | "womens_accessory_and_specialty_shops"
              | "womens_ready_to_wear_stores"
              | "wrecking_and_salvage_yards"
            )[]
            interval:
              | "all_time"
              | "daily"
              | "monthly"
              | "per_authorization"
              | "weekly"
              | "yearly"
          }[]
          spending_limits_currency?: string
        }
        status?: "active" | "inactive"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_cardholder> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/cardholders/${p["cardholder"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingCards(
    p: {
      cardholder?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expMonth?: number
      expYear?: number
      expand?: string[]
      last4?: string
      limit?: number
      startingAfter?: string
      status?: "active" | "canceled" | "inactive"
      type?: "physical" | "virtual"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_issuing_card[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/cards`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      cardholder: p["cardholder"],
      created: p["created"],
      ending_before: p["endingBefore"],
      exp_month: p["expMonth"],
      exp_year: p["expYear"],
      expand: p["expand"],
      last4: p["last4"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingCards(
    p: {
      requestBody: {
        cardholder?: string
        currency: string
        expand?: string[]
        financial_account?: string
        metadata?: {
          [key: string]: string
        }
        replacement_for?: string
        replacement_reason?: "damaged" | "expired" | "lost" | "stolen"
        shipping?: {
          address: {
            city: string
            country: string
            line1: string
            line2?: string
            postal_code: string
            state?: string
          }
          customs?: {
            eori_number?: string
          }
          name: string
          phone_number?: string
          require_signature?: boolean
          service?: "express" | "priority" | "standard"
          type?: "bulk" | "individual"
        }
        spending_controls?: {
          allowed_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          blocked_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          spending_limits?: {
            amount: number
            categories?: (
              | "ac_refrigeration_repair"
              | "accounting_bookkeeping_services"
              | "advertising_services"
              | "agricultural_cooperative"
              | "airlines_air_carriers"
              | "airports_flying_fields"
              | "ambulance_services"
              | "amusement_parks_carnivals"
              | "antique_reproductions"
              | "antique_shops"
              | "aquariums"
              | "architectural_surveying_services"
              | "art_dealers_and_galleries"
              | "artists_supply_and_craft_shops"
              | "auto_and_home_supply_stores"
              | "auto_body_repair_shops"
              | "auto_paint_shops"
              | "auto_service_shops"
              | "automated_cash_disburse"
              | "automated_fuel_dispensers"
              | "automobile_associations"
              | "automotive_parts_and_accessories_stores"
              | "automotive_tire_stores"
              | "bail_and_bond_payments"
              | "bakeries"
              | "bands_orchestras"
              | "barber_and_beauty_shops"
              | "betting_casino_gambling"
              | "bicycle_shops"
              | "billiard_pool_establishments"
              | "boat_dealers"
              | "boat_rentals_and_leases"
              | "book_stores"
              | "books_periodicals_and_newspapers"
              | "bowling_alleys"
              | "bus_lines"
              | "business_secretarial_schools"
              | "buying_shopping_services"
              | "cable_satellite_and_other_pay_television_and_radio"
              | "camera_and_photographic_supply_stores"
              | "candy_nut_and_confectionery_stores"
              | "car_and_truck_dealers_new_used"
              | "car_and_truck_dealers_used_only"
              | "car_rental_agencies"
              | "car_washes"
              | "carpentry_services"
              | "carpet_upholstery_cleaning"
              | "caterers"
              | "charitable_and_social_service_organizations_fundraising"
              | "chemicals_and_allied_products"
              | "child_care_services"
              | "childrens_and_infants_wear_stores"
              | "chiropodists_podiatrists"
              | "chiropractors"
              | "cigar_stores_and_stands"
              | "civic_social_fraternal_associations"
              | "cleaning_and_maintenance"
              | "clothing_rental"
              | "colleges_universities"
              | "commercial_equipment"
              | "commercial_footwear"
              | "commercial_photography_art_and_graphics"
              | "commuter_transport_and_ferries"
              | "computer_network_services"
              | "computer_programming"
              | "computer_repair"
              | "computer_software_stores"
              | "computers_peripherals_and_software"
              | "concrete_work_services"
              | "construction_materials"
              | "consulting_public_relations"
              | "correspondence_schools"
              | "cosmetic_stores"
              | "counseling_services"
              | "country_clubs"
              | "courier_services"
              | "court_costs"
              | "credit_reporting_agencies"
              | "cruise_lines"
              | "dairy_products_stores"
              | "dance_hall_studios_schools"
              | "dating_escort_services"
              | "dentists_orthodontists"
              | "department_stores"
              | "detective_agencies"
              | "digital_goods_applications"
              | "digital_goods_games"
              | "digital_goods_large_volume"
              | "digital_goods_media"
              | "direct_marketing_catalog_merchant"
              | "direct_marketing_combination_catalog_and_retail_merchant"
              | "direct_marketing_inbound_telemarketing"
              | "direct_marketing_insurance_services"
              | "direct_marketing_other"
              | "direct_marketing_outbound_telemarketing"
              | "direct_marketing_subscription"
              | "direct_marketing_travel"
              | "discount_stores"
              | "doctors"
              | "door_to_door_sales"
              | "drapery_window_covering_and_upholstery_stores"
              | "drinking_places"
              | "drug_stores_and_pharmacies"
              | "drugs_drug_proprietaries_and_druggist_sundries"
              | "dry_cleaners"
              | "durable_goods"
              | "duty_free_stores"
              | "eating_places_restaurants"
              | "educational_services"
              | "electric_razor_stores"
              | "electric_vehicle_charging"
              | "electrical_parts_and_equipment"
              | "electrical_services"
              | "electronics_repair_shops"
              | "electronics_stores"
              | "elementary_secondary_schools"
              | "emergency_services_gcas_visa_use_only"
              | "employment_temp_agencies"
              | "equipment_rental"
              | "exterminating_services"
              | "family_clothing_stores"
              | "fast_food_restaurants"
              | "financial_institutions"
              | "fines_government_administrative_entities"
              | "fireplace_fireplace_screens_and_accessories_stores"
              | "floor_covering_stores"
              | "florists"
              | "florists_supplies_nursery_stock_and_flowers"
              | "freezer_and_locker_meat_provisioners"
              | "fuel_dealers_non_automotive"
              | "funeral_services_crematories"
              | "furniture_home_furnishings_and_equipment_stores_except_appliances"
              | "furniture_repair_refinishing"
              | "furriers_and_fur_shops"
              | "general_services"
              | "gift_card_novelty_and_souvenir_shops"
              | "glass_paint_and_wallpaper_stores"
              | "glassware_crystal_stores"
              | "golf_courses_public"
              | "government_licensed_horse_dog_racing_us_region_only"
              | "government_licensed_online_casions_online_gambling_us_region_only"
              | "government_owned_lotteries_non_us_region"
              | "government_owned_lotteries_us_region_only"
              | "government_services"
              | "grocery_stores_supermarkets"
              | "hardware_equipment_and_supplies"
              | "hardware_stores"
              | "health_and_beauty_spas"
              | "hearing_aids_sales_and_supplies"
              | "heating_plumbing_a_c"
              | "hobby_toy_and_game_shops"
              | "home_supply_warehouse_stores"
              | "hospitals"
              | "hotels_motels_and_resorts"
              | "household_appliance_stores"
              | "industrial_supplies"
              | "information_retrieval_services"
              | "insurance_default"
              | "insurance_underwriting_premiums"
              | "intra_company_purchases"
              | "jewelry_stores_watches_clocks_and_silverware_stores"
              | "landscaping_services"
              | "laundries"
              | "laundry_cleaning_services"
              | "legal_services_attorneys"
              | "luggage_and_leather_goods_stores"
              | "lumber_building_materials_stores"
              | "manual_cash_disburse"
              | "marinas_service_and_supplies"
              | "marketplaces"
              | "masonry_stonework_and_plaster"
              | "massage_parlors"
              | "medical_and_dental_labs"
              | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
              | "medical_services"
              | "membership_organizations"
              | "mens_and_boys_clothing_and_accessories_stores"
              | "mens_womens_clothing_stores"
              | "metal_service_centers"
              | "miscellaneous"
              | "miscellaneous_apparel_and_accessory_shops"
              | "miscellaneous_auto_dealers"
              | "miscellaneous_business_services"
              | "miscellaneous_food_stores"
              | "miscellaneous_general_merchandise"
              | "miscellaneous_general_services"
              | "miscellaneous_home_furnishing_specialty_stores"
              | "miscellaneous_publishing_and_printing"
              | "miscellaneous_recreation_services"
              | "miscellaneous_repair_shops"
              | "miscellaneous_specialty_retail"
              | "mobile_home_dealers"
              | "motion_picture_theaters"
              | "motor_freight_carriers_and_trucking"
              | "motor_homes_dealers"
              | "motor_vehicle_supplies_and_new_parts"
              | "motorcycle_shops_and_dealers"
              | "motorcycle_shops_dealers"
              | "music_stores_musical_instruments_pianos_and_sheet_music"
              | "news_dealers_and_newsstands"
              | "non_fi_money_orders"
              | "non_fi_stored_value_card_purchase_load"
              | "nondurable_goods"
              | "nurseries_lawn_and_garden_supply_stores"
              | "nursing_personal_care"
              | "office_and_commercial_furniture"
              | "opticians_eyeglasses"
              | "optometrists_ophthalmologist"
              | "orthopedic_goods_prosthetic_devices"
              | "osteopaths"
              | "package_stores_beer_wine_and_liquor"
              | "paints_varnishes_and_supplies"
              | "parking_lots_garages"
              | "passenger_railways"
              | "pawn_shops"
              | "pet_shops_pet_food_and_supplies"
              | "petroleum_and_petroleum_products"
              | "photo_developing"
              | "photographic_photocopy_microfilm_equipment_and_supplies"
              | "photographic_studios"
              | "picture_video_production"
              | "piece_goods_notions_and_other_dry_goods"
              | "plumbing_heating_equipment_and_supplies"
              | "political_organizations"
              | "postal_services_government_only"
              | "precious_stones_and_metals_watches_and_jewelry"
              | "professional_services"
              | "public_warehousing_and_storage"
              | "quick_copy_repro_and_blueprint"
              | "railroads"
              | "real_estate_agents_and_managers_rentals"
              | "record_stores"
              | "recreational_vehicle_rentals"
              | "religious_goods_stores"
              | "religious_organizations"
              | "roofing_siding_sheet_metal"
              | "secretarial_support_services"
              | "security_brokers_dealers"
              | "service_stations"
              | "sewing_needlework_fabric_and_piece_goods_stores"
              | "shoe_repair_hat_cleaning"
              | "shoe_stores"
              | "small_appliance_repair"
              | "snowmobile_dealers"
              | "special_trade_services"
              | "specialty_cleaning"
              | "sporting_goods_stores"
              | "sporting_recreation_camps"
              | "sports_and_riding_apparel_stores"
              | "sports_clubs_fields"
              | "stamp_and_coin_stores"
              | "stationary_office_supplies_printing_and_writing_paper"
              | "stationery_stores_office_and_school_supply_stores"
              | "swimming_pools_sales"
              | "t_ui_travel_germany"
              | "tailors_alterations"
              | "tax_payments_government_agencies"
              | "tax_preparation_services"
              | "taxicabs_limousines"
              | "telecommunication_equipment_and_telephone_sales"
              | "telecommunication_services"
              | "telegraph_services"
              | "tent_and_awning_shops"
              | "testing_laboratories"
              | "theatrical_ticket_agencies"
              | "timeshares"
              | "tire_retreading_and_repair"
              | "tolls_bridge_fees"
              | "tourist_attractions_and_exhibits"
              | "towing_services"
              | "trailer_parks_campgrounds"
              | "transportation_services"
              | "travel_agencies_tour_operators"
              | "truck_stop_iteration"
              | "truck_utility_trailer_rentals"
              | "typesetting_plate_making_and_related_services"
              | "typewriter_stores"
              | "u_s_federal_government_agencies_or_departments"
              | "uniforms_commercial_clothing"
              | "used_merchandise_and_secondhand_stores"
              | "utilities"
              | "variety_stores"
              | "veterinary_services"
              | "video_amusement_game_supplies"
              | "video_game_arcades"
              | "video_tape_rental_stores"
              | "vocational_trade_schools"
              | "watch_jewelry_repair"
              | "welding_repair"
              | "wholesale_clubs"
              | "wig_and_toupee_stores"
              | "wires_money_orders"
              | "womens_accessory_and_specialty_shops"
              | "womens_ready_to_wear_stores"
              | "wrecking_and_salvage_yards"
            )[]
            interval:
              | "all_time"
              | "daily"
              | "monthly"
              | "per_authorization"
              | "weekly"
              | "yearly"
          }[]
        }
        status?: "active" | "inactive"
        type: "physical" | "virtual"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_card> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/issuing/cards`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingCardsCard(
    p: {
      card: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_card> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/issuing/cards/${p["card"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingCardsCard(
    p: {
      card: string
      requestBody?: {
        cancellation_reason?: "lost" | "stolen"
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        pin?: {
          encrypted_number?: string
        }
        spending_controls?: {
          allowed_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          blocked_categories?: (
            | "ac_refrigeration_repair"
            | "accounting_bookkeeping_services"
            | "advertising_services"
            | "agricultural_cooperative"
            | "airlines_air_carriers"
            | "airports_flying_fields"
            | "ambulance_services"
            | "amusement_parks_carnivals"
            | "antique_reproductions"
            | "antique_shops"
            | "aquariums"
            | "architectural_surveying_services"
            | "art_dealers_and_galleries"
            | "artists_supply_and_craft_shops"
            | "auto_and_home_supply_stores"
            | "auto_body_repair_shops"
            | "auto_paint_shops"
            | "auto_service_shops"
            | "automated_cash_disburse"
            | "automated_fuel_dispensers"
            | "automobile_associations"
            | "automotive_parts_and_accessories_stores"
            | "automotive_tire_stores"
            | "bail_and_bond_payments"
            | "bakeries"
            | "bands_orchestras"
            | "barber_and_beauty_shops"
            | "betting_casino_gambling"
            | "bicycle_shops"
            | "billiard_pool_establishments"
            | "boat_dealers"
            | "boat_rentals_and_leases"
            | "book_stores"
            | "books_periodicals_and_newspapers"
            | "bowling_alleys"
            | "bus_lines"
            | "business_secretarial_schools"
            | "buying_shopping_services"
            | "cable_satellite_and_other_pay_television_and_radio"
            | "camera_and_photographic_supply_stores"
            | "candy_nut_and_confectionery_stores"
            | "car_and_truck_dealers_new_used"
            | "car_and_truck_dealers_used_only"
            | "car_rental_agencies"
            | "car_washes"
            | "carpentry_services"
            | "carpet_upholstery_cleaning"
            | "caterers"
            | "charitable_and_social_service_organizations_fundraising"
            | "chemicals_and_allied_products"
            | "child_care_services"
            | "childrens_and_infants_wear_stores"
            | "chiropodists_podiatrists"
            | "chiropractors"
            | "cigar_stores_and_stands"
            | "civic_social_fraternal_associations"
            | "cleaning_and_maintenance"
            | "clothing_rental"
            | "colleges_universities"
            | "commercial_equipment"
            | "commercial_footwear"
            | "commercial_photography_art_and_graphics"
            | "commuter_transport_and_ferries"
            | "computer_network_services"
            | "computer_programming"
            | "computer_repair"
            | "computer_software_stores"
            | "computers_peripherals_and_software"
            | "concrete_work_services"
            | "construction_materials"
            | "consulting_public_relations"
            | "correspondence_schools"
            | "cosmetic_stores"
            | "counseling_services"
            | "country_clubs"
            | "courier_services"
            | "court_costs"
            | "credit_reporting_agencies"
            | "cruise_lines"
            | "dairy_products_stores"
            | "dance_hall_studios_schools"
            | "dating_escort_services"
            | "dentists_orthodontists"
            | "department_stores"
            | "detective_agencies"
            | "digital_goods_applications"
            | "digital_goods_games"
            | "digital_goods_large_volume"
            | "digital_goods_media"
            | "direct_marketing_catalog_merchant"
            | "direct_marketing_combination_catalog_and_retail_merchant"
            | "direct_marketing_inbound_telemarketing"
            | "direct_marketing_insurance_services"
            | "direct_marketing_other"
            | "direct_marketing_outbound_telemarketing"
            | "direct_marketing_subscription"
            | "direct_marketing_travel"
            | "discount_stores"
            | "doctors"
            | "door_to_door_sales"
            | "drapery_window_covering_and_upholstery_stores"
            | "drinking_places"
            | "drug_stores_and_pharmacies"
            | "drugs_drug_proprietaries_and_druggist_sundries"
            | "dry_cleaners"
            | "durable_goods"
            | "duty_free_stores"
            | "eating_places_restaurants"
            | "educational_services"
            | "electric_razor_stores"
            | "electric_vehicle_charging"
            | "electrical_parts_and_equipment"
            | "electrical_services"
            | "electronics_repair_shops"
            | "electronics_stores"
            | "elementary_secondary_schools"
            | "emergency_services_gcas_visa_use_only"
            | "employment_temp_agencies"
            | "equipment_rental"
            | "exterminating_services"
            | "family_clothing_stores"
            | "fast_food_restaurants"
            | "financial_institutions"
            | "fines_government_administrative_entities"
            | "fireplace_fireplace_screens_and_accessories_stores"
            | "floor_covering_stores"
            | "florists"
            | "florists_supplies_nursery_stock_and_flowers"
            | "freezer_and_locker_meat_provisioners"
            | "fuel_dealers_non_automotive"
            | "funeral_services_crematories"
            | "furniture_home_furnishings_and_equipment_stores_except_appliances"
            | "furniture_repair_refinishing"
            | "furriers_and_fur_shops"
            | "general_services"
            | "gift_card_novelty_and_souvenir_shops"
            | "glass_paint_and_wallpaper_stores"
            | "glassware_crystal_stores"
            | "golf_courses_public"
            | "government_licensed_horse_dog_racing_us_region_only"
            | "government_licensed_online_casions_online_gambling_us_region_only"
            | "government_owned_lotteries_non_us_region"
            | "government_owned_lotteries_us_region_only"
            | "government_services"
            | "grocery_stores_supermarkets"
            | "hardware_equipment_and_supplies"
            | "hardware_stores"
            | "health_and_beauty_spas"
            | "hearing_aids_sales_and_supplies"
            | "heating_plumbing_a_c"
            | "hobby_toy_and_game_shops"
            | "home_supply_warehouse_stores"
            | "hospitals"
            | "hotels_motels_and_resorts"
            | "household_appliance_stores"
            | "industrial_supplies"
            | "information_retrieval_services"
            | "insurance_default"
            | "insurance_underwriting_premiums"
            | "intra_company_purchases"
            | "jewelry_stores_watches_clocks_and_silverware_stores"
            | "landscaping_services"
            | "laundries"
            | "laundry_cleaning_services"
            | "legal_services_attorneys"
            | "luggage_and_leather_goods_stores"
            | "lumber_building_materials_stores"
            | "manual_cash_disburse"
            | "marinas_service_and_supplies"
            | "marketplaces"
            | "masonry_stonework_and_plaster"
            | "massage_parlors"
            | "medical_and_dental_labs"
            | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
            | "medical_services"
            | "membership_organizations"
            | "mens_and_boys_clothing_and_accessories_stores"
            | "mens_womens_clothing_stores"
            | "metal_service_centers"
            | "miscellaneous"
            | "miscellaneous_apparel_and_accessory_shops"
            | "miscellaneous_auto_dealers"
            | "miscellaneous_business_services"
            | "miscellaneous_food_stores"
            | "miscellaneous_general_merchandise"
            | "miscellaneous_general_services"
            | "miscellaneous_home_furnishing_specialty_stores"
            | "miscellaneous_publishing_and_printing"
            | "miscellaneous_recreation_services"
            | "miscellaneous_repair_shops"
            | "miscellaneous_specialty_retail"
            | "mobile_home_dealers"
            | "motion_picture_theaters"
            | "motor_freight_carriers_and_trucking"
            | "motor_homes_dealers"
            | "motor_vehicle_supplies_and_new_parts"
            | "motorcycle_shops_and_dealers"
            | "motorcycle_shops_dealers"
            | "music_stores_musical_instruments_pianos_and_sheet_music"
            | "news_dealers_and_newsstands"
            | "non_fi_money_orders"
            | "non_fi_stored_value_card_purchase_load"
            | "nondurable_goods"
            | "nurseries_lawn_and_garden_supply_stores"
            | "nursing_personal_care"
            | "office_and_commercial_furniture"
            | "opticians_eyeglasses"
            | "optometrists_ophthalmologist"
            | "orthopedic_goods_prosthetic_devices"
            | "osteopaths"
            | "package_stores_beer_wine_and_liquor"
            | "paints_varnishes_and_supplies"
            | "parking_lots_garages"
            | "passenger_railways"
            | "pawn_shops"
            | "pet_shops_pet_food_and_supplies"
            | "petroleum_and_petroleum_products"
            | "photo_developing"
            | "photographic_photocopy_microfilm_equipment_and_supplies"
            | "photographic_studios"
            | "picture_video_production"
            | "piece_goods_notions_and_other_dry_goods"
            | "plumbing_heating_equipment_and_supplies"
            | "political_organizations"
            | "postal_services_government_only"
            | "precious_stones_and_metals_watches_and_jewelry"
            | "professional_services"
            | "public_warehousing_and_storage"
            | "quick_copy_repro_and_blueprint"
            | "railroads"
            | "real_estate_agents_and_managers_rentals"
            | "record_stores"
            | "recreational_vehicle_rentals"
            | "religious_goods_stores"
            | "religious_organizations"
            | "roofing_siding_sheet_metal"
            | "secretarial_support_services"
            | "security_brokers_dealers"
            | "service_stations"
            | "sewing_needlework_fabric_and_piece_goods_stores"
            | "shoe_repair_hat_cleaning"
            | "shoe_stores"
            | "small_appliance_repair"
            | "snowmobile_dealers"
            | "special_trade_services"
            | "specialty_cleaning"
            | "sporting_goods_stores"
            | "sporting_recreation_camps"
            | "sports_and_riding_apparel_stores"
            | "sports_clubs_fields"
            | "stamp_and_coin_stores"
            | "stationary_office_supplies_printing_and_writing_paper"
            | "stationery_stores_office_and_school_supply_stores"
            | "swimming_pools_sales"
            | "t_ui_travel_germany"
            | "tailors_alterations"
            | "tax_payments_government_agencies"
            | "tax_preparation_services"
            | "taxicabs_limousines"
            | "telecommunication_equipment_and_telephone_sales"
            | "telecommunication_services"
            | "telegraph_services"
            | "tent_and_awning_shops"
            | "testing_laboratories"
            | "theatrical_ticket_agencies"
            | "timeshares"
            | "tire_retreading_and_repair"
            | "tolls_bridge_fees"
            | "tourist_attractions_and_exhibits"
            | "towing_services"
            | "trailer_parks_campgrounds"
            | "transportation_services"
            | "travel_agencies_tour_operators"
            | "truck_stop_iteration"
            | "truck_utility_trailer_rentals"
            | "typesetting_plate_making_and_related_services"
            | "typewriter_stores"
            | "u_s_federal_government_agencies_or_departments"
            | "uniforms_commercial_clothing"
            | "used_merchandise_and_secondhand_stores"
            | "utilities"
            | "variety_stores"
            | "veterinary_services"
            | "video_amusement_game_supplies"
            | "video_game_arcades"
            | "video_tape_rental_stores"
            | "vocational_trade_schools"
            | "watch_jewelry_repair"
            | "welding_repair"
            | "wholesale_clubs"
            | "wig_and_toupee_stores"
            | "wires_money_orders"
            | "womens_accessory_and_specialty_shops"
            | "womens_ready_to_wear_stores"
            | "wrecking_and_salvage_yards"
          )[]
          spending_limits?: {
            amount: number
            categories?: (
              | "ac_refrigeration_repair"
              | "accounting_bookkeeping_services"
              | "advertising_services"
              | "agricultural_cooperative"
              | "airlines_air_carriers"
              | "airports_flying_fields"
              | "ambulance_services"
              | "amusement_parks_carnivals"
              | "antique_reproductions"
              | "antique_shops"
              | "aquariums"
              | "architectural_surveying_services"
              | "art_dealers_and_galleries"
              | "artists_supply_and_craft_shops"
              | "auto_and_home_supply_stores"
              | "auto_body_repair_shops"
              | "auto_paint_shops"
              | "auto_service_shops"
              | "automated_cash_disburse"
              | "automated_fuel_dispensers"
              | "automobile_associations"
              | "automotive_parts_and_accessories_stores"
              | "automotive_tire_stores"
              | "bail_and_bond_payments"
              | "bakeries"
              | "bands_orchestras"
              | "barber_and_beauty_shops"
              | "betting_casino_gambling"
              | "bicycle_shops"
              | "billiard_pool_establishments"
              | "boat_dealers"
              | "boat_rentals_and_leases"
              | "book_stores"
              | "books_periodicals_and_newspapers"
              | "bowling_alleys"
              | "bus_lines"
              | "business_secretarial_schools"
              | "buying_shopping_services"
              | "cable_satellite_and_other_pay_television_and_radio"
              | "camera_and_photographic_supply_stores"
              | "candy_nut_and_confectionery_stores"
              | "car_and_truck_dealers_new_used"
              | "car_and_truck_dealers_used_only"
              | "car_rental_agencies"
              | "car_washes"
              | "carpentry_services"
              | "carpet_upholstery_cleaning"
              | "caterers"
              | "charitable_and_social_service_organizations_fundraising"
              | "chemicals_and_allied_products"
              | "child_care_services"
              | "childrens_and_infants_wear_stores"
              | "chiropodists_podiatrists"
              | "chiropractors"
              | "cigar_stores_and_stands"
              | "civic_social_fraternal_associations"
              | "cleaning_and_maintenance"
              | "clothing_rental"
              | "colleges_universities"
              | "commercial_equipment"
              | "commercial_footwear"
              | "commercial_photography_art_and_graphics"
              | "commuter_transport_and_ferries"
              | "computer_network_services"
              | "computer_programming"
              | "computer_repair"
              | "computer_software_stores"
              | "computers_peripherals_and_software"
              | "concrete_work_services"
              | "construction_materials"
              | "consulting_public_relations"
              | "correspondence_schools"
              | "cosmetic_stores"
              | "counseling_services"
              | "country_clubs"
              | "courier_services"
              | "court_costs"
              | "credit_reporting_agencies"
              | "cruise_lines"
              | "dairy_products_stores"
              | "dance_hall_studios_schools"
              | "dating_escort_services"
              | "dentists_orthodontists"
              | "department_stores"
              | "detective_agencies"
              | "digital_goods_applications"
              | "digital_goods_games"
              | "digital_goods_large_volume"
              | "digital_goods_media"
              | "direct_marketing_catalog_merchant"
              | "direct_marketing_combination_catalog_and_retail_merchant"
              | "direct_marketing_inbound_telemarketing"
              | "direct_marketing_insurance_services"
              | "direct_marketing_other"
              | "direct_marketing_outbound_telemarketing"
              | "direct_marketing_subscription"
              | "direct_marketing_travel"
              | "discount_stores"
              | "doctors"
              | "door_to_door_sales"
              | "drapery_window_covering_and_upholstery_stores"
              | "drinking_places"
              | "drug_stores_and_pharmacies"
              | "drugs_drug_proprietaries_and_druggist_sundries"
              | "dry_cleaners"
              | "durable_goods"
              | "duty_free_stores"
              | "eating_places_restaurants"
              | "educational_services"
              | "electric_razor_stores"
              | "electric_vehicle_charging"
              | "electrical_parts_and_equipment"
              | "electrical_services"
              | "electronics_repair_shops"
              | "electronics_stores"
              | "elementary_secondary_schools"
              | "emergency_services_gcas_visa_use_only"
              | "employment_temp_agencies"
              | "equipment_rental"
              | "exterminating_services"
              | "family_clothing_stores"
              | "fast_food_restaurants"
              | "financial_institutions"
              | "fines_government_administrative_entities"
              | "fireplace_fireplace_screens_and_accessories_stores"
              | "floor_covering_stores"
              | "florists"
              | "florists_supplies_nursery_stock_and_flowers"
              | "freezer_and_locker_meat_provisioners"
              | "fuel_dealers_non_automotive"
              | "funeral_services_crematories"
              | "furniture_home_furnishings_and_equipment_stores_except_appliances"
              | "furniture_repair_refinishing"
              | "furriers_and_fur_shops"
              | "general_services"
              | "gift_card_novelty_and_souvenir_shops"
              | "glass_paint_and_wallpaper_stores"
              | "glassware_crystal_stores"
              | "golf_courses_public"
              | "government_licensed_horse_dog_racing_us_region_only"
              | "government_licensed_online_casions_online_gambling_us_region_only"
              | "government_owned_lotteries_non_us_region"
              | "government_owned_lotteries_us_region_only"
              | "government_services"
              | "grocery_stores_supermarkets"
              | "hardware_equipment_and_supplies"
              | "hardware_stores"
              | "health_and_beauty_spas"
              | "hearing_aids_sales_and_supplies"
              | "heating_plumbing_a_c"
              | "hobby_toy_and_game_shops"
              | "home_supply_warehouse_stores"
              | "hospitals"
              | "hotels_motels_and_resorts"
              | "household_appliance_stores"
              | "industrial_supplies"
              | "information_retrieval_services"
              | "insurance_default"
              | "insurance_underwriting_premiums"
              | "intra_company_purchases"
              | "jewelry_stores_watches_clocks_and_silverware_stores"
              | "landscaping_services"
              | "laundries"
              | "laundry_cleaning_services"
              | "legal_services_attorneys"
              | "luggage_and_leather_goods_stores"
              | "lumber_building_materials_stores"
              | "manual_cash_disburse"
              | "marinas_service_and_supplies"
              | "marketplaces"
              | "masonry_stonework_and_plaster"
              | "massage_parlors"
              | "medical_and_dental_labs"
              | "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
              | "medical_services"
              | "membership_organizations"
              | "mens_and_boys_clothing_and_accessories_stores"
              | "mens_womens_clothing_stores"
              | "metal_service_centers"
              | "miscellaneous"
              | "miscellaneous_apparel_and_accessory_shops"
              | "miscellaneous_auto_dealers"
              | "miscellaneous_business_services"
              | "miscellaneous_food_stores"
              | "miscellaneous_general_merchandise"
              | "miscellaneous_general_services"
              | "miscellaneous_home_furnishing_specialty_stores"
              | "miscellaneous_publishing_and_printing"
              | "miscellaneous_recreation_services"
              | "miscellaneous_repair_shops"
              | "miscellaneous_specialty_retail"
              | "mobile_home_dealers"
              | "motion_picture_theaters"
              | "motor_freight_carriers_and_trucking"
              | "motor_homes_dealers"
              | "motor_vehicle_supplies_and_new_parts"
              | "motorcycle_shops_and_dealers"
              | "motorcycle_shops_dealers"
              | "music_stores_musical_instruments_pianos_and_sheet_music"
              | "news_dealers_and_newsstands"
              | "non_fi_money_orders"
              | "non_fi_stored_value_card_purchase_load"
              | "nondurable_goods"
              | "nurseries_lawn_and_garden_supply_stores"
              | "nursing_personal_care"
              | "office_and_commercial_furniture"
              | "opticians_eyeglasses"
              | "optometrists_ophthalmologist"
              | "orthopedic_goods_prosthetic_devices"
              | "osteopaths"
              | "package_stores_beer_wine_and_liquor"
              | "paints_varnishes_and_supplies"
              | "parking_lots_garages"
              | "passenger_railways"
              | "pawn_shops"
              | "pet_shops_pet_food_and_supplies"
              | "petroleum_and_petroleum_products"
              | "photo_developing"
              | "photographic_photocopy_microfilm_equipment_and_supplies"
              | "photographic_studios"
              | "picture_video_production"
              | "piece_goods_notions_and_other_dry_goods"
              | "plumbing_heating_equipment_and_supplies"
              | "political_organizations"
              | "postal_services_government_only"
              | "precious_stones_and_metals_watches_and_jewelry"
              | "professional_services"
              | "public_warehousing_and_storage"
              | "quick_copy_repro_and_blueprint"
              | "railroads"
              | "real_estate_agents_and_managers_rentals"
              | "record_stores"
              | "recreational_vehicle_rentals"
              | "religious_goods_stores"
              | "religious_organizations"
              | "roofing_siding_sheet_metal"
              | "secretarial_support_services"
              | "security_brokers_dealers"
              | "service_stations"
              | "sewing_needlework_fabric_and_piece_goods_stores"
              | "shoe_repair_hat_cleaning"
              | "shoe_stores"
              | "small_appliance_repair"
              | "snowmobile_dealers"
              | "special_trade_services"
              | "specialty_cleaning"
              | "sporting_goods_stores"
              | "sporting_recreation_camps"
              | "sports_and_riding_apparel_stores"
              | "sports_clubs_fields"
              | "stamp_and_coin_stores"
              | "stationary_office_supplies_printing_and_writing_paper"
              | "stationery_stores_office_and_school_supply_stores"
              | "swimming_pools_sales"
              | "t_ui_travel_germany"
              | "tailors_alterations"
              | "tax_payments_government_agencies"
              | "tax_preparation_services"
              | "taxicabs_limousines"
              | "telecommunication_equipment_and_telephone_sales"
              | "telecommunication_services"
              | "telegraph_services"
              | "tent_and_awning_shops"
              | "testing_laboratories"
              | "theatrical_ticket_agencies"
              | "timeshares"
              | "tire_retreading_and_repair"
              | "tolls_bridge_fees"
              | "tourist_attractions_and_exhibits"
              | "towing_services"
              | "trailer_parks_campgrounds"
              | "transportation_services"
              | "travel_agencies_tour_operators"
              | "truck_stop_iteration"
              | "truck_utility_trailer_rentals"
              | "typesetting_plate_making_and_related_services"
              | "typewriter_stores"
              | "u_s_federal_government_agencies_or_departments"
              | "uniforms_commercial_clothing"
              | "used_merchandise_and_secondhand_stores"
              | "utilities"
              | "variety_stores"
              | "veterinary_services"
              | "video_amusement_game_supplies"
              | "video_game_arcades"
              | "video_tape_rental_stores"
              | "vocational_trade_schools"
              | "watch_jewelry_repair"
              | "welding_repair"
              | "wholesale_clubs"
              | "wig_and_toupee_stores"
              | "wires_money_orders"
              | "womens_accessory_and_specialty_shops"
              | "womens_ready_to_wear_stores"
              | "wrecking_and_salvage_yards"
            )[]
            interval:
              | "all_time"
              | "daily"
              | "monthly"
              | "per_authorization"
              | "weekly"
              | "yearly"
          }[]
        }
        status?: "active" | "canceled" | "inactive"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_card> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/issuing/cards/${p["card"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingDisputes(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "expired" | "lost" | "submitted" | "unsubmitted" | "won"
      transaction?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_issuing_dispute[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/disputes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      transaction: p["transaction"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingDisputes(
    p: {
      requestBody?: {
        amount?: number
        evidence?: {
          canceled?:
            | {
                additional_documentation?: string | ""
                canceled_at?: number | ""
                cancellation_policy_provided?: boolean | ""
                cancellation_reason?: string
                expected_at?: number | ""
                explanation?: string
                product_description?: string
                product_type?: "" | "merchandise" | "service"
                return_status?: "" | "merchant_rejected" | "successful"
                returned_at?: number | ""
              }
            | ""
          duplicate?:
            | {
                additional_documentation?: string | ""
                card_statement?: string | ""
                cash_receipt?: string | ""
                check_image?: string | ""
                explanation?: string
                original_transaction?: string
              }
            | ""
          fraudulent?:
            | {
                additional_documentation?: string | ""
                explanation?: string
              }
            | ""
          merchandise_not_as_described?:
            | {
                additional_documentation?: string | ""
                explanation?: string
                received_at?: number | ""
                return_description?: string
                return_status?: "" | "merchant_rejected" | "successful"
                returned_at?: number | ""
              }
            | ""
          not_received?:
            | {
                additional_documentation?: string | ""
                expected_at?: number | ""
                explanation?: string
                product_description?: string
                product_type?: "" | "merchandise" | "service"
              }
            | ""
          other?:
            | {
                additional_documentation?: string | ""
                explanation?: string
                product_description?: string
                product_type?: "" | "merchandise" | "service"
              }
            | ""
          reason?:
            | "canceled"
            | "duplicate"
            | "fraudulent"
            | "merchandise_not_as_described"
            | "not_received"
            | "other"
            | "service_not_as_described"
          service_not_as_described?:
            | {
                additional_documentation?: string | ""
                canceled_at?: number | ""
                cancellation_reason?: string
                explanation?: string
                received_at?: number | ""
              }
            | ""
        }
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        transaction?: string
        treasury?: {
          received_debit: string
        }
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/issuing/disputes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingDisputesDispute(
    p: {
      dispute: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/issuing/disputes/${p["dispute"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingDisputesDispute(
    p: {
      dispute: string
      requestBody?: {
        amount?: number
        evidence?: {
          canceled?:
            | {
                additional_documentation?: string | ""
                canceled_at?: number | ""
                cancellation_policy_provided?: boolean | ""
                cancellation_reason?: string
                expected_at?: number | ""
                explanation?: string
                product_description?: string
                product_type?: "" | "merchandise" | "service"
                return_status?: "" | "merchant_rejected" | "successful"
                returned_at?: number | ""
              }
            | ""
          duplicate?:
            | {
                additional_documentation?: string | ""
                card_statement?: string | ""
                cash_receipt?: string | ""
                check_image?: string | ""
                explanation?: string
                original_transaction?: string
              }
            | ""
          fraudulent?:
            | {
                additional_documentation?: string | ""
                explanation?: string
              }
            | ""
          merchandise_not_as_described?:
            | {
                additional_documentation?: string | ""
                explanation?: string
                received_at?: number | ""
                return_description?: string
                return_status?: "" | "merchant_rejected" | "successful"
                returned_at?: number | ""
              }
            | ""
          not_received?:
            | {
                additional_documentation?: string | ""
                expected_at?: number | ""
                explanation?: string
                product_description?: string
                product_type?: "" | "merchandise" | "service"
              }
            | ""
          other?:
            | {
                additional_documentation?: string | ""
                explanation?: string
                product_description?: string
                product_type?: "" | "merchandise" | "service"
              }
            | ""
          reason?:
            | "canceled"
            | "duplicate"
            | "fraudulent"
            | "merchandise_not_as_described"
            | "not_received"
            | "other"
            | "service_not_as_described"
          service_not_as_described?:
            | {
                additional_documentation?: string | ""
                canceled_at?: number | ""
                cancellation_reason?: string
                explanation?: string
                received_at?: number | ""
              }
            | ""
        }
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/issuing/disputes/${p["dispute"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingDisputesDisputeSubmit(
    p: {
      dispute: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/issuing/disputes/${p["dispute"]}/submit`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingSettlements(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_issuing_settlement[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/settlements`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingSettlementsSettlement(
    p: {
      expand?: string[]
      settlement: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_settlement> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/settlements/${p["settlement"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingSettlementsSettlement(
    p: {
      settlement: string
      requestBody?: {
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_settlement> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/settlements/${p["settlement"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingTransactions(
    p: {
      card?: string
      cardholder?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?: "capture" | "refund"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_issuing_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/transactions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      card: p["card"],
      cardholder: p["cardholder"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getIssuingTransactionsTransaction(
    p: {
      expand?: string[]
      transaction: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/transactions/${p["transaction"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postIssuingTransactionsTransaction(
    p: {
      transaction: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issuing_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/issuing/transactions/${p["transaction"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postLinkAccountSessions(
    p: {
      requestBody: {
        account_holder: {
          account?: string
          customer?: string
          type: "account" | "customer"
        }
        expand?: string[]
        filters?: {
          countries: string[]
        }
        permissions: (
          | "balances"
          | "ownership"
          | "payment_method"
          | "transactions"
        )[]
        return_url?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/link_account_sessions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getLinkAccountSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/link_account_sessions/${p["session"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getLinkedAccounts(
    p: {
      accountHolder?: {
        account?: string
        customer?: string
      }
      endingBefore?: string
      expand?: string[]
      limit?: number
      session?: string
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_financial_connections_account[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/linked_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      account_holder: p["accountHolder"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      session: p["session"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getLinkedAccountsAccount(
    p: {
      account: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postLinkedAccountsAccountDisconnect(
    p: {
      account: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}/disconnect`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getLinkedAccountsAccountOwners(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      ownership: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_financial_connections_account_owner[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}/owners`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      ownership: p["ownership"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postLinkedAccountsAccountRefresh(
    p: {
      account: string
      requestBody: {
        expand?: string[]
        features: ("balance" | "ownership")[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}/refresh`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getMandatesMandate(
    p: {
      expand?: string[]
      mandate: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_mandate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/mandates/${p["mandate"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentIntents(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_payment_intent[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/payment_intents`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntents(
    p: {
      requestBody: {
        amount: number
        application_fee_amount?: number
        automatic_payment_methods?: {
          enabled: boolean
        }
        capture_method?: "automatic" | "automatic_async" | "manual"
        confirm?: boolean
        confirmation_method?: "automatic" | "manual"
        currency: string
        customer?: string
        description?: string
        error_on_requires_action?: boolean
        expand?: string[]
        mandate?: string
        mandate_data?: {
          customer_acceptance: {
            accepted_at?: number
            offline?: EmptyObject
            online?: {
              ip_address: string
              user_agent: string
            }
            type: "offline" | "online"
          }
        }
        metadata?: {
          [key: string]: string
        }
        off_session?: boolean | "one_off" | "recurring"
        on_behalf_of?: string
        payment_method?: string
        payment_method_data?: {
          acss_debit?: {
            account_number: string
            institution_number: string
            transit_number: string
          }
          affirm?: EmptyObject
          afterpay_clearpay?: EmptyObject
          alipay?: EmptyObject
          au_becs_debit?: {
            account_number: string
            bsb_number: string
          }
          bacs_debit?: {
            account_number?: string
            sort_code?: string
          }
          bancontact?: EmptyObject
          billing_details?: {
            address?:
              | {
                  city?: string
                  country?: string
                  line1?: string
                  line2?: string
                  postal_code?: string
                  state?: string
                }
              | ""
            email?: string | ""
            name?: string
            phone?: string
          }
          blik?: EmptyObject
          boleto?: {
            tax_id: string
          }
          cashapp?: EmptyObject
          customer_balance?: EmptyObject
          eps?: {
            bank?:
              | "arzte_und_apotheker_bank"
              | "austrian_anadi_bank_ag"
              | "bank_austria"
              | "bankhaus_carl_spangler"
              | "bankhaus_schelhammer_und_schattera_ag"
              | "bawag_psk_ag"
              | "bks_bank_ag"
              | "brull_kallmus_bank_ag"
              | "btv_vier_lander_bank"
              | "capital_bank_grawe_gruppe_ag"
              | "deutsche_bank_ag"
              | "dolomitenbank"
              | "easybank_ag"
              | "erste_bank_und_sparkassen"
              | "hypo_alpeadriabank_international_ag"
              | "hypo_bank_burgenland_aktiengesellschaft"
              | "hypo_noe_lb_fur_niederosterreich_u_wien"
              | "hypo_oberosterreich_salzburg_steiermark"
              | "hypo_tirol_bank_ag"
              | "hypo_vorarlberg_bank_ag"
              | "marchfelder_bank"
              | "oberbank_ag"
              | "raiffeisen_bankengruppe_osterreich"
              | "schoellerbank_ag"
              | "sparda_bank_wien"
              | "volksbank_gruppe"
              | "volkskreditbank_ag"
              | "vr_bank_braunau"
          }
          fpx?: {
            bank:
              | "affin_bank"
              | "agrobank"
              | "alliance_bank"
              | "ambank"
              | "bank_islam"
              | "bank_muamalat"
              | "bank_of_china"
              | "bank_rakyat"
              | "bsn"
              | "cimb"
              | "deutsche_bank"
              | "hong_leong_bank"
              | "hsbc"
              | "kfh"
              | "maybank2e"
              | "maybank2u"
              | "ocbc"
              | "pb_enterprise"
              | "public_bank"
              | "rhb"
              | "standard_chartered"
              | "uob"
          }
          giropay?: EmptyObject
          grabpay?: EmptyObject
          ideal?: {
            bank?:
              | "abn_amro"
              | "asn_bank"
              | "bunq"
              | "handelsbanken"
              | "ing"
              | "knab"
              | "moneyou"
              | "rabobank"
              | "regiobank"
              | "revolut"
              | "sns_bank"
              | "triodos_bank"
              | "van_lanschot"
              | "yoursafe"
          }
          interac_present?: EmptyObject
          klarna?: {
            dob?: {
              day: number
              month: number
              year: number
            }
          }
          konbini?: EmptyObject
          link?: EmptyObject
          metadata?: {
            [key: string]: string
          }
          oxxo?: EmptyObject
          p24?: {
            bank?:
              | "alior_bank"
              | "bank_millennium"
              | "bank_nowy_bfg_sa"
              | "bank_pekao_sa"
              | "banki_spbdzielcze"
              | "blik"
              | "bnp_paribas"
              | "boz"
              | "citi_handlowy"
              | "credit_agricole"
              | "envelobank"
              | "etransfer_pocztowy24"
              | "getin_bank"
              | "ideabank"
              | "ing"
              | "inteligo"
              | "mbank_mtransfer"
              | "nest_przelew"
              | "noble_pay"
              | "pbac_z_ipko"
              | "plus_bank"
              | "santander_przelew24"
              | "tmobile_usbugi_bankowe"
              | "toyota_bank"
              | "volkswagen_bank"
          }
          paynow?: EmptyObject
          pix?: EmptyObject
          promptpay?: EmptyObject
          radar_options?: {
            session?: string
          }
          sepa_debit?: {
            iban: string
          }
          sofort?: {
            country: "AT" | "BE" | "DE" | "ES" | "IT" | "NL"
          }
          type:
            | "acss_debit"
            | "affirm"
            | "afterpay_clearpay"
            | "alipay"
            | "au_becs_debit"
            | "bacs_debit"
            | "bancontact"
            | "blik"
            | "boleto"
            | "cashapp"
            | "customer_balance"
            | "eps"
            | "fpx"
            | "giropay"
            | "grabpay"
            | "ideal"
            | "klarna"
            | "konbini"
            | "link"
            | "oxxo"
            | "p24"
            | "paynow"
            | "pix"
            | "promptpay"
            | "sepa_debit"
            | "sofort"
            | "us_bank_account"
            | "wechat_pay"
          us_bank_account?: {
            account_holder_type?: "company" | "individual"
            account_number?: string
            account_type?: "checking" | "savings"
            financial_connections_account?: string
            routing_number?: string
          }
          wechat_pay?: EmptyObject
        }
        payment_method_options?: {
          acss_debit?:
            | {
                mandate_options?: {
                  custom_mandate_url?: string | ""
                  interval_description?: string
                  payment_schedule?: "combined" | "interval" | "sporadic"
                  transaction_type?: "business" | "personal"
                }
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                verification_method?: "automatic" | "instant" | "microdeposits"
              }
            | ""
          affirm?:
            | {
                capture_method?: "" | "manual"
                preferred_locale?: string
                setup_future_usage?: "none"
              }
            | ""
          afterpay_clearpay?:
            | {
                capture_method?: "" | "manual"
                reference?: string
                setup_future_usage?: "none"
              }
            | ""
          alipay?:
            | {
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          au_becs_debit?:
            | {
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          bacs_debit?:
            | {
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          bancontact?:
            | {
                preferred_language?: "de" | "en" | "fr" | "nl"
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          blik?:
            | {
                code?: string
              }
            | ""
          boleto?:
            | {
                expires_after_days?: number
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          card?:
            | {
                capture_method?: "" | "manual"
                cvc_token?: string
                installments?: {
                  enabled?: boolean
                  plan?:
                    | {
                        count: number
                        interval: "month"
                        type: "fixed_count"
                      }
                    | ""
                }
                mandate_options?: {
                  amount: number
                  amount_type: "fixed" | "maximum"
                  description?: string
                  end_date?: number
                  interval: "day" | "month" | "sporadic" | "week" | "year"
                  interval_count?: number
                  reference: string
                  start_date: number
                  supported_types?: "india"[]
                }
                network?:
                  | "amex"
                  | "cartes_bancaires"
                  | "diners"
                  | "discover"
                  | "interac"
                  | "jcb"
                  | "mastercard"
                  | "unionpay"
                  | "unknown"
                  | "visa"
                request_three_d_secure?: "any" | "automatic"
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                statement_descriptor_suffix_kana?: string | ""
                statement_descriptor_suffix_kanji?: string | ""
              }
            | ""
          card_present?:
            | {
                request_extended_authorization?: boolean
                request_incremental_authorization_support?: boolean
              }
            | ""
          cashapp?:
            | {
                capture_method?: "" | "manual"
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          customer_balance?:
            | {
                bank_transfer?: {
                  eu_bank_transfer?: {
                    country: string
                  }
                  requested_address_types?: (
                    | "iban"
                    | "sepa"
                    | "sort_code"
                    | "spei"
                    | "zengin"
                  )[]
                  type:
                    | "eu_bank_transfer"
                    | "gb_bank_transfer"
                    | "jp_bank_transfer"
                    | "mx_bank_transfer"
                }
                funding_type?: "bank_transfer"
                setup_future_usage?: "none"
              }
            | ""
          eps?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          fpx?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          giropay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          grabpay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          ideal?:
            | {
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          interac_present?: EmptyObject | ""
          klarna?:
            | {
                capture_method?: "" | "manual"
                preferred_locale?:
                  | "cs-CZ"
                  | "da-DK"
                  | "de-AT"
                  | "de-CH"
                  | "de-DE"
                  | "el-GR"
                  | "en-AT"
                  | "en-AU"
                  | "en-BE"
                  | "en-CA"
                  | "en-CH"
                  | "en-CZ"
                  | "en-DE"
                  | "en-DK"
                  | "en-ES"
                  | "en-FI"
                  | "en-FR"
                  | "en-GB"
                  | "en-GR"
                  | "en-IE"
                  | "en-IT"
                  | "en-NL"
                  | "en-NO"
                  | "en-NZ"
                  | "en-PL"
                  | "en-PT"
                  | "en-SE"
                  | "en-US"
                  | "es-ES"
                  | "es-US"
                  | "fi-FI"
                  | "fr-BE"
                  | "fr-CA"
                  | "fr-CH"
                  | "fr-FR"
                  | "it-CH"
                  | "it-IT"
                  | "nb-NO"
                  | "nl-BE"
                  | "nl-NL"
                  | "pl-PL"
                  | "pt-PT"
                  | "sv-FI"
                  | "sv-SE"
                setup_future_usage?: "none"
              }
            | ""
          konbini?:
            | {
                confirmation_number?: string
                expires_after_days?: number | ""
                expires_at?: number | ""
                product_description?: string
                setup_future_usage?: "none"
              }
            | ""
          link?:
            | {
                capture_method?: "" | "manual"
                persistent_token?: string
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          oxxo?:
            | {
                expires_after_days?: number
                setup_future_usage?: "none"
              }
            | ""
          p24?:
            | {
                setup_future_usage?: "none"
                tos_shown_and_accepted?: boolean
              }
            | ""
          paynow?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          pix?:
            | {
                expires_after_seconds?: number
                expires_at?: number
                setup_future_usage?: "none"
              }
            | ""
          promptpay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          sepa_debit?:
            | {
                mandate_options?: EmptyObject
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          sofort?:
            | {
                preferred_language?:
                  | ""
                  | "de"
                  | "en"
                  | "es"
                  | "fr"
                  | "it"
                  | "nl"
                  | "pl"
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          us_bank_account?:
            | {
                financial_connections?: {
                  permissions?: (
                    | "balances"
                    | "ownership"
                    | "payment_method"
                    | "transactions"
                  )[]
                  return_url?: string
                }
                networks?: {
                  requested?: ("ach" | "us_domestic_wire")[]
                }
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                verification_method?: "automatic" | "instant" | "microdeposits"
              }
            | ""
          wechat_pay?:
            | {
                app_id?: string
                client: "android" | "ios" | "web"
                setup_future_usage?: "none"
              }
            | ""
        }
        payment_method_types?: string[]
        radar_options?: {
          session?: string
        }
        receipt_email?: string
        return_url?: string
        setup_future_usage?: "off_session" | "on_session"
        shipping?: {
          address: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          carrier?: string
          name: string
          phone?: string
          tracking_number?: string
        }
        statement_descriptor?: string
        statement_descriptor_suffix?: string
        transfer_data?: {
          amount?: number
          destination: string
        }
        transfer_group?: string
        use_stripe_sdk?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_intents`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentIntentsSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_payment_intent[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/payment_intents/search`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentIntentsIntent(
    p: {
      clientSecret?: string
      expand?: string[]
      intent: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      client_secret: p["clientSecret"],
      expand: p["expand"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntentsIntent(
    p: {
      intent: string
      requestBody?: {
        amount?: number
        application_fee_amount?: number | ""
        capture_method?: "automatic" | "automatic_async" | "manual"
        currency?: string
        customer?: string
        description?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        payment_method?: string
        payment_method_data?: {
          acss_debit?: {
            account_number: string
            institution_number: string
            transit_number: string
          }
          affirm?: EmptyObject
          afterpay_clearpay?: EmptyObject
          alipay?: EmptyObject
          au_becs_debit?: {
            account_number: string
            bsb_number: string
          }
          bacs_debit?: {
            account_number?: string
            sort_code?: string
          }
          bancontact?: EmptyObject
          billing_details?: {
            address?:
              | {
                  city?: string
                  country?: string
                  line1?: string
                  line2?: string
                  postal_code?: string
                  state?: string
                }
              | ""
            email?: string | ""
            name?: string
            phone?: string
          }
          blik?: EmptyObject
          boleto?: {
            tax_id: string
          }
          cashapp?: EmptyObject
          customer_balance?: EmptyObject
          eps?: {
            bank?:
              | "arzte_und_apotheker_bank"
              | "austrian_anadi_bank_ag"
              | "bank_austria"
              | "bankhaus_carl_spangler"
              | "bankhaus_schelhammer_und_schattera_ag"
              | "bawag_psk_ag"
              | "bks_bank_ag"
              | "brull_kallmus_bank_ag"
              | "btv_vier_lander_bank"
              | "capital_bank_grawe_gruppe_ag"
              | "deutsche_bank_ag"
              | "dolomitenbank"
              | "easybank_ag"
              | "erste_bank_und_sparkassen"
              | "hypo_alpeadriabank_international_ag"
              | "hypo_bank_burgenland_aktiengesellschaft"
              | "hypo_noe_lb_fur_niederosterreich_u_wien"
              | "hypo_oberosterreich_salzburg_steiermark"
              | "hypo_tirol_bank_ag"
              | "hypo_vorarlberg_bank_ag"
              | "marchfelder_bank"
              | "oberbank_ag"
              | "raiffeisen_bankengruppe_osterreich"
              | "schoellerbank_ag"
              | "sparda_bank_wien"
              | "volksbank_gruppe"
              | "volkskreditbank_ag"
              | "vr_bank_braunau"
          }
          fpx?: {
            bank:
              | "affin_bank"
              | "agrobank"
              | "alliance_bank"
              | "ambank"
              | "bank_islam"
              | "bank_muamalat"
              | "bank_of_china"
              | "bank_rakyat"
              | "bsn"
              | "cimb"
              | "deutsche_bank"
              | "hong_leong_bank"
              | "hsbc"
              | "kfh"
              | "maybank2e"
              | "maybank2u"
              | "ocbc"
              | "pb_enterprise"
              | "public_bank"
              | "rhb"
              | "standard_chartered"
              | "uob"
          }
          giropay?: EmptyObject
          grabpay?: EmptyObject
          ideal?: {
            bank?:
              | "abn_amro"
              | "asn_bank"
              | "bunq"
              | "handelsbanken"
              | "ing"
              | "knab"
              | "moneyou"
              | "rabobank"
              | "regiobank"
              | "revolut"
              | "sns_bank"
              | "triodos_bank"
              | "van_lanschot"
              | "yoursafe"
          }
          interac_present?: EmptyObject
          klarna?: {
            dob?: {
              day: number
              month: number
              year: number
            }
          }
          konbini?: EmptyObject
          link?: EmptyObject
          metadata?: {
            [key: string]: string
          }
          oxxo?: EmptyObject
          p24?: {
            bank?:
              | "alior_bank"
              | "bank_millennium"
              | "bank_nowy_bfg_sa"
              | "bank_pekao_sa"
              | "banki_spbdzielcze"
              | "blik"
              | "bnp_paribas"
              | "boz"
              | "citi_handlowy"
              | "credit_agricole"
              | "envelobank"
              | "etransfer_pocztowy24"
              | "getin_bank"
              | "ideabank"
              | "ing"
              | "inteligo"
              | "mbank_mtransfer"
              | "nest_przelew"
              | "noble_pay"
              | "pbac_z_ipko"
              | "plus_bank"
              | "santander_przelew24"
              | "tmobile_usbugi_bankowe"
              | "toyota_bank"
              | "volkswagen_bank"
          }
          paynow?: EmptyObject
          pix?: EmptyObject
          promptpay?: EmptyObject
          radar_options?: {
            session?: string
          }
          sepa_debit?: {
            iban: string
          }
          sofort?: {
            country: "AT" | "BE" | "DE" | "ES" | "IT" | "NL"
          }
          type:
            | "acss_debit"
            | "affirm"
            | "afterpay_clearpay"
            | "alipay"
            | "au_becs_debit"
            | "bacs_debit"
            | "bancontact"
            | "blik"
            | "boleto"
            | "cashapp"
            | "customer_balance"
            | "eps"
            | "fpx"
            | "giropay"
            | "grabpay"
            | "ideal"
            | "klarna"
            | "konbini"
            | "link"
            | "oxxo"
            | "p24"
            | "paynow"
            | "pix"
            | "promptpay"
            | "sepa_debit"
            | "sofort"
            | "us_bank_account"
            | "wechat_pay"
          us_bank_account?: {
            account_holder_type?: "company" | "individual"
            account_number?: string
            account_type?: "checking" | "savings"
            financial_connections_account?: string
            routing_number?: string
          }
          wechat_pay?: EmptyObject
        }
        payment_method_options?: {
          acss_debit?:
            | {
                mandate_options?: {
                  custom_mandate_url?: string | ""
                  interval_description?: string
                  payment_schedule?: "combined" | "interval" | "sporadic"
                  transaction_type?: "business" | "personal"
                }
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                verification_method?: "automatic" | "instant" | "microdeposits"
              }
            | ""
          affirm?:
            | {
                capture_method?: "" | "manual"
                preferred_locale?: string
                setup_future_usage?: "none"
              }
            | ""
          afterpay_clearpay?:
            | {
                capture_method?: "" | "manual"
                reference?: string
                setup_future_usage?: "none"
              }
            | ""
          alipay?:
            | {
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          au_becs_debit?:
            | {
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          bacs_debit?:
            | {
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          bancontact?:
            | {
                preferred_language?: "de" | "en" | "fr" | "nl"
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          blik?:
            | {
                code?: string
              }
            | ""
          boleto?:
            | {
                expires_after_days?: number
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          card?:
            | {
                capture_method?: "" | "manual"
                cvc_token?: string
                installments?: {
                  enabled?: boolean
                  plan?:
                    | {
                        count: number
                        interval: "month"
                        type: "fixed_count"
                      }
                    | ""
                }
                mandate_options?: {
                  amount: number
                  amount_type: "fixed" | "maximum"
                  description?: string
                  end_date?: number
                  interval: "day" | "month" | "sporadic" | "week" | "year"
                  interval_count?: number
                  reference: string
                  start_date: number
                  supported_types?: "india"[]
                }
                network?:
                  | "amex"
                  | "cartes_bancaires"
                  | "diners"
                  | "discover"
                  | "interac"
                  | "jcb"
                  | "mastercard"
                  | "unionpay"
                  | "unknown"
                  | "visa"
                request_three_d_secure?: "any" | "automatic"
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                statement_descriptor_suffix_kana?: string | ""
                statement_descriptor_suffix_kanji?: string | ""
              }
            | ""
          card_present?:
            | {
                request_extended_authorization?: boolean
                request_incremental_authorization_support?: boolean
              }
            | ""
          cashapp?:
            | {
                capture_method?: "" | "manual"
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          customer_balance?:
            | {
                bank_transfer?: {
                  eu_bank_transfer?: {
                    country: string
                  }
                  requested_address_types?: (
                    | "iban"
                    | "sepa"
                    | "sort_code"
                    | "spei"
                    | "zengin"
                  )[]
                  type:
                    | "eu_bank_transfer"
                    | "gb_bank_transfer"
                    | "jp_bank_transfer"
                    | "mx_bank_transfer"
                }
                funding_type?: "bank_transfer"
                setup_future_usage?: "none"
              }
            | ""
          eps?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          fpx?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          giropay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          grabpay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          ideal?:
            | {
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          interac_present?: EmptyObject | ""
          klarna?:
            | {
                capture_method?: "" | "manual"
                preferred_locale?:
                  | "cs-CZ"
                  | "da-DK"
                  | "de-AT"
                  | "de-CH"
                  | "de-DE"
                  | "el-GR"
                  | "en-AT"
                  | "en-AU"
                  | "en-BE"
                  | "en-CA"
                  | "en-CH"
                  | "en-CZ"
                  | "en-DE"
                  | "en-DK"
                  | "en-ES"
                  | "en-FI"
                  | "en-FR"
                  | "en-GB"
                  | "en-GR"
                  | "en-IE"
                  | "en-IT"
                  | "en-NL"
                  | "en-NO"
                  | "en-NZ"
                  | "en-PL"
                  | "en-PT"
                  | "en-SE"
                  | "en-US"
                  | "es-ES"
                  | "es-US"
                  | "fi-FI"
                  | "fr-BE"
                  | "fr-CA"
                  | "fr-CH"
                  | "fr-FR"
                  | "it-CH"
                  | "it-IT"
                  | "nb-NO"
                  | "nl-BE"
                  | "nl-NL"
                  | "pl-PL"
                  | "pt-PT"
                  | "sv-FI"
                  | "sv-SE"
                setup_future_usage?: "none"
              }
            | ""
          konbini?:
            | {
                confirmation_number?: string
                expires_after_days?: number | ""
                expires_at?: number | ""
                product_description?: string
                setup_future_usage?: "none"
              }
            | ""
          link?:
            | {
                capture_method?: "" | "manual"
                persistent_token?: string
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          oxxo?:
            | {
                expires_after_days?: number
                setup_future_usage?: "none"
              }
            | ""
          p24?:
            | {
                setup_future_usage?: "none"
                tos_shown_and_accepted?: boolean
              }
            | ""
          paynow?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          pix?:
            | {
                expires_after_seconds?: number
                expires_at?: number
                setup_future_usage?: "none"
              }
            | ""
          promptpay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          sepa_debit?:
            | {
                mandate_options?: EmptyObject
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          sofort?:
            | {
                preferred_language?:
                  | ""
                  | "de"
                  | "en"
                  | "es"
                  | "fr"
                  | "it"
                  | "nl"
                  | "pl"
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          us_bank_account?:
            | {
                financial_connections?: {
                  permissions?: (
                    | "balances"
                    | "ownership"
                    | "payment_method"
                    | "transactions"
                  )[]
                  return_url?: string
                }
                networks?: {
                  requested?: ("ach" | "us_domestic_wire")[]
                }
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                verification_method?: "automatic" | "instant" | "microdeposits"
              }
            | ""
          wechat_pay?:
            | {
                app_id?: string
                client: "android" | "ios" | "web"
                setup_future_usage?: "none"
              }
            | ""
        }
        payment_method_types?: string[]
        receipt_email?: string | ""
        setup_future_usage?: "" | "off_session" | "on_session"
        shipping?:
          | {
              address: {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
              carrier?: string
              name: string
              phone?: string
              tracking_number?: string
            }
          | ""
        statement_descriptor?: string
        statement_descriptor_suffix?: string
        transfer_data?: {
          amount?: number
        }
        transfer_group?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntentsIntentApplyCustomerBalance(
    p: {
      intent: string
      requestBody?: {
        amount?: number
        currency?: string
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/payment_intents/${p["intent"]}/apply_customer_balance`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntentsIntentCancel(
    p: {
      intent: string
      requestBody?: {
        cancellation_reason?:
          | "abandoned"
          | "duplicate"
          | "fraudulent"
          | "requested_by_customer"
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntentsIntentCapture(
    p: {
      intent: string
      requestBody?: {
        amount_to_capture?: number
        application_fee_amount?: number
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        statement_descriptor?: string
        statement_descriptor_suffix?: string
        transfer_data?: {
          amount?: number
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}/capture`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntentsIntentConfirm(
    p: {
      intent: string
      requestBody?: {
        capture_method?: "automatic" | "automatic_async" | "manual"
        client_secret?: string
        error_on_requires_action?: boolean
        expand?: string[]
        mandate?: string
        mandate_data?:
          | {
              customer_acceptance: {
                accepted_at?: number
                offline?: EmptyObject
                online?: {
                  ip_address: string
                  user_agent: string
                }
                type: "offline" | "online"
              }
            }
          | {
              customer_acceptance: {
                online: {
                  ip_address?: string
                  user_agent?: string
                }
                type: "online"
              }
            }
        off_session?: boolean | "one_off" | "recurring"
        payment_method?: string
        payment_method_data?: {
          acss_debit?: {
            account_number: string
            institution_number: string
            transit_number: string
          }
          affirm?: EmptyObject
          afterpay_clearpay?: EmptyObject
          alipay?: EmptyObject
          au_becs_debit?: {
            account_number: string
            bsb_number: string
          }
          bacs_debit?: {
            account_number?: string
            sort_code?: string
          }
          bancontact?: EmptyObject
          billing_details?: {
            address?:
              | {
                  city?: string
                  country?: string
                  line1?: string
                  line2?: string
                  postal_code?: string
                  state?: string
                }
              | ""
            email?: string | ""
            name?: string
            phone?: string
          }
          blik?: EmptyObject
          boleto?: {
            tax_id: string
          }
          cashapp?: EmptyObject
          customer_balance?: EmptyObject
          eps?: {
            bank?:
              | "arzte_und_apotheker_bank"
              | "austrian_anadi_bank_ag"
              | "bank_austria"
              | "bankhaus_carl_spangler"
              | "bankhaus_schelhammer_und_schattera_ag"
              | "bawag_psk_ag"
              | "bks_bank_ag"
              | "brull_kallmus_bank_ag"
              | "btv_vier_lander_bank"
              | "capital_bank_grawe_gruppe_ag"
              | "deutsche_bank_ag"
              | "dolomitenbank"
              | "easybank_ag"
              | "erste_bank_und_sparkassen"
              | "hypo_alpeadriabank_international_ag"
              | "hypo_bank_burgenland_aktiengesellschaft"
              | "hypo_noe_lb_fur_niederosterreich_u_wien"
              | "hypo_oberosterreich_salzburg_steiermark"
              | "hypo_tirol_bank_ag"
              | "hypo_vorarlberg_bank_ag"
              | "marchfelder_bank"
              | "oberbank_ag"
              | "raiffeisen_bankengruppe_osterreich"
              | "schoellerbank_ag"
              | "sparda_bank_wien"
              | "volksbank_gruppe"
              | "volkskreditbank_ag"
              | "vr_bank_braunau"
          }
          fpx?: {
            bank:
              | "affin_bank"
              | "agrobank"
              | "alliance_bank"
              | "ambank"
              | "bank_islam"
              | "bank_muamalat"
              | "bank_of_china"
              | "bank_rakyat"
              | "bsn"
              | "cimb"
              | "deutsche_bank"
              | "hong_leong_bank"
              | "hsbc"
              | "kfh"
              | "maybank2e"
              | "maybank2u"
              | "ocbc"
              | "pb_enterprise"
              | "public_bank"
              | "rhb"
              | "standard_chartered"
              | "uob"
          }
          giropay?: EmptyObject
          grabpay?: EmptyObject
          ideal?: {
            bank?:
              | "abn_amro"
              | "asn_bank"
              | "bunq"
              | "handelsbanken"
              | "ing"
              | "knab"
              | "moneyou"
              | "rabobank"
              | "regiobank"
              | "revolut"
              | "sns_bank"
              | "triodos_bank"
              | "van_lanschot"
              | "yoursafe"
          }
          interac_present?: EmptyObject
          klarna?: {
            dob?: {
              day: number
              month: number
              year: number
            }
          }
          konbini?: EmptyObject
          link?: EmptyObject
          metadata?: {
            [key: string]: string
          }
          oxxo?: EmptyObject
          p24?: {
            bank?:
              | "alior_bank"
              | "bank_millennium"
              | "bank_nowy_bfg_sa"
              | "bank_pekao_sa"
              | "banki_spbdzielcze"
              | "blik"
              | "bnp_paribas"
              | "boz"
              | "citi_handlowy"
              | "credit_agricole"
              | "envelobank"
              | "etransfer_pocztowy24"
              | "getin_bank"
              | "ideabank"
              | "ing"
              | "inteligo"
              | "mbank_mtransfer"
              | "nest_przelew"
              | "noble_pay"
              | "pbac_z_ipko"
              | "plus_bank"
              | "santander_przelew24"
              | "tmobile_usbugi_bankowe"
              | "toyota_bank"
              | "volkswagen_bank"
          }
          paynow?: EmptyObject
          pix?: EmptyObject
          promptpay?: EmptyObject
          radar_options?: {
            session?: string
          }
          sepa_debit?: {
            iban: string
          }
          sofort?: {
            country: "AT" | "BE" | "DE" | "ES" | "IT" | "NL"
          }
          type:
            | "acss_debit"
            | "affirm"
            | "afterpay_clearpay"
            | "alipay"
            | "au_becs_debit"
            | "bacs_debit"
            | "bancontact"
            | "blik"
            | "boleto"
            | "cashapp"
            | "customer_balance"
            | "eps"
            | "fpx"
            | "giropay"
            | "grabpay"
            | "ideal"
            | "klarna"
            | "konbini"
            | "link"
            | "oxxo"
            | "p24"
            | "paynow"
            | "pix"
            | "promptpay"
            | "sepa_debit"
            | "sofort"
            | "us_bank_account"
            | "wechat_pay"
          us_bank_account?: {
            account_holder_type?: "company" | "individual"
            account_number?: string
            account_type?: "checking" | "savings"
            financial_connections_account?: string
            routing_number?: string
          }
          wechat_pay?: EmptyObject
        }
        payment_method_options?: {
          acss_debit?:
            | {
                mandate_options?: {
                  custom_mandate_url?: string | ""
                  interval_description?: string
                  payment_schedule?: "combined" | "interval" | "sporadic"
                  transaction_type?: "business" | "personal"
                }
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                verification_method?: "automatic" | "instant" | "microdeposits"
              }
            | ""
          affirm?:
            | {
                capture_method?: "" | "manual"
                preferred_locale?: string
                setup_future_usage?: "none"
              }
            | ""
          afterpay_clearpay?:
            | {
                capture_method?: "" | "manual"
                reference?: string
                setup_future_usage?: "none"
              }
            | ""
          alipay?:
            | {
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          au_becs_debit?:
            | {
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          bacs_debit?:
            | {
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          bancontact?:
            | {
                preferred_language?: "de" | "en" | "fr" | "nl"
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          blik?:
            | {
                code?: string
              }
            | ""
          boleto?:
            | {
                expires_after_days?: number
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          card?:
            | {
                capture_method?: "" | "manual"
                cvc_token?: string
                installments?: {
                  enabled?: boolean
                  plan?:
                    | {
                        count: number
                        interval: "month"
                        type: "fixed_count"
                      }
                    | ""
                }
                mandate_options?: {
                  amount: number
                  amount_type: "fixed" | "maximum"
                  description?: string
                  end_date?: number
                  interval: "day" | "month" | "sporadic" | "week" | "year"
                  interval_count?: number
                  reference: string
                  start_date: number
                  supported_types?: "india"[]
                }
                network?:
                  | "amex"
                  | "cartes_bancaires"
                  | "diners"
                  | "discover"
                  | "interac"
                  | "jcb"
                  | "mastercard"
                  | "unionpay"
                  | "unknown"
                  | "visa"
                request_three_d_secure?: "any" | "automatic"
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                statement_descriptor_suffix_kana?: string | ""
                statement_descriptor_suffix_kanji?: string | ""
              }
            | ""
          card_present?:
            | {
                request_extended_authorization?: boolean
                request_incremental_authorization_support?: boolean
              }
            | ""
          cashapp?:
            | {
                capture_method?: "" | "manual"
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          customer_balance?:
            | {
                bank_transfer?: {
                  eu_bank_transfer?: {
                    country: string
                  }
                  requested_address_types?: (
                    | "iban"
                    | "sepa"
                    | "sort_code"
                    | "spei"
                    | "zengin"
                  )[]
                  type:
                    | "eu_bank_transfer"
                    | "gb_bank_transfer"
                    | "jp_bank_transfer"
                    | "mx_bank_transfer"
                }
                funding_type?: "bank_transfer"
                setup_future_usage?: "none"
              }
            | ""
          eps?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          fpx?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          giropay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          grabpay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          ideal?:
            | {
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          interac_present?: EmptyObject | ""
          klarna?:
            | {
                capture_method?: "" | "manual"
                preferred_locale?:
                  | "cs-CZ"
                  | "da-DK"
                  | "de-AT"
                  | "de-CH"
                  | "de-DE"
                  | "el-GR"
                  | "en-AT"
                  | "en-AU"
                  | "en-BE"
                  | "en-CA"
                  | "en-CH"
                  | "en-CZ"
                  | "en-DE"
                  | "en-DK"
                  | "en-ES"
                  | "en-FI"
                  | "en-FR"
                  | "en-GB"
                  | "en-GR"
                  | "en-IE"
                  | "en-IT"
                  | "en-NL"
                  | "en-NO"
                  | "en-NZ"
                  | "en-PL"
                  | "en-PT"
                  | "en-SE"
                  | "en-US"
                  | "es-ES"
                  | "es-US"
                  | "fi-FI"
                  | "fr-BE"
                  | "fr-CA"
                  | "fr-CH"
                  | "fr-FR"
                  | "it-CH"
                  | "it-IT"
                  | "nb-NO"
                  | "nl-BE"
                  | "nl-NL"
                  | "pl-PL"
                  | "pt-PT"
                  | "sv-FI"
                  | "sv-SE"
                setup_future_usage?: "none"
              }
            | ""
          konbini?:
            | {
                confirmation_number?: string
                expires_after_days?: number | ""
                expires_at?: number | ""
                product_description?: string
                setup_future_usage?: "none"
              }
            | ""
          link?:
            | {
                capture_method?: "" | "manual"
                persistent_token?: string
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          oxxo?:
            | {
                expires_after_days?: number
                setup_future_usage?: "none"
              }
            | ""
          p24?:
            | {
                setup_future_usage?: "none"
                tos_shown_and_accepted?: boolean
              }
            | ""
          paynow?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          pix?:
            | {
                expires_after_seconds?: number
                expires_at?: number
                setup_future_usage?: "none"
              }
            | ""
          promptpay?:
            | {
                setup_future_usage?: "none"
              }
            | ""
          sepa_debit?:
            | {
                mandate_options?: EmptyObject
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
              }
            | ""
          sofort?:
            | {
                preferred_language?:
                  | ""
                  | "de"
                  | "en"
                  | "es"
                  | "fr"
                  | "it"
                  | "nl"
                  | "pl"
                setup_future_usage?: "" | "none" | "off_session"
              }
            | ""
          us_bank_account?:
            | {
                financial_connections?: {
                  permissions?: (
                    | "balances"
                    | "ownership"
                    | "payment_method"
                    | "transactions"
                  )[]
                  return_url?: string
                }
                networks?: {
                  requested?: ("ach" | "us_domestic_wire")[]
                }
                setup_future_usage?: "" | "none" | "off_session" | "on_session"
                verification_method?: "automatic" | "instant" | "microdeposits"
              }
            | ""
          wechat_pay?:
            | {
                app_id?: string
                client: "android" | "ios" | "web"
                setup_future_usage?: "none"
              }
            | ""
        }
        payment_method_types?: string[]
        radar_options?: {
          session?: string
        }
        receipt_email?: string | ""
        return_url?: string
        setup_future_usage?: "" | "off_session" | "on_session"
        shipping?:
          | {
              address: {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
              carrier?: string
              name: string
              phone?: string
              tracking_number?: string
            }
          | ""
        use_stripe_sdk?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}/confirm`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntentsIntentIncrementAuthorization(
    p: {
      intent: string
      requestBody: {
        amount: number
        application_fee_amount?: number
        description?: string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        statement_descriptor?: string
        transfer_data?: {
          amount?: number
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/payment_intents/${p["intent"]}/increment_authorization`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentIntentsIntentVerifyMicrodeposits(
    p: {
      intent: string
      requestBody?: {
        amounts?: number[]
        client_secret?: string
        descriptor_code?: string
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_intent> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/payment_intents/${p["intent"]}/verify_microdeposits`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentLinks(
    p: {
      active?: boolean
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_payment_link[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/payment_links`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentLinks(
    p: {
      requestBody: {
        after_completion?: {
          hosted_confirmation?: {
            custom_message?: string
          }
          redirect?: {
            url: string
          }
          type: "hosted_confirmation" | "redirect"
        }
        allow_promotion_codes?: boolean
        application_fee_amount?: number
        application_fee_percent?: number
        automatic_tax?: {
          enabled: boolean
        }
        billing_address_collection?: "auto" | "required"
        consent_collection?: {
          promotions?: "auto" | "none"
          terms_of_service?: "none" | "required"
        }
        currency?: string
        custom_fields?: {
          dropdown?: {
            options: {
              label: string
              value: string
            }[]
          }
          key: string
          label: {
            custom: string
            type: "custom"
          }
          optional?: boolean
          type: "dropdown" | "numeric" | "text"
        }[]
        custom_text?: {
          shipping_address?:
            | {
                message: string
              }
            | ""
          submit?:
            | {
                message: string
              }
            | ""
        }
        customer_creation?: "always" | "if_required"
        expand?: string[]
        invoice_creation?: {
          enabled: boolean
          invoice_data?: {
            account_tax_ids?: string[] | ""
            custom_fields?:
              | {
                  name: string
                  value: string
                }[]
              | ""
            description?: string
            footer?: string
            metadata?:
              | {
                  [key: string]: string
                }
              | ""
            rendering_options?:
              | {
                  amount_tax_display?:
                    | ""
                    | "exclude_tax"
                    | "include_inclusive_tax"
                }
              | ""
          }
        }
        line_items: {
          adjustable_quantity?: {
            enabled: boolean
            maximum?: number
            minimum?: number
          }
          price: string
          quantity: number
        }[]
        metadata?: {
          [key: string]: string
        }
        on_behalf_of?: string
        payment_intent_data?: {
          capture_method?: "automatic" | "automatic_async" | "manual"
          setup_future_usage?: "off_session" | "on_session"
        }
        payment_method_collection?: "always" | "if_required"
        payment_method_types?: (
          | "affirm"
          | "afterpay_clearpay"
          | "alipay"
          | "au_becs_debit"
          | "bacs_debit"
          | "bancontact"
          | "blik"
          | "boleto"
          | "card"
          | "cashapp"
          | "eps"
          | "fpx"
          | "giropay"
          | "grabpay"
          | "ideal"
          | "klarna"
          | "konbini"
          | "link"
          | "oxxo"
          | "p24"
          | "paynow"
          | "pix"
          | "promptpay"
          | "sepa_debit"
          | "sofort"
          | "us_bank_account"
          | "wechat_pay"
        )[]
        phone_number_collection?: {
          enabled: boolean
        }
        shipping_address_collection?: {
          allowed_countries: (
            | "AC"
            | "AD"
            | "AE"
            | "AF"
            | "AG"
            | "AI"
            | "AL"
            | "AM"
            | "AO"
            | "AQ"
            | "AR"
            | "AT"
            | "AU"
            | "AW"
            | "AX"
            | "AZ"
            | "BA"
            | "BB"
            | "BD"
            | "BE"
            | "BF"
            | "BG"
            | "BH"
            | "BI"
            | "BJ"
            | "BL"
            | "BM"
            | "BN"
            | "BO"
            | "BQ"
            | "BR"
            | "BS"
            | "BT"
            | "BV"
            | "BW"
            | "BY"
            | "BZ"
            | "CA"
            | "CD"
            | "CF"
            | "CG"
            | "CH"
            | "CI"
            | "CK"
            | "CL"
            | "CM"
            | "CN"
            | "CO"
            | "CR"
            | "CV"
            | "CW"
            | "CY"
            | "CZ"
            | "DE"
            | "DJ"
            | "DK"
            | "DM"
            | "DO"
            | "DZ"
            | "EC"
            | "EE"
            | "EG"
            | "EH"
            | "ER"
            | "ES"
            | "ET"
            | "FI"
            | "FJ"
            | "FK"
            | "FO"
            | "FR"
            | "GA"
            | "GB"
            | "GD"
            | "GE"
            | "GF"
            | "GG"
            | "GH"
            | "GI"
            | "GL"
            | "GM"
            | "GN"
            | "GP"
            | "GQ"
            | "GR"
            | "GS"
            | "GT"
            | "GU"
            | "GW"
            | "GY"
            | "HK"
            | "HN"
            | "HR"
            | "HT"
            | "HU"
            | "ID"
            | "IE"
            | "IL"
            | "IM"
            | "IN"
            | "IO"
            | "IQ"
            | "IS"
            | "IT"
            | "JE"
            | "JM"
            | "JO"
            | "JP"
            | "KE"
            | "KG"
            | "KH"
            | "KI"
            | "KM"
            | "KN"
            | "KR"
            | "KW"
            | "KY"
            | "KZ"
            | "LA"
            | "LB"
            | "LC"
            | "LI"
            | "LK"
            | "LR"
            | "LS"
            | "LT"
            | "LU"
            | "LV"
            | "LY"
            | "MA"
            | "MC"
            | "MD"
            | "ME"
            | "MF"
            | "MG"
            | "MK"
            | "ML"
            | "MM"
            | "MN"
            | "MO"
            | "MQ"
            | "MR"
            | "MS"
            | "MT"
            | "MU"
            | "MV"
            | "MW"
            | "MX"
            | "MY"
            | "MZ"
            | "NA"
            | "NC"
            | "NE"
            | "NG"
            | "NI"
            | "NL"
            | "NO"
            | "NP"
            | "NR"
            | "NU"
            | "NZ"
            | "OM"
            | "PA"
            | "PE"
            | "PF"
            | "PG"
            | "PH"
            | "PK"
            | "PL"
            | "PM"
            | "PN"
            | "PR"
            | "PS"
            | "PT"
            | "PY"
            | "QA"
            | "RE"
            | "RO"
            | "RS"
            | "RU"
            | "RW"
            | "SA"
            | "SB"
            | "SC"
            | "SE"
            | "SG"
            | "SH"
            | "SI"
            | "SJ"
            | "SK"
            | "SL"
            | "SM"
            | "SN"
            | "SO"
            | "SR"
            | "SS"
            | "ST"
            | "SV"
            | "SX"
            | "SZ"
            | "TA"
            | "TC"
            | "TD"
            | "TF"
            | "TG"
            | "TH"
            | "TJ"
            | "TK"
            | "TL"
            | "TM"
            | "TN"
            | "TO"
            | "TR"
            | "TT"
            | "TV"
            | "TW"
            | "TZ"
            | "UA"
            | "UG"
            | "US"
            | "UY"
            | "UZ"
            | "VA"
            | "VC"
            | "VE"
            | "VG"
            | "VN"
            | "VU"
            | "WF"
            | "WS"
            | "XK"
            | "YE"
            | "YT"
            | "ZA"
            | "ZM"
            | "ZW"
            | "ZZ"
          )[]
        }
        shipping_options?: {
          shipping_rate?: string
        }[]
        submit_type?: "auto" | "book" | "donate" | "pay"
        subscription_data?: {
          description?: string
          trial_period_days?: number
        }
        tax_id_collection?: {
          enabled: boolean
        }
        transfer_data?: {
          amount?: number
          destination: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_links`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentLinksPaymentLink(
    p: {
      expand?: string[]
      paymentLink: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_links/${p["paymentLink"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentLinksPaymentLink(
    p: {
      paymentLink: string
      requestBody?: {
        active?: boolean
        after_completion?: {
          hosted_confirmation?: {
            custom_message?: string
          }
          redirect?: {
            url: string
          }
          type: "hosted_confirmation" | "redirect"
        }
        allow_promotion_codes?: boolean
        automatic_tax?: {
          enabled: boolean
        }
        billing_address_collection?: "auto" | "required"
        custom_fields?:
          | {
              dropdown?: {
                options: {
                  label: string
                  value: string
                }[]
              }
              key: string
              label: {
                custom: string
                type: "custom"
              }
              optional?: boolean
              type: "dropdown" | "numeric" | "text"
            }[]
          | ""
        custom_text?: {
          shipping_address?:
            | {
                message: string
              }
            | ""
          submit?:
            | {
                message: string
              }
            | ""
        }
        customer_creation?: "always" | "if_required"
        expand?: string[]
        invoice_creation?: {
          enabled: boolean
          invoice_data?: {
            account_tax_ids?: string[] | ""
            custom_fields?:
              | {
                  name: string
                  value: string
                }[]
              | ""
            description?: string
            footer?: string
            metadata?:
              | {
                  [key: string]: string
                }
              | ""
            rendering_options?:
              | {
                  amount_tax_display?:
                    | ""
                    | "exclude_tax"
                    | "include_inclusive_tax"
                }
              | ""
          }
        }
        line_items?: {
          adjustable_quantity?: {
            enabled: boolean
            maximum?: number
            minimum?: number
          }
          id: string
          quantity?: number
        }[]
        metadata?: {
          [key: string]: string
        }
        payment_method_collection?: "always" | "if_required"
        payment_method_types?:
          | (
              | "affirm"
              | "afterpay_clearpay"
              | "alipay"
              | "au_becs_debit"
              | "bacs_debit"
              | "bancontact"
              | "blik"
              | "boleto"
              | "card"
              | "cashapp"
              | "eps"
              | "fpx"
              | "giropay"
              | "grabpay"
              | "ideal"
              | "klarna"
              | "konbini"
              | "link"
              | "oxxo"
              | "p24"
              | "paynow"
              | "pix"
              | "promptpay"
              | "sepa_debit"
              | "sofort"
              | "us_bank_account"
              | "wechat_pay"
            )[]
          | ""
        shipping_address_collection?:
          | {
              allowed_countries: (
                | "AC"
                | "AD"
                | "AE"
                | "AF"
                | "AG"
                | "AI"
                | "AL"
                | "AM"
                | "AO"
                | "AQ"
                | "AR"
                | "AT"
                | "AU"
                | "AW"
                | "AX"
                | "AZ"
                | "BA"
                | "BB"
                | "BD"
                | "BE"
                | "BF"
                | "BG"
                | "BH"
                | "BI"
                | "BJ"
                | "BL"
                | "BM"
                | "BN"
                | "BO"
                | "BQ"
                | "BR"
                | "BS"
                | "BT"
                | "BV"
                | "BW"
                | "BY"
                | "BZ"
                | "CA"
                | "CD"
                | "CF"
                | "CG"
                | "CH"
                | "CI"
                | "CK"
                | "CL"
                | "CM"
                | "CN"
                | "CO"
                | "CR"
                | "CV"
                | "CW"
                | "CY"
                | "CZ"
                | "DE"
                | "DJ"
                | "DK"
                | "DM"
                | "DO"
                | "DZ"
                | "EC"
                | "EE"
                | "EG"
                | "EH"
                | "ER"
                | "ES"
                | "ET"
                | "FI"
                | "FJ"
                | "FK"
                | "FO"
                | "FR"
                | "GA"
                | "GB"
                | "GD"
                | "GE"
                | "GF"
                | "GG"
                | "GH"
                | "GI"
                | "GL"
                | "GM"
                | "GN"
                | "GP"
                | "GQ"
                | "GR"
                | "GS"
                | "GT"
                | "GU"
                | "GW"
                | "GY"
                | "HK"
                | "HN"
                | "HR"
                | "HT"
                | "HU"
                | "ID"
                | "IE"
                | "IL"
                | "IM"
                | "IN"
                | "IO"
                | "IQ"
                | "IS"
                | "IT"
                | "JE"
                | "JM"
                | "JO"
                | "JP"
                | "KE"
                | "KG"
                | "KH"
                | "KI"
                | "KM"
                | "KN"
                | "KR"
                | "KW"
                | "KY"
                | "KZ"
                | "LA"
                | "LB"
                | "LC"
                | "LI"
                | "LK"
                | "LR"
                | "LS"
                | "LT"
                | "LU"
                | "LV"
                | "LY"
                | "MA"
                | "MC"
                | "MD"
                | "ME"
                | "MF"
                | "MG"
                | "MK"
                | "ML"
                | "MM"
                | "MN"
                | "MO"
                | "MQ"
                | "MR"
                | "MS"
                | "MT"
                | "MU"
                | "MV"
                | "MW"
                | "MX"
                | "MY"
                | "MZ"
                | "NA"
                | "NC"
                | "NE"
                | "NG"
                | "NI"
                | "NL"
                | "NO"
                | "NP"
                | "NR"
                | "NU"
                | "NZ"
                | "OM"
                | "PA"
                | "PE"
                | "PF"
                | "PG"
                | "PH"
                | "PK"
                | "PL"
                | "PM"
                | "PN"
                | "PR"
                | "PS"
                | "PT"
                | "PY"
                | "QA"
                | "RE"
                | "RO"
                | "RS"
                | "RU"
                | "RW"
                | "SA"
                | "SB"
                | "SC"
                | "SE"
                | "SG"
                | "SH"
                | "SI"
                | "SJ"
                | "SK"
                | "SL"
                | "SM"
                | "SN"
                | "SO"
                | "SR"
                | "SS"
                | "ST"
                | "SV"
                | "SX"
                | "SZ"
                | "TA"
                | "TC"
                | "TD"
                | "TF"
                | "TG"
                | "TH"
                | "TJ"
                | "TK"
                | "TL"
                | "TM"
                | "TN"
                | "TO"
                | "TR"
                | "TT"
                | "TV"
                | "TW"
                | "TZ"
                | "UA"
                | "UG"
                | "US"
                | "UY"
                | "UZ"
                | "VA"
                | "VC"
                | "VE"
                | "VG"
                | "VN"
                | "VU"
                | "WF"
                | "WS"
                | "XK"
                | "YE"
                | "YT"
                | "ZA"
                | "ZM"
                | "ZW"
                | "ZZ"
              )[]
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_link> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_links/${p["paymentLink"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentLinksPaymentLinkLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentLink: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/payment_links/${p["paymentLink"]}/line_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentMethods(
    p: {
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?:
        | "acss_debit"
        | "affirm"
        | "afterpay_clearpay"
        | "alipay"
        | "au_becs_debit"
        | "bacs_debit"
        | "bancontact"
        | "blik"
        | "boleto"
        | "card"
        | "cashapp"
        | "customer_balance"
        | "eps"
        | "fpx"
        | "giropay"
        | "grabpay"
        | "ideal"
        | "klarna"
        | "konbini"
        | "link"
        | "oxxo"
        | "p24"
        | "paynow"
        | "pix"
        | "promptpay"
        | "sepa_debit"
        | "sofort"
        | "us_bank_account"
        | "wechat_pay"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_payment_method[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/payment_methods`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentMethods(
    p: {
      requestBody?: {
        acss_debit?: {
          account_number: string
          institution_number: string
          transit_number: string
        }
        affirm?: EmptyObject
        afterpay_clearpay?: EmptyObject
        alipay?: EmptyObject
        au_becs_debit?: {
          account_number: string
          bsb_number: string
        }
        bacs_debit?: {
          account_number?: string
          sort_code?: string
        }
        bancontact?: EmptyObject
        billing_details?: {
          address?:
            | {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
            | ""
          email?: string | ""
          name?: string
          phone?: string
        }
        blik?: EmptyObject
        boleto?: {
          tax_id: string
        }
        card?:
          | {
              cvc?: string
              exp_month: number
              exp_year: number
              number: string
            }
          | {
              token: string
            }
        cashapp?: EmptyObject
        customer?: string
        customer_balance?: EmptyObject
        eps?: {
          bank?:
            | "arzte_und_apotheker_bank"
            | "austrian_anadi_bank_ag"
            | "bank_austria"
            | "bankhaus_carl_spangler"
            | "bankhaus_schelhammer_und_schattera_ag"
            | "bawag_psk_ag"
            | "bks_bank_ag"
            | "brull_kallmus_bank_ag"
            | "btv_vier_lander_bank"
            | "capital_bank_grawe_gruppe_ag"
            | "deutsche_bank_ag"
            | "dolomitenbank"
            | "easybank_ag"
            | "erste_bank_und_sparkassen"
            | "hypo_alpeadriabank_international_ag"
            | "hypo_bank_burgenland_aktiengesellschaft"
            | "hypo_noe_lb_fur_niederosterreich_u_wien"
            | "hypo_oberosterreich_salzburg_steiermark"
            | "hypo_tirol_bank_ag"
            | "hypo_vorarlberg_bank_ag"
            | "marchfelder_bank"
            | "oberbank_ag"
            | "raiffeisen_bankengruppe_osterreich"
            | "schoellerbank_ag"
            | "sparda_bank_wien"
            | "volksbank_gruppe"
            | "volkskreditbank_ag"
            | "vr_bank_braunau"
        }
        expand?: string[]
        fpx?: {
          bank:
            | "affin_bank"
            | "agrobank"
            | "alliance_bank"
            | "ambank"
            | "bank_islam"
            | "bank_muamalat"
            | "bank_of_china"
            | "bank_rakyat"
            | "bsn"
            | "cimb"
            | "deutsche_bank"
            | "hong_leong_bank"
            | "hsbc"
            | "kfh"
            | "maybank2e"
            | "maybank2u"
            | "ocbc"
            | "pb_enterprise"
            | "public_bank"
            | "rhb"
            | "standard_chartered"
            | "uob"
        }
        giropay?: EmptyObject
        grabpay?: EmptyObject
        ideal?: {
          bank?:
            | "abn_amro"
            | "asn_bank"
            | "bunq"
            | "handelsbanken"
            | "ing"
            | "knab"
            | "moneyou"
            | "rabobank"
            | "regiobank"
            | "revolut"
            | "sns_bank"
            | "triodos_bank"
            | "van_lanschot"
            | "yoursafe"
        }
        interac_present?: EmptyObject
        klarna?: {
          dob?: {
            day: number
            month: number
            year: number
          }
        }
        konbini?: EmptyObject
        link?: EmptyObject
        metadata?: {
          [key: string]: string
        }
        oxxo?: EmptyObject
        p24?: {
          bank?:
            | "alior_bank"
            | "bank_millennium"
            | "bank_nowy_bfg_sa"
            | "bank_pekao_sa"
            | "banki_spbdzielcze"
            | "blik"
            | "bnp_paribas"
            | "boz"
            | "citi_handlowy"
            | "credit_agricole"
            | "envelobank"
            | "etransfer_pocztowy24"
            | "getin_bank"
            | "ideabank"
            | "ing"
            | "inteligo"
            | "mbank_mtransfer"
            | "nest_przelew"
            | "noble_pay"
            | "pbac_z_ipko"
            | "plus_bank"
            | "santander_przelew24"
            | "tmobile_usbugi_bankowe"
            | "toyota_bank"
            | "volkswagen_bank"
        }
        payment_method?: string
        paynow?: EmptyObject
        pix?: EmptyObject
        promptpay?: EmptyObject
        radar_options?: {
          session?: string
        }
        sepa_debit?: {
          iban: string
        }
        sofort?: {
          country: "AT" | "BE" | "DE" | "ES" | "IT" | "NL"
        }
        type?:
          | "acss_debit"
          | "affirm"
          | "afterpay_clearpay"
          | "alipay"
          | "au_becs_debit"
          | "bacs_debit"
          | "bancontact"
          | "blik"
          | "boleto"
          | "card"
          | "cashapp"
          | "customer_balance"
          | "eps"
          | "fpx"
          | "giropay"
          | "grabpay"
          | "ideal"
          | "klarna"
          | "konbini"
          | "link"
          | "oxxo"
          | "p24"
          | "paynow"
          | "pix"
          | "promptpay"
          | "sepa_debit"
          | "sofort"
          | "us_bank_account"
          | "wechat_pay"
        us_bank_account?: {
          account_holder_type?: "company" | "individual"
          account_number?: string
          account_type?: "checking" | "savings"
          financial_connections_account?: string
          routing_number?: string
        }
        wechat_pay?: EmptyObject
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_method> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_methods`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPaymentMethodsPaymentMethod(
    p: {
      expand?: string[]
      paymentMethod: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_method> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_methods/${p["paymentMethod"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentMethodsPaymentMethod(
    p: {
      paymentMethod: string
      requestBody?: {
        billing_details?: {
          address?:
            | {
                city?: string
                country?: string
                line1?: string
                line2?: string
                postal_code?: string
                state?: string
              }
            | ""
          email?: string | ""
          name?: string
          phone?: string
        }
        card?: {
          exp_month?: number
          exp_year?: number
        }
        expand?: string[]
        link?: EmptyObject
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        us_bank_account?: {
          account_holder_type?: "company" | "individual"
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_method> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payment_methods/${p["paymentMethod"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentMethodsPaymentMethodAttach(
    p: {
      paymentMethod: string
      requestBody: {
        customer: string
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_method> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/payment_methods/${p["paymentMethod"]}/attach`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPaymentMethodsPaymentMethodDetach(
    p: {
      paymentMethod: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payment_method> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/payment_methods/${p["paymentMethod"]}/detach`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPayouts(
    p: {
      arrivalDate?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      destination?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_payout[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/payouts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      arrival_date: p["arrivalDate"],
      created: p["created"],
      destination: p["destination"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPayouts(
    p: {
      requestBody: {
        amount: number
        currency: string
        description?: string
        destination?: string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        method?: "instant" | "standard"
        source_type?: "bank_account" | "card" | "fpx"
        statement_descriptor?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payout> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payouts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPayoutsPayout(
    p: {
      expand?: string[]
      payout: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payout> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payouts/${p["payout"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPayoutsPayout(
    p: {
      payout: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payout> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payouts/${p["payout"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPayoutsPayoutCancel(
    p: {
      payout: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payout> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payouts/${p["payout"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPayoutsPayoutReverse(
    p: {
      payout: string
      requestBody?: {
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_payout> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/payouts/${p["payout"]}/reverse`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPlans(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      product?: string
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_plan[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/plans`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      product: p["product"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPlans(
    p: {
      requestBody: {
        active?: boolean
        aggregate_usage?: "last_during_period" | "last_ever" | "max" | "sum"
        amount?: number
        amount_decimal?: string
        billing_scheme?: "per_unit" | "tiered"
        currency: string
        expand?: string[]
        id?: string
        interval: "day" | "month" | "week" | "year"
        interval_count?: number
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        nickname?: string
        product?:
          | {
              active?: boolean
              id?: string
              metadata?: {
                [key: string]: string
              }
              name: string
              statement_descriptor?: string
              tax_code?: string
              unit_label?: string
            }
          | string
        tiers?: {
          flat_amount?: number
          flat_amount_decimal?: string
          unit_amount?: number
          unit_amount_decimal?: string
          up_to: "inf" | number
        }[]
        tiers_mode?: "graduated" | "volume"
        transform_usage?: {
          divide_by: number
          round: "down" | "up"
        }
        trial_period_days?: number
        usage_type?: "licensed" | "metered"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_plan> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/plans`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deletePlansPlan(
    p: {
      plan: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_plan> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/plans/${p["plan"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPlansPlan(
    p: {
      expand?: string[]
      plan: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_plan> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/plans/${p["plan"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPlansPlan(
    p: {
      plan: string
      requestBody?: {
        active?: boolean
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        nickname?: string
        product?: string
        trial_period_days?: number
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_plan> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/plans/${p["plan"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPrices(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      lookupKeys?: string[]
      product?: string
      recurring?: {
        interval?: "day" | "month" | "week" | "year"
        usage_type?: "licensed" | "metered"
      }
      startingAfter?: string
      type?: "one_time" | "recurring"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_price[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/prices`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      lookup_keys: p["lookupKeys"],
      product: p["product"],
      recurring: p["recurring"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPrices(
    p: {
      requestBody: {
        active?: boolean
        billing_scheme?: "per_unit" | "tiered"
        currency: string
        currency_options?: {
          [key: string]: {
            custom_unit_amount?: {
              enabled: boolean
              maximum?: number
              minimum?: number
              preset?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            tiers?: {
              flat_amount?: number
              flat_amount_decimal?: string
              unit_amount?: number
              unit_amount_decimal?: string
              up_to: "inf" | number
            }[]
            unit_amount?: number
            unit_amount_decimal?: string
          }
        }
        custom_unit_amount?: {
          enabled: boolean
          maximum?: number
          minimum?: number
          preset?: number
        }
        expand?: string[]
        lookup_key?: string
        metadata?: {
          [key: string]: string
        }
        nickname?: string
        product?: string
        product_data?: {
          active?: boolean
          id?: string
          metadata?: {
            [key: string]: string
          }
          name: string
          statement_descriptor?: string
          tax_code?: string
          unit_label?: string
        }
        recurring?: {
          aggregate_usage?: "last_during_period" | "last_ever" | "max" | "sum"
          interval: "day" | "month" | "week" | "year"
          interval_count?: number
          usage_type?: "licensed" | "metered"
        }
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
        tiers?: {
          flat_amount?: number
          flat_amount_decimal?: string
          unit_amount?: number
          unit_amount_decimal?: string
          up_to: "inf" | number
        }[]
        tiers_mode?: "graduated" | "volume"
        transfer_lookup_key?: boolean
        transform_quantity?: {
          divide_by: number
          round: "down" | "up"
        }
        unit_amount?: number
        unit_amount_decimal?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_price> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/prices`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPricesSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_price[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/prices/search`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPricesPrice(
    p: {
      expand?: string[]
      price: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_price> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/prices/${p["price"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPricesPrice(
    p: {
      price: string
      requestBody?: {
        active?: boolean
        currency_options?:
          | {
              [key: string]: {
                custom_unit_amount?: {
                  enabled: boolean
                  maximum?: number
                  minimum?: number
                  preset?: number
                }
                tax_behavior?: "exclusive" | "inclusive" | "unspecified"
                tiers?: {
                  flat_amount?: number
                  flat_amount_decimal?: string
                  unit_amount?: number
                  unit_amount_decimal?: string
                  up_to: "inf" | number
                }[]
                unit_amount?: number
                unit_amount_decimal?: string
              }
            }
          | ""
        expand?: string[]
        lookup_key?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        nickname?: string
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
        transfer_lookup_key?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_price> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/prices/${p["price"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getProducts(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      ids?: string[]
      limit?: number
      shippable?: boolean
      startingAfter?: string
      url?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_product[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/products`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      ids: p["ids"],
      limit: p["limit"],
      shippable: p["shippable"],
      starting_after: p["startingAfter"],
      url: p["url"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postProducts(
    p: {
      requestBody: {
        active?: boolean
        default_price_data?: {
          currency: string
          currency_options?: {
            [key: string]: {
              custom_unit_amount?: {
                enabled: boolean
                maximum?: number
                minimum?: number
                preset?: number
              }
              tax_behavior?: "exclusive" | "inclusive" | "unspecified"
              tiers?: {
                flat_amount?: number
                flat_amount_decimal?: string
                unit_amount?: number
                unit_amount_decimal?: string
                up_to: "inf" | number
              }[]
              unit_amount?: number
              unit_amount_decimal?: string
            }
          }
          recurring?: {
            interval: "day" | "month" | "week" | "year"
            interval_count?: number
          }
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        description?: string
        expand?: string[]
        id?: string
        images?: string[]
        metadata?: {
          [key: string]: string
        }
        name: string
        package_dimensions?: {
          height: number
          length: number
          weight: number
          width: number
        }
        shippable?: boolean
        statement_descriptor?: string
        tax_code?: string
        unit_label?: string
        url?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_product> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/products`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getProductsSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_product[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/products/search`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteProductsId(
    p: {
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_product> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/products/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getProductsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_product> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/products/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postProductsId(
    p: {
      id: string
      requestBody?: {
        active?: boolean
        default_price?: string
        description?: string
        expand?: string[]
        images?: string[] | ""
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        name?: string
        package_dimensions?:
          | {
              height: number
              length: number
              weight: number
              width: number
            }
          | ""
        shippable?: boolean
        statement_descriptor?: string
        tax_code?: string | ""
        unit_label?: string
        url?: string | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_product> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/products/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPromotionCodes(
    p: {
      active?: boolean
      code?: string
      coupon?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_promotion_code[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/promotion_codes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      code: p["code"],
      coupon: p["coupon"],
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPromotionCodes(
    p: {
      requestBody: {
        active?: boolean
        code?: string
        coupon: string
        customer?: string
        expand?: string[]
        expires_at?: number
        max_redemptions?: number
        metadata?: {
          [key: string]: string
        }
        restrictions?: {
          currency_options?: {
            [key: string]: {
              minimum_amount?: number
            }
          }
          first_time_transaction?: boolean
          minimum_amount?: number
          minimum_amount_currency?: string
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_promotion_code> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/promotion_codes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getPromotionCodesPromotionCode(
    p: {
      expand?: string[]
      promotionCode: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_promotion_code> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/promotion_codes/${p["promotionCode"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postPromotionCodesPromotionCode(
    p: {
      promotionCode: string
      requestBody?: {
        active?: boolean
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        restrictions?: {
          currency_options?: {
            [key: string]: {
              minimum_amount?: number
            }
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_promotion_code> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/promotion_codes/${p["promotionCode"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getQuotes(
    p: {
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "accepted" | "canceled" | "draft" | "open"
      testClock?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_quote[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/quotes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      test_clock: p["testClock"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postQuotes(
    p: {
      requestBody?: {
        application_fee_amount?: number | ""
        application_fee_percent?: number | ""
        automatic_tax?: {
          enabled: boolean
        }
        collection_method?: "charge_automatically" | "send_invoice"
        customer?: string
        default_tax_rates?: string[] | ""
        description?: string
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        expand?: string[]
        expires_at?: number
        footer?: string
        from_quote?: {
          is_revision?: boolean
          quote: string
        }
        header?: string
        invoice_settings?: {
          days_until_due?: number
        }
        line_items?: {
          price?: string
          price_data?: {
            currency: string
            product: string
            recurring?: {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        metadata?: {
          [key: string]: string
        }
        on_behalf_of?: string | ""
        subscription_data?: {
          description?: string
          effective_date?: "current_period_end" | number | ""
          trial_period_days?: number | ""
        }
        test_clock?: string
        transfer_data?:
          | {
              amount?: number
              amount_percent?: number
              destination: string
            }
          | ""
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_quote> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/quotes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getQuotesQuote(
    p: {
      expand?: string[]
      quote: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_quote> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postQuotesQuote(
    p: {
      quote: string
      requestBody?: {
        application_fee_amount?: number | ""
        application_fee_percent?: number | ""
        automatic_tax?: {
          enabled: boolean
        }
        collection_method?: "charge_automatically" | "send_invoice"
        customer?: string
        default_tax_rates?: string[] | ""
        description?: string
        discounts?:
          | {
              coupon?: string
              discount?: string
            }[]
          | ""
        expand?: string[]
        expires_at?: number
        footer?: string
        header?: string
        invoice_settings?: {
          days_until_due?: number
        }
        line_items?: {
          id?: string
          price?: string
          price_data?: {
            currency: string
            product: string
            recurring?: {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        metadata?: {
          [key: string]: string
        }
        on_behalf_of?: string | ""
        subscription_data?: {
          description?: string
          effective_date?: "current_period_end" | number | ""
          trial_period_days?: number | ""
        }
        transfer_data?:
          | {
              amount?: number
              amount_percent?: number
              destination: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_quote> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postQuotesQuoteAccept(
    p: {
      quote: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_quote> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/accept`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postQuotesQuoteCancel(
    p: {
      quote: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_quote> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getQuotesQuoteComputedUpfrontLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      quote: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/quotes/${p["quote"]}/computed_upfront_line_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postQuotesQuoteFinalize(
    p: {
      quote: string
      requestBody?: {
        expand?: string[]
        expires_at?: number
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_quote> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/finalize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getQuotesQuoteLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      quote: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/line_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getQuotesQuotePdf(
    p: {
      expand?: string[]
      quote: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/pdf`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRadarEarlyFraudWarnings(
    p: {
      charge?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_radar_early_fraud_warning[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/radar/early_fraud_warnings`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      charge: p["charge"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRadarEarlyFraudWarningsEarlyFraudWarning(
    p: {
      earlyFraudWarning: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_radar_early_fraud_warning> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/radar/early_fraud_warnings/${p["earlyFraudWarning"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRadarValueListItems(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      value?: string
      valueList: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_radar_value_list_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/radar/value_list_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      value: p["value"],
      value_list: p["valueList"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postRadarValueListItems(
    p: {
      requestBody: {
        expand?: string[]
        value: string
        value_list: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_radar_value_list_item> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/radar/value_list_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteRadarValueListItemsItem(
    p: {
      item: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_radar_value_list_item> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/radar/value_list_items/${p["item"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRadarValueListItemsItem(
    p: {
      expand?: string[]
      item: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_radar_value_list_item> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/radar/value_list_items/${p["item"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRadarValueLists(
    p: {
      alias?: string
      contains?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_radar_value_list[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/radar/value_lists`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      alias: p["alias"],
      contains: p["contains"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postRadarValueLists(
    p: {
      requestBody: {
        alias: string
        expand?: string[]
        item_type?:
          | "card_bin"
          | "card_fingerprint"
          | "case_sensitive_string"
          | "country"
          | "customer_id"
          | "email"
          | "ip_address"
          | "string"
        metadata?: {
          [key: string]: string
        }
        name: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_radar_value_list> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/radar/value_lists`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteRadarValueListsValueList(
    p: {
      valueList: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_radar_value_list> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/radar/value_lists/${p["valueList"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRadarValueListsValueList(
    p: {
      expand?: string[]
      valueList: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_radar_value_list> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/radar/value_lists/${p["valueList"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postRadarValueListsValueList(
    p: {
      valueList: string
      requestBody?: {
        alias?: string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        name?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_radar_value_list> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/radar/value_lists/${p["valueList"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRefunds(
    p: {
      charge?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_refund[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/refunds`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      charge: p["charge"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postRefunds(
    p: {
      requestBody?: {
        amount?: number
        charge?: string
        currency?: string
        customer?: string
        expand?: string[]
        instructions_email?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        origin?: "customer_balance"
        payment_intent?: string
        reason?: "duplicate" | "fraudulent" | "requested_by_customer"
        refund_application_fee?: boolean
        reverse_transfer?: boolean
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/refunds`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getRefundsRefund(
    p: {
      expand?: string[]
      refund: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/refunds/${p["refund"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postRefundsRefund(
    p: {
      refund: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/refunds/${p["refund"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postRefundsRefundCancel(
    p: {
      refund: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/refunds/${p["refund"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getReportingReportRuns(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_reporting_report_run[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/reporting/report_runs`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postReportingReportRuns(
    p: {
      requestBody: {
        expand?: string[]
        parameters?: {
          columns?: string[]
          connected_account?: string
          currency?: string
          interval_end?: number
          interval_start?: number
          payout?: string
          reporting_category?:
            | "advance"
            | "advance_funding"
            | "anticipation_repayment"
            | "charge"
            | "charge_failure"
            | "connect_collection_transfer"
            | "connect_reserved_funds"
            | "contribution"
            | "dispute"
            | "dispute_reversal"
            | "fee"
            | "financing_paydown"
            | "financing_paydown_reversal"
            | "financing_payout"
            | "financing_payout_reversal"
            | "issuing_authorization_hold"
            | "issuing_authorization_release"
            | "issuing_dispute"
            | "issuing_transaction"
            | "network_cost"
            | "other_adjustment"
            | "partial_capture_reversal"
            | "payout"
            | "payout_reversal"
            | "platform_earning"
            | "platform_earning_refund"
            | "refund"
            | "refund_failure"
            | "risk_reserved_funds"
            | "tax"
            | "topup"
            | "topup_reversal"
            | "transfer"
            | "transfer_reversal"
          timezone?:
            | "Africa/Abidjan"
            | "Africa/Accra"
            | "Africa/Addis_Ababa"
            | "Africa/Algiers"
            | "Africa/Asmara"
            | "Africa/Asmera"
            | "Africa/Bamako"
            | "Africa/Bangui"
            | "Africa/Banjul"
            | "Africa/Bissau"
            | "Africa/Blantyre"
            | "Africa/Brazzaville"
            | "Africa/Bujumbura"
            | "Africa/Cairo"
            | "Africa/Casablanca"
            | "Africa/Ceuta"
            | "Africa/Conakry"
            | "Africa/Dakar"
            | "Africa/Dar_es_Salaam"
            | "Africa/Djibouti"
            | "Africa/Douala"
            | "Africa/El_Aaiun"
            | "Africa/Freetown"
            | "Africa/Gaborone"
            | "Africa/Harare"
            | "Africa/Johannesburg"
            | "Africa/Juba"
            | "Africa/Kampala"
            | "Africa/Khartoum"
            | "Africa/Kigali"
            | "Africa/Kinshasa"
            | "Africa/Lagos"
            | "Africa/Libreville"
            | "Africa/Lome"
            | "Africa/Luanda"
            | "Africa/Lubumbashi"
            | "Africa/Lusaka"
            | "Africa/Malabo"
            | "Africa/Maputo"
            | "Africa/Maseru"
            | "Africa/Mbabane"
            | "Africa/Mogadishu"
            | "Africa/Monrovia"
            | "Africa/Nairobi"
            | "Africa/Ndjamena"
            | "Africa/Niamey"
            | "Africa/Nouakchott"
            | "Africa/Ouagadougou"
            | "Africa/Porto-Novo"
            | "Africa/Sao_Tome"
            | "Africa/Timbuktu"
            | "Africa/Tripoli"
            | "Africa/Tunis"
            | "Africa/Windhoek"
            | "America/Adak"
            | "America/Anchorage"
            | "America/Anguilla"
            | "America/Antigua"
            | "America/Araguaina"
            | "America/Argentina/Buenos_Aires"
            | "America/Argentina/Catamarca"
            | "America/Argentina/ComodRivadavia"
            | "America/Argentina/Cordoba"
            | "America/Argentina/Jujuy"
            | "America/Argentina/La_Rioja"
            | "America/Argentina/Mendoza"
            | "America/Argentina/Rio_Gallegos"
            | "America/Argentina/Salta"
            | "America/Argentina/San_Juan"
            | "America/Argentina/San_Luis"
            | "America/Argentina/Tucuman"
            | "America/Argentina/Ushuaia"
            | "America/Aruba"
            | "America/Asuncion"
            | "America/Atikokan"
            | "America/Atka"
            | "America/Bahia"
            | "America/Bahia_Banderas"
            | "America/Barbados"
            | "America/Belem"
            | "America/Belize"
            | "America/Blanc-Sablon"
            | "America/Boa_Vista"
            | "America/Bogota"
            | "America/Boise"
            | "America/Buenos_Aires"
            | "America/Cambridge_Bay"
            | "America/Campo_Grande"
            | "America/Cancun"
            | "America/Caracas"
            | "America/Catamarca"
            | "America/Cayenne"
            | "America/Cayman"
            | "America/Chicago"
            | "America/Chihuahua"
            | "America/Ciudad_Juarez"
            | "America/Coral_Harbour"
            | "America/Cordoba"
            | "America/Costa_Rica"
            | "America/Creston"
            | "America/Cuiaba"
            | "America/Curacao"
            | "America/Danmarkshavn"
            | "America/Dawson"
            | "America/Dawson_Creek"
            | "America/Denver"
            | "America/Detroit"
            | "America/Dominica"
            | "America/Edmonton"
            | "America/Eirunepe"
            | "America/El_Salvador"
            | "America/Ensenada"
            | "America/Fort_Nelson"
            | "America/Fort_Wayne"
            | "America/Fortaleza"
            | "America/Glace_Bay"
            | "America/Godthab"
            | "America/Goose_Bay"
            | "America/Grand_Turk"
            | "America/Grenada"
            | "America/Guadeloupe"
            | "America/Guatemala"
            | "America/Guayaquil"
            | "America/Guyana"
            | "America/Halifax"
            | "America/Havana"
            | "America/Hermosillo"
            | "America/Indiana/Indianapolis"
            | "America/Indiana/Knox"
            | "America/Indiana/Marengo"
            | "America/Indiana/Petersburg"
            | "America/Indiana/Tell_City"
            | "America/Indiana/Vevay"
            | "America/Indiana/Vincennes"
            | "America/Indiana/Winamac"
            | "America/Indianapolis"
            | "America/Inuvik"
            | "America/Iqaluit"
            | "America/Jamaica"
            | "America/Jujuy"
            | "America/Juneau"
            | "America/Kentucky/Louisville"
            | "America/Kentucky/Monticello"
            | "America/Knox_IN"
            | "America/Kralendijk"
            | "America/La_Paz"
            | "America/Lima"
            | "America/Los_Angeles"
            | "America/Louisville"
            | "America/Lower_Princes"
            | "America/Maceio"
            | "America/Managua"
            | "America/Manaus"
            | "America/Marigot"
            | "America/Martinique"
            | "America/Matamoros"
            | "America/Mazatlan"
            | "America/Mendoza"
            | "America/Menominee"
            | "America/Merida"
            | "America/Metlakatla"
            | "America/Mexico_City"
            | "America/Miquelon"
            | "America/Moncton"
            | "America/Monterrey"
            | "America/Montevideo"
            | "America/Montreal"
            | "America/Montserrat"
            | "America/Nassau"
            | "America/New_York"
            | "America/Nipigon"
            | "America/Nome"
            | "America/Noronha"
            | "America/North_Dakota/Beulah"
            | "America/North_Dakota/Center"
            | "America/North_Dakota/New_Salem"
            | "America/Nuuk"
            | "America/Ojinaga"
            | "America/Panama"
            | "America/Pangnirtung"
            | "America/Paramaribo"
            | "America/Phoenix"
            | "America/Port-au-Prince"
            | "America/Port_of_Spain"
            | "America/Porto_Acre"
            | "America/Porto_Velho"
            | "America/Puerto_Rico"
            | "America/Punta_Arenas"
            | "America/Rainy_River"
            | "America/Rankin_Inlet"
            | "America/Recife"
            | "America/Regina"
            | "America/Resolute"
            | "America/Rio_Branco"
            | "America/Rosario"
            | "America/Santa_Isabel"
            | "America/Santarem"
            | "America/Santiago"
            | "America/Santo_Domingo"
            | "America/Sao_Paulo"
            | "America/Scoresbysund"
            | "America/Shiprock"
            | "America/Sitka"
            | "America/St_Barthelemy"
            | "America/St_Johns"
            | "America/St_Kitts"
            | "America/St_Lucia"
            | "America/St_Thomas"
            | "America/St_Vincent"
            | "America/Swift_Current"
            | "America/Tegucigalpa"
            | "America/Thule"
            | "America/Thunder_Bay"
            | "America/Tijuana"
            | "America/Toronto"
            | "America/Tortola"
            | "America/Vancouver"
            | "America/Virgin"
            | "America/Whitehorse"
            | "America/Winnipeg"
            | "America/Yakutat"
            | "America/Yellowknife"
            | "Antarctica/Casey"
            | "Antarctica/Davis"
            | "Antarctica/DumontDUrville"
            | "Antarctica/Macquarie"
            | "Antarctica/Mawson"
            | "Antarctica/McMurdo"
            | "Antarctica/Palmer"
            | "Antarctica/Rothera"
            | "Antarctica/South_Pole"
            | "Antarctica/Syowa"
            | "Antarctica/Troll"
            | "Antarctica/Vostok"
            | "Arctic/Longyearbyen"
            | "Asia/Aden"
            | "Asia/Almaty"
            | "Asia/Amman"
            | "Asia/Anadyr"
            | "Asia/Aqtau"
            | "Asia/Aqtobe"
            | "Asia/Ashgabat"
            | "Asia/Ashkhabad"
            | "Asia/Atyrau"
            | "Asia/Baghdad"
            | "Asia/Bahrain"
            | "Asia/Baku"
            | "Asia/Bangkok"
            | "Asia/Barnaul"
            | "Asia/Beirut"
            | "Asia/Bishkek"
            | "Asia/Brunei"
            | "Asia/Calcutta"
            | "Asia/Chita"
            | "Asia/Choibalsan"
            | "Asia/Chongqing"
            | "Asia/Chungking"
            | "Asia/Colombo"
            | "Asia/Dacca"
            | "Asia/Damascus"
            | "Asia/Dhaka"
            | "Asia/Dili"
            | "Asia/Dubai"
            | "Asia/Dushanbe"
            | "Asia/Famagusta"
            | "Asia/Gaza"
            | "Asia/Harbin"
            | "Asia/Hebron"
            | "Asia/Ho_Chi_Minh"
            | "Asia/Hong_Kong"
            | "Asia/Hovd"
            | "Asia/Irkutsk"
            | "Asia/Istanbul"
            | "Asia/Jakarta"
            | "Asia/Jayapura"
            | "Asia/Jerusalem"
            | "Asia/Kabul"
            | "Asia/Kamchatka"
            | "Asia/Karachi"
            | "Asia/Kashgar"
            | "Asia/Kathmandu"
            | "Asia/Katmandu"
            | "Asia/Khandyga"
            | "Asia/Kolkata"
            | "Asia/Krasnoyarsk"
            | "Asia/Kuala_Lumpur"
            | "Asia/Kuching"
            | "Asia/Kuwait"
            | "Asia/Macao"
            | "Asia/Macau"
            | "Asia/Magadan"
            | "Asia/Makassar"
            | "Asia/Manila"
            | "Asia/Muscat"
            | "Asia/Nicosia"
            | "Asia/Novokuznetsk"
            | "Asia/Novosibirsk"
            | "Asia/Omsk"
            | "Asia/Oral"
            | "Asia/Phnom_Penh"
            | "Asia/Pontianak"
            | "Asia/Pyongyang"
            | "Asia/Qatar"
            | "Asia/Qostanay"
            | "Asia/Qyzylorda"
            | "Asia/Rangoon"
            | "Asia/Riyadh"
            | "Asia/Saigon"
            | "Asia/Sakhalin"
            | "Asia/Samarkand"
            | "Asia/Seoul"
            | "Asia/Shanghai"
            | "Asia/Singapore"
            | "Asia/Srednekolymsk"
            | "Asia/Taipei"
            | "Asia/Tashkent"
            | "Asia/Tbilisi"
            | "Asia/Tehran"
            | "Asia/Tel_Aviv"
            | "Asia/Thimbu"
            | "Asia/Thimphu"
            | "Asia/Tokyo"
            | "Asia/Tomsk"
            | "Asia/Ujung_Pandang"
            | "Asia/Ulaanbaatar"
            | "Asia/Ulan_Bator"
            | "Asia/Urumqi"
            | "Asia/Ust-Nera"
            | "Asia/Vientiane"
            | "Asia/Vladivostok"
            | "Asia/Yakutsk"
            | "Asia/Yangon"
            | "Asia/Yekaterinburg"
            | "Asia/Yerevan"
            | "Atlantic/Azores"
            | "Atlantic/Bermuda"
            | "Atlantic/Canary"
            | "Atlantic/Cape_Verde"
            | "Atlantic/Faeroe"
            | "Atlantic/Faroe"
            | "Atlantic/Jan_Mayen"
            | "Atlantic/Madeira"
            | "Atlantic/Reykjavik"
            | "Atlantic/South_Georgia"
            | "Atlantic/St_Helena"
            | "Atlantic/Stanley"
            | "Australia/ACT"
            | "Australia/Adelaide"
            | "Australia/Brisbane"
            | "Australia/Broken_Hill"
            | "Australia/Canberra"
            | "Australia/Currie"
            | "Australia/Darwin"
            | "Australia/Eucla"
            | "Australia/Hobart"
            | "Australia/LHI"
            | "Australia/Lindeman"
            | "Australia/Lord_Howe"
            | "Australia/Melbourne"
            | "Australia/NSW"
            | "Australia/North"
            | "Australia/Perth"
            | "Australia/Queensland"
            | "Australia/South"
            | "Australia/Sydney"
            | "Australia/Tasmania"
            | "Australia/Victoria"
            | "Australia/West"
            | "Australia/Yancowinna"
            | "Brazil/Acre"
            | "Brazil/DeNoronha"
            | "Brazil/East"
            | "Brazil/West"
            | "CET"
            | "CST6CDT"
            | "Canada/Atlantic"
            | "Canada/Central"
            | "Canada/Eastern"
            | "Canada/Mountain"
            | "Canada/Newfoundland"
            | "Canada/Pacific"
            | "Canada/Saskatchewan"
            | "Canada/Yukon"
            | "Chile/Continental"
            | "Chile/EasterIsland"
            | "Cuba"
            | "EET"
            | "EST"
            | "EST5EDT"
            | "Egypt"
            | "Eire"
            | "Etc/GMT"
            | "Etc/GMT+0"
            | "Etc/GMT+1"
            | "Etc/GMT+10"
            | "Etc/GMT+11"
            | "Etc/GMT+12"
            | "Etc/GMT+2"
            | "Etc/GMT+3"
            | "Etc/GMT+4"
            | "Etc/GMT+5"
            | "Etc/GMT+6"
            | "Etc/GMT+7"
            | "Etc/GMT+8"
            | "Etc/GMT+9"
            | "Etc/GMT-0"
            | "Etc/GMT-1"
            | "Etc/GMT-10"
            | "Etc/GMT-11"
            | "Etc/GMT-12"
            | "Etc/GMT-13"
            | "Etc/GMT-14"
            | "Etc/GMT-2"
            | "Etc/GMT-3"
            | "Etc/GMT-4"
            | "Etc/GMT-5"
            | "Etc/GMT-6"
            | "Etc/GMT-7"
            | "Etc/GMT-8"
            | "Etc/GMT-9"
            | "Etc/GMT0"
            | "Etc/Greenwich"
            | "Etc/UCT"
            | "Etc/UTC"
            | "Etc/Universal"
            | "Etc/Zulu"
            | "Europe/Amsterdam"
            | "Europe/Andorra"
            | "Europe/Astrakhan"
            | "Europe/Athens"
            | "Europe/Belfast"
            | "Europe/Belgrade"
            | "Europe/Berlin"
            | "Europe/Bratislava"
            | "Europe/Brussels"
            | "Europe/Bucharest"
            | "Europe/Budapest"
            | "Europe/Busingen"
            | "Europe/Chisinau"
            | "Europe/Copenhagen"
            | "Europe/Dublin"
            | "Europe/Gibraltar"
            | "Europe/Guernsey"
            | "Europe/Helsinki"
            | "Europe/Isle_of_Man"
            | "Europe/Istanbul"
            | "Europe/Jersey"
            | "Europe/Kaliningrad"
            | "Europe/Kiev"
            | "Europe/Kirov"
            | "Europe/Kyiv"
            | "Europe/Lisbon"
            | "Europe/Ljubljana"
            | "Europe/London"
            | "Europe/Luxembourg"
            | "Europe/Madrid"
            | "Europe/Malta"
            | "Europe/Mariehamn"
            | "Europe/Minsk"
            | "Europe/Monaco"
            | "Europe/Moscow"
            | "Europe/Nicosia"
            | "Europe/Oslo"
            | "Europe/Paris"
            | "Europe/Podgorica"
            | "Europe/Prague"
            | "Europe/Riga"
            | "Europe/Rome"
            | "Europe/Samara"
            | "Europe/San_Marino"
            | "Europe/Sarajevo"
            | "Europe/Saratov"
            | "Europe/Simferopol"
            | "Europe/Skopje"
            | "Europe/Sofia"
            | "Europe/Stockholm"
            | "Europe/Tallinn"
            | "Europe/Tirane"
            | "Europe/Tiraspol"
            | "Europe/Ulyanovsk"
            | "Europe/Uzhgorod"
            | "Europe/Vaduz"
            | "Europe/Vatican"
            | "Europe/Vienna"
            | "Europe/Vilnius"
            | "Europe/Volgograd"
            | "Europe/Warsaw"
            | "Europe/Zagreb"
            | "Europe/Zaporozhye"
            | "Europe/Zurich"
            | "Factory"
            | "GB"
            | "GB-Eire"
            | "GMT"
            | "GMT+0"
            | "GMT-0"
            | "GMT0"
            | "Greenwich"
            | "HST"
            | "Hongkong"
            | "Iceland"
            | "Indian/Antananarivo"
            | "Indian/Chagos"
            | "Indian/Christmas"
            | "Indian/Cocos"
            | "Indian/Comoro"
            | "Indian/Kerguelen"
            | "Indian/Mahe"
            | "Indian/Maldives"
            | "Indian/Mauritius"
            | "Indian/Mayotte"
            | "Indian/Reunion"
            | "Iran"
            | "Israel"
            | "Jamaica"
            | "Japan"
            | "Kwajalein"
            | "Libya"
            | "MET"
            | "MST"
            | "MST7MDT"
            | "Mexico/BajaNorte"
            | "Mexico/BajaSur"
            | "Mexico/General"
            | "NZ"
            | "NZ-CHAT"
            | "Navajo"
            | "PRC"
            | "PST8PDT"
            | "Pacific/Apia"
            | "Pacific/Auckland"
            | "Pacific/Bougainville"
            | "Pacific/Chatham"
            | "Pacific/Chuuk"
            | "Pacific/Easter"
            | "Pacific/Efate"
            | "Pacific/Enderbury"
            | "Pacific/Fakaofo"
            | "Pacific/Fiji"
            | "Pacific/Funafuti"
            | "Pacific/Galapagos"
            | "Pacific/Gambier"
            | "Pacific/Guadalcanal"
            | "Pacific/Guam"
            | "Pacific/Honolulu"
            | "Pacific/Johnston"
            | "Pacific/Kanton"
            | "Pacific/Kiritimati"
            | "Pacific/Kosrae"
            | "Pacific/Kwajalein"
            | "Pacific/Majuro"
            | "Pacific/Marquesas"
            | "Pacific/Midway"
            | "Pacific/Nauru"
            | "Pacific/Niue"
            | "Pacific/Norfolk"
            | "Pacific/Noumea"
            | "Pacific/Pago_Pago"
            | "Pacific/Palau"
            | "Pacific/Pitcairn"
            | "Pacific/Pohnpei"
            | "Pacific/Ponape"
            | "Pacific/Port_Moresby"
            | "Pacific/Rarotonga"
            | "Pacific/Saipan"
            | "Pacific/Samoa"
            | "Pacific/Tahiti"
            | "Pacific/Tarawa"
            | "Pacific/Tongatapu"
            | "Pacific/Truk"
            | "Pacific/Wake"
            | "Pacific/Wallis"
            | "Pacific/Yap"
            | "Poland"
            | "Portugal"
            | "ROC"
            | "ROK"
            | "Singapore"
            | "Turkey"
            | "UCT"
            | "US/Alaska"
            | "US/Aleutian"
            | "US/Arizona"
            | "US/Central"
            | "US/East-Indiana"
            | "US/Eastern"
            | "US/Hawaii"
            | "US/Indiana-Starke"
            | "US/Michigan"
            | "US/Mountain"
            | "US/Pacific"
            | "US/Pacific-New"
            | "US/Samoa"
            | "UTC"
            | "Universal"
            | "W-SU"
            | "WET"
            | "Zulu"
        }
        report_type: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reporting_report_run> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/reporting/report_runs`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getReportingReportRunsReportRun(
    p: {
      expand?: string[]
      reportRun: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reporting_report_run> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/reporting/report_runs/${p["reportRun"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getReportingReportTypes(
    p: {
      expand?: string[]
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_reporting_report_type[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/reporting/report_types`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getReportingReportTypesReportType(
    p: {
      expand?: string[]
      reportType: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reporting_report_type> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/reporting/report_types/${p["reportType"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getReviews(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_review[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/reviews`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getReviewsReview(
    p: {
      expand?: string[]
      review: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_review> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/reviews/${p["review"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postReviewsReviewApprove(
    p: {
      review: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_review> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/reviews/${p["review"]}/approve`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSetupAttempts(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      setupIntent: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_setup_attempt[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/setup_attempts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      setup_intent: p["setupIntent"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSetupIntents(
    p: {
      attachToSelf?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentMethod?: string
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_setup_intent[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/setup_intents`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      attach_to_self: p["attachToSelf"],
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_method: p["paymentMethod"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSetupIntents(
    p: {
      requestBody?: {
        attach_to_self?: boolean
        automatic_payment_methods?: {
          enabled: boolean
        }
        confirm?: boolean
        customer?: string
        description?: string
        expand?: string[]
        flow_directions?: ("inbound" | "outbound")[]
        mandate_data?: {
          customer_acceptance: {
            accepted_at?: number
            offline?: EmptyObject
            online?: {
              ip_address: string
              user_agent: string
            }
            type: "offline" | "online"
          }
        }
        metadata?: {
          [key: string]: string
        }
        on_behalf_of?: string
        payment_method?: string
        payment_method_data?: {
          acss_debit?: {
            account_number: string
            institution_number: string
            transit_number: string
          }
          affirm?: EmptyObject
          afterpay_clearpay?: EmptyObject
          alipay?: EmptyObject
          au_becs_debit?: {
            account_number: string
            bsb_number: string
          }
          bacs_debit?: {
            account_number?: string
            sort_code?: string
          }
          bancontact?: EmptyObject
          billing_details?: {
            address?:
              | {
                  city?: string
                  country?: string
                  line1?: string
                  line2?: string
                  postal_code?: string
                  state?: string
                }
              | ""
            email?: string | ""
            name?: string
            phone?: string
          }
          blik?: EmptyObject
          boleto?: {
            tax_id: string
          }
          cashapp?: EmptyObject
          customer_balance?: EmptyObject
          eps?: {
            bank?:
              | "arzte_und_apotheker_bank"
              | "austrian_anadi_bank_ag"
              | "bank_austria"
              | "bankhaus_carl_spangler"
              | "bankhaus_schelhammer_und_schattera_ag"
              | "bawag_psk_ag"
              | "bks_bank_ag"
              | "brull_kallmus_bank_ag"
              | "btv_vier_lander_bank"
              | "capital_bank_grawe_gruppe_ag"
              | "deutsche_bank_ag"
              | "dolomitenbank"
              | "easybank_ag"
              | "erste_bank_und_sparkassen"
              | "hypo_alpeadriabank_international_ag"
              | "hypo_bank_burgenland_aktiengesellschaft"
              | "hypo_noe_lb_fur_niederosterreich_u_wien"
              | "hypo_oberosterreich_salzburg_steiermark"
              | "hypo_tirol_bank_ag"
              | "hypo_vorarlberg_bank_ag"
              | "marchfelder_bank"
              | "oberbank_ag"
              | "raiffeisen_bankengruppe_osterreich"
              | "schoellerbank_ag"
              | "sparda_bank_wien"
              | "volksbank_gruppe"
              | "volkskreditbank_ag"
              | "vr_bank_braunau"
          }
          fpx?: {
            bank:
              | "affin_bank"
              | "agrobank"
              | "alliance_bank"
              | "ambank"
              | "bank_islam"
              | "bank_muamalat"
              | "bank_of_china"
              | "bank_rakyat"
              | "bsn"
              | "cimb"
              | "deutsche_bank"
              | "hong_leong_bank"
              | "hsbc"
              | "kfh"
              | "maybank2e"
              | "maybank2u"
              | "ocbc"
              | "pb_enterprise"
              | "public_bank"
              | "rhb"
              | "standard_chartered"
              | "uob"
          }
          giropay?: EmptyObject
          grabpay?: EmptyObject
          ideal?: {
            bank?:
              | "abn_amro"
              | "asn_bank"
              | "bunq"
              | "handelsbanken"
              | "ing"
              | "knab"
              | "moneyou"
              | "rabobank"
              | "regiobank"
              | "revolut"
              | "sns_bank"
              | "triodos_bank"
              | "van_lanschot"
              | "yoursafe"
          }
          interac_present?: EmptyObject
          klarna?: {
            dob?: {
              day: number
              month: number
              year: number
            }
          }
          konbini?: EmptyObject
          link?: EmptyObject
          metadata?: {
            [key: string]: string
          }
          oxxo?: EmptyObject
          p24?: {
            bank?:
              | "alior_bank"
              | "bank_millennium"
              | "bank_nowy_bfg_sa"
              | "bank_pekao_sa"
              | "banki_spbdzielcze"
              | "blik"
              | "bnp_paribas"
              | "boz"
              | "citi_handlowy"
              | "credit_agricole"
              | "envelobank"
              | "etransfer_pocztowy24"
              | "getin_bank"
              | "ideabank"
              | "ing"
              | "inteligo"
              | "mbank_mtransfer"
              | "nest_przelew"
              | "noble_pay"
              | "pbac_z_ipko"
              | "plus_bank"
              | "santander_przelew24"
              | "tmobile_usbugi_bankowe"
              | "toyota_bank"
              | "volkswagen_bank"
          }
          paynow?: EmptyObject
          pix?: EmptyObject
          promptpay?: EmptyObject
          radar_options?: {
            session?: string
          }
          sepa_debit?: {
            iban: string
          }
          sofort?: {
            country: "AT" | "BE" | "DE" | "ES" | "IT" | "NL"
          }
          type:
            | "acss_debit"
            | "affirm"
            | "afterpay_clearpay"
            | "alipay"
            | "au_becs_debit"
            | "bacs_debit"
            | "bancontact"
            | "blik"
            | "boleto"
            | "cashapp"
            | "customer_balance"
            | "eps"
            | "fpx"
            | "giropay"
            | "grabpay"
            | "ideal"
            | "klarna"
            | "konbini"
            | "link"
            | "oxxo"
            | "p24"
            | "paynow"
            | "pix"
            | "promptpay"
            | "sepa_debit"
            | "sofort"
            | "us_bank_account"
            | "wechat_pay"
          us_bank_account?: {
            account_holder_type?: "company" | "individual"
            account_number?: string
            account_type?: "checking" | "savings"
            financial_connections_account?: string
            routing_number?: string
          }
          wechat_pay?: EmptyObject
        }
        payment_method_options?: {
          acss_debit?: {
            currency?: "cad" | "usd"
            mandate_options?: {
              custom_mandate_url?: string | ""
              default_for?: ("invoice" | "subscription")[]
              interval_description?: string
              payment_schedule?: "combined" | "interval" | "sporadic"
              transaction_type?: "business" | "personal"
            }
            verification_method?: "automatic" | "instant" | "microdeposits"
          }
          blik?: {
            code?: string
          }
          card?: {
            mandate_options?: {
              amount: number
              amount_type: "fixed" | "maximum"
              currency: string
              description?: string
              end_date?: number
              interval: "day" | "month" | "sporadic" | "week" | "year"
              interval_count?: number
              reference: string
              start_date: number
              supported_types?: "india"[]
            }
            network?:
              | "amex"
              | "cartes_bancaires"
              | "diners"
              | "discover"
              | "interac"
              | "jcb"
              | "mastercard"
              | "unionpay"
              | "unknown"
              | "visa"
            request_three_d_secure?: "any" | "automatic"
          }
          link?: {
            persistent_token?: string
          }
          sepa_debit?: {
            mandate_options?: EmptyObject
          }
          us_bank_account?: {
            financial_connections?: {
              permissions?: (
                | "balances"
                | "ownership"
                | "payment_method"
                | "transactions"
              )[]
              return_url?: string
            }
            networks?: {
              requested?: ("ach" | "us_domestic_wire")[]
            }
            verification_method?: "automatic" | "instant" | "microdeposits"
          }
        }
        payment_method_types?: string[]
        return_url?: string
        single_use?: {
          amount: number
          currency: string
        }
        usage?: "off_session" | "on_session"
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_setup_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/setup_intents`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSetupIntentsIntent(
    p: {
      clientSecret?: string
      expand?: string[]
      intent: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_setup_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      client_secret: p["clientSecret"],
      expand: p["expand"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSetupIntentsIntent(
    p: {
      intent: string
      requestBody?: {
        attach_to_self?: boolean
        customer?: string
        description?: string
        expand?: string[]
        flow_directions?: ("inbound" | "outbound")[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        payment_method?: string
        payment_method_data?: {
          acss_debit?: {
            account_number: string
            institution_number: string
            transit_number: string
          }
          affirm?: EmptyObject
          afterpay_clearpay?: EmptyObject
          alipay?: EmptyObject
          au_becs_debit?: {
            account_number: string
            bsb_number: string
          }
          bacs_debit?: {
            account_number?: string
            sort_code?: string
          }
          bancontact?: EmptyObject
          billing_details?: {
            address?:
              | {
                  city?: string
                  country?: string
                  line1?: string
                  line2?: string
                  postal_code?: string
                  state?: string
                }
              | ""
            email?: string | ""
            name?: string
            phone?: string
          }
          blik?: EmptyObject
          boleto?: {
            tax_id: string
          }
          cashapp?: EmptyObject
          customer_balance?: EmptyObject
          eps?: {
            bank?:
              | "arzte_und_apotheker_bank"
              | "austrian_anadi_bank_ag"
              | "bank_austria"
              | "bankhaus_carl_spangler"
              | "bankhaus_schelhammer_und_schattera_ag"
              | "bawag_psk_ag"
              | "bks_bank_ag"
              | "brull_kallmus_bank_ag"
              | "btv_vier_lander_bank"
              | "capital_bank_grawe_gruppe_ag"
              | "deutsche_bank_ag"
              | "dolomitenbank"
              | "easybank_ag"
              | "erste_bank_und_sparkassen"
              | "hypo_alpeadriabank_international_ag"
              | "hypo_bank_burgenland_aktiengesellschaft"
              | "hypo_noe_lb_fur_niederosterreich_u_wien"
              | "hypo_oberosterreich_salzburg_steiermark"
              | "hypo_tirol_bank_ag"
              | "hypo_vorarlberg_bank_ag"
              | "marchfelder_bank"
              | "oberbank_ag"
              | "raiffeisen_bankengruppe_osterreich"
              | "schoellerbank_ag"
              | "sparda_bank_wien"
              | "volksbank_gruppe"
              | "volkskreditbank_ag"
              | "vr_bank_braunau"
          }
          fpx?: {
            bank:
              | "affin_bank"
              | "agrobank"
              | "alliance_bank"
              | "ambank"
              | "bank_islam"
              | "bank_muamalat"
              | "bank_of_china"
              | "bank_rakyat"
              | "bsn"
              | "cimb"
              | "deutsche_bank"
              | "hong_leong_bank"
              | "hsbc"
              | "kfh"
              | "maybank2e"
              | "maybank2u"
              | "ocbc"
              | "pb_enterprise"
              | "public_bank"
              | "rhb"
              | "standard_chartered"
              | "uob"
          }
          giropay?: EmptyObject
          grabpay?: EmptyObject
          ideal?: {
            bank?:
              | "abn_amro"
              | "asn_bank"
              | "bunq"
              | "handelsbanken"
              | "ing"
              | "knab"
              | "moneyou"
              | "rabobank"
              | "regiobank"
              | "revolut"
              | "sns_bank"
              | "triodos_bank"
              | "van_lanschot"
              | "yoursafe"
          }
          interac_present?: EmptyObject
          klarna?: {
            dob?: {
              day: number
              month: number
              year: number
            }
          }
          konbini?: EmptyObject
          link?: EmptyObject
          metadata?: {
            [key: string]: string
          }
          oxxo?: EmptyObject
          p24?: {
            bank?:
              | "alior_bank"
              | "bank_millennium"
              | "bank_nowy_bfg_sa"
              | "bank_pekao_sa"
              | "banki_spbdzielcze"
              | "blik"
              | "bnp_paribas"
              | "boz"
              | "citi_handlowy"
              | "credit_agricole"
              | "envelobank"
              | "etransfer_pocztowy24"
              | "getin_bank"
              | "ideabank"
              | "ing"
              | "inteligo"
              | "mbank_mtransfer"
              | "nest_przelew"
              | "noble_pay"
              | "pbac_z_ipko"
              | "plus_bank"
              | "santander_przelew24"
              | "tmobile_usbugi_bankowe"
              | "toyota_bank"
              | "volkswagen_bank"
          }
          paynow?: EmptyObject
          pix?: EmptyObject
          promptpay?: EmptyObject
          radar_options?: {
            session?: string
          }
          sepa_debit?: {
            iban: string
          }
          sofort?: {
            country: "AT" | "BE" | "DE" | "ES" | "IT" | "NL"
          }
          type:
            | "acss_debit"
            | "affirm"
            | "afterpay_clearpay"
            | "alipay"
            | "au_becs_debit"
            | "bacs_debit"
            | "bancontact"
            | "blik"
            | "boleto"
            | "cashapp"
            | "customer_balance"
            | "eps"
            | "fpx"
            | "giropay"
            | "grabpay"
            | "ideal"
            | "klarna"
            | "konbini"
            | "link"
            | "oxxo"
            | "p24"
            | "paynow"
            | "pix"
            | "promptpay"
            | "sepa_debit"
            | "sofort"
            | "us_bank_account"
            | "wechat_pay"
          us_bank_account?: {
            account_holder_type?: "company" | "individual"
            account_number?: string
            account_type?: "checking" | "savings"
            financial_connections_account?: string
            routing_number?: string
          }
          wechat_pay?: EmptyObject
        }
        payment_method_options?: {
          acss_debit?: {
            currency?: "cad" | "usd"
            mandate_options?: {
              custom_mandate_url?: string | ""
              default_for?: ("invoice" | "subscription")[]
              interval_description?: string
              payment_schedule?: "combined" | "interval" | "sporadic"
              transaction_type?: "business" | "personal"
            }
            verification_method?: "automatic" | "instant" | "microdeposits"
          }
          blik?: {
            code?: string
          }
          card?: {
            mandate_options?: {
              amount: number
              amount_type: "fixed" | "maximum"
              currency: string
              description?: string
              end_date?: number
              interval: "day" | "month" | "sporadic" | "week" | "year"
              interval_count?: number
              reference: string
              start_date: number
              supported_types?: "india"[]
            }
            network?:
              | "amex"
              | "cartes_bancaires"
              | "diners"
              | "discover"
              | "interac"
              | "jcb"
              | "mastercard"
              | "unionpay"
              | "unknown"
              | "visa"
            request_three_d_secure?: "any" | "automatic"
          }
          link?: {
            persistent_token?: string
          }
          sepa_debit?: {
            mandate_options?: EmptyObject
          }
          us_bank_account?: {
            financial_connections?: {
              permissions?: (
                | "balances"
                | "ownership"
                | "payment_method"
                | "transactions"
              )[]
              return_url?: string
            }
            networks?: {
              requested?: ("ach" | "us_domestic_wire")[]
            }
            verification_method?: "automatic" | "instant" | "microdeposits"
          }
        }
        payment_method_types?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_setup_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSetupIntentsIntentCancel(
    p: {
      intent: string
      requestBody?: {
        cancellation_reason?:
          | "abandoned"
          | "duplicate"
          | "requested_by_customer"
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_setup_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSetupIntentsIntentConfirm(
    p: {
      intent: string
      requestBody?: {
        client_secret?: string
        expand?: string[]
        mandate_data?:
          | {
              customer_acceptance: {
                accepted_at?: number
                offline?: EmptyObject
                online?: {
                  ip_address: string
                  user_agent: string
                }
                type: "offline" | "online"
              }
            }
          | {
              customer_acceptance: {
                online: {
                  ip_address?: string
                  user_agent?: string
                }
                type: "online"
              }
            }
        payment_method?: string
        payment_method_data?: {
          acss_debit?: {
            account_number: string
            institution_number: string
            transit_number: string
          }
          affirm?: EmptyObject
          afterpay_clearpay?: EmptyObject
          alipay?: EmptyObject
          au_becs_debit?: {
            account_number: string
            bsb_number: string
          }
          bacs_debit?: {
            account_number?: string
            sort_code?: string
          }
          bancontact?: EmptyObject
          billing_details?: {
            address?:
              | {
                  city?: string
                  country?: string
                  line1?: string
                  line2?: string
                  postal_code?: string
                  state?: string
                }
              | ""
            email?: string | ""
            name?: string
            phone?: string
          }
          blik?: EmptyObject
          boleto?: {
            tax_id: string
          }
          cashapp?: EmptyObject
          customer_balance?: EmptyObject
          eps?: {
            bank?:
              | "arzte_und_apotheker_bank"
              | "austrian_anadi_bank_ag"
              | "bank_austria"
              | "bankhaus_carl_spangler"
              | "bankhaus_schelhammer_und_schattera_ag"
              | "bawag_psk_ag"
              | "bks_bank_ag"
              | "brull_kallmus_bank_ag"
              | "btv_vier_lander_bank"
              | "capital_bank_grawe_gruppe_ag"
              | "deutsche_bank_ag"
              | "dolomitenbank"
              | "easybank_ag"
              | "erste_bank_und_sparkassen"
              | "hypo_alpeadriabank_international_ag"
              | "hypo_bank_burgenland_aktiengesellschaft"
              | "hypo_noe_lb_fur_niederosterreich_u_wien"
              | "hypo_oberosterreich_salzburg_steiermark"
              | "hypo_tirol_bank_ag"
              | "hypo_vorarlberg_bank_ag"
              | "marchfelder_bank"
              | "oberbank_ag"
              | "raiffeisen_bankengruppe_osterreich"
              | "schoellerbank_ag"
              | "sparda_bank_wien"
              | "volksbank_gruppe"
              | "volkskreditbank_ag"
              | "vr_bank_braunau"
          }
          fpx?: {
            bank:
              | "affin_bank"
              | "agrobank"
              | "alliance_bank"
              | "ambank"
              | "bank_islam"
              | "bank_muamalat"
              | "bank_of_china"
              | "bank_rakyat"
              | "bsn"
              | "cimb"
              | "deutsche_bank"
              | "hong_leong_bank"
              | "hsbc"
              | "kfh"
              | "maybank2e"
              | "maybank2u"
              | "ocbc"
              | "pb_enterprise"
              | "public_bank"
              | "rhb"
              | "standard_chartered"
              | "uob"
          }
          giropay?: EmptyObject
          grabpay?: EmptyObject
          ideal?: {
            bank?:
              | "abn_amro"
              | "asn_bank"
              | "bunq"
              | "handelsbanken"
              | "ing"
              | "knab"
              | "moneyou"
              | "rabobank"
              | "regiobank"
              | "revolut"
              | "sns_bank"
              | "triodos_bank"
              | "van_lanschot"
              | "yoursafe"
          }
          interac_present?: EmptyObject
          klarna?: {
            dob?: {
              day: number
              month: number
              year: number
            }
          }
          konbini?: EmptyObject
          link?: EmptyObject
          metadata?: {
            [key: string]: string
          }
          oxxo?: EmptyObject
          p24?: {
            bank?:
              | "alior_bank"
              | "bank_millennium"
              | "bank_nowy_bfg_sa"
              | "bank_pekao_sa"
              | "banki_spbdzielcze"
              | "blik"
              | "bnp_paribas"
              | "boz"
              | "citi_handlowy"
              | "credit_agricole"
              | "envelobank"
              | "etransfer_pocztowy24"
              | "getin_bank"
              | "ideabank"
              | "ing"
              | "inteligo"
              | "mbank_mtransfer"
              | "nest_przelew"
              | "noble_pay"
              | "pbac_z_ipko"
              | "plus_bank"
              | "santander_przelew24"
              | "tmobile_usbugi_bankowe"
              | "toyota_bank"
              | "volkswagen_bank"
          }
          paynow?: EmptyObject
          pix?: EmptyObject
          promptpay?: EmptyObject
          radar_options?: {
            session?: string
          }
          sepa_debit?: {
            iban: string
          }
          sofort?: {
            country: "AT" | "BE" | "DE" | "ES" | "IT" | "NL"
          }
          type:
            | "acss_debit"
            | "affirm"
            | "afterpay_clearpay"
            | "alipay"
            | "au_becs_debit"
            | "bacs_debit"
            | "bancontact"
            | "blik"
            | "boleto"
            | "cashapp"
            | "customer_balance"
            | "eps"
            | "fpx"
            | "giropay"
            | "grabpay"
            | "ideal"
            | "klarna"
            | "konbini"
            | "link"
            | "oxxo"
            | "p24"
            | "paynow"
            | "pix"
            | "promptpay"
            | "sepa_debit"
            | "sofort"
            | "us_bank_account"
            | "wechat_pay"
          us_bank_account?: {
            account_holder_type?: "company" | "individual"
            account_number?: string
            account_type?: "checking" | "savings"
            financial_connections_account?: string
            routing_number?: string
          }
          wechat_pay?: EmptyObject
        }
        payment_method_options?: {
          acss_debit?: {
            currency?: "cad" | "usd"
            mandate_options?: {
              custom_mandate_url?: string | ""
              default_for?: ("invoice" | "subscription")[]
              interval_description?: string
              payment_schedule?: "combined" | "interval" | "sporadic"
              transaction_type?: "business" | "personal"
            }
            verification_method?: "automatic" | "instant" | "microdeposits"
          }
          blik?: {
            code?: string
          }
          card?: {
            mandate_options?: {
              amount: number
              amount_type: "fixed" | "maximum"
              currency: string
              description?: string
              end_date?: number
              interval: "day" | "month" | "sporadic" | "week" | "year"
              interval_count?: number
              reference: string
              start_date: number
              supported_types?: "india"[]
            }
            network?:
              | "amex"
              | "cartes_bancaires"
              | "diners"
              | "discover"
              | "interac"
              | "jcb"
              | "mastercard"
              | "unionpay"
              | "unknown"
              | "visa"
            request_three_d_secure?: "any" | "automatic"
          }
          link?: {
            persistent_token?: string
          }
          sepa_debit?: {
            mandate_options?: EmptyObject
          }
          us_bank_account?: {
            financial_connections?: {
              permissions?: (
                | "balances"
                | "ownership"
                | "payment_method"
                | "transactions"
              )[]
              return_url?: string
            }
            networks?: {
              requested?: ("ach" | "us_domestic_wire")[]
            }
            verification_method?: "automatic" | "instant" | "microdeposits"
          }
        }
        return_url?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_setup_intent> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}/confirm`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSetupIntentsIntentVerifyMicrodeposits(
    p: {
      intent: string
      requestBody?: {
        amounts?: number[]
        client_secret?: string
        descriptor_code?: string
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_setup_intent> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/setup_intents/${p["intent"]}/verify_microdeposits`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getShippingRates(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_shipping_rate[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/shipping_rates`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postShippingRates(
    p: {
      requestBody: {
        delivery_estimate?: {
          maximum?: {
            unit: "business_day" | "day" | "hour" | "month" | "week"
            value: number
          }
          minimum?: {
            unit: "business_day" | "day" | "hour" | "month" | "week"
            value: number
          }
        }
        display_name: string
        expand?: string[]
        fixed_amount?: {
          amount: number
          currency: string
          currency_options?: {
            [key: string]: {
              amount: number
              tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            }
          }
        }
        metadata?: {
          [key: string]: string
        }
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
        tax_code?: string
        type?: "fixed_amount"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_shipping_rate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/shipping_rates`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getShippingRatesShippingRateToken(
    p: {
      expand?: string[]
      shippingRateToken: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_shipping_rate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/shipping_rates/${p["shippingRateToken"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postShippingRatesShippingRateToken(
    p: {
      shippingRateToken: string
      requestBody?: {
        active?: boolean
        expand?: string[]
        fixed_amount?: {
          currency_options?: {
            [key: string]: {
              amount?: number
              tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            }
          }
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        tax_behavior?: "exclusive" | "inclusive" | "unspecified"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_shipping_rate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/shipping_rates/${p["shippingRateToken"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSigmaScheduledQueryRuns(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_scheduled_query_run[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/sigma/scheduled_query_runs`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSigmaScheduledQueryRunsScheduledQueryRun(
    p: {
      expand?: string[]
      scheduledQueryRun: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_scheduled_query_run> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/sigma/scheduled_query_runs/${p["scheduledQueryRun"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSources(
    p: {
      requestBody?: {
        amount?: number
        currency?: string
        customer?: string
        expand?: string[]
        flow?: "code_verification" | "none" | "receiver" | "redirect"
        mandate?: {
          acceptance?: {
            date?: number
            ip?: string
            offline?: {
              contact_email: string
            }
            online?: {
              date?: number
              ip?: string
              user_agent?: string
            }
            status: "accepted" | "pending" | "refused" | "revoked"
            type?: "offline" | "online"
            user_agent?: string
          }
          amount?: number | ""
          currency?: string
          interval?: "one_time" | "scheduled" | "variable"
          notification_method?:
            | "deprecated_none"
            | "email"
            | "manual"
            | "none"
            | "stripe_email"
        }
        metadata?: {
          [key: string]: string
        }
        original_source?: string
        owner?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          email?: string
          name?: string
          phone?: string
        }
        receiver?: {
          refund_attributes_method?: "email" | "manual" | "none"
        }
        redirect?: {
          return_url: string
        }
        source_order?: {
          items?: {
            amount?: number
            currency?: string
            description?: string
            parent?: string
            quantity?: number
            type?: "discount" | "shipping" | "sku" | "tax"
          }[]
          shipping?: {
            address: {
              city?: string
              country?: string
              line1: string
              line2?: string
              postal_code?: string
              state?: string
            }
            carrier?: string
            name?: string
            phone?: string
            tracking_number?: string
          }
        }
        statement_descriptor?: string
        token?: string
        type?: string
        usage?: "reusable" | "single_use"
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_source> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/sources`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSourcesSource(
    p: {
      clientSecret?: string
      expand?: string[]
      source: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_source> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/sources/${p["source"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      client_secret: p["clientSecret"],
      expand: p["expand"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSourcesSource(
    p: {
      source: string
      requestBody?: {
        amount?: number
        expand?: string[]
        mandate?: {
          acceptance?: {
            date?: number
            ip?: string
            offline?: {
              contact_email: string
            }
            online?: {
              date?: number
              ip?: string
              user_agent?: string
            }
            status: "accepted" | "pending" | "refused" | "revoked"
            type?: "offline" | "online"
            user_agent?: string
          }
          amount?: number | ""
          currency?: string
          interval?: "one_time" | "scheduled" | "variable"
          notification_method?:
            | "deprecated_none"
            | "email"
            | "manual"
            | "none"
            | "stripe_email"
        }
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        owner?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          email?: string
          name?: string
          phone?: string
        }
        source_order?: {
          items?: {
            amount?: number
            currency?: string
            description?: string
            parent?: string
            quantity?: number
            type?: "discount" | "shipping" | "sku" | "tax"
          }[]
          shipping?: {
            address: {
              city?: string
              country?: string
              line1: string
              line2?: string
              postal_code?: string
              state?: string
            }
            carrier?: string
            name?: string
            phone?: string
            tracking_number?: string
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_source> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/sources/${p["source"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSourcesSourceMandateNotificationsMandateNotification(
    p: {
      expand?: string[]
      mandateNotification: string
      source: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_source_mandate_notification> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/sources/${p["source"]}/mandate_notifications/${p["mandateNotification"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSourcesSourceSourceTransactions(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      source: string
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_source_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/sources/${p["source"]}/source_transactions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSourcesSourceSourceTransactionsSourceTransaction(
    p: {
      expand?: string[]
      source: string
      sourceTransaction: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_source_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/sources/${p["source"]}/source_transactions/${p["sourceTransaction"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSourcesSourceVerify(
    p: {
      source: string
      requestBody: {
        expand?: string[]
        values: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_source> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/sources/${p["source"]}/verify`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptionItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      subscription: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_subscription_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscription_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      subscription: p["subscription"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionItems(
    p: {
      requestBody: {
        billing_thresholds?:
          | {
              usage_gte: number
            }
          | ""
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        payment_behavior?:
          | "allow_incomplete"
          | "default_incomplete"
          | "error_if_incomplete"
          | "pending_if_incomplete"
        price?: string
        price_data?: {
          currency: string
          product: string
          recurring: {
            interval: "day" | "month" | "week" | "year"
            interval_count?: number
          }
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        proration_date?: number
        quantity?: number
        subscription: string
        tax_rates?: string[] | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription_item> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/subscription_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteSubscriptionItemsItem(
    p: {
      item: string
      requestBody?: {
        clear_usage?: boolean
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        proration_date?: number
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_subscription_item> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscription_items/${p["item"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptionItemsItem(
    p: {
      expand?: string[]
      item: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription_item> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/subscription_items/${p["item"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionItemsItem(
    p: {
      item: string
      requestBody?: {
        billing_thresholds?:
          | {
              usage_gte: number
            }
          | ""
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        off_session?: boolean
        payment_behavior?:
          | "allow_incomplete"
          | "default_incomplete"
          | "error_if_incomplete"
          | "pending_if_incomplete"
        price?: string
        price_data?: {
          currency: string
          product: string
          recurring: {
            interval: "day" | "month" | "week" | "year"
            interval_count?: number
          }
          tax_behavior?: "exclusive" | "inclusive" | "unspecified"
          unit_amount?: number
          unit_amount_decimal?: string
        }
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        proration_date?: number
        quantity?: number
        tax_rates?: string[] | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription_item> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/subscription_items/${p["item"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptionItemsSubscriptionItemUsageRecordSummaries(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      subscriptionItem: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_usage_record_summary[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/subscription_items/${p["subscriptionItem"]}/usage_record_summaries`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionItemsSubscriptionItemUsageRecords(
    p: {
      subscriptionItem: string
      requestBody: {
        action?: "increment" | "set"
        expand?: string[]
        quantity: number
        timestamp?: "now" | number
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_usage_record> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/subscription_items/${p["subscriptionItem"]}/usage_records`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptionSchedules(
    p: {
      canceledAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      completedAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      releasedAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      scheduled?: boolean
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_subscription_schedule[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscription_schedules`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      canceled_at: p["canceledAt"],
      completed_at: p["completedAt"],
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      released_at: p["releasedAt"],
      scheduled: p["scheduled"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionSchedules(
    p: {
      requestBody?: {
        customer?: string
        default_settings?: {
          application_fee_percent?: number
          automatic_tax?: {
            enabled: boolean
          }
          billing_cycle_anchor?: "automatic" | "phase_start"
          billing_thresholds?:
            | {
                amount_gte?: number
                reset_billing_cycle_anchor?: boolean
              }
            | ""
          collection_method?: "charge_automatically" | "send_invoice"
          default_payment_method?: string
          description?: string
          invoice_settings?: {
            days_until_due?: number
          }
          on_behalf_of?: string | ""
          transfer_data?:
            | {
                amount_percent?: number
                destination: string
              }
            | ""
        }
        end_behavior?: "cancel" | "none" | "release" | "renew"
        expand?: string[]
        from_subscription?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        phases?: {
          add_invoice_items?: {
            price?: string
            price_data?: {
              currency: string
              product: string
              tax_behavior?: "exclusive" | "inclusive" | "unspecified"
              unit_amount?: number
              unit_amount_decimal?: string
            }
            quantity?: number
            tax_rates?: string[] | ""
          }[]
          application_fee_percent?: number
          automatic_tax?: {
            enabled: boolean
          }
          billing_cycle_anchor?: "automatic" | "phase_start"
          billing_thresholds?:
            | {
                amount_gte?: number
                reset_billing_cycle_anchor?: boolean
              }
            | ""
          collection_method?: "charge_automatically" | "send_invoice"
          coupon?: string
          currency?: string
          default_payment_method?: string
          default_tax_rates?: string[] | ""
          description?: string
          end_date?: number
          invoice_settings?: {
            days_until_due?: number
          }
          items: {
            billing_thresholds?:
              | {
                  usage_gte: number
                }
              | ""
            metadata?: {
              [key: string]: string
            }
            price?: string
            price_data?: {
              currency: string
              product: string
              recurring: {
                interval: "day" | "month" | "week" | "year"
                interval_count?: number
              }
              tax_behavior?: "exclusive" | "inclusive" | "unspecified"
              unit_amount?: number
              unit_amount_decimal?: string
            }
            quantity?: number
            tax_rates?: string[] | ""
          }[]
          iterations?: number
          metadata?: {
            [key: string]: string
          }
          on_behalf_of?: string
          proration_behavior?: "always_invoice" | "create_prorations" | "none"
          transfer_data?: {
            amount_percent?: number
            destination: string
          }
          trial?: boolean
          trial_end?: number
        }[]
        start_date?: number | "now"
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_subscription_schedule> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscription_schedules`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptionSchedulesSchedule(
    p: {
      expand?: string[]
      schedule: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_subscription_schedule> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscription_schedules/${p["schedule"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionSchedulesSchedule(
    p: {
      schedule: string
      requestBody?: {
        default_settings?: {
          application_fee_percent?: number
          automatic_tax?: {
            enabled: boolean
          }
          billing_cycle_anchor?: "automatic" | "phase_start"
          billing_thresholds?:
            | {
                amount_gte?: number
                reset_billing_cycle_anchor?: boolean
              }
            | ""
          collection_method?: "charge_automatically" | "send_invoice"
          default_payment_method?: string
          description?: string
          invoice_settings?: {
            days_until_due?: number
          }
          on_behalf_of?: string | ""
          transfer_data?:
            | {
                amount_percent?: number
                destination: string
              }
            | ""
        }
        end_behavior?: "cancel" | "none" | "release" | "renew"
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        phases?: {
          add_invoice_items?: {
            price?: string
            price_data?: {
              currency: string
              product: string
              tax_behavior?: "exclusive" | "inclusive" | "unspecified"
              unit_amount?: number
              unit_amount_decimal?: string
            }
            quantity?: number
            tax_rates?: string[] | ""
          }[]
          application_fee_percent?: number
          automatic_tax?: {
            enabled: boolean
          }
          billing_cycle_anchor?: "automatic" | "phase_start"
          billing_thresholds?:
            | {
                amount_gte?: number
                reset_billing_cycle_anchor?: boolean
              }
            | ""
          collection_method?: "charge_automatically" | "send_invoice"
          coupon?: string
          default_payment_method?: string
          default_tax_rates?: string[] | ""
          description?: string
          end_date?: number | "now"
          invoice_settings?: {
            days_until_due?: number
          }
          items: {
            billing_thresholds?:
              | {
                  usage_gte: number
                }
              | ""
            metadata?: {
              [key: string]: string
            }
            price?: string
            price_data?: {
              currency: string
              product: string
              recurring: {
                interval: "day" | "month" | "week" | "year"
                interval_count?: number
              }
              tax_behavior?: "exclusive" | "inclusive" | "unspecified"
              unit_amount?: number
              unit_amount_decimal?: string
            }
            quantity?: number
            tax_rates?: string[] | ""
          }[]
          iterations?: number
          metadata?: {
            [key: string]: string
          }
          on_behalf_of?: string
          proration_behavior?: "always_invoice" | "create_prorations" | "none"
          start_date?: number | "now"
          transfer_data?: {
            amount_percent?: number
            destination: string
          }
          trial?: boolean
          trial_end?: number | "now"
        }[]
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_subscription_schedule> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscription_schedules/${p["schedule"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionSchedulesScheduleCancel(
    p: {
      schedule: string
      requestBody?: {
        expand?: string[]
        invoice_now?: boolean
        prorate?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_subscription_schedule> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/subscription_schedules/${p["schedule"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionSchedulesScheduleRelease(
    p: {
      schedule: string
      requestBody?: {
        expand?: string[]
        preserve_cancel_date?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_subscription_schedule> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/subscription_schedules/${p["schedule"]}/release`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptions(
    p: {
      collectionMethod?: "charge_automatically" | "send_invoice"
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currentPeriodEnd?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currentPeriodStart?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      price?: string
      startingAfter?: string
      status?:
        | "active"
        | "all"
        | "canceled"
        | "ended"
        | "incomplete"
        | "incomplete_expired"
        | "past_due"
        | "paused"
        | "trialing"
        | "unpaid"
      testClock?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_subscription[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscriptions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      collection_method: p["collectionMethod"],
      created: p["created"],
      current_period_end: p["currentPeriodEnd"],
      current_period_start: p["currentPeriodStart"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      price: p["price"],
      starting_after: p["startingAfter"],
      status: p["status"],
      test_clock: p["testClock"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptions(
    p: {
      requestBody: {
        add_invoice_items?: {
          price?: string
          price_data?: {
            currency: string
            product: string
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        application_fee_percent?: number
        automatic_tax?: {
          enabled: boolean
        }
        backdate_start_date?: number
        billing_cycle_anchor?: number
        billing_thresholds?:
          | {
              amount_gte?: number
              reset_billing_cycle_anchor?: boolean
            }
          | ""
        cancel_at?: number
        cancel_at_period_end?: boolean
        collection_method?: "charge_automatically" | "send_invoice"
        coupon?: string
        currency?: string
        customer: string
        days_until_due?: number
        default_payment_method?: string
        default_source?: string
        default_tax_rates?: string[] | ""
        description?: string
        expand?: string[]
        items?: {
          billing_thresholds?:
            | {
                usage_gte: number
              }
            | ""
          metadata?: {
            [key: string]: string
          }
          price?: string
          price_data?: {
            currency: string
            product: string
            recurring: {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        off_session?: boolean
        on_behalf_of?: string | ""
        payment_behavior?:
          | "allow_incomplete"
          | "default_incomplete"
          | "error_if_incomplete"
          | "pending_if_incomplete"
        payment_settings?: {
          payment_method_options?: {
            acss_debit?:
              | {
                  mandate_options?: {
                    transaction_type?: "business" | "personal"
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
            bancontact?:
              | {
                  preferred_language?: "de" | "en" | "fr" | "nl"
                }
              | ""
            card?:
              | {
                  mandate_options?: {
                    amount?: number
                    amount_type?: "fixed" | "maximum"
                    description?: string
                  }
                  network?:
                    | "amex"
                    | "cartes_bancaires"
                    | "diners"
                    | "discover"
                    | "interac"
                    | "jcb"
                    | "mastercard"
                    | "unionpay"
                    | "unknown"
                    | "visa"
                  request_three_d_secure?: "any" | "automatic"
                }
              | ""
            customer_balance?:
              | {
                  bank_transfer?: {
                    eu_bank_transfer?: {
                      country: string
                    }
                    type?: string
                  }
                  funding_type?: string
                }
              | ""
            konbini?: EmptyObject | ""
            us_bank_account?:
              | {
                  financial_connections?: {
                    permissions?: (
                      | "balances"
                      | "ownership"
                      | "payment_method"
                      | "transactions"
                    )[]
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
          }
          payment_method_types?:
            | (
                | "ach_credit_transfer"
                | "ach_debit"
                | "acss_debit"
                | "au_becs_debit"
                | "bacs_debit"
                | "bancontact"
                | "boleto"
                | "card"
                | "cashapp"
                | "customer_balance"
                | "fpx"
                | "giropay"
                | "grabpay"
                | "ideal"
                | "konbini"
                | "link"
                | "paynow"
                | "promptpay"
                | "sepa_debit"
                | "sofort"
                | "us_bank_account"
                | "wechat_pay"
              )[]
            | ""
          save_default_payment_method?: "off" | "on_subscription"
        }
        pending_invoice_item_interval?:
          | {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
          | ""
        promotion_code?: string
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        transfer_data?: {
          amount_percent?: number
          destination: string
        }
        trial_end?: "now" | number
        trial_from_plan?: boolean
        trial_period_days?: number
        trial_settings?: {
          end_behavior: {
            missing_payment_method: "cancel" | "create_invoice" | "pause"
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/subscriptions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptionsSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_subscription[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/subscriptions/search`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteSubscriptionsSubscriptionExposedId(
    p: {
      subscriptionExposedId: string
      requestBody?: {
        cancellation_details?: {
          comment?: string
          feedback?:
            | ""
            | "customer_service"
            | "low_quality"
            | "missing_features"
            | "other"
            | "switched_service"
            | "too_complex"
            | "too_expensive"
            | "unused"
        }
        expand?: string[]
        invoice_now?: boolean
        prorate?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getSubscriptionsSubscriptionExposedId(
    p: {
      expand?: string[]
      subscriptionExposedId: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionsSubscriptionExposedId(
    p: {
      subscriptionExposedId: string
      requestBody?: {
        add_invoice_items?: {
          price?: string
          price_data?: {
            currency: string
            product: string
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        application_fee_percent?: number
        automatic_tax?: {
          enabled: boolean
        }
        billing_cycle_anchor?: "now" | "unchanged"
        billing_thresholds?:
          | {
              amount_gte?: number
              reset_billing_cycle_anchor?: boolean
            }
          | ""
        cancel_at?: number | ""
        cancel_at_period_end?: boolean
        cancellation_details?: {
          comment?: string
          feedback?:
            | ""
            | "customer_service"
            | "low_quality"
            | "missing_features"
            | "other"
            | "switched_service"
            | "too_complex"
            | "too_expensive"
            | "unused"
        }
        collection_method?: "charge_automatically" | "send_invoice"
        coupon?: string
        days_until_due?: number
        default_payment_method?: string
        default_source?: string
        default_tax_rates?: string[] | ""
        description?: string
        expand?: string[]
        items?: {
          billing_thresholds?:
            | {
                usage_gte: number
              }
            | ""
          clear_usage?: boolean
          deleted?: boolean
          id?: string
          metadata?:
            | {
                [key: string]: string
              }
            | ""
          price?: string
          price_data?: {
            currency: string
            product: string
            recurring: {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
            tax_behavior?: "exclusive" | "inclusive" | "unspecified"
            unit_amount?: number
            unit_amount_decimal?: string
          }
          quantity?: number
          tax_rates?: string[] | ""
        }[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        off_session?: boolean
        on_behalf_of?: string | ""
        pause_collection?:
          | {
              behavior: "keep_as_draft" | "mark_uncollectible" | "void"
              resumes_at?: number
            }
          | ""
        payment_behavior?:
          | "allow_incomplete"
          | "default_incomplete"
          | "error_if_incomplete"
          | "pending_if_incomplete"
        payment_settings?: {
          payment_method_options?: {
            acss_debit?:
              | {
                  mandate_options?: {
                    transaction_type?: "business" | "personal"
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
            bancontact?:
              | {
                  preferred_language?: "de" | "en" | "fr" | "nl"
                }
              | ""
            card?:
              | {
                  mandate_options?: {
                    amount?: number
                    amount_type?: "fixed" | "maximum"
                    description?: string
                  }
                  network?:
                    | "amex"
                    | "cartes_bancaires"
                    | "diners"
                    | "discover"
                    | "interac"
                    | "jcb"
                    | "mastercard"
                    | "unionpay"
                    | "unknown"
                    | "visa"
                  request_three_d_secure?: "any" | "automatic"
                }
              | ""
            customer_balance?:
              | {
                  bank_transfer?: {
                    eu_bank_transfer?: {
                      country: string
                    }
                    type?: string
                  }
                  funding_type?: string
                }
              | ""
            konbini?: EmptyObject | ""
            us_bank_account?:
              | {
                  financial_connections?: {
                    permissions?: (
                      | "balances"
                      | "ownership"
                      | "payment_method"
                      | "transactions"
                    )[]
                  }
                  verification_method?:
                    | "automatic"
                    | "instant"
                    | "microdeposits"
                }
              | ""
          }
          payment_method_types?:
            | (
                | "ach_credit_transfer"
                | "ach_debit"
                | "acss_debit"
                | "au_becs_debit"
                | "bacs_debit"
                | "bancontact"
                | "boleto"
                | "card"
                | "cashapp"
                | "customer_balance"
                | "fpx"
                | "giropay"
                | "grabpay"
                | "ideal"
                | "konbini"
                | "link"
                | "paynow"
                | "promptpay"
                | "sepa_debit"
                | "sofort"
                | "us_bank_account"
                | "wechat_pay"
              )[]
            | ""
          save_default_payment_method?: "off" | "on_subscription"
        }
        pending_invoice_item_interval?:
          | {
              interval: "day" | "month" | "week" | "year"
              interval_count?: number
            }
          | ""
        promotion_code?: string
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        proration_date?: number
        transfer_data?:
          | {
              amount_percent?: number
              destination: string
            }
          | ""
        trial_end?: "now" | number
        trial_from_plan?: boolean
        trial_settings?: {
          end_behavior: {
            missing_payment_method: "cancel" | "create_invoice" | "pause"
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteSubscriptionsSubscriptionExposedIdDiscount(
    p: {
      subscriptionExposedId: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deleted_discount> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}/discount`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postSubscriptionsSubscriptionResume(
    p: {
      subscription: string
      requestBody?: {
        billing_cycle_anchor?: "now" | "unchanged"
        expand?: string[]
        proration_behavior?: "always_invoice" | "create_prorations" | "none"
        proration_date?: number
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_subscription> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/subscriptions/${p["subscription"]}/resume`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTaxCalculations(
    p: {
      requestBody: {
        currency: string
        customer?: string
        customer_details?: {
          address?: {
            city?: string
            country: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          address_source?: "billing" | "shipping"
          ip_address?: string
          tax_ids?: {
            type:
              | "ae_trn"
              | "au_abn"
              | "au_arn"
              | "bg_uic"
              | "br_cnpj"
              | "br_cpf"
              | "ca_bn"
              | "ca_gst_hst"
              | "ca_pst_bc"
              | "ca_pst_mb"
              | "ca_pst_sk"
              | "ca_qst"
              | "ch_vat"
              | "cl_tin"
              | "eg_tin"
              | "es_cif"
              | "eu_oss_vat"
              | "eu_vat"
              | "gb_vat"
              | "ge_vat"
              | "hk_br"
              | "hu_tin"
              | "id_npwp"
              | "il_vat"
              | "in_gst"
              | "is_vat"
              | "jp_cn"
              | "jp_rn"
              | "jp_trn"
              | "ke_pin"
              | "kr_brn"
              | "li_uid"
              | "mx_rfc"
              | "my_frp"
              | "my_itn"
              | "my_sst"
              | "no_vat"
              | "nz_gst"
              | "ph_tin"
              | "ru_inn"
              | "ru_kpp"
              | "sa_vat"
              | "sg_gst"
              | "sg_uen"
              | "si_tin"
              | "th_vat"
              | "tr_tin"
              | "tw_vat"
              | "ua_vat"
              | "us_ein"
              | "za_vat"
            value: string
          }[]
          taxability_override?: "customer_exempt" | "none" | "reverse_charge"
        }
        expand?: string[]
        line_items: {
          amount: number
          product?: string
          quantity?: number
          reference?: string
          tax_behavior?: "exclusive" | "inclusive"
          tax_code?: string
        }[]
        shipping_cost?: {
          amount?: number
          shipping_rate?: string
          tax_behavior?: "exclusive" | "inclusive"
          tax_code?: string
        }
        tax_date?: number
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_calculation> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax/calculations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTaxCalculationsCalculationLineItems(
    p: {
      calculation: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_tax_calculation_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/tax/calculations/${p["calculation"]}/line_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTaxTransactionsCreateFromCalculation(
    p: {
      requestBody: {
        calculation: string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        reference: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_transaction> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax/transactions/create_from_calculation`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTaxTransactionsCreateReversal(
    p: {
      requestBody: {
        expand?: string[]
        line_items?: {
          amount: number
          amount_tax: number
          metadata?: {
            [key: string]: string
          }
          original_line_item: string
          quantity?: number
          reference: string
        }[]
        metadata?: {
          [key: string]: string
        }
        mode: "full" | "partial"
        original_transaction: string
        reference: string
        shipping_cost?: {
          amount: number
          amount_tax: number
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_transaction> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax/transactions/create_reversal`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTaxTransactionsTransaction(
    p: {
      expand?: string[]
      transaction: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_transaction> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax/transactions/${p["transaction"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTaxTransactionsTransactionLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      transaction: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_tax_transaction_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/tax/transactions/${p["transaction"]}/line_items`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTaxCodes(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_tax_code[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/tax_codes`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTaxCodesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_code> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax_codes/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTaxRates(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      inclusive?: boolean
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_tax_rate[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/tax_rates`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      active: p["active"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      inclusive: p["inclusive"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTaxRates(
    p: {
      requestBody: {
        active?: boolean
        country?: string
        description?: string
        display_name: string
        expand?: string[]
        inclusive: boolean
        jurisdiction?: string
        metadata?: {
          [key: string]: string
        }
        percentage: number
        state?: string
        tax_type?:
          | "gst"
          | "hst"
          | "igst"
          | "jct"
          | "lease_tax"
          | "pst"
          | "qst"
          | "rst"
          | "sales_tax"
          | "vat"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_rate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax_rates`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTaxRatesTaxRate(
    p: {
      expand?: string[]
      taxRate: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_rate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax_rates/${p["taxRate"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTaxRatesTaxRate(
    p: {
      taxRate: string
      requestBody?: {
        active?: boolean
        country?: string
        description?: string
        display_name?: string
        expand?: string[]
        jurisdiction?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        state?: string
        tax_type?:
          | "gst"
          | "hst"
          | "igst"
          | "jct"
          | "lease_tax"
          | "pst"
          | "qst"
          | "rst"
          | "sales_tax"
          | "vat"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_tax_rate> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/tax_rates/${p["taxRate"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTerminalConfigurations(
    p: {
      endingBefore?: string
      expand?: string[]
      isAccountDefault?: boolean
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_terminal_configuration[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/configurations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      is_account_default: p["isAccountDefault"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalConfigurations(
    p: {
      requestBody?: {
        bbpos_wisepos_e?: {
          splashscreen?: string | ""
        }
        expand?: string[]
        tipping?:
          | {
              aud?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              cad?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              chf?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              czk?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              dkk?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              eur?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              gbp?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              hkd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              myr?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              nok?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              nzd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              sek?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              sgd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              usd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
            }
          | ""
        verifone_p400?: {
          splashscreen?: string | ""
        }
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_terminal_configuration> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/configurations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteTerminalConfigurationsConfiguration(
    p: {
      configuration: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_terminal_configuration> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/terminal/configurations/${p["configuration"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTerminalConfigurationsConfiguration(
    p: {
      configuration: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_terminal_configuration | t_deleted_terminal_configuration>
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/terminal/configurations/${p["configuration"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalConfigurationsConfiguration(
    p: {
      configuration: string
      requestBody?: {
        bbpos_wisepos_e?:
          | {
              splashscreen?: string | ""
            }
          | ""
        expand?: string[]
        tipping?:
          | {
              aud?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              cad?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              chf?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              czk?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              dkk?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              eur?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              gbp?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              hkd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              myr?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              nok?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              nzd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              sek?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              sgd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
              usd?: {
                fixed_amounts?: number[]
                percentages?: number[]
                smart_tip_threshold?: number
              }
            }
          | ""
        verifone_p400?:
          | {
              splashscreen?: string | ""
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_terminal_configuration | t_deleted_terminal_configuration>
      | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/terminal/configurations/${p["configuration"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalConnectionTokens(
    p: {
      requestBody?: {
        expand?: string[]
        location?: string
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_terminal_connection_token> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/connection_tokens`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTerminalLocations(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_terminal_location[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/locations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalLocations(
    p: {
      requestBody: {
        address: {
          city?: string
          country: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        configuration_overrides?: string
        display_name: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_location> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/terminal/locations`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteTerminalLocationsLocation(
    p: {
      location: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_terminal_location> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/locations/${p["location"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTerminalLocationsLocation(
    p: {
      expand?: string[]
      location: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_terminal_location | t_deleted_terminal_location>
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/locations/${p["location"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalLocationsLocation(
    p: {
      location: string
      requestBody?: {
        address?: {
          city?: string
          country?: string
          line1?: string
          line2?: string
          postal_code?: string
          state?: string
        }
        configuration_overrides?: string
        display_name?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_terminal_location | t_deleted_terminal_location>
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/locations/${p["location"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTerminalReaders(
    p: {
      deviceType?:
        | "bbpos_chipper2x"
        | "bbpos_wisepad3"
        | "bbpos_wisepos_e"
        | "simulated_wisepos_e"
        | "stripe_m2"
        | "verifone_P400"
      endingBefore?: string
      expand?: string[]
      limit?: number
      location?: string
      startingAfter?: string
      status?: "offline" | "online"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_terminal_reader[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/readers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      device_type: p["deviceType"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      location: p["location"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalReaders(
    p: {
      requestBody: {
        expand?: string[]
        label?: string
        location?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        registration_code: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_reader> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/terminal/readers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteTerminalReadersReader(
    p: {
      reader: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_terminal_reader> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/readers/${p["reader"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTerminalReadersReader(
    p: {
      expand?: string[]
      reader: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_terminal_reader | t_deleted_terminal_reader>
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/readers/${p["reader"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalReadersReader(
    p: {
      reader: string
      requestBody?: {
        expand?: string[]
        label?: string
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_terminal_reader | t_deleted_terminal_reader>
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/terminal/readers/${p["reader"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalReadersReaderCancelAction(
    p: {
      reader: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_reader> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/cancel_action`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalReadersReaderProcessPaymentIntent(
    p: {
      reader: string
      requestBody: {
        expand?: string[]
        payment_intent: string
        process_config?: {
          skip_tipping?: boolean
          tipping?: {
            amount_eligible?: number
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_reader> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/terminal/readers/${p["reader"]}/process_payment_intent`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalReadersReaderProcessSetupIntent(
    p: {
      reader: string
      requestBody: {
        customer_consent_collected: boolean
        expand?: string[]
        setup_intent: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_reader> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/process_setup_intent`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalReadersReaderRefundPayment(
    p: {
      reader: string
      requestBody?: {
        amount?: number
        charge?: string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        payment_intent?: string
        refund_application_fee?: boolean
        reverse_transfer?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_reader> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/refund_payment`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTerminalReadersReaderSetReaderDisplay(
    p: {
      reader: string
      requestBody: {
        cart?: {
          currency: string
          line_items: {
            amount: number
            description: string
            quantity: number
          }[]
          tax?: number
          total: number
        }
        expand?: string[]
        type: "cart"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_reader> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/set_reader_display`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersCustomersCustomerFundCashBalance(
    p: {
      customer: string
      requestBody: {
        amount: number
        currency: string
        expand?: string[]
        reference?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_customer_cash_balance_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/customers/${p["customer"]}/fund_cash_balance`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingDeliver(
    p: {
      card: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_card> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/deliver`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingFail(
    p: {
      card: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_card> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/fail`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingReturn(
    p: {
      card: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_card> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/return`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingShip(
    p: {
      card: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issuing_card> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/ship`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersRefundsRefundExpire(
    p: {
      refund: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_refund> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/test_helpers/refunds/${p["refund"]}/expire`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTerminalReadersReaderPresentPaymentMethod(
    p: {
      reader: string
      requestBody?: {
        amount_tip?: number
        card_present?: {
          number?: string
        }
        expand?: string[]
        interac_present?: {
          number?: string
        }
        type?: "card_present" | "interac_present"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_terminal_reader> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/terminal/readers/${p["reader"]}/present_payment_method`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTestHelpersTestClocks(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_test_helpers_test_clock[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/test_helpers/test_clocks`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTestClocks(
    p: {
      requestBody: {
        expand?: string[]
        frozen_time: number
        name?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_test_helpers_test_clock> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/test_helpers/test_clocks`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteTestHelpersTestClocksTestClock(
    p: {
      testClock: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_test_helpers_test_clock> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/test_helpers/test_clocks/${p["testClock"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTestHelpersTestClocksTestClock(
    p: {
      expand?: string[]
      testClock: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_test_helpers_test_clock> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/test_helpers/test_clocks/${p["testClock"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTestClocksTestClockAdvance(
    p: {
      testClock: string
      requestBody: {
        expand?: string[]
        frozen_time: number
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_test_helpers_test_clock> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/test_helpers/test_clocks/${p["testClock"]}/advance`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryInboundTransfersIdFail(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
        failure_details?: {
          code?:
            | "account_closed"
            | "account_frozen"
            | "bank_account_restricted"
            | "bank_ownership_changed"
            | "debit_not_authorized"
            | "incorrect_account_holder_address"
            | "incorrect_account_holder_name"
            | "incorrect_account_holder_tax_id"
            | "insufficient_funds"
            | "invalid_account_number"
            | "invalid_currency"
            | "no_account"
            | "other"
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/inbound_transfers/${p["id"]}/fail`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryInboundTransfersIdReturn(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/inbound_transfers/${p["id"]}/return`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryInboundTransfersIdSucceed(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/inbound_transfers/${p["id"]}/succeed`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundPaymentsIdFail(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_payments/${p["id"]}/fail`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundPaymentsIdPost(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_payments/${p["id"]}/post`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundPaymentsIdReturn(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
        returned_details?: {
          code?:
            | "account_closed"
            | "account_frozen"
            | "bank_account_restricted"
            | "bank_ownership_changed"
            | "declined"
            | "incorrect_account_holder_name"
            | "invalid_account_number"
            | "invalid_currency"
            | "no_account"
            | "other"
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_payments/${p["id"]}/return`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundTransfersOutboundTransferFail(
    p: {
      outboundTransfer: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_transfers/${p["outboundTransfer"]}/fail`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundTransfersOutboundTransferPost(
    p: {
      outboundTransfer: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_transfers/${p["outboundTransfer"]}/post`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn(
    p: {
      outboundTransfer: string
      requestBody?: {
        expand?: string[]
        returned_details?: {
          code?:
            | "account_closed"
            | "account_frozen"
            | "bank_account_restricted"
            | "bank_ownership_changed"
            | "declined"
            | "incorrect_account_holder_name"
            | "invalid_account_number"
            | "invalid_currency"
            | "no_account"
            | "other"
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_transfers/${p["outboundTransfer"]}/return`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryReceivedCredits(
    p: {
      requestBody: {
        amount: number
        currency: string
        description?: string
        expand?: string[]
        financial_account: string
        initiating_payment_method_details?: {
          type: "us_bank_account"
          us_bank_account?: {
            account_holder_name?: string
            account_number?: string
            routing_number?: string
          }
        }
        network: "ach" | "us_domestic_wire"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_received_credit> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/test_helpers/treasury/received_credits`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTestHelpersTreasuryReceivedDebits(
    p: {
      requestBody: {
        amount: number
        currency: string
        description?: string
        expand?: string[]
        financial_account: string
        initiating_payment_method_details?: {
          type: "us_bank_account"
          us_bank_account?: {
            account_holder_name?: string
            account_number?: string
            routing_number?: string
          }
        }
        network: "ach"
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_received_debit> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/test_helpers/treasury/received_debits`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTokens(
    p: {
      requestBody?: {
        account?: {
          business_type?:
            | "company"
            | "government_entity"
            | "individual"
            | "non_profit"
          company?: {
            address?: {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
            }
            address_kana?: {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
              town?: string
            }
            address_kanji?: {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
              town?: string
            }
            directors_provided?: boolean
            executives_provided?: boolean
            export_license_id?: string
            export_purpose_code?: string
            name?: string
            name_kana?: string
            name_kanji?: string
            owners_provided?: boolean
            ownership_declaration?: {
              date?: number
              ip?: string
              user_agent?: string
            }
            ownership_declaration_shown_and_signed?: boolean
            phone?: string
            registration_number?: string
            structure?:
              | ""
              | "free_zone_establishment"
              | "free_zone_llc"
              | "government_instrumentality"
              | "governmental_unit"
              | "incorporated_non_profit"
              | "limited_liability_partnership"
              | "llc"
              | "multi_member_llc"
              | "private_company"
              | "private_corporation"
              | "private_partnership"
              | "public_company"
              | "public_corporation"
              | "public_partnership"
              | "single_member_llc"
              | "sole_establishment"
              | "sole_proprietorship"
              | "tax_exempt_government_instrumentality"
              | "unincorporated_association"
              | "unincorporated_non_profit"
            tax_id?: string
            tax_id_registrar?: string
            vat_id?: string
            verification?: {
              document?: {
                back?: string
                front?: string
              }
            }
          }
          individual?: {
            address?: {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
            }
            address_kana?: {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
              town?: string
            }
            address_kanji?: {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
              town?: string
            }
            dob?:
              | {
                  day: number
                  month: number
                  year: number
                }
              | ""
            email?: string
            first_name?: string
            first_name_kana?: string
            first_name_kanji?: string
            full_name_aliases?: string[] | ""
            gender?: string
            id_number?: string
            id_number_secondary?: string
            last_name?: string
            last_name_kana?: string
            last_name_kanji?: string
            maiden_name?: string
            metadata?:
              | {
                  [key: string]: string
                }
              | ""
            phone?: string
            political_exposure?: "existing" | "none"
            registered_address?: {
              city?: string
              country?: string
              line1?: string
              line2?: string
              postal_code?: string
              state?: string
            }
            ssn_last_4?: string
            verification?: {
              additional_document?: {
                back?: string
                front?: string
              }
              document?: {
                back?: string
                front?: string
              }
            }
          }
          tos_shown_and_accepted?: boolean
        }
        bank_account?: {
          account_holder_name?: string
          account_holder_type?: "company" | "individual"
          account_number: string
          account_type?: "checking" | "futsu" | "savings" | "toza"
          country: string
          currency?: string
          routing_number?: string
        }
        card?:
          | {
              address_city?: string
              address_country?: string
              address_line1?: string
              address_line2?: string
              address_state?: string
              address_zip?: string
              currency?: string
              cvc?: string
              exp_month: string
              exp_year: string
              name?: string
              number: string
            }
          | string
        customer?: string
        cvc_update?: {
          cvc: string
        }
        expand?: string[]
        person?: {
          address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          address_kana?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          address_kanji?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
            town?: string
          }
          dob?:
            | {
                day: number
                month: number
                year: number
              }
            | ""
          documents?: {
            company_authorization?: {
              files?: string[]
            }
            passport?: {
              files?: string[]
            }
            visa?: {
              files?: string[]
            }
          }
          email?: string
          first_name?: string
          first_name_kana?: string
          first_name_kanji?: string
          full_name_aliases?: string[] | ""
          gender?: string
          id_number?: string
          id_number_secondary?: string
          last_name?: string
          last_name_kana?: string
          last_name_kanji?: string
          maiden_name?: string
          metadata?:
            | {
                [key: string]: string
              }
            | ""
          nationality?: string
          phone?: string
          political_exposure?: string
          registered_address?: {
            city?: string
            country?: string
            line1?: string
            line2?: string
            postal_code?: string
            state?: string
          }
          relationship?: {
            director?: boolean
            executive?: boolean
            owner?: boolean
            percent_ownership?: number | ""
            representative?: boolean
            title?: string
          }
          ssn_last_4?: string
          verification?: {
            additional_document?: {
              back?: string
              front?: string
            }
            document?: {
              back?: string
              front?: string
            }
          }
        }
        pii?: {
          id_number?: string
        }
      }
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_token> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/tokens`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTokensToken(
    p: {
      expand?: string[]
      token: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_token> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/tokens/${p["token"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTopups(
    p: {
      amount?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "canceled" | "failed" | "pending" | "succeeded"
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_topup[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/topups`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      amount: p["amount"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTopups(
    p: {
      requestBody: {
        amount: number
        currency: string
        description?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        source?: string
        statement_descriptor?: string
        transfer_group?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_topup> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/topups`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTopupsTopup(
    p: {
      expand?: string[]
      topup: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_topup> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/topups/${p["topup"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTopupsTopup(
    p: {
      topup: string
      requestBody?: {
        description?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_topup> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/topups/${p["topup"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTopupsTopupCancel(
    p: {
      topup: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_topup> | Res<StatusCode, t_error>>> {
    const url = this.basePath + `/v1/topups/${p["topup"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTransfers(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      destination?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      transferGroup?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_transfer[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/transfers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      destination: p["destination"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      transfer_group: p["transferGroup"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTransfers(
    p: {
      requestBody: {
        amount?: number
        currency: string
        description?: string
        destination: string
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        source_transaction?: string
        source_type?: "bank_account" | "card" | "fpx"
        transfer_group?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_transfer> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/transfers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTransfersIdReversals(
    p: {
      endingBefore?: string
      expand?: string[]
      id: string
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_transfer_reversal[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/transfers/${p["id"]}/reversals`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTransfersIdReversals(
    p: {
      id: string
      requestBody?: {
        amount?: number
        description?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        refund_application_fee?: boolean
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_transfer_reversal> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/transfers/${p["id"]}/reversals`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTransfersTransfer(
    p: {
      expand?: string[]
      transfer: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_transfer> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/transfers/${p["transfer"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTransfersTransfer(
    p: {
      transfer: string
      requestBody?: {
        description?: string
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_transfer> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/transfers/${p["transfer"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTransfersTransferReversalsId(
    p: {
      expand?: string[]
      id: string
      transfer: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_transfer_reversal> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/transfers/${p["transfer"]}/reversals/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTransfersTransferReversalsId(
    p: {
      id: string
      transfer: string
      requestBody?: {
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_transfer_reversal> | Res<StatusCode, t_error>>
  > {
    const url =
      this.basePath + `/v1/transfers/${p["transfer"]}/reversals/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryCreditReversals(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      receivedCredit?: string
      startingAfter?: string
      status?: "canceled" | "posted" | "processing"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_credit_reversal[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/credit_reversals`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      received_credit: p["receivedCredit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryCreditReversals(
    p: {
      requestBody: {
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        received_credit: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_credit_reversal> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/credit_reversals`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryCreditReversalsCreditReversal(
    p: {
      creditReversal: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_credit_reversal> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/treasury/credit_reversals/${p["creditReversal"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryDebitReversals(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      receivedDebit?: string
      resolution?: "lost" | "won"
      startingAfter?: string
      status?: "canceled" | "completed" | "processing"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_debit_reversal[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/debit_reversals`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      received_debit: p["receivedDebit"],
      resolution: p["resolution"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryDebitReversals(
    p: {
      requestBody: {
        expand?: string[]
        metadata?: {
          [key: string]: string
        }
        received_debit: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_debit_reversal> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/debit_reversals`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryDebitReversalsDebitReversal(
    p: {
      debitReversal: string
      expand?: string[]
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_debit_reversal> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/treasury/debit_reversals/${p["debitReversal"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryFinancialAccounts(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_financial_account[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/financial_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryFinancialAccounts(
    p: {
      requestBody: {
        expand?: string[]
        features?: {
          card_issuing?: {
            requested: boolean
          }
          deposit_insurance?: {
            requested: boolean
          }
          financial_addresses?: {
            aba?: {
              requested: boolean
            }
          }
          inbound_transfers?: {
            ach?: {
              requested: boolean
            }
          }
          intra_stripe_flows?: {
            requested: boolean
          }
          outbound_payments?: {
            ach?: {
              requested: boolean
            }
            us_domestic_wire?: {
              requested: boolean
            }
          }
          outbound_transfers?: {
            ach?: {
              requested: boolean
            }
            us_domestic_wire?: {
              requested: boolean
            }
          }
        }
        metadata?: {
          [key: string]: string
        }
        platform_restrictions?: {
          inbound_flows?: "restricted" | "unrestricted"
          outbound_flows?: "restricted" | "unrestricted"
        }
        supported_currencies: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_financial_account> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/financial_accounts`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryFinancialAccountsFinancialAccount(
    p: {
      expand?: string[]
      financialAccount: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_financial_account> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/treasury/financial_accounts/${p["financialAccount"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryFinancialAccountsFinancialAccount(
    p: {
      financialAccount: string
      requestBody?: {
        expand?: string[]
        features?: {
          card_issuing?: {
            requested: boolean
          }
          deposit_insurance?: {
            requested: boolean
          }
          financial_addresses?: {
            aba?: {
              requested: boolean
            }
          }
          inbound_transfers?: {
            ach?: {
              requested: boolean
            }
          }
          intra_stripe_flows?: {
            requested: boolean
          }
          outbound_payments?: {
            ach?: {
              requested: boolean
            }
            us_domestic_wire?: {
              requested: boolean
            }
          }
          outbound_transfers?: {
            ach?: {
              requested: boolean
            }
            us_domestic_wire?: {
              requested: boolean
            }
          }
        }
        metadata?: {
          [key: string]: string
        }
        platform_restrictions?: {
          inbound_flows?: "restricted" | "unrestricted"
          outbound_flows?: "restricted" | "unrestricted"
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_financial_account> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/treasury/financial_accounts/${p["financialAccount"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryFinancialAccountsFinancialAccountFeatures(
    p: {
      expand?: string[]
      financialAccount: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_financial_account_features> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/treasury/financial_accounts/${p["financialAccount"]}/features`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryFinancialAccountsFinancialAccountFeatures(
    p: {
      financialAccount: string
      requestBody?: {
        card_issuing?: {
          requested: boolean
        }
        deposit_insurance?: {
          requested: boolean
        }
        expand?: string[]
        financial_addresses?: {
          aba?: {
            requested: boolean
          }
        }
        inbound_transfers?: {
          ach?: {
            requested: boolean
          }
        }
        intra_stripe_flows?: {
          requested: boolean
        }
        outbound_payments?: {
          ach?: {
            requested: boolean
          }
          us_domestic_wire?: {
            requested: boolean
          }
        }
        outbound_transfers?: {
          ach?: {
            requested: boolean
          }
          us_domestic_wire?: {
            requested: boolean
          }
        }
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_financial_account_features> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/treasury/financial_accounts/${p["financialAccount"]}/features`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryInboundTransfers(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?: "canceled" | "failed" | "processing" | "succeeded"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_inbound_transfer[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/inbound_transfers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryInboundTransfers(
    p: {
      requestBody: {
        amount: number
        currency: string
        description?: string
        expand?: string[]
        financial_account: string
        metadata?: {
          [key: string]: string
        }
        origin_payment_method: string
        statement_descriptor?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/inbound_transfers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryInboundTransfersId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/inbound_transfers/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryInboundTransfersInboundTransferCancel(
    p: {
      inboundTransfer: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/treasury/inbound_transfers/${p["inboundTransfer"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryOutboundPayments(
    p: {
      customer?: string
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?: "canceled" | "failed" | "posted" | "processing" | "returned"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_outbound_payment[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/outbound_payments`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryOutboundPayments(
    p: {
      requestBody: {
        amount: number
        currency: string
        customer?: string
        description?: string
        destination_payment_method?: string
        destination_payment_method_data?: {
          billing_details?: {
            address?:
              | {
                  city?: string
                  country?: string
                  line1?: string
                  line2?: string
                  postal_code?: string
                  state?: string
                }
              | ""
            email?: string | ""
            name?: string
            phone?: string
          }
          financial_account?: string
          metadata?: {
            [key: string]: string
          }
          type: "financial_account" | "us_bank_account"
          us_bank_account?: {
            account_holder_type?: "company" | "individual"
            account_number?: string
            account_type?: "checking" | "savings"
            financial_connections_account?: string
            routing_number?: string
          }
        }
        destination_payment_method_options?: {
          us_bank_account?:
            | {
                network?: "ach" | "us_domestic_wire"
              }
            | ""
        }
        end_user_details?: {
          ip_address?: string
          present: boolean
        }
        expand?: string[]
        financial_account: string
        metadata?: {
          [key: string]: string
        }
        statement_descriptor?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/outbound_payments`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryOutboundPaymentsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/outbound_payments/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryOutboundPaymentsIdCancel(
    p: {
      id: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/treasury/outbound_payments/${p["id"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryOutboundTransfers(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?: "canceled" | "failed" | "posted" | "processing" | "returned"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_outbound_transfer[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/outbound_transfers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryOutboundTransfers(
    p: {
      requestBody: {
        amount: number
        currency: string
        description?: string
        destination_payment_method?: string
        destination_payment_method_options?: {
          us_bank_account?:
            | {
                network?: "ach" | "us_domestic_wire"
              }
            | ""
        }
        expand?: string[]
        financial_account: string
        metadata?: {
          [key: string]: string
        }
        statement_descriptor?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/outbound_transfers`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryOutboundTransfersOutboundTransfer(
    p: {
      expand?: string[]
      outboundTransfer: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath + `/v1/treasury/outbound_transfers/${p["outboundTransfer"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postTreasuryOutboundTransfersOutboundTransferCancel(
    p: {
      outboundTransfer: string
      requestBody?: {
        expand?: string[]
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
    >
  > {
    const url =
      this.basePath +
      `/v1/treasury/outbound_transfers/${p["outboundTransfer"]}/cancel`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryReceivedCredits(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      linkedFlows?: {
        source_flow_type:
          | "credit_reversal"
          | "other"
          | "outbound_payment"
          | "payout"
      }
      startingAfter?: string
      status?: "failed" | "succeeded"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_received_credit[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/received_credits`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      linked_flows: p["linkedFlows"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryReceivedCreditsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_received_credit> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/received_credits/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryReceivedDebits(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?: "failed" | "succeeded"
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_received_debit[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/received_debits`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryReceivedDebitsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_received_debit> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/received_debits/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryTransactionEntries(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      effectiveAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      orderBy?: "created" | "effective_at"
      startingAfter?: string
      transaction?: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_transaction_entry[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/transaction_entries`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      effective_at: p["effectiveAt"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      order_by: p["orderBy"],
      starting_after: p["startingAfter"],
      transaction: p["transaction"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryTransactionEntriesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_transaction_entry> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/transaction_entries/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryTransactions(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      orderBy?: "created" | "posted_at"
      startingAfter?: string
      status?: "open" | "posted" | "void"
      statusTransitions?: {
        posted_at?:
          | {
              gt?: number
              gte?: number
              lt?: number
              lte?: number
            }
          | number
      }
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_treasury_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/transactions`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      order_by: p["orderBy"],
      starting_after: p["startingAfter"],
      status: p["status"],
      status_transitions: p["statusTransitions"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getTreasuryTransactionsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_treasury_transaction> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/treasury/transactions/${p["id"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getWebhookEndpoints(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: EmptyObject
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            data: t_webhook_endpoint[]
            has_more: boolean
            object: "list"
            url: string
          }
        >
      | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/webhook_endpoints`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postWebhookEndpoints(
    p: {
      requestBody: {
        api_version?:
          | "2011-01-01"
          | "2011-06-21"
          | "2011-06-28"
          | "2011-08-01"
          | "2011-09-15"
          | "2011-11-17"
          | "2012-02-23"
          | "2012-03-25"
          | "2012-06-18"
          | "2012-06-28"
          | "2012-07-09"
          | "2012-09-24"
          | "2012-10-26"
          | "2012-11-07"
          | "2013-02-11"
          | "2013-02-13"
          | "2013-07-05"
          | "2013-08-12"
          | "2013-08-13"
          | "2013-10-29"
          | "2013-12-03"
          | "2014-01-31"
          | "2014-03-13"
          | "2014-03-28"
          | "2014-05-19"
          | "2014-06-13"
          | "2014-06-17"
          | "2014-07-22"
          | "2014-07-26"
          | "2014-08-04"
          | "2014-08-20"
          | "2014-09-08"
          | "2014-10-07"
          | "2014-11-05"
          | "2014-11-20"
          | "2014-12-08"
          | "2014-12-17"
          | "2014-12-22"
          | "2015-01-11"
          | "2015-01-26"
          | "2015-02-10"
          | "2015-02-16"
          | "2015-02-18"
          | "2015-03-24"
          | "2015-04-07"
          | "2015-06-15"
          | "2015-07-07"
          | "2015-07-13"
          | "2015-07-28"
          | "2015-08-07"
          | "2015-08-19"
          | "2015-09-03"
          | "2015-09-08"
          | "2015-09-23"
          | "2015-10-01"
          | "2015-10-12"
          | "2015-10-16"
          | "2016-02-03"
          | "2016-02-19"
          | "2016-02-22"
          | "2016-02-23"
          | "2016-02-29"
          | "2016-03-07"
          | "2016-06-15"
          | "2016-07-06"
          | "2016-10-19"
          | "2017-01-27"
          | "2017-02-14"
          | "2017-04-06"
          | "2017-05-25"
          | "2017-06-05"
          | "2017-08-15"
          | "2017-12-14"
          | "2018-01-23"
          | "2018-02-05"
          | "2018-02-06"
          | "2018-02-28"
          | "2018-05-21"
          | "2018-07-27"
          | "2018-08-23"
          | "2018-09-06"
          | "2018-09-24"
          | "2018-10-31"
          | "2018-11-08"
          | "2019-02-11"
          | "2019-02-19"
          | "2019-03-14"
          | "2019-05-16"
          | "2019-08-14"
          | "2019-09-09"
          | "2019-10-08"
          | "2019-10-17"
          | "2019-11-05"
          | "2019-12-03"
          | "2020-03-02"
          | "2020-08-27"
          | "2022-08-01"
          | "2022-11-15"
        connect?: boolean
        description?: string
        enabled_events: (
          | "*"
          | "account.application.authorized"
          | "account.application.deauthorized"
          | "account.external_account.created"
          | "account.external_account.deleted"
          | "account.external_account.updated"
          | "account.updated"
          | "application_fee.created"
          | "application_fee.refund.updated"
          | "application_fee.refunded"
          | "balance.available"
          | "billing_portal.configuration.created"
          | "billing_portal.configuration.updated"
          | "billing_portal.session.created"
          | "capability.updated"
          | "cash_balance.funds_available"
          | "charge.captured"
          | "charge.dispute.closed"
          | "charge.dispute.created"
          | "charge.dispute.funds_reinstated"
          | "charge.dispute.funds_withdrawn"
          | "charge.dispute.updated"
          | "charge.expired"
          | "charge.failed"
          | "charge.pending"
          | "charge.refund.updated"
          | "charge.refunded"
          | "charge.succeeded"
          | "charge.updated"
          | "checkout.session.async_payment_failed"
          | "checkout.session.async_payment_succeeded"
          | "checkout.session.completed"
          | "checkout.session.expired"
          | "coupon.created"
          | "coupon.deleted"
          | "coupon.updated"
          | "credit_note.created"
          | "credit_note.updated"
          | "credit_note.voided"
          | "customer.created"
          | "customer.deleted"
          | "customer.discount.created"
          | "customer.discount.deleted"
          | "customer.discount.updated"
          | "customer.source.created"
          | "customer.source.deleted"
          | "customer.source.expiring"
          | "customer.source.updated"
          | "customer.subscription.created"
          | "customer.subscription.deleted"
          | "customer.subscription.paused"
          | "customer.subscription.pending_update_applied"
          | "customer.subscription.pending_update_expired"
          | "customer.subscription.resumed"
          | "customer.subscription.trial_will_end"
          | "customer.subscription.updated"
          | "customer.tax_id.created"
          | "customer.tax_id.deleted"
          | "customer.tax_id.updated"
          | "customer.updated"
          | "customer_cash_balance_transaction.created"
          | "file.created"
          | "financial_connections.account.created"
          | "financial_connections.account.deactivated"
          | "financial_connections.account.disconnected"
          | "financial_connections.account.reactivated"
          | "financial_connections.account.refreshed_balance"
          | "identity.verification_session.canceled"
          | "identity.verification_session.created"
          | "identity.verification_session.processing"
          | "identity.verification_session.redacted"
          | "identity.verification_session.requires_input"
          | "identity.verification_session.verified"
          | "invoice.created"
          | "invoice.deleted"
          | "invoice.finalization_failed"
          | "invoice.finalized"
          | "invoice.marked_uncollectible"
          | "invoice.paid"
          | "invoice.payment_action_required"
          | "invoice.payment_failed"
          | "invoice.payment_succeeded"
          | "invoice.sent"
          | "invoice.upcoming"
          | "invoice.updated"
          | "invoice.voided"
          | "invoiceitem.created"
          | "invoiceitem.deleted"
          | "invoiceitem.updated"
          | "issuing_authorization.created"
          | "issuing_authorization.request"
          | "issuing_authorization.updated"
          | "issuing_card.created"
          | "issuing_card.updated"
          | "issuing_cardholder.created"
          | "issuing_cardholder.updated"
          | "issuing_dispute.closed"
          | "issuing_dispute.created"
          | "issuing_dispute.funds_reinstated"
          | "issuing_dispute.submitted"
          | "issuing_dispute.updated"
          | "issuing_transaction.created"
          | "issuing_transaction.updated"
          | "mandate.updated"
          | "order.created"
          | "payment_intent.amount_capturable_updated"
          | "payment_intent.canceled"
          | "payment_intent.created"
          | "payment_intent.partially_funded"
          | "payment_intent.payment_failed"
          | "payment_intent.processing"
          | "payment_intent.requires_action"
          | "payment_intent.succeeded"
          | "payment_link.created"
          | "payment_link.updated"
          | "payment_method.attached"
          | "payment_method.automatically_updated"
          | "payment_method.detached"
          | "payment_method.updated"
          | "payout.canceled"
          | "payout.created"
          | "payout.failed"
          | "payout.paid"
          | "payout.reconciliation_completed"
          | "payout.updated"
          | "person.created"
          | "person.deleted"
          | "person.updated"
          | "plan.created"
          | "plan.deleted"
          | "plan.updated"
          | "price.created"
          | "price.deleted"
          | "price.updated"
          | "product.created"
          | "product.deleted"
          | "product.updated"
          | "promotion_code.created"
          | "promotion_code.updated"
          | "quote.accepted"
          | "quote.canceled"
          | "quote.created"
          | "quote.finalized"
          | "radar.early_fraud_warning.created"
          | "radar.early_fraud_warning.updated"
          | "recipient.created"
          | "recipient.deleted"
          | "recipient.updated"
          | "refund.created"
          | "refund.updated"
          | "reporting.report_run.failed"
          | "reporting.report_run.succeeded"
          | "reporting.report_type.updated"
          | "review.closed"
          | "review.opened"
          | "setup_intent.canceled"
          | "setup_intent.created"
          | "setup_intent.requires_action"
          | "setup_intent.setup_failed"
          | "setup_intent.succeeded"
          | "sigma.scheduled_query_run.created"
          | "sku.created"
          | "sku.deleted"
          | "sku.updated"
          | "source.canceled"
          | "source.chargeable"
          | "source.failed"
          | "source.mandate_notification"
          | "source.refund_attributes_required"
          | "source.transaction.created"
          | "source.transaction.updated"
          | "subscription_schedule.aborted"
          | "subscription_schedule.canceled"
          | "subscription_schedule.completed"
          | "subscription_schedule.created"
          | "subscription_schedule.expiring"
          | "subscription_schedule.released"
          | "subscription_schedule.updated"
          | "tax_rate.created"
          | "tax_rate.updated"
          | "terminal.reader.action_failed"
          | "terminal.reader.action_succeeded"
          | "test_helpers.test_clock.advancing"
          | "test_helpers.test_clock.created"
          | "test_helpers.test_clock.deleted"
          | "test_helpers.test_clock.internal_failure"
          | "test_helpers.test_clock.ready"
          | "topup.canceled"
          | "topup.created"
          | "topup.failed"
          | "topup.reversed"
          | "topup.succeeded"
          | "transfer.created"
          | "transfer.reversed"
          | "transfer.updated"
          | "treasury.credit_reversal.created"
          | "treasury.credit_reversal.posted"
          | "treasury.debit_reversal.completed"
          | "treasury.debit_reversal.created"
          | "treasury.debit_reversal.initial_credit_granted"
          | "treasury.financial_account.closed"
          | "treasury.financial_account.created"
          | "treasury.financial_account.features_status_updated"
          | "treasury.inbound_transfer.canceled"
          | "treasury.inbound_transfer.created"
          | "treasury.inbound_transfer.failed"
          | "treasury.inbound_transfer.succeeded"
          | "treasury.outbound_payment.canceled"
          | "treasury.outbound_payment.created"
          | "treasury.outbound_payment.expected_arrival_date_updated"
          | "treasury.outbound_payment.failed"
          | "treasury.outbound_payment.posted"
          | "treasury.outbound_payment.returned"
          | "treasury.outbound_transfer.canceled"
          | "treasury.outbound_transfer.created"
          | "treasury.outbound_transfer.expected_arrival_date_updated"
          | "treasury.outbound_transfer.failed"
          | "treasury.outbound_transfer.posted"
          | "treasury.outbound_transfer.returned"
          | "treasury.received_credit.created"
          | "treasury.received_credit.failed"
          | "treasury.received_credit.succeeded"
          | "treasury.received_debit.created"
        )[]
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        url: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_webhook_endpoint> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/webhook_endpoints`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteWebhookEndpointsWebhookEndpoint(
    p: {
      webhookEndpoint: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deleted_webhook_endpoint> | Res<StatusCode, t_error>
    >
  > {
    const url = this.basePath + `/v1/webhook_endpoints/${p["webhookEndpoint"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "DELETE", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getWebhookEndpointsWebhookEndpoint(
    p: {
      expand?: string[]
      webhookEndpoint: string
      requestBody?: EmptyObject
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_webhook_endpoint> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/webhook_endpoints/${p["webhookEndpoint"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const query = this._query({ expand: p["expand"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "GET", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async postWebhookEndpointsWebhookEndpoint(
    p: {
      webhookEndpoint: string
      requestBody?: {
        description?: string
        disabled?: boolean
        enabled_events?: (
          | "*"
          | "account.application.authorized"
          | "account.application.deauthorized"
          | "account.external_account.created"
          | "account.external_account.deleted"
          | "account.external_account.updated"
          | "account.updated"
          | "application_fee.created"
          | "application_fee.refund.updated"
          | "application_fee.refunded"
          | "balance.available"
          | "billing_portal.configuration.created"
          | "billing_portal.configuration.updated"
          | "billing_portal.session.created"
          | "capability.updated"
          | "cash_balance.funds_available"
          | "charge.captured"
          | "charge.dispute.closed"
          | "charge.dispute.created"
          | "charge.dispute.funds_reinstated"
          | "charge.dispute.funds_withdrawn"
          | "charge.dispute.updated"
          | "charge.expired"
          | "charge.failed"
          | "charge.pending"
          | "charge.refund.updated"
          | "charge.refunded"
          | "charge.succeeded"
          | "charge.updated"
          | "checkout.session.async_payment_failed"
          | "checkout.session.async_payment_succeeded"
          | "checkout.session.completed"
          | "checkout.session.expired"
          | "coupon.created"
          | "coupon.deleted"
          | "coupon.updated"
          | "credit_note.created"
          | "credit_note.updated"
          | "credit_note.voided"
          | "customer.created"
          | "customer.deleted"
          | "customer.discount.created"
          | "customer.discount.deleted"
          | "customer.discount.updated"
          | "customer.source.created"
          | "customer.source.deleted"
          | "customer.source.expiring"
          | "customer.source.updated"
          | "customer.subscription.created"
          | "customer.subscription.deleted"
          | "customer.subscription.paused"
          | "customer.subscription.pending_update_applied"
          | "customer.subscription.pending_update_expired"
          | "customer.subscription.resumed"
          | "customer.subscription.trial_will_end"
          | "customer.subscription.updated"
          | "customer.tax_id.created"
          | "customer.tax_id.deleted"
          | "customer.tax_id.updated"
          | "customer.updated"
          | "customer_cash_balance_transaction.created"
          | "file.created"
          | "financial_connections.account.created"
          | "financial_connections.account.deactivated"
          | "financial_connections.account.disconnected"
          | "financial_connections.account.reactivated"
          | "financial_connections.account.refreshed_balance"
          | "identity.verification_session.canceled"
          | "identity.verification_session.created"
          | "identity.verification_session.processing"
          | "identity.verification_session.redacted"
          | "identity.verification_session.requires_input"
          | "identity.verification_session.verified"
          | "invoice.created"
          | "invoice.deleted"
          | "invoice.finalization_failed"
          | "invoice.finalized"
          | "invoice.marked_uncollectible"
          | "invoice.paid"
          | "invoice.payment_action_required"
          | "invoice.payment_failed"
          | "invoice.payment_succeeded"
          | "invoice.sent"
          | "invoice.upcoming"
          | "invoice.updated"
          | "invoice.voided"
          | "invoiceitem.created"
          | "invoiceitem.deleted"
          | "invoiceitem.updated"
          | "issuing_authorization.created"
          | "issuing_authorization.request"
          | "issuing_authorization.updated"
          | "issuing_card.created"
          | "issuing_card.updated"
          | "issuing_cardholder.created"
          | "issuing_cardholder.updated"
          | "issuing_dispute.closed"
          | "issuing_dispute.created"
          | "issuing_dispute.funds_reinstated"
          | "issuing_dispute.submitted"
          | "issuing_dispute.updated"
          | "issuing_transaction.created"
          | "issuing_transaction.updated"
          | "mandate.updated"
          | "order.created"
          | "payment_intent.amount_capturable_updated"
          | "payment_intent.canceled"
          | "payment_intent.created"
          | "payment_intent.partially_funded"
          | "payment_intent.payment_failed"
          | "payment_intent.processing"
          | "payment_intent.requires_action"
          | "payment_intent.succeeded"
          | "payment_link.created"
          | "payment_link.updated"
          | "payment_method.attached"
          | "payment_method.automatically_updated"
          | "payment_method.detached"
          | "payment_method.updated"
          | "payout.canceled"
          | "payout.created"
          | "payout.failed"
          | "payout.paid"
          | "payout.reconciliation_completed"
          | "payout.updated"
          | "person.created"
          | "person.deleted"
          | "person.updated"
          | "plan.created"
          | "plan.deleted"
          | "plan.updated"
          | "price.created"
          | "price.deleted"
          | "price.updated"
          | "product.created"
          | "product.deleted"
          | "product.updated"
          | "promotion_code.created"
          | "promotion_code.updated"
          | "quote.accepted"
          | "quote.canceled"
          | "quote.created"
          | "quote.finalized"
          | "radar.early_fraud_warning.created"
          | "radar.early_fraud_warning.updated"
          | "recipient.created"
          | "recipient.deleted"
          | "recipient.updated"
          | "refund.created"
          | "refund.updated"
          | "reporting.report_run.failed"
          | "reporting.report_run.succeeded"
          | "reporting.report_type.updated"
          | "review.closed"
          | "review.opened"
          | "setup_intent.canceled"
          | "setup_intent.created"
          | "setup_intent.requires_action"
          | "setup_intent.setup_failed"
          | "setup_intent.succeeded"
          | "sigma.scheduled_query_run.created"
          | "sku.created"
          | "sku.deleted"
          | "sku.updated"
          | "source.canceled"
          | "source.chargeable"
          | "source.failed"
          | "source.mandate_notification"
          | "source.refund_attributes_required"
          | "source.transaction.created"
          | "source.transaction.updated"
          | "subscription_schedule.aborted"
          | "subscription_schedule.canceled"
          | "subscription_schedule.completed"
          | "subscription_schedule.created"
          | "subscription_schedule.expiring"
          | "subscription_schedule.released"
          | "subscription_schedule.updated"
          | "tax_rate.created"
          | "tax_rate.updated"
          | "terminal.reader.action_failed"
          | "terminal.reader.action_succeeded"
          | "test_helpers.test_clock.advancing"
          | "test_helpers.test_clock.created"
          | "test_helpers.test_clock.deleted"
          | "test_helpers.test_clock.internal_failure"
          | "test_helpers.test_clock.ready"
          | "topup.canceled"
          | "topup.created"
          | "topup.failed"
          | "topup.reversed"
          | "topup.succeeded"
          | "transfer.created"
          | "transfer.reversed"
          | "transfer.updated"
          | "treasury.credit_reversal.created"
          | "treasury.credit_reversal.posted"
          | "treasury.debit_reversal.completed"
          | "treasury.debit_reversal.created"
          | "treasury.debit_reversal.initial_credit_granted"
          | "treasury.financial_account.closed"
          | "treasury.financial_account.created"
          | "treasury.financial_account.features_status_updated"
          | "treasury.inbound_transfer.canceled"
          | "treasury.inbound_transfer.created"
          | "treasury.inbound_transfer.failed"
          | "treasury.inbound_transfer.succeeded"
          | "treasury.outbound_payment.canceled"
          | "treasury.outbound_payment.created"
          | "treasury.outbound_payment.expected_arrival_date_updated"
          | "treasury.outbound_payment.failed"
          | "treasury.outbound_payment.posted"
          | "treasury.outbound_payment.returned"
          | "treasury.outbound_transfer.canceled"
          | "treasury.outbound_transfer.created"
          | "treasury.outbound_transfer.expected_arrival_date_updated"
          | "treasury.outbound_transfer.failed"
          | "treasury.outbound_transfer.posted"
          | "treasury.outbound_transfer.returned"
          | "treasury.received_credit.created"
          | "treasury.received_credit.failed"
          | "treasury.received_credit.succeeded"
          | "treasury.received_debit.created"
        )[]
        expand?: string[]
        metadata?:
          | {
              [key: string]: string
            }
          | ""
        url?: string
      }
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_webhook_endpoint> | Res<StatusCode, t_error>>
  > {
    const url = this.basePath + `/v1/webhook_endpoints/${p["webhookEndpoint"]}`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }
}
