/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint:disable */

import {
  t_actions_billing_usage,
  t_actions_cache_list,
  t_actions_cache_usage_by_repository,
  t_actions_cache_usage_org_enterprise,
  t_actions_enabled,
  t_actions_get_default_workflow_permissions,
  t_actions_organization_permissions,
  t_actions_public_key,
  t_actions_repository_permissions,
  t_actions_secret,
  t_actions_set_default_workflow_permissions,
  t_actions_variable,
  t_actions_workflow_access_to_repository,
  t_alert_number,
  t_allowed_actions,
  t_api_overview,
  t_app_permissions,
  t_artifact,
  t_authentication_token,
  t_authorization,
  t_autolink,
  t_base_gist,
  t_basic_error,
  t_blob,
  t_branch_protection,
  t_branch_restriction_policy,
  t_branch_short,
  t_branch_with_protection,
  t_check_annotation,
  t_check_run,
  t_check_suite,
  t_check_suite_preference,
  t_clone_traffic,
  t_code_frequency_stat,
  t_code_of_conduct,
  t_code_scanning_alert,
  t_code_scanning_alert_dismissed_comment,
  t_code_scanning_alert_dismissed_reason,
  t_code_scanning_alert_instance,
  t_code_scanning_alert_items,
  t_code_scanning_alert_set_state,
  t_code_scanning_alert_severity,
  t_code_scanning_alert_state,
  t_code_scanning_analysis,
  t_code_scanning_analysis_commit_sha,
  t_code_scanning_analysis_deletion,
  t_code_scanning_analysis_sarif_file,
  t_code_scanning_analysis_sarif_id,
  t_code_scanning_analysis_tool_guid,
  t_code_scanning_analysis_tool_name,
  t_code_scanning_codeql_database,
  t_code_scanning_organization_alert_items,
  t_code_scanning_ref,
  t_code_scanning_sarifs_receipt,
  t_code_scanning_sarifs_status,
  t_code_search_result_item,
  t_codeowners_errors,
  t_codespace,
  t_codespace_export_details,
  t_codespace_machine,
  t_codespace_with_full_repository,
  t_codespaces_org_secret,
  t_codespaces_public_key,
  t_codespaces_secret,
  t_codespaces_user_public_key,
  t_collaborator,
  t_combined_billing_usage,
  t_combined_commit_status,
  t_commit,
  t_commit_activity,
  t_commit_comment,
  t_commit_comparison,
  t_commit_search_result_item,
  t_community_profile,
  t_content_file,
  t_content_traffic,
  t_contributor,
  t_contributor_activity,
  t_dependabot_alert,
  t_dependabot_alert_with_repository,
  t_dependabot_public_key,
  t_dependabot_secret,
  t_dependency_graph_diff,
  t_deploy_key,
  t_deployment,
  t_deployment_branch_policy,
  t_deployment_branch_policy_name_pattern,
  t_deployment_branch_policy_settings,
  t_deployment_reviewer_type,
  t_deployment_status,
  t_diff_entry,
  t_email,
  t_empty_object,
  t_enabled_repositories,
  t_enterprise_security_analysis_settings,
  t_environment,
  t_environment_approvals,
  t_event,
  t_feed,
  t_file_commit,
  t_full_repository,
  t_gist_comment,
  t_gist_commit,
  t_gist_simple,
  t_git_commit,
  t_git_ref,
  t_git_tag,
  t_git_tree,
  t_gitignore_template,
  t_gpg_key,
  t_hook,
  t_hook_delivery,
  t_hook_delivery_item,
  t_hovercard,
  t_import,
  t_installation,
  t_installation_token,
  t_integration,
  t_interaction_limit,
  t_interaction_limit_response,
  t_issue,
  t_issue_comment,
  t_issue_event,
  t_issue_event_for_issue,
  t_issue_search_result_item,
  t_job,
  t_key,
  t_key_simple,
  t_label,
  t_label_search_result_item,
  t_language,
  t_license,
  t_license_content,
  t_license_simple,
  t_marketplace_listing_plan,
  t_marketplace_purchase,
  t_merged_upstream,
  t_migration,
  t_milestone,
  t_minimal_repository,
  t_oidc_custom_sub,
  t_oidc_custom_sub_repo,
  t_org_hook,
  t_org_membership,
  t_organization_actions_secret,
  t_organization_actions_variable,
  t_organization_dependabot_secret,
  t_organization_full,
  t_organization_invitation,
  t_organization_secret_scanning_alert,
  t_organization_simple,
  t_package,
  t_package_version,
  t_packages_billing_usage,
  t_page,
  t_page_build,
  t_page_build_status,
  t_page_deployment,
  t_pages_health_check,
  t_participation_stats,
  t_pending_deployment,
  t_porter_author,
  t_porter_large_file,
  t_private_user,
  t_project,
  t_project_card,
  t_project_collaborator_permission,
  t_project_column,
  t_protected_branch,
  t_protected_branch_admin_enforced,
  t_protected_branch_pull_request_review,
  t_pull_request,
  t_pull_request_merge_result,
  t_pull_request_review,
  t_pull_request_review_comment,
  t_pull_request_review_request,
  t_pull_request_simple,
  t_rate_limit_overview,
  t_reaction,
  t_referrer_traffic,
  t_release,
  t_release_asset,
  t_release_notes_content,
  t_repo_codespaces_secret,
  t_repo_required_workflow,
  t_repo_search_result_item,
  t_repository,
  t_repository_collaborator_permission,
  t_repository_invitation,
  t_repository_subscription,
  t_required_workflow,
  t_review_comment,
  t_root,
  t_runner,
  t_runner_application,
  t_runner_groups_enterprise,
  t_runner_groups_org,
  t_runner_label,
  t_scim_error,
  t_secret_scanning_alert,
  t_secret_scanning_alert_resolution,
  t_secret_scanning_alert_resolution_comment,
  t_secret_scanning_alert_state,
  t_secret_scanning_location,
  t_selected_actions,
  t_short_blob,
  t_short_branch,
  t_simple_user,
  t_snapshot,
  t_ssh_signing_key,
  t_starred_repository,
  t_status,
  t_status_check_policy,
  t_tag,
  t_tag_protection,
  t_team,
  t_team_discussion,
  t_team_discussion_comment,
  t_team_full,
  t_team_membership,
  t_team_project,
  t_team_repository,
  t_team_simple,
  t_thread,
  t_thread_subscription,
  t_timeline_issue_events,
  t_topic,
  t_topic_search_result_item,
  t_user_marketplace_purchase,
  t_user_search_result_item,
  t_validation_error,
  t_validation_error_simple,
  t_view_traffic,
  t_wait_timer,
  t_webhook_config,
  t_webhook_config_content_type,
  t_webhook_config_insecure_ssl,
  t_webhook_config_secret,
  t_webhook_config_url,
  t_workflow,
  t_workflow_run,
  t_workflow_run_usage,
  t_workflow_usage,
} from "./models"
import qs from "querystring"

export interface ApiClientConfig {
  basePath: string
  defaultHeaders: Record<string, string>
}

export interface Res<StatusCode, Body> {
  status: StatusCode
  body: Body
}

export class ApiClient {
  constructor(private readonly config: ApiClientConfig) {}

  private _query(
    params: Record<
      string,
      string | number | boolean | string[] | undefined | null
    >
  ): string {
    const filtered = Object.fromEntries(
      Object.entries(params).filter(([k, v]) => v !== undefined)
    )

    return qs.stringify(filtered)
  }

  private _headers(
    headers: Record<string, string | undefined>
  ): Record<string, string> {
    return Object.fromEntries(
      Object.entries({ ...this.config.defaultHeaders, ...headers }).filter(
        (it): it is [string, string] => it[1] !== undefined
      )
    )
  }

  async metaRoot(): Promise<Res<200, t_root>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetAuthenticated(): Promise<Res<200, t_integration>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/app`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCreateFromManifest(p: { code: string }): Promise<
    | Res<
        201,
        t_integration & {
          client_id: string
          client_secret: string
          pem: string
          webhook_secret: string | null
          [key: string]: unknown
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/app-manifests/${p["code"]}/conversions`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetWebhookConfigForApp(): Promise<Res<200, t_webhook_config>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/app/hook/config`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsUpdateWebhookConfigForApp(p: {
    requestBody: {
      content_type: t_webhook_config_content_type
      insecure_ssl: t_webhook_config_insecure_ssl
      secret: t_webhook_config_secret
      url: t_webhook_config_url
    }
  }): Promise<Res<200, t_webhook_config>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/app/hook/config`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListWebhookDeliveries(p: {
    perPage?: number
    cursor?: string
    redelivery?: boolean
  }): Promise<
    | Res<200, t_hook_delivery_item[]>
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/app/hook/deliveries?${this._query({
          per_page: p["perPage"],
          cursor: p["cursor"],
          redelivery: p["redelivery"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetWebhookDelivery(p: {
    deliveryId: number
  }): Promise<
    | Res<200, t_hook_delivery>
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/app/hook/deliveries/${p["deliveryId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsRedeliverWebhookDelivery(p: { deliveryId: number }): Promise<
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/app/hook/deliveries/${p["deliveryId"]}/attempts`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListInstallations(p: {
    perPage?: number
    page?: number
    since?: string
    outdated?: string
  }): Promise<Res<200, t_installation[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/app/installations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
          since: p["since"],
          outdated: p["outdated"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetInstallation(p: {
    installationId: number
  }): Promise<Res<200, t_installation> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/app/installations/${p["installationId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsDeleteInstallation(p: {
    installationId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/app/installations/${p["installationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCreateInstallationAccessToken(p: {
    installationId: number
    requestBody?: {
      permissions: t_app_permissions
      repositories?: string[]
      repository_ids?: number[]
    }
  }): Promise<
    | Res<201, t_installation_token>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/app/installations/${p["installationId"]}/access_tokens`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsSuspendInstallation(p: {
    installationId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/app/installations/${p["installationId"]}/suspended`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsUnsuspendInstallation(p: {
    installationId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/app/installations/${p["installationId"]}/suspended`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsDeleteAuthorization(p: {
    clientId: string
    requestBody: {
      access_token: string
    }
  }): Promise<Res<204, void> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/grant`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCheckToken(p: {
    clientId: string
    requestBody: {
      access_token: string
    }
  }): Promise<
    | Res<200, t_authorization>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/token`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsResetToken(p: {
    clientId: string
    requestBody: {
      access_token: string
    }
  }): Promise<Res<200, t_authorization> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/token`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsDeleteToken(p: {
    clientId: string
    requestBody: {
      access_token: string
    }
  }): Promise<Res<204, void> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/token`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsScopeToken(p: {
    clientId: string
    requestBody: {
      access_token: string
      permissions: t_app_permissions
      repositories?: string[]
      repository_ids?: number[]
      target?: string
      target_id?: number
    }
  }): Promise<
    | Res<200, t_authorization>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/token/scoped`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetBySlug(p: {
    appSlug: string
  }): Promise<
    Res<200, t_integration> | Res<403, t_basic_error> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/apps/${p["appSlug"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codesOfConductGetAllCodesOfConduct(): Promise<
    Res<200, t_code_of_conduct[]> | Res<304, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/codes_of_conduct`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codesOfConductGetConductCode(p: {
    key: string
  }): Promise<
    Res<200, t_code_of_conduct> | Res<304, void> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/codes_of_conduct/${p["key"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async emojisGet(): Promise<
    | Res<
        200,
        {
          [key: string]: unknown
        }
      >
    | Res<304, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/emojis`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(p: {
    enterprise: string
    orgId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/permissions/organizations/${p["orgId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminListSelfHostedRunnerGroupsForEnterprise(p: {
    enterprise: string
    perPage?: number
    page?: number
    visibleToOrganization?: string
  }): Promise<
    Res<
      200,
      {
        runner_groups: t_runner_groups_enterprise[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runner-groups?${this._query({
          per_page: p["perPage"],
          page: p["page"],
          visible_to_organization: p["visibleToOrganization"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(p: {
    enterprise: string
    requestBody: {
      allows_public_repositories?: boolean
      name: string
      restricted_to_workflows?: boolean
      runners?: number[]
      selected_organization_ids?: number[]
      selected_workflows?: string[]
      visibility?: "selected" | "all"
    }
  }): Promise<Res<201, t_runner_groups_enterprise>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runner-groups`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminGetSelfHostedRunnerGroupForEnterprise(p: {
    enterprise: string
    runnerGroupId: number
  }): Promise<Res<200, t_runner_groups_enterprise>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runner-groups/${p["runnerGroupId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(p: {
    enterprise: string
    runnerGroupId: number
    orgId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runner-groups/${p["runnerGroupId"]}/organizations/${p["orgId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(p: {
    enterprise: string
    runnerGroupId: number
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runner-groups/${p["runnerGroupId"]}/runners/${p["runnerId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminDeleteSelfHostedRunnerFromEnterprise(p: {
    enterprise: string
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise(p: {
    enterprise: string
    runnerId: number
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise(p: {
    enterprise: string
    runnerId: number
    requestBody: {
      labels: string[]
    }
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningGetSecurityAnalysisSettingsForEnterprise(p: {
    enterprise: string
  }): Promise<
    Res<200, t_enterprise_security_analysis_settings> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/code_security_and_analysis`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningPatchSecurityAnalysisSettingsForEnterprise(p: {
    enterprise: string
    requestBody?: {
      advanced_security_enabled_for_new_repositories?: boolean
      secret_scanning_enabled_for_new_repositories?: boolean
      secret_scanning_push_protection_custom_link?: string | null
      secret_scanning_push_protection_enabled_for_new_repositories?: boolean
    }
  }): Promise<Res<204, void> | Res<404, t_basic_error> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/code_security_and_analysis`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotListAlertsForEnterprise(p: {
    enterprise: string
    state?: string
    severity?: string
    ecosystem?: string
    package?: string
    scope?: "development" | "runtime"
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    before?: string
    after?: string
    first?: number
    last?: number
    perPage?: number
  }): Promise<
    | Res<200, t_dependabot_alert_with_repository[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/dependabot/alerts?${this._query({
          state: p["state"],
          severity: p["severity"],
          ecosystem: p["ecosystem"],
          package: p["package"],
          scope: p["scope"],
          sort: p["sort"],
          direction: p["direction"],
          before: p["before"],
          after: p["after"],
          first: p["first"],
          last: p["last"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningListAlertsForEnterprise(p: {
    enterprise: string
    state?: "open" | "resolved"
    secretType?: string
    resolution?: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    before?: string
    after?: string
  }): Promise<
    | Res<200, t_organization_secret_scanning_alert[]>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/secret-scanning/alerts?${this._query({
          state: p["state"],
          secret_type: p["secretType"],
          resolution: p["resolution"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          before: p["before"],
          after: p["after"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningPostSecurityProductEnablementForEnterprise(p: {
    enterprise: string
    securityProduct:
      | "advanced_security"
      | "secret_scanning"
      | "secret_scanning_push_protection"
    enablement: "enable_all" | "disable_all"
  }): Promise<Res<204, void> | Res<404, t_basic_error> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/enterprises/${p["enterprise"]}/${p["securityProduct"]}/${p["enablement"]}`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicEvents(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_event[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/events?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetFeeds(): Promise<Res<200, t_feed>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/feeds`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsList(p: {
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<200, t_base_gist[]> | Res<304, void> | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/gists?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsCreate(p: {
    requestBody: {
      description?: string
      files: {
        [key: string]: unknown
      }
      public?: {
        [key: string]: unknown
      }
    }
  }): Promise<
    | Res<201, t_gist_simple>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/gists`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListPublic(p: {
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_base_gist[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/gists/public?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListStarred(p: {
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_base_gist[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/gists/starred?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsGet(p: { gistId: string }): Promise<
    | Res<200, t_gist_simple>
    | Res<304, void>
    | Res<
        403,
        {
          block?: {
            created_at?: string
            html_url?: string | null
            reason?: string
          }
          documentation_url?: string
          message?: string
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/gists/${p["gistId"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsUpdate(p: {
    gistId: string
    requestBody: {
      description?: string
      files?: {
        [key: string]: unknown
      }
    }
  }): Promise<
    | Res<200, t_gist_simple>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/gists/${p["gistId"]}`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsDelete(p: {
    gistId: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/gists/${p["gistId"]}`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListComments(p: {
    gistId: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_gist_comment[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/gists/${p["gistId"]}/comments?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsCreateComment(p: {
    gistId: string
    requestBody: {
      body: string
    }
  }): Promise<
    | Res<201, t_gist_comment>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsGetComment(p: { gistId: string; commentId: number }): Promise<
    | Res<200, t_gist_comment>
    | Res<304, void>
    | Res<
        403,
        {
          block?: {
            created_at?: string
            html_url?: string | null
            reason?: string
          }
          documentation_url?: string
          message?: string
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsUpdateComment(p: {
    gistId: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<Res<200, t_gist_comment> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsDeleteComment(p: {
    gistId: string
    commentId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListCommits(p: {
    gistId: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_gist_commit[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/gists/${p["gistId"]}/commits?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListForks(p: {
    gistId: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_gist_simple[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/gists/${p["gistId"]}/forks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsFork(p: {
    gistId: string
  }): Promise<
    | Res<201, t_base_gist>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/forks`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsCheckIsStarred(p: { gistId: string }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<
        404,
        {
          [key: string]: unknown
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/star`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsStar(p: {
    gistId: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/star`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsUnstar(p: {
    gistId: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/star`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsGetRevision(p: {
    gistId: string
    sha: string
  }): Promise<
    | Res<200, t_gist_simple>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/${p["sha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitignoreGetAllTemplates(): Promise<
    Res<200, string[]> | Res<304, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/gitignore/templates`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitignoreGetTemplate(p: {
    name: string
  }): Promise<Res<200, t_gitignore_template> | Res<304, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/gitignore/templates/${p["name"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListReposAccessibleToInstallation(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          repositories: t_repository[]
          repository_selection?: string
          total_count: number
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/installation/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsRevokeInstallationAccessToken(): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/installation/token`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesList(p: {
    filter?:
      | "assigned"
      | "created"
      | "mentioned"
      | "subscribed"
      | "repos"
      | "all"
    state?: "open" | "closed" | "all"
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    collab?: boolean
    orgs?: boolean
    owned?: boolean
    pulls?: boolean
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_issue[]>
    | Res<304, void>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/issues?${this._query({
          filter: p["filter"],
          state: p["state"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          collab: p["collab"],
          orgs: p["orgs"],
          owned: p["owned"],
          pulls: p["pulls"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async licensesGetAllCommonlyUsed(p: {
    featured?: boolean
    perPage?: number
    page?: number
  }): Promise<Res<200, t_license_simple[]> | Res<304, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/licenses?${this._query({
          featured: p["featured"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async licensesGet(p: {
    license: string
  }): Promise<
    | Res<200, t_license>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/licenses/${p["license"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async markdownRender(p: {
    requestBody: {
      context?: string
      mode?: "markdown" | "gfm"
      text: string
    }
  }): Promise<Res<200, string> | Res<304, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/markdown`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async markdownRenderRaw(p: {
    requestBody?: string
  }): Promise<Res<200, string> | Res<304, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "text/plain",
    }

    const res = await fetch(this.config.basePath + `/markdown/raw`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetSubscriptionPlanForAccount(p: {
    accountId: number
  }): Promise<
    | Res<200, t_marketplace_purchase>
    | Res<401, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/marketplace_listing/accounts/${p["accountId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListPlans(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_marketplace_listing_plan[]>
    | Res<401, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/plans?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListAccountsForPlan(p: {
    planId: number
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_marketplace_purchase[]>
    | Res<401, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/plans/${p["planId"]}/accounts?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetSubscriptionPlanForAccountStubbed(p: {
    accountId: number
  }): Promise<
    Res<200, t_marketplace_purchase> | Res<401, t_basic_error> | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/stubbed/accounts/${p["accountId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListPlansStubbed(p: {
    perPage?: number
    page?: number
  }): Promise<
    Res<200, t_marketplace_listing_plan[]> | Res<401, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/stubbed/plans?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListAccountsForPlanStubbed(p: {
    planId: number
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_marketplace_purchase[]> | Res<401, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/stubbed/plans/${
          p["planId"]
        }/accounts?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async metaGet(): Promise<Res<200, t_api_overview> | Res<304, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/meta`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicEventsForRepoNetwork(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_event[]>
    | Res<301, t_basic_error>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/networks/${p["owner"]}/${p["repo"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListNotificationsForAuthenticatedUser(p: {
    all?: boolean
    participating?: boolean
    since?: string
    before?: string
    page?: number
    perPage?: number
  }): Promise<
    | Res<200, t_thread[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/notifications?${this._query({
          all: p["all"],
          participating: p["participating"],
          since: p["since"],
          before: p["before"],
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityMarkNotificationsAsRead(p: {
    requestBody?: {
      last_read_at?: string
      read?: boolean
    }
  }): Promise<
    | Res<
        202,
        {
          message?: string
        }
      >
    | Res<205, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/notifications`, {
      method: "PUT",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetThread(p: {
    threadId: number
  }): Promise<
    | Res<200, t_thread>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/notifications/threads/${p["threadId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityMarkThreadAsRead(p: {
    threadId: number
  }): Promise<Res<205, void> | Res<304, void> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/notifications/threads/${p["threadId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetThreadSubscriptionForAuthenticatedUser(p: {
    threadId: number
  }): Promise<
    | Res<200, t_thread_subscription>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/notifications/threads/${p["threadId"]}/subscription`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activitySetThreadSubscription(p: {
    threadId: number
    requestBody?: {
      ignored?: boolean
    }
  }): Promise<
    | Res<200, t_thread_subscription>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/notifications/threads/${p["threadId"]}/subscription`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityDeleteThreadSubscription(p: {
    threadId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/notifications/threads/${p["threadId"]}/subscription`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async metaGetOctocat(p: { s?: string }): Promise<Res<200, string>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/octocat?${this._query({ s: p["s"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsList(p: {
    since?: number
    perPage?: number
  }): Promise<Res<200, t_organization_simple[]> | Res<304, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/organizations?${this._query({
          since: p["since"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGet(p: {
    org: string
  }): Promise<Res<200, t_organization_full> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUpdate(p: {
    org: string
    requestBody?: {
      advanced_security_enabled_for_new_repositories?: boolean
      billing_email?: string
      blog?: string
      company?: string
      default_repository_permission?: "read" | "write" | "admin" | "none"
      dependabot_alerts_enabled_for_new_repositories?: boolean
      dependabot_security_updates_enabled_for_new_repositories?: boolean
      dependency_graph_enabled_for_new_repositories?: boolean
      description?: string
      email?: string
      has_organization_projects?: boolean
      has_repository_projects?: boolean
      location?: string
      members_allowed_repository_creation_type?: "all" | "private" | "none"
      members_can_create_internal_repositories?: boolean
      members_can_create_pages?: boolean
      members_can_create_private_pages?: boolean
      members_can_create_private_repositories?: boolean
      members_can_create_public_pages?: boolean
      members_can_create_public_repositories?: boolean
      members_can_create_repositories?: boolean
      members_can_fork_private_repositories?: boolean
      name?: string
      secret_scanning_enabled_for_new_repositories?: boolean
      secret_scanning_push_protection_custom_link?: string
      secret_scanning_push_protection_custom_link_enabled?: boolean
      secret_scanning_push_protection_enabled_for_new_repositories?: boolean
      twitter_username?: string
      web_commit_signoff_required?: boolean
    }
  }): Promise<
    | Res<200, t_organization_full>
    | Res<409, t_basic_error>
    | Res<
        422,
        {
          [key: string]: unknown
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetActionsCacheUsageForOrg(p: {
    org: string
  }): Promise<Res<200, t_actions_cache_usage_org_enterprise>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/cache/usage`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetActionsCacheUsageByRepoForOrg(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        repository_cache_usages: t_actions_cache_usage_by_repository[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/cache/usage-by-repository?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oidcGetOidcCustomSubTemplateForOrg(p: {
    org: string
  }): Promise<Res<200, t_oidc_custom_sub>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/oidc/customization/sub`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oidcUpdateOidcCustomSubTemplateForOrg(p: {
    org: string
    requestBody: t_oidc_custom_sub
  }): Promise<
    Res<201, t_empty_object> | Res<403, t_basic_error> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/oidc/customization/sub`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetGithubActionsPermissionsOrganization(p: {
    org: string
  }): Promise<Res<200, t_actions_organization_permissions>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/permissions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetGithubActionsPermissionsOrganization(p: {
    org: string
    requestBody: {
      allowed_actions: t_allowed_actions
      enabled_repositories: t_enabled_repositories
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/permissions`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelectedRepositoriesEnabledGithubActionsOrganization(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        repositories: t_repository[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/permissions/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(p: {
    org: string
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/permissions/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsEnableSelectedRepositoryGithubActionsOrganization(p: {
    org: string
    repositoryId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/permissions/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDisableSelectedRepositoryGithubActionsOrganization(p: {
    org: string
    repositoryId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/permissions/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetAllowedActionsOrganization(p: {
    org: string
  }): Promise<Res<200, t_selected_actions>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/permissions/selected-actions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetAllowedActionsOrganization(p: {
    org: string
    requestBody?: t_selected_actions
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/permissions/selected-actions`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(p: {
    org: string
  }): Promise<Res<200, t_actions_get_default_workflow_permissions>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/permissions/workflow`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(p: {
    org: string
    requestBody?: t_actions_set_default_workflow_permissions
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/permissions/workflow`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRequiredWorkflows(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        required_workflows: t_required_workflow[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRequiredWorkflow(p: {
    org: string
    requestBody: {
      repository_id: string
      scope?: "selected" | "all"
      selected_repository_ids?: number[]
      workflow_file_path: string
    }
  }): Promise<
    Res<201, t_required_workflow> | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/required_workflows`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRequiredWorkflow(p: {
    org: string
    requiredWorkflowId: number
  }): Promise<Res<200, t_required_workflow>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows/${p["requiredWorkflowId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsUpdateRequiredWorkflow(p: {
    org: string
    requiredWorkflowId: number
    requestBody: {
      repository_id?: string
      scope?: "selected" | "all"
      selected_repository_ids?: number[]
      workflow_file_path?: string
    }
  }): Promise<
    Res<200, t_required_workflow> | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows/${p["requiredWorkflowId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteRequiredWorkflow(p: {
    org: string
    requiredWorkflowId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows/${p["requiredWorkflowId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelectedRepositoriesRequiredWorkflow(p: {
    org: string
    requiredWorkflowId: number
  }): Promise<
    | Res<
        200,
        {
          repositories: t_repository[]
          total_count: number
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows/${p["requiredWorkflowId"]}/repositories`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetSelectedReposToRequiredWorkflow(p: {
    org: string
    requiredWorkflowId: number
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows/${p["requiredWorkflowId"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsAddSelectedRepoToRequiredWorkflow(p: {
    org: string
    requiredWorkflowId: number
    repositoryId: number
  }): Promise<Res<204, void> | Res<404, void> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows/${p["requiredWorkflowId"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveSelectedRepoFromRequiredWorkflow(p: {
    org: string
    requiredWorkflowId: number
    repositoryId: number
  }): Promise<Res<204, void> | Res<404, void> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/required_workflows/${p["requiredWorkflowId"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelfHostedRunnerGroupsForOrg(p: {
    org: string
    perPage?: number
    page?: number
    visibleToRepository?: string
  }): Promise<
    Res<
      200,
      {
        runner_groups: t_runner_groups_org[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups?${this._query({
          per_page: p["perPage"],
          page: p["page"],
          visible_to_repository: p["visibleToRepository"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateSelfHostedRunnerGroupForOrg(p: {
    org: string
    requestBody: {
      allows_public_repositories?: boolean
      name: string
      restricted_to_workflows?: boolean
      runners?: number[]
      selected_repository_ids?: number[]
      selected_workflows?: string[]
      visibility?: "selected" | "all" | "private"
    }
  }): Promise<Res<201, t_runner_groups_org>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/runner-groups`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetSelfHostedRunnerGroupForOrg(p: {
    org: string
    runnerGroupId: number
  }): Promise<Res<200, t_runner_groups_org>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsUpdateSelfHostedRunnerGroupForOrg(p: {
    org: string
    runnerGroupId: number
    requestBody: {
      allows_public_repositories?: boolean
      name: string
      restricted_to_workflows?: boolean
      selected_workflows?: string[]
      visibility?: "selected" | "all" | "private"
    }
  }): Promise<Res<200, t_runner_groups_org>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteSelfHostedRunnerGroupFromOrg(p: {
    org: string
    runnerGroupId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRepoAccessToSelfHostedRunnerGroupInOrg(p: {
    org: string
    runnerGroupId: number
    page?: number
    perPage?: number
  }): Promise<
    Res<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${
          p["runnerGroupId"]
        }/repositories?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(p: {
    org: string
    runnerGroupId: number
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(p: {
    org: string
    runnerGroupId: number
    repositoryId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelfHostedRunnersInGroupForOrg(p: {
    org: string
    runnerGroupId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        runners: t_runner[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${
          p["runnerGroupId"]
        }/runners?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetSelfHostedRunnersInGroupForOrg(p: {
    org: string
    runnerGroupId: number
    requestBody: {
      runners: number[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/runners`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsAddSelfHostedRunnerToGroupForOrg(p: {
    org: string
    runnerGroupId: number
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/runners/${p["runnerId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveSelfHostedRunnerFromGroupForOrg(p: {
    org: string
    runnerGroupId: number
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/runners/${p["runnerId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelfHostedRunnersForOrg(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        runners: t_runner[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRunnerApplicationsForOrg(p: {
    org: string
  }): Promise<Res<200, t_runner_application[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/runners/downloads`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRegistrationTokenForOrg(p: {
    org: string
  }): Promise<Res<201, t_authentication_token>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/registration-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRemoveTokenForOrg(p: {
    org: string
  }): Promise<Res<201, t_authentication_token>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/runners/remove-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetSelfHostedRunnerForOrg(p: {
    org: string
    runnerId: number
  }): Promise<Res<200, t_runner>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteSelfHostedRunnerFromOrg(p: {
    org: string
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListLabelsForSelfHostedRunnerForOrg(p: {
    org: string
    runnerId: number
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsAddCustomLabelsToSelfHostedRunnerForOrg(p: {
    org: string
    runnerId: number
    requestBody: {
      labels: string[]
    }
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetCustomLabelsForSelfHostedRunnerForOrg(p: {
    org: string
    runnerId: number
    requestBody: {
      labels: string[]
    }
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(p: {
    org: string
    runnerId: number
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(p: {
    org: string
    runnerId: number
    name: string
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListOrgSecrets(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_organization_actions_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetOrgPublicKey(p: {
    org: string
  }): Promise<Res<200, t_actions_public_key>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetOrgSecret(p: {
    org: string
    secretName: string
  }): Promise<Res<200, t_organization_actions_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateOrUpdateOrgSecret(p: {
    org: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
      selected_repository_ids?: number[]
      visibility: "all" | "private" | "selected"
    }
  }): Promise<Res<201, t_empty_object> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteOrgSecret(p: {
    org: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelectedReposForOrgSecret(p: {
    org: string
    secretName: string
    page?: number
    perPage?: number
  }): Promise<
    Res<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${
          p["secretName"]
        }/repositories?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetSelectedReposForOrgSecret(p: {
    org: string
    secretName: string
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsAddSelectedRepoToOrgSecret(p: {
    org: string
    secretName: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveSelectedRepoFromOrgSecret(p: {
    org: string
    secretName: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListOrgVariables(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        total_count: number
        variables: t_organization_actions_variable[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/variables?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateOrgVariable(p: {
    org: string
    requestBody: {
      name: string
      selected_repository_ids?: number[]
      value: string
      visibility: "all" | "private" | "selected"
    }
  }): Promise<Res<201, t_empty_object>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/variables`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetOrgVariable(p: {
    org: string
    name: string
  }): Promise<Res<200, t_organization_actions_variable>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/variables/${p["name"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsUpdateOrgVariable(p: {
    org: string
    name: string
    requestBody: {
      name?: string
      selected_repository_ids?: number[]
      value?: string
      visibility?: "all" | "private" | "selected"
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/variables/${p["name"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteOrgVariable(p: {
    org: string
    name: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/variables/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelectedReposForOrgVariable(p: {
    org: string
    name: string
    page?: number
    perPage?: number
  }): Promise<
    | Res<
        200,
        {
          repositories: t_minimal_repository[]
          total_count: number
        }
      >
    | Res<409, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/variables/${
          p["name"]
        }/repositories?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetSelectedReposForOrgVariable(p: {
    org: string
    name: string
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsAddSelectedRepoToOrgVariable(p: {
    org: string
    name: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveSelectedRepoFromOrgVariable(p: {
    org: string
    name: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListBlockedUsers(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/blocks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCheckBlockedUser(p: {
    org: string
    username: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsBlockUser(p: {
    org: string
    username: string
  }): Promise<Res<204, void> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUnblockUser(p: {
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningListAlertsForOrg(p: {
    org: string
    toolName?: t_code_scanning_analysis_tool_name
    toolGuid?: t_code_scanning_analysis_tool_guid
    before?: string
    after?: string
    page?: number
    perPage?: number
    direction?: "asc" | "desc"
    state?: t_code_scanning_alert_state
    sort?: "created" | "updated"
    severity?: t_code_scanning_alert_severity
  }): Promise<
    | Res<200, t_code_scanning_organization_alert_items[]>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/code-scanning/alerts?${this._query({
          tool_name: p["toolName"],
          tool_guid: p["toolGuid"],
          before: p["before"],
          after: p["after"],
          page: p["page"],
          per_page: p["perPage"],
          direction: p["direction"],
          state: p["state"],
          sort: p["sort"],
          severity: p["severity"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListInOrganization(p: {
    perPage?: number
    page?: number
    org: string
  }): Promise<
    | Res<
        200,
        {
          codespaces: t_codespace[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesSetCodespacesBilling(p: {
    org: string
    requestBody: {
      selected_usernames?: string[]
      visibility:
        | "disabled"
        | "selected_members"
        | "all_members"
        | "all_members_and_outside_collaborators"
    }
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<400, void>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/codespaces/billing`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListOrgSecrets(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_codespaces_org_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetOrgPublicKey(p: {
    org: string
  }): Promise<Res<200, t_codespaces_public_key>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/codespaces/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetOrgSecret(p: {
    org: string
    secretName: string
  }): Promise<Res<200, t_codespaces_org_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesCreateOrUpdateOrgSecret(p: {
    org: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
      selected_repository_ids?: number[]
      visibility: "all" | "private" | "selected"
    }
  }): Promise<
    | Res<201, t_empty_object>
    | Res<204, void>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesDeleteOrgSecret(p: {
    org: string
    secretName: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListSelectedReposForOrgSecret(p: {
    org: string
    secretName: string
    page?: number
    perPage?: number
  }): Promise<
    | Res<
        200,
        {
          repositories: t_minimal_repository[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets/${
          p["secretName"]
        }/repositories?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesSetSelectedReposForOrgSecret(p: {
    org: string
    secretName: string
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<Res<204, void> | Res<404, t_basic_error> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesAddSelectedRepoToOrgSecret(p: {
    org: string
    secretName: string
    repositoryId: number
  }): Promise<
    | Res<204, void>
    | Res<404, t_basic_error>
    | Res<409, void>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesRemoveSelectedRepoFromOrgSecret(p: {
    org: string
    secretName: string
    repositoryId: number
  }): Promise<
    | Res<204, void>
    | Res<404, t_basic_error>
    | Res<409, void>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotListAlertsForOrg(p: {
    org: string
    state?: string
    severity?: string
    ecosystem?: string
    package?: string
    scope?: "development" | "runtime"
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    before?: string
    after?: string
    first?: number
    last?: number
    perPage?: number
  }): Promise<
    | Res<200, t_dependabot_alert_with_repository[]>
    | Res<304, void>
    | Res<400, t_scim_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/alerts?${this._query({
          state: p["state"],
          severity: p["severity"],
          ecosystem: p["ecosystem"],
          package: p["package"],
          scope: p["scope"],
          sort: p["sort"],
          direction: p["direction"],
          before: p["before"],
          after: p["after"],
          first: p["first"],
          last: p["last"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotListOrgSecrets(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_organization_dependabot_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotGetOrgPublicKey(p: {
    org: string
  }): Promise<Res<200, t_dependabot_public_key>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/dependabot/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotGetOrgSecret(p: {
    org: string
    secretName: string
  }): Promise<Res<200, t_organization_dependabot_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotCreateOrUpdateOrgSecret(p: {
    org: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
      selected_repository_ids?: string[]
      visibility: "all" | "private" | "selected"
    }
  }): Promise<Res<201, t_empty_object> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotDeleteOrgSecret(p: {
    org: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotListSelectedReposForOrgSecret(p: {
    org: string
    secretName: string
    page?: number
    perPage?: number
  }): Promise<
    Res<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets/${
          p["secretName"]
        }/repositories?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotSetSelectedReposForOrgSecret(p: {
    org: string
    secretName: string
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotAddSelectedRepoToOrgSecret(p: {
    org: string
    secretName: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotRemoveSelectedRepoFromOrgSecret(p: {
    org: string
    secretName: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicOrgEvents(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_event[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListFailedInvitations(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_organization_invitation[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/failed_invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListWebhooks(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_org_hook[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/hooks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCreateWebhook(p: {
    org: string
    requestBody: {
      active?: boolean
      config: {
        content_type: t_webhook_config_content_type
        insecure_ssl: t_webhook_config_insecure_ssl
        password?: string
        secret: t_webhook_config_secret
        url: t_webhook_config_url
        username?: string
      }
      events?: string[]
      name: string
    }
  }): Promise<
    | Res<201, t_org_hook>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}/hooks`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetWebhook(p: {
    org: string
    hookId: number
  }): Promise<Res<200, t_org_hook> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUpdateWebhook(p: {
    org: string
    hookId: number
    requestBody?: {
      active?: boolean
      config?: {
        content_type: t_webhook_config_content_type
        insecure_ssl: t_webhook_config_insecure_ssl
        secret: t_webhook_config_secret
        url: t_webhook_config_url
      }
      events?: string[]
      name?: string
    }
  }): Promise<
    | Res<200, t_org_hook>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsDeleteWebhook(p: {
    org: string
    hookId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetWebhookConfigForOrg(p: {
    org: string
    hookId: number
  }): Promise<Res<200, t_webhook_config>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/config`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUpdateWebhookConfigForOrg(p: {
    org: string
    hookId: number
    requestBody?: {
      content_type: t_webhook_config_content_type
      insecure_ssl: t_webhook_config_insecure_ssl
      secret: t_webhook_config_secret
      url: t_webhook_config_url
    }
  }): Promise<Res<200, t_webhook_config>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/config`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListWebhookDeliveries(p: {
    org: string
    hookId: number
    perPage?: number
    cursor?: string
    redelivery?: boolean
  }): Promise<
    | Res<200, t_hook_delivery_item[]>
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries?${this._query({
          per_page: p["perPage"],
          cursor: p["cursor"],
          redelivery: p["redelivery"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetWebhookDelivery(p: {
    org: string
    hookId: number
    deliveryId: number
  }): Promise<
    | Res<200, t_hook_delivery>
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRedeliverWebhookDelivery(p: {
    org: string
    hookId: number
    deliveryId: number
  }): Promise<
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}/attempts`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsPingWebhook(p: {
    org: string
    hookId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/pings`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetOrgInstallation(p: {
    org: string
  }): Promise<Res<200, t_installation>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/installation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListAppInstallations(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        installations: t_installation[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/installations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsGetRestrictionsForOrg(p: { org: string }): Promise<
    Res<
      200,
      {
        [key: string]: unknown
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/interaction-limits`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsSetRestrictionsForOrg(p: {
    org: string
    requestBody: t_interaction_limit
  }): Promise<
    Res<200, t_interaction_limit_response> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/interaction-limits`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsRemoveRestrictionsForOrg(p: {
    org: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/interaction-limits`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListPendingInvitations(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_organization_invitation[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCreateInvitation(p: {
    org: string
    requestBody?: {
      email?: string
      invitee_id?: number
      role?: "admin" | "direct_member" | "billing_manager"
      team_ids?: number[]
    }
  }): Promise<
    | Res<201, t_organization_invitation>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/invitations`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCancelInvitation(p: {
    org: string
    invitationId: number
  }): Promise<
    Res<204, void> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/invitations/${p["invitationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListInvitationTeams(p: {
    org: string
    invitationId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/invitations/${p["invitationId"]}/teams?${this._query(
          { per_page: p["perPage"], page: p["page"] }
        )}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListForOrg(p: {
    org: string
    filter?:
      | "assigned"
      | "created"
      | "mentioned"
      | "subscribed"
      | "repos"
      | "all"
    state?: "open" | "closed" | "all"
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_issue[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/issues?${this._query({
          filter: p["filter"],
          state: p["state"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListMembers(p: {
    org: string
    filter?: "2fa_disabled" | "all"
    role?: "all" | "admin" | "member"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/members?${this._query({
          filter: p["filter"],
          role: p["role"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCheckMembershipForUser(p: {
    org: string
    username: string
  }): Promise<Res<204, void> | Res<302, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/members/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveMember(p: {
    org: string
    username: string
  }): Promise<Res<204, void> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/members/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetCodespacesForUserInOrg(p: {
    perPage?: number
    page?: number
    org: string
    username: string
  }): Promise<
    | Res<
        200,
        {
          codespaces: t_codespace[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/members/${p["username"]}/codespaces?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesDeleteFromOrganization(p: {
    org: string
    username: string
    codespaceName: string
  }): Promise<
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/members/${p["username"]}/codespaces/${p["codespaceName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesStopInOrganization(p: {
    org: string
    username: string
    codespaceName: string
  }): Promise<
    | Res<200, t_codespace>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/members/${p["username"]}/codespaces/${p["codespaceName"]}/stop`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetMembershipForUser(p: {
    org: string
    username: string
  }): Promise<
    | Res<200, t_org_membership>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsSetMembershipForUser(p: {
    org: string
    username: string
    requestBody?: {
      role?: "admin" | "member"
    }
  }): Promise<
    | Res<200, t_org_membership>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveMembershipForUser(p: {
    org: string
    username: string
  }): Promise<
    Res<204, void> | Res<403, t_basic_error> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListForOrg(p: {
    org: string
    perPage?: number
    page?: number
    exclude?: "repositories"[]
  }): Promise<Res<200, t_migration[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
          exclude: p["exclude"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsStartForOrg(p: {
    org: string
    requestBody: {
      exclude?: "repositories"[]
      exclude_attachments?: boolean
      exclude_git_data?: boolean
      exclude_metadata?: boolean
      exclude_owner_projects?: boolean
      exclude_releases?: boolean
      lock_repositories?: boolean
      org_metadata_only?: boolean
      repositories: string[]
    }
  }): Promise<
    | Res<201, t_migration>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/migrations`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetStatusForOrg(p: {
    org: string
    migrationId: number
    exclude?: "repositories"[]
  }): Promise<Res<200, t_migration> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${p["migrationId"]}?${this._query({
          exclude: p["exclude"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsDownloadArchiveForOrg(p: {
    org: string
    migrationId: number
  }): Promise<Res<302, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsDeleteArchiveForOrg(p: {
    org: string
    migrationId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsUnlockRepoForOrg(p: {
    org: string
    migrationId: number
    repoName: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListReposForOrg(p: {
    org: string
    migrationId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${
          p["migrationId"]
        }/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListOutsideCollaborators(p: {
    org: string
    filter?: "2fa_disabled" | "all"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/outside_collaborators?${this._query({
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsConvertMemberToOutsideCollaborator(p: {
    org: string
    username: string
    requestBody?: {
      async?: boolean
    }
  }): Promise<
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<204, void>
    | Res<403, void>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveOutsideCollaborator(p: {
    org: string
    username: string
  }): Promise<
    | Res<204, void>
    | Res<
        422,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesListPackagesForOrganization(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    org: string
    visibility?: "public" | "private" | "internal"
  }): Promise<
    Res<200, t_package[]> | Res<401, t_basic_error> | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages?${this._query({
          package_type: p["packageType"],
          visibility: p["visibility"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetPackageForOrganization(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    org: string
  }): Promise<Res<200, t_package>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesDeletePackageForOrg(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    org: string
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesRestorePackageForOrg(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    org: string
    token?: string
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages/${p["packageType"]}/${
          p["packageName"]
        }/restore?${this._query({ token: p["token"] })}`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetAllPackageVersionsForPackageOwnedByOrg(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    org: string
    page?: number
    perPage?: number
    state?: "active" | "deleted"
  }): Promise<
    | Res<200, t_package_version[]>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages/${p["packageType"]}/${
          p["packageName"]
        }/versions?${this._query({
          page: p["page"],
          per_page: p["perPage"],
          state: p["state"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetPackageVersionForOrganization(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    org: string
    packageVersionId: number
  }): Promise<Res<200, t_package_version>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesDeletePackageVersionForOrg(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    org: string
    packageVersionId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesRestorePackageVersionForOrg(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    org: string
    packageVersionId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListForOrg(p: {
    org: string
    state?: "open" | "closed" | "all"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_project[]> | Res<422, t_validation_error_simple>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/projects?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateForOrg(p: {
    org: string
    requestBody: {
      body?: string
      name: string
    }
  }): Promise<
    | Res<201, t_project>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/projects`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListPublicMembers(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCheckPublicMembershipForUser(p: {
    org: string
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsSetPublicMembershipForAuthenticatedUser(p: {
    org: string
    username: string
  }): Promise<Res<204, void> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemovePublicMembershipForAuthenticatedUser(p: {
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForOrg(p: {
    org: string
    type?: "all" | "public" | "private" | "forks" | "sources" | "member"
    sort?: "created" | "updated" | "pushed" | "full_name"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/repos?${this._query({
          type: p["type"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateInOrg(p: {
    org: string
    requestBody: {
      allow_auto_merge?: boolean
      allow_merge_commit?: boolean
      allow_rebase_merge?: boolean
      allow_squash_merge?: boolean
      auto_init?: boolean
      delete_branch_on_merge?: boolean
      description?: string
      gitignore_template?: string
      has_downloads?: boolean
      has_issues?: boolean
      has_projects?: boolean
      has_wiki?: boolean
      homepage?: string
      is_template?: boolean
      license_template?: string
      merge_commit_message?: "PR_BODY" | "PR_TITLE" | "BLANK"
      merge_commit_title?: "PR_TITLE" | "MERGE_MESSAGE"
      name: string
      private?: boolean
      squash_merge_commit_message?: "PR_BODY" | "COMMIT_MESSAGES" | "BLANK"
      squash_merge_commit_title?: "PR_TITLE" | "COMMIT_OR_PR_TITLE"
      team_id?: number
      use_squash_pr_title_as_default?: boolean
      visibility?: "public" | "private"
    }
  }): Promise<
    | Res<201, t_repository>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}/repos`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningListAlertsForOrg(p: {
    org: string
    state?: "open" | "resolved"
    secretType?: string
    resolution?: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    page?: number
    perPage?: number
    before?: string
    after?: string
  }): Promise<
    | Res<200, t_organization_secret_scanning_alert[]>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/secret-scanning/alerts?${this._query({
          state: p["state"],
          secret_type: p["secretType"],
          resolution: p["resolution"],
          sort: p["sort"],
          direction: p["direction"],
          page: p["page"],
          per_page: p["perPage"],
          before: p["before"],
          after: p["after"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListSecurityManagerTeams(p: {
    org: string
  }): Promise<Res<200, t_team_simple[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/security-managers`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsAddSecurityManagerTeam(p: {
    org: string
    teamSlug: string
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/security-managers/teams/${p["teamSlug"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveSecurityManagerTeam(p: {
    org: string
    teamSlug: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/security-managers/teams/${p["teamSlug"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async billingGetGithubActionsBillingOrg(p: {
    org: string
  }): Promise<Res<200, t_actions_billing_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/settings/billing/actions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async billingGetGithubPackagesBillingOrg(p: {
    org: string
  }): Promise<Res<200, t_packages_billing_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/settings/billing/packages`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async billingGetSharedStorageBillingOrg(p: {
    org: string
  }): Promise<Res<200, t_combined_billing_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/settings/billing/shared-storage`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsList(p: {
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team[]> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreate(p: {
    org: string
    requestBody: {
      description?: string
      maintainers?: string[]
      name: string
      parent_team_id?: number
      permission?: "pull" | "push"
      privacy?: "secret" | "closed"
      repo_names?: string[]
    }
  }): Promise<
    | Res<201, t_team_full>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}/teams`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetByName(p: {
    org: string
    teamSlug: string
  }): Promise<Res<200, t_team_full> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateInOrg(p: {
    org: string
    teamSlug: string
    requestBody?: {
      description?: string
      name?: string
      parent_team_id?: number | null
      permission?: "pull" | "push" | "admin"
      privacy?: "secret" | "closed"
    }
  }): Promise<
    | Res<200, t_team_full>
    | Res<201, t_team_full>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteInOrg(p: {
    org: string
    teamSlug: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionsInOrg(p: {
    org: string
    teamSlug: string
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
    pinned?: string
  }): Promise<Res<200, t_team_discussion[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
          pinned: p["pinned"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionInOrg(p: {
    org: string
    teamSlug: string
    requestBody: {
      body: string
      private?: boolean
      title: string
    }
  }): Promise<Res<201, t_team_discussion>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
  }): Promise<Res<200, t_team_discussion>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    requestBody?: {
      body?: string
      title?: string
    }
  }): Promise<Res<200, t_team_discussion>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionCommentsInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team_discussion_comment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${
          p["discussionNumber"]
        }/comments?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionCommentInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    requestBody: {
      body: string
    }
  }): Promise<Res<201, t_team_discussion_comment>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionCommentInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
  }): Promise<Res<200, t_team_discussion_comment>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionCommentInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    requestBody: {
      body: string
    }
  }): Promise<Res<200, t_team_discussion_comment>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionCommentInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionCommentInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${
          p["discussionNumber"]
        }/comments/${p["commentNumber"]}/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionCommentInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<Res<200, t_reaction> | Res<201, t_reaction>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForTeamDiscussionComment(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${
          p["discussionNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionInOrg(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<Res<200, t_reaction> | Res<201, t_reaction>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForTeamDiscussion(p: {
    org: string
    teamSlug: string
    discussionNumber: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListPendingInvitationsInOrg(p: {
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_organization_invitation[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListMembersInOrg(p: {
    org: string
    teamSlug: string
    role?: "member" | "maintainer" | "all"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/members?${this._query({
          role: p["role"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetMembershipForUserInOrg(p: {
    org: string
    teamSlug: string
    username: string
  }): Promise<Res<200, t_team_membership> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateMembershipForUserInOrg(p: {
    org: string
    teamSlug: string
    username: string
    requestBody?: {
      role?: "member" | "maintainer"
    }
  }): Promise<Res<200, t_team_membership> | Res<403, void> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveMembershipForUserInOrg(p: {
    org: string
    teamSlug: string
    username: string
  }): Promise<Res<204, void> | Res<403, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListProjectsInOrg(p: {
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team_project[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForProjectInOrg(p: {
    org: string
    teamSlug: string
    projectId: number
  }): Promise<Res<200, t_team_project> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateProjectPermissionsInOrg(p: {
    org: string
    teamSlug: string
    projectId: number
    requestBody?: {
      permission?: "read" | "write" | "admin"
    }
  }): Promise<
    | Res<204, void>
    | Res<
        403,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveProjectInOrg(p: {
    org: string
    teamSlug: string
    projectId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListReposInOrg(p: {
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForRepoInOrg(p: {
    org: string
    teamSlug: string
    owner: string
    repo: string
  }): Promise<Res<200, t_team_repository> | Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateRepoPermissionsInOrg(p: {
    org: string
    teamSlug: string
    owner: string
    repo: string
    requestBody?: {
      permission?: string
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveRepoInOrg(p: {
    org: string
    teamSlug: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListChildInOrg(p: {
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsEnableOrDisableSecurityProductOnAllOrgRepos(p: {
    org: string
    securityProduct:
      | "dependency_graph"
      | "dependabot_alerts"
      | "dependabot_security_updates"
      | "advanced_security"
      | "secret_scanning"
      | "secret_scanning_push_protection"
    enablement: "enable_all" | "disable_all"
  }): Promise<Res<204, void> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/${p["securityProduct"]}/${p["enablement"]}`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGetCard(p: {
    cardId: number
  }): Promise<
    | Res<200, t_project_card>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsUpdateCard(p: {
    cardId: number
    requestBody?: {
      archived?: boolean
      note?: string | null
    }
  }): Promise<
    | Res<200, t_project_card>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsDeleteCard(p: { cardId: number }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<
        403,
        {
          documentation_url?: string
          errors?: string[]
          message?: string
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsMoveCard(p: {
    cardId: number
    requestBody: {
      column_id?: number
      position: string
    }
  }): Promise<
    | Res<
        201,
        {
          [key: string]: unknown
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<
        403,
        {
          documentation_url?: string
          errors?: {
            code?: string
            field?: string
            message?: string
            resource?: string
          }[]
          message?: string
        }
      >
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          errors?: {
            code?: string
            message?: string
          }[]
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}/moves`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGetColumn(p: {
    columnId: number
  }): Promise<
    | Res<200, t_project_column>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsUpdateColumn(p: {
    columnId: number
    requestBody: {
      name: string
    }
  }): Promise<
    | Res<200, t_project_column>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsDeleteColumn(p: {
    columnId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListCards(p: {
    columnId: number
    archivedState?: "all" | "archived" | "not_archived"
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_project_card[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/projects/columns/${p["columnId"]}/cards?${this._query({
          archived_state: p["archivedState"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateCard(p: {
    columnId: number
    requestBody: {
      [key: string]: unknown
    }
  }): Promise<
    | Res<201, t_project_card>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<
        422,
        {
          [key: string]: unknown
        }
      >
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          errors?: {
            code?: string
            message?: string
          }[]
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}/cards`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsMoveColumn(p: {
    columnId: number
    requestBody: {
      position: string
    }
  }): Promise<
    | Res<
        201,
        {
          [key: string]: unknown
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}/moves`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGet(p: {
    projectId: number
  }): Promise<
    | Res<200, t_project>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsUpdate(p: {
    projectId: number
    requestBody?: {
      body?: string | null
      name?: string
      organization_permission?: "read" | "write" | "admin" | "none"
      private?: boolean
      state?: string
    }
  }): Promise<
    | Res<200, t_project>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<
        403,
        {
          documentation_url?: string
          errors?: string[]
          message?: string
        }
      >
    | Res<404, void>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsDelete(p: { projectId: number }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<
        403,
        {
          documentation_url?: string
          errors?: string[]
          message?: string
        }
      >
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListCollaborators(p: {
    projectId: number
    affiliation?: "outside" | "direct" | "all"
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_simple_user[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators?${this._query({
          affiliation: p["affiliation"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsAddCollaborator(p: {
    projectId: number
    username: string
    requestBody?: {
      permission?: "read" | "write" | "admin"
    }
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsRemoveCollaborator(p: {
    projectId: number
    username: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGetPermissionForUser(p: {
    projectId: number
    username: string
  }): Promise<
    | Res<200, t_project_collaborator_permission>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators/${p["username"]}/permission`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListColumns(p: {
    projectId: number
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_project_column[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/columns?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateColumn(p: {
    projectId: number
    requestBody: {
      name: string
    }
  }): Promise<
    | Res<201, t_project_column>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}/columns`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async rateLimitGet(): Promise<
    Res<200, t_rate_limit_overview> | Res<304, void> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/rate_limit`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRepoRequiredWorkflows(p: {
    org: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          required_workflows: t_repo_required_workflow[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["org"]}/${
          p["repo"]
        }/actions/required_workflows?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRepoRequiredWorkflow(p: {
    org: string
    repo: string
    requiredWorkflowIdForRepo: number
  }): Promise<Res<200, t_repo_required_workflow> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["org"]}/${p["repo"]}/actions/required_workflows/${p["requiredWorkflowIdForRepo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRepoRequiredWorkflowUsage(p: {
    org: string
    repo: string
    requiredWorkflowIdForRepo: number
  }): Promise<Res<200, t_workflow_usage> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["org"]}/${p["repo"]}/actions/required_workflows/${p["requiredWorkflowIdForRepo"]}/timing`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGet(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<200, t_full_repository>
    | Res<301, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdate(p: {
    owner: string
    repo: string
    requestBody?: {
      allow_auto_merge?: boolean
      allow_forking?: boolean
      allow_merge_commit?: boolean
      allow_rebase_merge?: boolean
      allow_squash_merge?: boolean
      allow_update_branch?: boolean
      archived?: boolean
      default_branch?: string
      delete_branch_on_merge?: boolean
      description?: string
      has_issues?: boolean
      has_projects?: boolean
      has_wiki?: boolean
      homepage?: string
      is_template?: boolean
      merge_commit_message?: "PR_BODY" | "PR_TITLE" | "BLANK"
      merge_commit_title?: "PR_TITLE" | "MERGE_MESSAGE"
      name?: string
      private?: boolean
      security_and_analysis?: {
        advanced_security?: {
          status?: string
        }
        secret_scanning?: {
          status?: string
        }
        secret_scanning_push_protection?: {
          status?: string
        }
      } | null
      squash_merge_commit_message?: "PR_BODY" | "COMMIT_MESSAGES" | "BLANK"
      squash_merge_commit_title?: "PR_TITLE" | "COMMIT_OR_PR_TITLE"
      use_squash_pr_title_as_default?: boolean
      visibility?: "public" | "private"
      web_commit_signoff_required?: boolean
    }
  }): Promise<
    | Res<200, t_full_repository>
    | Res<307, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDelete(p: { owner: string; repo: string }): Promise<
    | Res<204, void>
    | Res<307, t_basic_error>
    | Res<
        403,
        {
          documentation_url?: string
          message?: string
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListArtifactsForRepo(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
    name?: string
  }): Promise<
    Res<
      200,
      {
        artifacts: t_artifact[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts?${this._query({
          per_page: p["perPage"],
          page: p["page"],
          name: p["name"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetArtifact(p: {
    owner: string
    repo: string
    artifactId: number
  }): Promise<Res<200, t_artifact>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteArtifact(p: {
    owner: string
    repo: string
    artifactId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDownloadArtifact(p: {
    owner: string
    repo: string
    artifactId: number
    archiveFormat: string
  }): Promise<Res<302, void> | Res<410, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}/${p["archiveFormat"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetActionsCacheUsage(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_actions_cache_usage_by_repository>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/cache/usage`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetActionsCacheList(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
    ref?: t_code_scanning_ref
    key?: string
    sort?: "created_at" | "last_accessed_at" | "size_in_bytes"
    direction?: "asc" | "desc"
  }): Promise<Res<200, t_actions_cache_list>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/caches?${this._query({
          per_page: p["perPage"],
          page: p["page"],
          ref: p["ref"],
          key: p["key"],
          sort: p["sort"],
          direction: p["direction"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteActionsCacheByKey(p: {
    owner: string
    repo: string
    key: string
    ref?: t_code_scanning_ref
  }): Promise<Res<200, t_actions_cache_list>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/caches?${this._query({
          key: p["key"],
          ref: p["ref"],
        })}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteActionsCacheById(p: {
    owner: string
    repo: string
    cacheId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/caches/${p["cacheId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetJobForWorkflowRun(p: {
    owner: string
    repo: string
    jobId: number
  }): Promise<Res<200, t_job>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDownloadJobLogsForWorkflowRun(p: {
    owner: string
    repo: string
    jobId: number
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}/logs`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsReRunJobForWorkflowRun(p: {
    owner: string
    repo: string
    jobId: number
    requestBody?: {
      enable_debug_logging?: boolean
    }
  }): Promise<Res<201, t_empty_object> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}/rerun`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetCustomOidcSubClaimForRepo(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<200, t_oidc_custom_sub_repo>
    | Res<400, t_scim_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/oidc/customization/sub`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetCustomOidcSubClaimForRepo(p: {
    owner: string
    repo: string
    requestBody: t_oidc_custom_sub_repo
  }): Promise<
    | Res<201, t_empty_object>
    | Res<400, t_scim_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/oidc/customization/sub`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetGithubActionsPermissionsRepository(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_actions_repository_permissions>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetGithubActionsPermissionsRepository(p: {
    owner: string
    repo: string
    requestBody: {
      allowed_actions: t_allowed_actions
      enabled: t_actions_enabled
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowAccessToRepository(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_actions_workflow_access_to_repository>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/access`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetWorkflowAccessToRepository(p: {
    owner: string
    repo: string
    requestBody: t_actions_workflow_access_to_repository
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/access`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetAllowedActionsRepository(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_selected_actions>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/selected-actions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetAllowedActionsRepository(p: {
    owner: string
    repo: string
    requestBody?: t_selected_actions
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/selected-actions`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetGithubActionsDefaultWorkflowPermissionsRepository(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_actions_get_default_workflow_permissions>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/workflow`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetGithubActionsDefaultWorkflowPermissionsRepository(p: {
    owner: string
    repo: string
    requestBody: t_actions_set_default_workflow_permissions
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/workflow`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRequiredWorkflowRuns(p: {
    owner: string
    repo: string
    requiredWorkflowIdForRepo: number
    actor?: string
    branch?: string
    event?: string
    status?:
      | "completed"
      | "action_required"
      | "cancelled"
      | "failure"
      | "neutral"
      | "skipped"
      | "stale"
      | "success"
      | "timed_out"
      | "in_progress"
      | "queued"
      | "requested"
      | "waiting"
    perPage?: number
    page?: number
    created?: string
    excludePullRequests?: boolean
    checkSuiteId?: number
    headSha?: string
  }): Promise<
    Res<
      200,
      {
        total_count: number
        workflow_runs: t_workflow_run[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/required_workflows/${
          p["requiredWorkflowIdForRepo"]
        }/runs?${this._query({
          actor: p["actor"],
          branch: p["branch"],
          event: p["event"],
          status: p["status"],
          per_page: p["perPage"],
          page: p["page"],
          created: p["created"],
          exclude_pull_requests: p["excludePullRequests"],
          check_suite_id: p["checkSuiteId"],
          head_sha: p["headSha"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelfHostedRunnersForRepo(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        runners: t_runner[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRunnerApplicationsForRepo(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_runner_application[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/downloads`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRegistrationTokenForRepo(p: {
    owner: string
    repo: string
  }): Promise<Res<201, t_authentication_token>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/registration-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRemoveTokenForRepo(p: {
    owner: string
    repo: string
  }): Promise<Res<201, t_authentication_token>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/remove-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetSelfHostedRunnerForRepo(p: {
    owner: string
    repo: string
    runnerId: number
  }): Promise<Res<200, t_runner>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteSelfHostedRunnerFromRepo(p: {
    owner: string
    repo: string
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListLabelsForSelfHostedRunnerForRepo(p: {
    owner: string
    repo: string
    runnerId: number
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsAddCustomLabelsToSelfHostedRunnerForRepo(p: {
    owner: string
    repo: string
    runnerId: number
    requestBody: {
      labels: string[]
    }
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetCustomLabelsForSelfHostedRunnerForRepo(p: {
    owner: string
    repo: string
    runnerId: number
    requestBody: {
      labels: string[]
    }
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(p: {
    owner: string
    repo: string
    runnerId: number
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(p: {
    owner: string
    repo: string
    runnerId: number
    name: string
  }): Promise<
    | Res<
        200,
        {
          labels: t_runner_label[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListWorkflowRunsForRepo(p: {
    owner: string
    repo: string
    actor?: string
    branch?: string
    event?: string
    status?:
      | "completed"
      | "action_required"
      | "cancelled"
      | "failure"
      | "neutral"
      | "skipped"
      | "stale"
      | "success"
      | "timed_out"
      | "in_progress"
      | "queued"
      | "requested"
      | "waiting"
    perPage?: number
    page?: number
    created?: string
    excludePullRequests?: boolean
    checkSuiteId?: number
    headSha?: string
  }): Promise<
    Res<
      200,
      {
        total_count: number
        workflow_runs: t_workflow_run[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs?${this._query({
          actor: p["actor"],
          branch: p["branch"],
          event: p["event"],
          status: p["status"],
          per_page: p["perPage"],
          page: p["page"],
          created: p["created"],
          exclude_pull_requests: p["excludePullRequests"],
          check_suite_id: p["checkSuiteId"],
          head_sha: p["headSha"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowRun(p: {
    owner: string
    repo: string
    runId: number
    excludePullRequests?: boolean
  }): Promise<Res<200, t_workflow_run>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${
          p["runId"]
        }?${this._query({ exclude_pull_requests: p["excludePullRequests"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteWorkflowRun(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetReviewsForRun(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<Res<200, t_environment_approvals[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/approvals`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsApproveWorkflowRun(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<
    Res<201, t_empty_object> | Res<403, t_basic_error> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/approve`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListWorkflowRunArtifacts(p: {
    owner: string
    repo: string
    runId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        artifacts: t_artifact[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${
          p["runId"]
        }/artifacts?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowRunAttempt(p: {
    owner: string
    repo: string
    runId: number
    attemptNumber: number
    excludePullRequests?: boolean
  }): Promise<Res<200, t_workflow_run>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${
          p["runId"]
        }/attempts/${p["attemptNumber"]}?${this._query({
          exclude_pull_requests: p["excludePullRequests"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListJobsForWorkflowRunAttempt(p: {
    owner: string
    repo: string
    runId: number
    attemptNumber: number
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          jobs: t_job[]
          total_count: number
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${
          p["runId"]
        }/attempts/${p["attemptNumber"]}/jobs?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDownloadWorkflowRunAttemptLogs(p: {
    owner: string
    repo: string
    runId: number
    attemptNumber: number
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/attempts/${p["attemptNumber"]}/logs`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCancelWorkflowRun(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<Res<202, t_empty_object> | Res<409, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/cancel`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListJobsForWorkflowRun(p: {
    owner: string
    repo: string
    runId: number
    filter?: "latest" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        jobs: t_job[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${
          p["runId"]
        }/jobs?${this._query({
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDownloadWorkflowRunLogs(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteWorkflowRunLogs(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<
    Res<204, void> | Res<403, t_basic_error> | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetPendingDeploymentsForRun(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<Res<200, t_pending_deployment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/pending_deployments`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsReviewPendingDeploymentsForRun(p: {
    owner: string
    repo: string
    runId: number
    requestBody: {
      comment: string
      environment_ids: number[]
      state: "approved" | "rejected"
    }
  }): Promise<Res<200, t_deployment[]>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/pending_deployments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsReRunWorkflow(p: {
    owner: string
    repo: string
    runId: number
    requestBody?: {
      enable_debug_logging?: boolean
    }
  }): Promise<Res<201, t_empty_object>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/rerun`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsReRunWorkflowFailedJobs(p: {
    owner: string
    repo: string
    runId: number
    requestBody?: {
      enable_debug_logging?: boolean
    }
  }): Promise<Res<201, t_empty_object>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/rerun-failed-jobs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowRunUsage(p: {
    owner: string
    repo: string
    runId: number
  }): Promise<Res<200, t_workflow_run_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/timing`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRepoSecrets(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_actions_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRepoPublicKey(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_actions_public_key>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
  }): Promise<Res<200, t_actions_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateOrUpdateRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
    }
  }): Promise<Res<201, t_empty_object> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRepoVariables(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        total_count: number
        variables: t_actions_variable[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/variables?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRepoVariable(p: {
    owner: string
    repo: string
    requestBody: {
      name: string
      value: string
    }
  }): Promise<Res<201, t_empty_object>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/variables`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRepoVariable(p: {
    owner: string
    repo: string
    name: string
  }): Promise<Res<200, t_actions_variable>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsUpdateRepoVariable(p: {
    owner: string
    repo: string
    name: string
    requestBody: {
      name?: string
      value?: string
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteRepoVariable(p: {
    owner: string
    repo: string
    name: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRepoWorkflows(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        total_count: number
        workflows: t_workflow[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflow(p: {
    owner: string
    repo: string
    workflowId: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_workflow>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDisableWorkflow(p: {
    owner: string
    repo: string
    workflowId: {
      [key: string]: unknown
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/disable`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateWorkflowDispatch(p: {
    owner: string
    repo: string
    workflowId: {
      [key: string]: unknown
    }
    requestBody: {
      inputs?: {
        [key: string]: unknown
      }
      ref: string
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/dispatches`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsEnableWorkflow(p: {
    owner: string
    repo: string
    workflowId: {
      [key: string]: unknown
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/enable`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListWorkflowRuns(p: {
    owner: string
    repo: string
    workflowId: {
      [key: string]: unknown
    }
    actor?: string
    branch?: string
    event?: string
    status?:
      | "completed"
      | "action_required"
      | "cancelled"
      | "failure"
      | "neutral"
      | "skipped"
      | "stale"
      | "success"
      | "timed_out"
      | "in_progress"
      | "queued"
      | "requested"
      | "waiting"
    perPage?: number
    page?: number
    created?: string
    excludePullRequests?: boolean
    checkSuiteId?: number
    headSha?: string
  }): Promise<
    Res<
      200,
      {
        total_count: number
        workflow_runs: t_workflow_run[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${
          p["workflowId"]
        }/runs?${this._query({
          actor: p["actor"],
          branch: p["branch"],
          event: p["event"],
          status: p["status"],
          per_page: p["perPage"],
          page: p["page"],
          created: p["created"],
          exclude_pull_requests: p["excludePullRequests"],
          check_suite_id: p["checkSuiteId"],
          head_sha: p["headSha"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowUsage(p: {
    owner: string
    repo: string
    workflowId: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_workflow_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/timing`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListAssignees(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/assignees?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCheckUserCanBeAssigned(p: {
    owner: string
    repo: string
    assignee: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/assignees/${p["assignee"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListAutolinks(p: {
    owner: string
    repo: string
    page?: number
  }): Promise<Res<200, t_autolink[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/autolinks?${this._query({
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateAutolink(p: {
    owner: string
    repo: string
    requestBody: {
      is_alphanumeric?: boolean
      key_prefix: string
      url_template: string
    }
  }): Promise<Res<201, t_autolink> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/autolinks`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAutolink(p: {
    owner: string
    repo: string
    autolinkId: number
  }): Promise<Res<200, t_autolink> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/autolinks/${p["autolinkId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteAutolink(p: {
    owner: string
    repo: string
    autolinkId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/autolinks/${p["autolinkId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposEnableAutomatedSecurityFixes(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDisableAutomatedSecurityFixes(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListBranches(p: {
    owner: string
    repo: string
    protected?: boolean
    perPage?: number
    page?: number
  }): Promise<Res<200, t_short_branch[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches?${this._query({
          protected: p["protected"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetBranch(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<
    | Res<200, t_branch_with_protection>
    | Res<301, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetBranchProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_branch_protection> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateBranchProtection(p: {
    owner: string
    repo: string
    branch: string
    requestBody: {
      allow_deletions?: boolean
      allow_force_pushes?: boolean | null
      allow_fork_syncing?: boolean
      block_creations?: boolean
      enforce_admins: boolean | null
      lock_branch?: boolean
      required_conversation_resolution?: boolean
      required_linear_history?: boolean
      required_pull_request_reviews: {
        bypass_pull_request_allowances?: {
          apps?: string[]
          teams?: string[]
          users?: string[]
        }
        dismiss_stale_reviews?: boolean
        dismissal_restrictions?: {
          apps?: string[]
          teams?: string[]
          users?: string[]
        }
        require_code_owner_reviews?: boolean
        require_last_push_approval?: boolean
        required_approving_review_count?: number
      } | null
      required_status_checks: {
        checks?: {
          app_id?: number
          context: string
        }[]
        contexts: string[]
        strict: boolean
      } | null
      restrictions: {
        apps?: string[]
        teams: string[]
        users: string[]
      } | null
    }
  }): Promise<
    | Res<200, t_protected_branch>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteBranchProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<204, void> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAdminBranchProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_protected_branch_admin_enforced>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetAdminBranchProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_protected_branch_admin_enforced>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteAdminBranchProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPullRequestReviewProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_protected_branch_pull_request_review>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdatePullRequestReviewProtection(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      bypass_pull_request_allowances?: {
        apps?: string[]
        teams?: string[]
        users?: string[]
      }
      dismiss_stale_reviews?: boolean
      dismissal_restrictions?: {
        apps?: string[]
        teams?: string[]
        users?: string[]
      }
      require_code_owner_reviews?: boolean
      require_last_push_approval?: boolean
      required_approving_review_count?: number
    }
  }): Promise<
    | Res<200, t_protected_branch_pull_request_review>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeletePullRequestReviewProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommitSignatureProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<200, t_protected_branch_admin_enforced> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateCommitSignatureProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<200, t_protected_branch_admin_enforced> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteCommitSignatureProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetStatusChecksProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_status_check_policy> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateStatusCheckProtection(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      checks?: {
        app_id?: number
        context: string
      }[]
      contexts?: string[]
      strict?: boolean
    }
  }): Promise<
    | Res<200, t_status_check_policy>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveStatusCheckProtection(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAllStatusCheckContexts(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, string[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddStatusCheckContexts(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<
    | Res<200, string[]>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetStatusCheckContexts(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<
    Res<200, string[]> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveStatusCheckContexts(p: {
    owner: string
    repo: string
    branch: string
    requestBody: {
      [key: string]: unknown
    }
  }): Promise<
    Res<200, string[]> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_branch_restriction_policy> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAppsWithAccessToProtectedBranch(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_integration[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddAppAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_integration[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetAppAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_integration[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveAppAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_integration[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetTeamsWithAccessToProtectedBranch(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_team[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddTeamAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_team[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetTeamAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_team[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveTeamAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_team[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetUsersWithAccessToProtectedBranch(p: {
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, t_simple_user[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddUserAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_simple_user[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetUserAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_simple_user[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveUserAccessRestrictions(p: {
    owner: string
    repo: string
    branch: string
    requestBody: {
      [key: string]: unknown
    }
  }): Promise<Res<200, t_simple_user[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRenameBranch(p: {
    owner: string
    repo: string
    branch: string
    requestBody: {
      new_name: string
    }
  }): Promise<
    | Res<201, t_branch_with_protection>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/rename`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksCreate(p: {
    owner: string
    repo: string
    requestBody: {
      actions?: {
        description: string
        identifier: string
        label: string
      }[]
      completed_at?: string
      conclusion?:
        | "action_required"
        | "cancelled"
        | "failure"
        | "neutral"
        | "success"
        | "skipped"
        | "stale"
        | "timed_out"
      details_url?: string
      external_id?: string
      head_sha: string
      name: string
      output?: {
        annotations?: {
          annotation_level: "notice" | "warning" | "failure"
          end_column?: number
          end_line: number
          message: string
          path: string
          raw_details?: string
          start_column?: number
          start_line: number
          title?: string
        }[]
        images?: {
          alt: string
          caption?: string
          image_url: string
        }[]
        summary: string
        text?: string
        title: string
      }
      started_at?: string
      status?: "queued" | "in_progress" | "completed"
    }
  }): Promise<Res<201, t_check_run>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/check-runs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksGet(p: {
    owner: string
    repo: string
    checkRunId: number
  }): Promise<Res<200, t_check_run>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksUpdate(p: {
    owner: string
    repo: string
    checkRunId: number
    requestBody: {
      actions?: {
        description: string
        identifier: string
        label: string
      }[]
      completed_at?: string
      conclusion?:
        | "action_required"
        | "cancelled"
        | "failure"
        | "neutral"
        | "success"
        | "skipped"
        | "stale"
        | "timed_out"
      details_url?: string
      external_id?: string
      name?: string
      output?: {
        annotations?: {
          annotation_level: "notice" | "warning" | "failure"
          end_column?: number
          end_line: number
          message: string
          path: string
          raw_details?: string
          start_column?: number
          start_line: number
          title?: string
        }[]
        images?: {
          alt: string
          caption?: string
          image_url: string
        }[]
        summary: string
        text?: string
        title?: string
      }
      started_at?: string
      status?: "queued" | "in_progress" | "completed"
    }
  }): Promise<Res<200, t_check_run>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListAnnotations(p: {
    owner: string
    repo: string
    checkRunId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_check_annotation[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-runs/${
          p["checkRunId"]
        }/annotations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksRerequestRun(p: {
    owner: string
    repo: string
    checkRunId: number
  }): Promise<
    | Res<201, t_empty_object>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}/rerequest`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksCreateSuite(p: {
    owner: string
    repo: string
    requestBody: {
      head_sha: string
    }
  }): Promise<Res<200, t_check_suite> | Res<201, t_check_suite>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/check-suites`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksSetSuitesPreferences(p: {
    owner: string
    repo: string
    requestBody: {
      auto_trigger_checks?: {
        app_id: number
        setting: boolean
      }[]
    }
  }): Promise<Res<200, t_check_suite_preference>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/preferences`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksGetSuite(p: {
    owner: string
    repo: string
    checkSuiteId: number
  }): Promise<Res<200, t_check_suite>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListForSuite(p: {
    owner: string
    repo: string
    checkSuiteId: number
    checkName?: string
    status?: "queued" | "in_progress" | "completed"
    filter?: "latest" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        check_runs: t_check_run[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/${
          p["checkSuiteId"]
        }/check-runs?${this._query({
          check_name: p["checkName"],
          status: p["status"],
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksRerequestSuite(p: {
    owner: string
    repo: string
    checkSuiteId: number
  }): Promise<Res<201, t_empty_object>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}/rerequest`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningListAlertsForRepo(p: {
    owner: string
    repo: string
    toolName?: t_code_scanning_analysis_tool_name
    toolGuid?: t_code_scanning_analysis_tool_guid
    page?: number
    perPage?: number
    ref?: t_code_scanning_ref
    direction?: "asc" | "desc"
    sort?: "created" | "updated"
    state?: t_code_scanning_alert_state
    severity?: t_code_scanning_alert_severity
  }): Promise<
    | Res<200, t_code_scanning_alert_items[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts?${this._query({
          tool_name: p["toolName"],
          tool_guid: p["toolGuid"],
          page: p["page"],
          per_page: p["perPage"],
          ref: p["ref"],
          direction: p["direction"],
          sort: p["sort"],
          state: p["state"],
          severity: p["severity"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningGetAlert(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
  }): Promise<
    | Res<200, t_code_scanning_alert>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningUpdateAlert(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
    requestBody: {
      dismissed_comment: t_code_scanning_alert_dismissed_comment
      dismissed_reason: t_code_scanning_alert_dismissed_reason
      state: t_code_scanning_alert_set_state
    }
  }): Promise<
    | Res<200, t_code_scanning_alert>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningListAlertInstances(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
    page?: number
    perPage?: number
    ref?: t_code_scanning_ref
  }): Promise<
    | Res<200, t_code_scanning_alert_instance[]>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${
          p["alertNumber"]
        }/instances?${this._query({
          page: p["page"],
          per_page: p["perPage"],
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningListRecentAnalyses(p: {
    owner: string
    repo: string
    toolName?: t_code_scanning_analysis_tool_name
    toolGuid?: t_code_scanning_analysis_tool_guid
    page?: number
    perPage?: number
    ref?: t_code_scanning_ref
    sarifId?: t_code_scanning_analysis_sarif_id
    direction?: "asc" | "desc"
    sort?: "created"
  }): Promise<
    | Res<200, t_code_scanning_analysis[]>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses?${this._query(
          {
            tool_name: p["toolName"],
            tool_guid: p["toolGuid"],
            page: p["page"],
            per_page: p["perPage"],
            ref: p["ref"],
            sarif_id: p["sarifId"],
            direction: p["direction"],
            sort: p["sort"],
          }
        )}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningGetAnalysis(p: {
    owner: string
    repo: string
    analysisId: number
  }): Promise<
    | Res<
        200,
        {
          [key: string]: unknown
        }
      >
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses/${p["analysisId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningDeleteAnalysis(p: {
    owner: string
    repo: string
    analysisId: number
    confirmDelete?: string
  }): Promise<
    | Res<200, t_code_scanning_analysis_deletion>
    | Res<400, t_scim_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses/${
          p["analysisId"]
        }?${this._query({ confirm_delete: p["confirmDelete"] })}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningListCodeqlDatabases(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<200, t_code_scanning_codeql_database[]>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/databases`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningGetCodeqlDatabase(p: {
    owner: string
    repo: string
    language: string
  }): Promise<
    | Res<200, t_code_scanning_codeql_database>
    | Res<302, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/databases/${p["language"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningUploadSarif(p: {
    owner: string
    repo: string
    requestBody: {
      checkout_uri?: string
      commit_sha: t_code_scanning_analysis_commit_sha
      ref: t_code_scanning_ref
      sarif: t_code_scanning_analysis_sarif_file
      started_at?: string
      tool_name?: string
      validate?: boolean
    }
  }): Promise<
    | Res<202, t_code_scanning_sarifs_receipt>
    | Res<400, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<413, void>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/sarifs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningGetSarif(p: {
    owner: string
    repo: string
    sarifId: string
  }): Promise<
    | Res<200, t_code_scanning_sarifs_status>
    | Res<403, t_basic_error>
    | Res<404, void>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/sarifs/${p["sarifId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCodeownersErrors(p: {
    owner: string
    repo: string
    ref?: string
  }): Promise<Res<200, t_codeowners_errors> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codeowners/errors?${this._query({
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListInRepositoryForAuthenticatedUser(p: {
    perPage?: number
    page?: number
    owner: string
    repo: string
  }): Promise<
    | Res<
        200,
        {
          codespaces: t_codespace[]
          total_count: number
        }
      >
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesCreateWithRepoForAuthenticatedUser(p: {
    owner: string
    repo: string
    requestBody: {
      client_ip?: string
      devcontainer_path?: string
      display_name?: string
      idle_timeout_minutes?: number
      location?: string
      machine?: string
      multi_repo_permissions_opt_out?: boolean
      ref?: string
      retention_period_minutes?: number
      working_directory?: string
    }
  }): Promise<
    | Res<201, t_codespace>
    | Res<202, t_codespace>
    | Res<400, t_scim_error>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/codespaces`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListDevcontainersInRepositoryForAuthenticatedUser(p: {
    perPage?: number
    page?: number
    owner: string
    repo: string
  }): Promise<
    | Res<
        200,
        {
          devcontainers: {
            name?: string
            path: string
          }[]
          total_count: number
        }
      >
    | Res<400, t_scim_error>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${
          p["repo"]
        }/codespaces/devcontainers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesRepoMachinesForAuthenticatedUser(p: {
    owner: string
    repo: string
    location?: string
    clientIp?: string
  }): Promise<
    | Res<
        200,
        {
          machines: t_codespace_machine[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces/machines?${this._query({
          location: p["location"],
          client_ip: p["clientIp"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesPreFlightWithRepoForAuthenticatedUser(p: {
    owner: string
    repo: string
    ref?: string
    clientIp?: string
  }): Promise<
    | Res<
        200,
        {
          billable_owner: t_simple_user
          defaults?: {
            devcontainer_path: string | null
            location: string
          }
        }
      >
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces/new?${this._query({
          ref: p["ref"],
          client_ip: p["clientIp"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListRepoSecrets(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_repo_codespaces_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetRepoPublicKey(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_codespaces_public_key>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
  }): Promise<Res<200, t_repo_codespaces_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesCreateOrUpdateRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
    }
  }): Promise<Res<201, t_empty_object> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesDeleteRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCollaborators(p: {
    owner: string
    repo: string
    affiliation?: "outside" | "direct" | "all"
    permission?: "pull" | "triage" | "push" | "maintain" | "admin"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_collaborator[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators?${this._query({
          affiliation: p["affiliation"],
          permission: p["permission"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCheckCollaborator(p: {
    owner: string
    repo: string
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddCollaborator(p: {
    owner: string
    repo: string
    username: string
    requestBody?: {
      permission?: string
    }
  }): Promise<
    | Res<201, t_repository_invitation>
    | Res<204, void>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveCollaborator(p: {
    owner: string
    repo: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCollaboratorPermissionLevel(p: {
    owner: string
    repo: string
    username: string
  }): Promise<
    Res<200, t_repository_collaborator_permission> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}/permission`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommitCommentsForRepo(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_commit_comment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommitComment(p: {
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<200, t_commit_comment> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateCommitComment(p: {
    owner: string
    repo: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<Res<200, t_commit_comment> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteCommitComment(p: {
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForCommitComment(p: {
    owner: string
    repo: string
    commentId: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${
          p["commentId"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForCommitComment(p: {
    owner: string
    repo: string
    commentId: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForCommitComment(p: {
    owner: string
    repo: string
    commentId: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommits(p: {
    owner: string
    repo: string
    sha?: string
    path?: string
    author?: string
    since?: string
    until?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_commit[]>
    | Res<400, t_scim_error>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits?${this._query({
          sha: p["sha"],
          path: p["path"],
          author: p["author"],
          since: p["since"],
          until: p["until"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListBranchesForHeadCommit(p: {
    owner: string
    repo: string
    commitSha: string
  }): Promise<Res<200, t_branch_short[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/branches-where-head`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommentsForCommit(p: {
    owner: string
    repo: string
    commitSha: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_commit_comment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["commitSha"]
        }/comments?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateCommitComment(p: {
    owner: string
    repo: string
    commitSha: string
    requestBody: {
      body: string
      line?: number
      path?: string
      position?: number
    }
  }): Promise<
    | Res<201, t_commit_comment>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListPullRequestsAssociatedWithCommit(p: {
    owner: string
    repo: string
    commitSha: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_pull_request_simple[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["commitSha"]
        }/pulls?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommit(p: {
    owner: string
    repo: string
    page?: number
    perPage?: number
    ref: string
  }): Promise<
    | Res<200, t_commit>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
    | Res<500, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListForRef(p: {
    owner: string
    repo: string
    ref: string
    checkName?: string
    status?: "queued" | "in_progress" | "completed"
    filter?: "latest" | "all"
    perPage?: number
    page?: number
    appId?: number
  }): Promise<
    Res<
      200,
      {
        check_runs: t_check_run[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["ref"]
        }/check-runs?${this._query({
          check_name: p["checkName"],
          status: p["status"],
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
          app_id: p["appId"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListSuitesForRef(p: {
    owner: string
    repo: string
    ref: string
    appId?: number
    checkName?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        check_suites: t_check_suite[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["ref"]
        }/check-suites?${this._query({
          app_id: p["appId"],
          check_name: p["checkName"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCombinedStatusForRef(p: {
    owner: string
    repo: string
    ref: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_combined_commit_status> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["ref"]
        }/status?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommitStatusesForRef(p: {
    owner: string
    repo: string
    ref: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_status[]> | Res<301, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["ref"]
        }/statuses?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommunityProfileMetrics(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_community_profile>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/community/profile`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCompareCommits(p: {
    owner: string
    repo: string
    page?: number
    perPage?: number
    basehead: string
  }): Promise<
    | Res<200, t_commit_comparison>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/compare/${
          p["basehead"]
        }?${this._query({ page: p["page"], per_page: p["perPage"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetContent(p: {
    owner: string
    repo: string
    path: string
    ref?: string
  }): Promise<
    | Res<
        200,
        {
          [key: string]: unknown
        }
      >
    | Res<302, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}?${this._query({
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateOrUpdateFileContents(p: {
    owner: string
    repo: string
    path: string
    requestBody: {
      author?: {
        date?: string
        email: string
        name: string
      }
      branch?: string
      committer?: {
        date?: string
        email: string
        name: string
      }
      content: string
      message: string
      sha?: string
    }
  }): Promise<
    | Res<200, t_file_commit>
    | Res<201, t_file_commit>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteFile(p: {
    owner: string
    repo: string
    path: string
    requestBody: {
      author?: {
        email?: string
        name?: string
      }
      branch?: string
      committer?: {
        email?: string
        name?: string
      }
      message: string
      sha: string
    }
  }): Promise<
    | Res<200, t_file_commit>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListContributors(p: {
    owner: string
    repo: string
    anon?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_contributor[]>
    | Res<204, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contributors?${this._query({
          anon: p["anon"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotListAlertsForRepo(p: {
    owner: string
    repo: string
    state?: string
    severity?: string
    ecosystem?: string
    package?: string
    manifest?: string
    scope?: "development" | "runtime"
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    page?: number
    perPage?: number
    before?: string
    after?: string
    first?: number
    last?: number
  }): Promise<
    | Res<200, t_dependabot_alert[]>
    | Res<304, void>
    | Res<400, t_scim_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts?${this._query({
          state: p["state"],
          severity: p["severity"],
          ecosystem: p["ecosystem"],
          package: p["package"],
          manifest: p["manifest"],
          scope: p["scope"],
          sort: p["sort"],
          direction: p["direction"],
          page: p["page"],
          per_page: p["perPage"],
          before: p["before"],
          after: p["after"],
          first: p["first"],
          last: p["last"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotGetAlert(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
  }): Promise<
    | Res<200, t_dependabot_alert>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts/${p["alertNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotUpdateAlert(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
    requestBody: {
      dismissed_comment?: string
      dismissed_reason?:
        | "fix_started"
        | "inaccurate"
        | "no_bandwidth"
        | "not_used"
        | "tolerable_risk"
      state: "dismissed" | "open"
    }
  }): Promise<
    | Res<200, t_dependabot_alert>
    | Res<400, t_scim_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts/${p["alertNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotListRepoSecrets(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_dependabot_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotGetRepoPublicKey(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_dependabot_public_key>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotGetRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
  }): Promise<Res<200, t_dependabot_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotCreateOrUpdateRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
    }
  }): Promise<Res<201, t_empty_object> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependabotDeleteRepoSecret(p: {
    owner: string
    repo: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependencyGraphDiffRange(p: {
    owner: string
    repo: string
    basehead: string
    name?: string
  }): Promise<
    | Res<200, t_dependency_graph_diff>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/compare/${
          p["basehead"]
        }?${this._query({ name: p["name"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async dependencyGraphCreateRepositorySnapshot(p: {
    owner: string
    repo: string
    requestBody: t_snapshot
  }): Promise<
    Res<
      201,
      {
        created_at: string
        id: number
        message: string
        result: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/snapshots`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListDeployments(p: {
    owner: string
    repo: string
    sha?: string
    ref?: string
    task?: string
    environment?: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_deployment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments?${this._query({
          sha: p["sha"],
          ref: p["ref"],
          task: p["task"],
          environment: p["environment"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDeployment(p: {
    owner: string
    repo: string
    requestBody: {
      auto_merge?: boolean
      description?: string | null
      environment?: string
      payload?: {
        [key: string]: unknown
      }
      production_environment?: boolean
      ref: string
      required_contexts?: string[]
      task?: string
      transient_environment?: boolean
    }
  }): Promise<
    | Res<201, t_deployment>
    | Res<
        202,
        {
          message?: string
        }
      >
    | Res<409, void>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/deployments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetDeployment(p: {
    owner: string
    repo: string
    deploymentId: number
  }): Promise<Res<200, t_deployment> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteDeployment(p: {
    owner: string
    repo: string
    deploymentId: number
  }): Promise<
    | Res<204, void>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListDeploymentStatuses(p: {
    owner: string
    repo: string
    deploymentId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_deployment_status[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${
          p["deploymentId"]
        }/statuses?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDeploymentStatus(p: {
    owner: string
    repo: string
    deploymentId: number
    requestBody: {
      auto_inactive?: boolean
      description?: string
      environment?: "production" | "staging" | "qa"
      environment_url?: string
      log_url?: string
      state:
        | "error"
        | "failure"
        | "inactive"
        | "in_progress"
        | "queued"
        | "pending"
        | "success"
      target_url?: string
    }
  }): Promise<Res<201, t_deployment_status> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetDeploymentStatus(p: {
    owner: string
    repo: string
    deploymentId: number
    statusId: number
  }): Promise<Res<200, t_deployment_status> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses/${p["statusId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDispatchEvent(p: {
    owner: string
    repo: string
    requestBody: {
      client_payload?: {
        [key: string]: unknown
      }
      event_type: string
    }
  }): Promise<Res<204, void> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/dispatches`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAllEnvironments(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        environments?: t_environment[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetEnvironment(p: {
    owner: string
    repo: string
    environmentName: string
  }): Promise<Res<200, t_environment>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateOrUpdateEnvironment(p: {
    owner: string
    repo: string
    environmentName: string
    requestBody?: {
      deployment_branch_policy: t_deployment_branch_policy_settings
      reviewers?:
        | {
            id?: number
            type: t_deployment_reviewer_type
          }[]
        | null
      wait_timer: t_wait_timer
    }
  }): Promise<Res<200, t_environment> | Res<422, t_basic_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteAnEnvironment(p: {
    owner: string
    repo: string
    environmentName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListDeploymentBranchPolicies(p: {
    owner: string
    repo: string
    environmentName: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        branch_policies: t_deployment_branch_policy[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${
          p["environmentName"]
        }/deployment-branch-policies?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDeploymentBranchPolicy(p: {
    owner: string
    repo: string
    environmentName: string
    requestBody: t_deployment_branch_policy_name_pattern
  }): Promise<
    Res<200, t_deployment_branch_policy> | Res<303, void> | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetDeploymentBranchPolicy(p: {
    owner: string
    repo: string
    environmentName: string
    branchPolicyId: number
  }): Promise<Res<200, t_deployment_branch_policy>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateDeploymentBranchPolicy(p: {
    owner: string
    repo: string
    environmentName: string
    branchPolicyId: number
    requestBody: t_deployment_branch_policy_name_pattern
  }): Promise<Res<200, t_deployment_branch_policy>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteDeploymentBranchPolicy(p: {
    owner: string
    repo: string
    environmentName: string
    branchPolicyId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListRepoEvents(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_event[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForks(p: {
    owner: string
    repo: string
    sort?: "newest" | "oldest" | "stargazers" | "watchers"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]> | Res<400, t_scim_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/forks?${this._query({
          sort: p["sort"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateFork(p: {
    owner: string
    repo: string
    requestBody?: {
      default_branch_only?: boolean
      name?: string
      organization?: string
    }
  }): Promise<
    | Res<202, t_full_repository>
    | Res<400, t_scim_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/forks`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateBlob(p: {
    owner: string
    repo: string
    requestBody: {
      content: string
      encoding?: string
    }
  }): Promise<
    | Res<201, t_short_blob>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/blobs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetBlob(p: {
    owner: string
    repo: string
    fileSha: string
  }): Promise<
    | Res<200, t_blob>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/blobs/${p["fileSha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateCommit(p: {
    owner: string
    repo: string
    requestBody: {
      author?: {
        date?: string
        email: string
        name: string
      }
      committer?: {
        date?: string
        email?: string
        name?: string
      }
      message: string
      parents?: string[]
      signature?: string
      tree: string
    }
  }): Promise<
    | Res<201, t_git_commit>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/commits`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetCommit(p: {
    owner: string
    repo: string
    commitSha: string
  }): Promise<Res<200, t_git_commit> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/commits/${p["commitSha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitListMatchingRefs(p: {
    owner: string
    repo: string
    ref: string
  }): Promise<Res<200, t_git_ref[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/matching-refs/${p["ref"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetRef(p: {
    owner: string
    repo: string
    ref: string
  }): Promise<Res<200, t_git_ref> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/ref/${p["ref"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateRef(p: {
    owner: string
    repo: string
    requestBody: {
      key?: string
      ref: string
      sha: string
    }
  }): Promise<Res<201, t_git_ref> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/refs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitUpdateRef(p: {
    owner: string
    repo: string
    ref: string
    requestBody: {
      force?: boolean
      sha: string
    }
  }): Promise<Res<200, t_git_ref> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitDeleteRef(p: {
    owner: string
    repo: string
    ref: string
  }): Promise<Res<204, void> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateTag(p: {
    owner: string
    repo: string
    requestBody: {
      message: string
      object: string
      tag: string
      tagger?: {
        date?: string
        email: string
        name: string
      }
      type: "commit" | "tree" | "blob"
    }
  }): Promise<Res<201, t_git_tag> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/tags`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetTag(p: {
    owner: string
    repo: string
    tagSha: string
  }): Promise<Res<200, t_git_tag> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/tags/${p["tagSha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateTree(p: {
    owner: string
    repo: string
    requestBody: {
      base_tree?: string
      tree: {
        content?: string
        mode?: "100644" | "100755" | "040000" | "160000" | "120000"
        path?: string
        sha?: string | null
        type?: "blob" | "tree" | "commit"
      }[]
    }
  }): Promise<
    | Res<201, t_git_tree>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/trees`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetTree(p: {
    owner: string
    repo: string
    treeSha: string
    recursive?: string
  }): Promise<
    | Res<200, t_git_tree>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/trees/${
          p["treeSha"]
        }?${this._query({ recursive: p["recursive"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListWebhooks(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_hook[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateWebhook(p: {
    owner: string
    repo: string
    requestBody?: {
      active?: boolean
      config?: {
        content_type: t_webhook_config_content_type
        digest?: string
        insecure_ssl: t_webhook_config_insecure_ssl
        secret: t_webhook_config_secret
        token?: string
        url: t_webhook_config_url
      }
      events?: string[]
      name?: string
    }
  }): Promise<
    | Res<201, t_hook>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/hooks`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetWebhook(p: {
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<200, t_hook> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateWebhook(p: {
    owner: string
    repo: string
    hookId: number
    requestBody: {
      active?: boolean
      add_events?: string[]
      config?: {
        address?: string
        content_type: t_webhook_config_content_type
        insecure_ssl: t_webhook_config_insecure_ssl
        room?: string
        secret: t_webhook_config_secret
        url: t_webhook_config_url
      }
      events?: string[]
      remove_events?: string[]
    }
  }): Promise<
    Res<200, t_hook> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteWebhook(p: {
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetWebhookConfigForRepo(p: {
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<200, t_webhook_config>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/config`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateWebhookConfigForRepo(p: {
    owner: string
    repo: string
    hookId: number
    requestBody?: {
      content_type: t_webhook_config_content_type
      insecure_ssl: t_webhook_config_insecure_ssl
      secret: t_webhook_config_secret
      url: t_webhook_config_url
    }
  }): Promise<Res<200, t_webhook_config>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/config`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListWebhookDeliveries(p: {
    owner: string
    repo: string
    hookId: number
    perPage?: number
    cursor?: string
    redelivery?: boolean
  }): Promise<
    | Res<200, t_hook_delivery_item[]>
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${
          p["hookId"]
        }/deliveries?${this._query({
          per_page: p["perPage"],
          cursor: p["cursor"],
          redelivery: p["redelivery"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetWebhookDelivery(p: {
    owner: string
    repo: string
    hookId: number
    deliveryId: number
  }): Promise<
    | Res<200, t_hook_delivery>
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRedeliverWebhookDelivery(p: {
    owner: string
    repo: string
    hookId: number
    deliveryId: number
  }): Promise<
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<400, t_scim_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}/attempts`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposPingWebhook(p: {
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/pings`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposTestPushWebhook(p: {
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/tests`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetImportStatus(p: {
    owner: string
    repo: string
  }): Promise<
    Res<200, t_import> | Res<404, t_basic_error> | Res<503, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsStartImport(p: {
    owner: string
    repo: string
    requestBody: {
      tfvc_project?: string
      vcs?: "subversion" | "git" | "mercurial" | "tfvc"
      vcs_password?: string
      vcs_url: string
      vcs_username?: string
    }
  }): Promise<
    | Res<201, t_import>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
    | Res<503, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsUpdateImport(p: {
    owner: string
    repo: string
    requestBody?: {
      tfvc_project?: string
      vcs?: "subversion" | "tfvc" | "git" | "mercurial"
      vcs_password?: string
      vcs_username?: string
    }
  }): Promise<Res<200, t_import> | Res<503, t_basic_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsCancelImport(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void> | Res<503, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetCommitAuthors(p: {
    owner: string
    repo: string
    since?: number
  }): Promise<
    | Res<200, t_porter_author[]>
    | Res<404, t_basic_error>
    | Res<503, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/import/authors?${this._query({
          since: p["since"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsMapCommitAuthor(p: {
    owner: string
    repo: string
    authorId: number
    requestBody?: {
      email?: string
      name?: string
    }
  }): Promise<
    | Res<200, t_porter_author>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
    | Res<503, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/import/authors/${p["authorId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetLargeFiles(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_porter_large_file[]> | Res<503, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/import/large_files`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsSetLfsPreference(p: {
    owner: string
    repo: string
    requestBody: {
      use_lfs: "opt_in" | "opt_out"
    }
  }): Promise<
    Res<200, t_import> | Res<422, t_validation_error> | Res<503, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import/lfs`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetRepoInstallation(p: {
    owner: string
    repo: string
  }): Promise<
    Res<200, t_installation> | Res<301, t_basic_error> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/installation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsGetRestrictionsForRepo(p: {
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        [key: string]: unknown
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsSetRestrictionsForRepo(p: {
    owner: string
    repo: string
    requestBody: t_interaction_limit
  }): Promise<Res<200, t_interaction_limit_response> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsRemoveRestrictionsForRepo(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListInvitations(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_repository_invitation[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateInvitation(p: {
    owner: string
    repo: string
    invitationId: number
    requestBody?: {
      permissions?: "read" | "write" | "maintain" | "triage" | "admin"
    }
  }): Promise<Res<200, t_repository_invitation>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteInvitation(p: {
    owner: string
    repo: string
    invitationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListForRepo(p: {
    owner: string
    repo: string
    milestone?: string
    state?: "open" | "closed" | "all"
    assignee?: string
    creator?: string
    mentioned?: string
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_issue[]>
    | Res<301, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues?${this._query({
          milestone: p["milestone"],
          state: p["state"],
          assignee: p["assignee"],
          creator: p["creator"],
          mentioned: p["mentioned"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreate(p: {
    owner: string
    repo: string
    requestBody: {
      assignee?: string | null
      assignees?: string[]
      body?: string
      labels?: {
        [key: string]: unknown
      }[]
      milestone?: {
        [key: string]: unknown
      } | null
      title: {
        [key: string]: unknown
      }
    }
  }): Promise<
    | Res<201, t_issue>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/issues`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListCommentsForRepo(p: {
    owner: string
    repo: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_issue_comment[]>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetComment(p: {
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<200, t_issue_comment> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdateComment(p: {
    owner: string
    repo: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<Res<200, t_issue_comment> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesDeleteComment(p: {
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForIssueComment(p: {
    owner: string
    repo: string
    commentId: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${
          p["commentId"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForIssueComment(p: {
    owner: string
    repo: string
    commentId: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForIssueComment(p: {
    owner: string
    repo: string
    commentId: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListEventsForRepo(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_issue_event[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetEvent(p: {
    owner: string
    repo: string
    eventId: number
  }): Promise<
    | Res<200, t_issue_event>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/events/${p["eventId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGet(p: {
    owner: string
    repo: string
    issueNumber: number
  }): Promise<
    | Res<200, t_issue>
    | Res<301, t_basic_error>
    | Res<304, void>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdate(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody?: {
      assignee?: string | null
      assignees?: string[]
      body?: string | null
      labels?: {
        [key: string]: unknown
      }[]
      milestone?: {
        [key: string]: unknown
      } | null
      state?: "open" | "closed"
      state_reason?: "completed" | "not_planned" | "reopened" | null
      title?: {
        [key: string]: unknown
      } | null
    }
  }): Promise<
    | Res<200, t_issue>
    | Res<301, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesAddAssignees(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody?: {
      assignees?: string[]
    }
  }): Promise<Res<201, t_issue>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesRemoveAssignees(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      assignees?: string[]
    }
  }): Promise<Res<200, t_issue>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCheckUserCanBeAssignedToIssue(p: {
    owner: string
    repo: string
    issueNumber: number
    assignee: string
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees/${p["assignee"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListComments(p: {
    owner: string
    repo: string
    issueNumber: number
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_issue_comment[]>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/comments?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreateComment(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      body: string
    }
  }): Promise<
    | Res<201, t_issue_comment>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListEvents(p: {
    owner: string
    repo: string
    issueNumber: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_issue_event_for_issue[]> | Res<410, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/events?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListLabelsOnIssue(p: {
    owner: string
    repo: string
    issueNumber: number
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_label[]>
    | Res<301, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/labels?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesAddLabels(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<
    | Res<200, t_label[]>
    | Res<301, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesSetLabels(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<
    | Res<200, t_label[]>
    | Res<301, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesRemoveAllLabels(p: {
    owner: string
    repo: string
    issueNumber: number
  }): Promise<
    | Res<204, void>
    | Res<301, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesRemoveLabel(p: {
    owner: string
    repo: string
    issueNumber: number
    name: string
  }): Promise<
    | Res<200, t_label[]>
    | Res<301, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesLock(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody?: {
      lock_reason?: "off-topic" | "too heated" | "resolved" | "spam"
    }
  }): Promise<
    | Res<204, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUnlock(p: {
    owner: string
    repo: string
    issueNumber: number
  }): Promise<
    Res<204, void> | Res<403, t_basic_error> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForIssue(p: {
    owner: string
    repo: string
    issueNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<200, t_reaction[]> | Res<404, t_basic_error> | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForIssue(p: {
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForIssue(p: {
    owner: string
    repo: string
    issueNumber: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListEventsForTimeline(p: {
    owner: string
    repo: string
    issueNumber: number
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_timeline_issue_events[]>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/timeline?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListDeployKeys(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_deploy_key[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDeployKey(p: {
    owner: string
    repo: string
    requestBody: {
      key: string
      read_only?: boolean
      title?: string
    }
  }): Promise<Res<201, t_deploy_key> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/keys`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetDeployKey(p: {
    owner: string
    repo: string
    keyId: number
  }): Promise<Res<200, t_deploy_key> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteDeployKey(p: {
    owner: string
    repo: string
    keyId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListLabelsForRepo(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_label[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreateLabel(p: {
    owner: string
    repo: string
    requestBody: {
      color?: string
      description?: string
      name: string
    }
  }): Promise<
    Res<201, t_label> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/labels`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetLabel(p: {
    owner: string
    repo: string
    name: string
  }): Promise<Res<200, t_label> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdateLabel(p: {
    owner: string
    repo: string
    name: string
    requestBody?: {
      color?: string
      description?: string
      new_name?: string
    }
  }): Promise<Res<200, t_label>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesDeleteLabel(p: {
    owner: string
    repo: string
    name: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListLanguages(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_language>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/languages`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposEnableLfsForRepo(p: { owner: string; repo: string }): Promise<
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<403, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/lfs`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDisableLfsForRepo(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/lfs`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async licensesGetForRepo(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_license_content>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/license`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposMergeUpstream(p: {
    owner: string
    repo: string
    requestBody: {
      branch: string
    }
  }): Promise<Res<200, t_merged_upstream> | Res<409, void> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/merge-upstream`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposMerge(p: {
    owner: string
    repo: string
    requestBody: {
      base: string
      commit_message?: string
      head: string
    }
  }): Promise<
    | Res<201, t_commit>
    | Res<204, void>
    | Res<403, t_basic_error>
    | Res<404, void>
    | Res<409, void>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/merges`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListMilestones(p: {
    owner: string
    repo: string
    state?: "open" | "closed" | "all"
    sort?: "due_on" | "completeness"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_milestone[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones?${this._query({
          state: p["state"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreateMilestone(p: {
    owner: string
    repo: string
    requestBody: {
      description?: string
      due_on?: string
      state?: "open" | "closed"
      title: string
    }
  }): Promise<
    | Res<201, t_milestone>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/milestones`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetMilestone(p: {
    owner: string
    repo: string
    milestoneNumber: number
  }): Promise<Res<200, t_milestone> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdateMilestone(p: {
    owner: string
    repo: string
    milestoneNumber: number
    requestBody?: {
      description?: string
      due_on?: string
      state?: "open" | "closed"
      title?: string
    }
  }): Promise<Res<200, t_milestone>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesDeleteMilestone(p: {
    owner: string
    repo: string
    milestoneNumber: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListLabelsForMilestone(p: {
    owner: string
    repo: string
    milestoneNumber: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_label[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${
          p["milestoneNumber"]
        }/labels?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListRepoNotificationsForAuthenticatedUser(p: {
    owner: string
    repo: string
    all?: boolean
    participating?: boolean
    since?: string
    before?: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_thread[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/notifications?${this._query({
          all: p["all"],
          participating: p["participating"],
          since: p["since"],
          before: p["before"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityMarkRepoNotificationsAsRead(p: {
    owner: string
    repo: string
    requestBody?: {
      last_read_at?: string
    }
  }): Promise<
    | Res<
        202,
        {
          message?: string
          url?: string
        }
      >
    | Res<205, void>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/notifications`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPages(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_page> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreatePagesSite(p: {
    owner: string
    repo: string
    requestBody: {
      build_type?: "legacy" | "workflow"
      source?: {
        branch: string
        path?: "/" | "/docs"
      }
    }
  }): Promise<
    Res<201, t_page> | Res<409, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateInformationAboutPagesSite(p: {
    owner: string
    repo: string
    requestBody: {
      build_type?: "legacy" | "workflow"
      cname?: string | null
      https_enforced?: boolean
      source?: {
        [key: string]: unknown
      }
    }
  }): Promise<
    | Res<204, void>
    | Res<400, t_scim_error>
    | Res<409, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeletePagesSite(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<204, void>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListPagesBuilds(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_page_build[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pages/builds?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRequestPagesBuild(p: {
    owner: string
    repo: string
  }): Promise<Res<201, t_page_build_status>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/builds`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetLatestPagesBuild(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_page_build>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pages/builds/latest`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPagesBuild(p: {
    owner: string
    repo: string
    buildId: number
  }): Promise<Res<200, t_page_build>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pages/builds/${p["buildId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreatePagesDeployment(p: {
    owner: string
    repo: string
    requestBody: {
      artifact_url: string
      environment?: string
      oidc_token: string
      pages_build_version: string
    }
  }): Promise<
    | Res<200, t_page_deployment>
    | Res<400, t_scim_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pages/deployment`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPagesHealthCheck(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<200, t_pages_health_check>
    | Res<202, t_empty_object>
    | Res<400, void>
    | Res<404, t_basic_error>
    | Res<422, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/health`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListForRepo(p: {
    owner: string
    repo: string
    state?: "open" | "closed" | "all"
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_project[]>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/projects?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateForRepo(p: {
    owner: string
    repo: string
    requestBody: {
      body?: string
      name: string
    }
  }): Promise<
    | Res<201, t_project>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<410, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/projects`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsList(p: {
    owner: string
    repo: string
    state?: "open" | "closed" | "all"
    head?: string
    base?: string
    sort?: "created" | "updated" | "popularity" | "long-running"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_pull_request_simple[]>
    | Res<304, void>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls?${this._query({
          state: p["state"],
          head: p["head"],
          base: p["base"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreate(p: {
    owner: string
    repo: string
    requestBody: {
      base: string
      body?: string
      draft?: boolean
      head: string
      issue?: number
      maintainer_can_modify?: boolean
      title?: string
    }
  }): Promise<
    | Res<201, t_pull_request>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pulls`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListReviewCommentsForRepo(p: {
    owner: string
    repo: string
    sort?: "created" | "updated" | "created_at"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_pull_request_review_comment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsGetReviewComment(p: {
    owner: string
    repo: string
    commentId: number
  }): Promise<
    Res<200, t_pull_request_review_comment> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdateReviewComment(p: {
    owner: string
    repo: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<Res<200, t_pull_request_review_comment>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsDeleteReviewComment(p: {
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<204, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForPullRequestReviewComment(p: {
    owner: string
    repo: string
    commentId: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${
          p["commentId"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForPullRequestReviewComment(p: {
    owner: string
    repo: string
    commentId: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForPullRequestComment(p: {
    owner: string
    repo: string
    commentId: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsGet(p: {
    owner: string
    repo: string
    pullNumber: number
  }): Promise<
    | Res<200, t_pull_request>
    | Res<304, void>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdate(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody?: {
      base?: string
      body?: string
      maintainer_can_modify?: boolean
      state?: "open" | "closed"
      title?: string
    }
  }): Promise<
    | Res<200, t_pull_request>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesCreateWithPrForAuthenticatedUser(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      client_ip?: string
      devcontainer_path?: string
      display_name?: string
      idle_timeout_minutes?: number
      location?: string
      machine?: string
      multi_repo_permissions_opt_out?: boolean
      retention_period_minutes?: number
      working_directory?: string
    }
  }): Promise<
    | Res<201, t_codespace>
    | Res<202, t_codespace>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/codespaces`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListReviewComments(p: {
    owner: string
    repo: string
    pullNumber: number
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_pull_request_review_comment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/comments?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreateReviewComment(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      body: string
      commit_id: string
      in_reply_to?: number
      line: number
      path: string
      position?: number
      side?: "LEFT" | "RIGHT"
      start_line?: number
      start_side?: "LEFT" | "RIGHT" | "side"
    }
  }): Promise<
    | Res<201, t_pull_request_review_comment>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreateReplyForReviewComment(p: {
    owner: string
    repo: string
    pullNumber: number
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<201, t_pull_request_review_comment> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments/${p["commentId"]}/replies`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListCommits(p: {
    owner: string
    repo: string
    pullNumber: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_commit[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/commits?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListFiles(p: {
    owner: string
    repo: string
    pullNumber: number
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_diff_entry[]>
    | Res<422, t_validation_error>
    | Res<500, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/files?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCheckIfMerged(p: {
    owner: string
    repo: string
    pullNumber: number
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsMerge(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody?: {
      commit_message?: string
      commit_title?: string
      merge_method?: "merge" | "squash" | "rebase"
      sha?: string
    }
  }): Promise<
    | Res<200, t_pull_request_merge_result>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        405,
        {
          documentation_url?: string
          message?: string
        }
      >
    | Res<
        409,
        {
          documentation_url?: string
          message?: string
        }
      >
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListRequestedReviewers(p: {
    owner: string
    repo: string
    pullNumber: number
  }): Promise<Res<200, t_pull_request_review_request>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsRequestReviewers(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody?: {
      reviewers?: string[]
      team_reviewers?: string[]
    }
  }): Promise<
    Res<201, t_pull_request_simple> | Res<403, t_basic_error> | Res<422, void>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsRemoveRequestedReviewers(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      reviewers: string[]
      team_reviewers?: string[]
    }
  }): Promise<Res<200, t_pull_request_simple> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListReviews(p: {
    owner: string
    repo: string
    pullNumber: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_pull_request_review[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/reviews?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreateReview(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody?: {
      body?: string
      comments?: {
        body: string
        line?: number
        path: string
        position?: number
        side?: string
        start_line?: number
        start_side?: string
      }[]
      commit_id?: string
      event?: "APPROVE" | "REQUEST_CHANGES" | "COMMENT"
    }
  }): Promise<
    | Res<200, t_pull_request_review>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsGetReview(p: {
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
  }): Promise<Res<200, t_pull_request_review> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdateReview(p: {
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<200, t_pull_request_review> | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsDeletePendingReview(p: {
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
  }): Promise<
    | Res<200, t_pull_request_review>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListCommentsForReview(p: {
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_review_comment[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${
          p["reviewId"]
        }/comments?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsDismissReview(p: {
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    requestBody: {
      event?: "DISMISS"
      message: string
    }
  }): Promise<
    | Res<200, t_pull_request_review>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/dismissals`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsSubmitReview(p: {
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    requestBody: {
      body?: string
      event: "APPROVE" | "REQUEST_CHANGES" | "COMMENT"
    }
  }): Promise<
    | Res<200, t_pull_request_review>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/events`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdateBranch(p: {
    owner: string
    repo: string
    pullNumber: number
    requestBody?: {
      expected_head_sha?: string
    }
  }): Promise<
    | Res<
        202,
        {
          message?: string
          url?: string
        }
      >
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/update-branch`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetReadme(p: {
    owner: string
    repo: string
    ref?: string
  }): Promise<
    | Res<200, t_content_file>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/readme?${this._query({
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetReadmeInDirectory(p: {
    owner: string
    repo: string
    dir: string
    ref?: string
  }): Promise<
    | Res<200, t_content_file>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/readme/${p["dir"]}?${this._query({
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListReleases(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_release[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateRelease(p: {
    owner: string
    repo: string
    requestBody: {
      body?: string
      discussion_category_name?: string
      draft?: boolean
      generate_release_notes?: boolean
      make_latest?: "true" | "false" | "legacy"
      name?: string
      prerelease?: boolean
      tag_name: string
      target_commitish?: string
    }
  }): Promise<
    Res<201, t_release> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/releases`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetReleaseAsset(p: {
    owner: string
    repo: string
    assetId: number
  }): Promise<
    Res<200, t_release_asset> | Res<302, void> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateReleaseAsset(p: {
    owner: string
    repo: string
    assetId: number
    requestBody?: {
      label?: string
      name?: string
      state?: string
    }
  }): Promise<Res<200, t_release_asset>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteReleaseAsset(p: {
    owner: string
    repo: string
    assetId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGenerateReleaseNotes(p: {
    owner: string
    repo: string
    requestBody: {
      configuration_file_path?: string
      previous_tag_name?: string
      tag_name: string
      target_commitish?: string
    }
  }): Promise<Res<200, t_release_notes_content> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/generate-notes`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetLatestRelease(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_release>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/latest`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetReleaseByTag(p: {
    owner: string
    repo: string
    tag: string
  }): Promise<Res<200, t_release> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/tags/${p["tag"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetRelease(p: {
    owner: string
    repo: string
    releaseId: number
  }): Promise<Res<200, t_release> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateRelease(p: {
    owner: string
    repo: string
    releaseId: number
    requestBody?: {
      body?: string
      discussion_category_name?: string
      draft?: boolean
      make_latest?: "true" | "false" | "legacy"
      name?: string
      prerelease?: boolean
      tag_name?: string
      target_commitish?: string
    }
  }): Promise<Res<200, t_release> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteRelease(p: {
    owner: string
    repo: string
    releaseId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListReleaseAssets(p: {
    owner: string
    repo: string
    releaseId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_release_asset[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${
          p["releaseId"]
        }/assets?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUploadReleaseAsset(p: {
    owner: string
    repo: string
    releaseId: number
    name: string
    label?: string
    requestBody?: string
  }): Promise<Res<201, t_release_asset> | Res<422, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "*/*",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${
          p["releaseId"]
        }/assets?${this._query({ name: p["name"], label: p["label"] })}`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForRelease(p: {
    owner: string
    repo: string
    releaseId: number
    content?: "+1" | "laugh" | "heart" | "hooray" | "rocket" | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${
          p["releaseId"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForRelease(p: {
    owner: string
    repo: string
    releaseId: number
    requestBody: {
      content: "+1" | "laugh" | "heart" | "hooray" | "rocket" | "eyes"
    }
  }): Promise<
    Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForRelease(p: {
    owner: string
    repo: string
    releaseId: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningListAlertsForRepo(p: {
    owner: string
    repo: string
    state?: "open" | "resolved"
    secretType?: string
    resolution?: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    page?: number
    perPage?: number
    before?: string
    after?: string
  }): Promise<
    | Res<200, t_secret_scanning_alert[]>
    | Res<404, void>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts?${this._query(
          {
            state: p["state"],
            secret_type: p["secretType"],
            resolution: p["resolution"],
            sort: p["sort"],
            direction: p["direction"],
            page: p["page"],
            per_page: p["perPage"],
            before: p["before"],
            after: p["after"],
          }
        )}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningGetAlert(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
  }): Promise<
    | Res<200, t_secret_scanning_alert>
    | Res<304, void>
    | Res<404, void>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningUpdateAlert(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
    requestBody: {
      resolution: t_secret_scanning_alert_resolution
      resolution_comment: t_secret_scanning_alert_resolution_comment
      state: t_secret_scanning_alert_state
    }
  }): Promise<
    | Res<200, t_secret_scanning_alert>
    | Res<400, void>
    | Res<404, void>
    | Res<422, void>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async secretScanningListLocationsForAlert(p: {
    owner: string
    repo: string
    alertNumber: t_alert_number
    page?: number
    perPage?: number
  }): Promise<
    | Res<200, t_secret_scanning_location[]>
    | Res<404, void>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${
          p["alertNumber"]
        }/locations?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListStargazersForRepo(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          [key: string]: unknown
        }
      >
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stargazers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCodeFrequencyStats(p: { owner: string; repo: string }): Promise<
    | Res<200, t_code_frequency_stat[]>
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<204, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/code_frequency`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommitActivityStats(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<200, t_commit_activity[]>
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<204, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/commit_activity`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetContributorsStats(p: { owner: string; repo: string }): Promise<
    | Res<200, t_contributor_activity[]>
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<204, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/contributors`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetParticipationStats(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_participation_stats> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/participation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPunchCardStats(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_code_frequency_stat[]> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/punch_card`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateCommitStatus(p: {
    owner: string
    repo: string
    sha: string
    requestBody: {
      context?: string
      description?: string | null
      state: "error" | "failure" | "pending" | "success"
      target_url?: string | null
    }
  }): Promise<Res<201, t_status>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/statuses/${p["sha"]}`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListWatchersForRepo(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/subscribers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetRepoSubscription(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<200, t_repository_subscription>
    | Res<403, t_basic_error>
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activitySetRepoSubscription(p: {
    owner: string
    repo: string
    requestBody?: {
      ignored?: boolean
      subscribed?: boolean
    }
  }): Promise<Res<200, t_repository_subscription>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityDeleteRepoSubscription(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListTags(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_tag[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/tags?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListTagProtection(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<200, t_tag_protection[]>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/tags/protection`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateTagProtection(p: {
    owner: string
    repo: string
    requestBody: {
      pattern: string
    }
  }): Promise<
    | Res<201, t_tag_protection>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/tags/protection`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteTagProtection(p: {
    owner: string
    repo: string
    tagProtectionId: number
  }): Promise<
    Res<204, void> | Res<403, t_basic_error> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/tags/protection/${p["tagProtectionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDownloadTarballArchive(p: {
    owner: string
    repo: string
    ref: string
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/tarball/${p["ref"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListTeams(p: {
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAllTopics(p: {
    owner: string
    repo: string
    page?: number
    perPage?: number
  }): Promise<Res<200, t_topic> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/topics?${this._query({
          page: p["page"],
          per_page: p["perPage"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposReplaceAllTopics(p: {
    owner: string
    repo: string
    requestBody: {
      names: string[]
    }
  }): Promise<
    | Res<200, t_topic>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/topics`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetClones(p: {
    owner: string
    repo: string
    per?: "" | "day" | "week"
  }): Promise<Res<200, t_clone_traffic> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/clones?${this._query({
          per: p["per"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetTopPaths(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_content_traffic[]> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/paths`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetTopReferrers(p: {
    owner: string
    repo: string
  }): Promise<Res<200, t_referrer_traffic[]> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/referrers`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetViews(p: {
    owner: string
    repo: string
    per?: "" | "day" | "week"
  }): Promise<Res<200, t_view_traffic> | Res<403, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/views?${this._query({
          per: p["per"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposTransfer(p: {
    owner: string
    repo: string
    requestBody: {
      new_name?: string
      new_owner: string
      team_ids?: number[]
    }
  }): Promise<Res<202, t_minimal_repository>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/transfer`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCheckVulnerabilityAlerts(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposEnableVulnerabilityAlerts(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDisableVulnerabilityAlerts(p: {
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDownloadZipballArchive(p: {
    owner: string
    repo: string
    ref: string
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/zipball/${p["ref"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateUsingTemplate(p: {
    templateOwner: string
    templateRepo: string
    requestBody: {
      description?: string
      include_all_branches?: boolean
      name: string
      owner?: string
      private?: boolean
    }
  }): Promise<Res<201, t_repository>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["templateOwner"]}/${p["templateRepo"]}/generate`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListPublic(p: {
    since?: number
  }): Promise<
    | Res<200, t_minimal_repository[]>
    | Res<304, void>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories?${this._query({ since: p["since"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListEnvironmentSecrets(p: {
    repositoryId: number
    environmentName: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_actions_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${
          p["environmentName"]
        }/secrets?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetEnvironmentPublicKey(p: {
    repositoryId: number
    environmentName: string
  }): Promise<Res<200, t_actions_public_key>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetEnvironmentSecret(p: {
    repositoryId: number
    environmentName: string
    secretName: string
  }): Promise<Res<200, t_actions_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateOrUpdateEnvironmentSecret(p: {
    repositoryId: number
    environmentName: string
    secretName: string
    requestBody: {
      encrypted_value: string
      key_id: string
    }
  }): Promise<Res<201, t_empty_object> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteEnvironmentSecret(p: {
    repositoryId: number
    environmentName: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListEnvironmentVariables(p: {
    repositoryId: number
    environmentName: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        total_count: number
        variables: t_actions_variable[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${
          p["environmentName"]
        }/variables?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateEnvironmentVariable(p: {
    repositoryId: number
    environmentName: string
    requestBody: {
      name: string
      value: string
    }
  }): Promise<Res<201, t_empty_object>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/variables`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetEnvironmentVariable(p: {
    repositoryId: number
    environmentName: string
    name: string
  }): Promise<Res<200, t_actions_variable>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/variables/${p["name"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsUpdateEnvironmentVariable(p: {
    repositoryId: number
    environmentName: string
    name: string
    requestBody: {
      name?: string
      value?: string
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/variables/${p["name"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteEnvironmentVariable(p: {
    repositoryId: number
    environmentName: string
    name: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/repositories/${p["repositoryId"]}/environments/${p["environmentName"]}/variables/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchCode(p: {
    q: string
    sort?: "indexed"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          incomplete_results: boolean
          items: t_code_search_result_item[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/search/code?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchCommits(p: {
    q: string
    sort?: "author-date" | "committer-date"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          incomplete_results: boolean
          items: t_commit_search_result_item[]
          total_count: number
        }
      >
    | Res<304, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/search/commits?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchIssuesAndPullRequests(p: {
    q: string
    sort?:
      | "comments"
      | "reactions"
      | "reactions-+1"
      | "reactions--1"
      | "reactions-smile"
      | "reactions-thinking_face"
      | "reactions-heart"
      | "reactions-tada"
      | "interactions"
      | "created"
      | "updated"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          incomplete_results: boolean
          items: t_issue_search_result_item[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/search/issues?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchLabels(p: {
    repositoryId: number
    q: string
    sort?: "created" | "updated"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          incomplete_results: boolean
          items: t_label_search_result_item[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/search/labels?${this._query({
          repository_id: p["repositoryId"],
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchRepos(p: {
    q: string
    sort?: "stars" | "forks" | "help-wanted-issues" | "updated"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          incomplete_results: boolean
          items: t_repo_search_result_item[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/search/repositories?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchTopics(p: {
    q: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          incomplete_results: boolean
          items: t_topic_search_result_item[]
          total_count: number
        }
      >
    | Res<304, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/search/topics?${this._query({
          q: p["q"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchUsers(p: {
    q: string
    sort?: "followers" | "repositories" | "joined"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          incomplete_results: boolean
          items: t_user_search_result_item[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<422, t_validation_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/search/users?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetLegacy(p: {
    teamId: number
  }): Promise<Res<200, t_team_full> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/teams/${p["teamId"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateLegacy(p: {
    teamId: number
    requestBody: {
      description?: string
      name: string
      parent_team_id?: number | null
      permission?: "pull" | "push" | "admin"
      privacy?: "secret" | "closed"
    }
  }): Promise<
    | Res<200, t_team_full>
    | Res<201, t_team_full>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/teams/${p["teamId"]}`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteLegacy(p: {
    teamId: number
  }): Promise<
    Res<204, void> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/teams/${p["teamId"]}`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionsLegacy(p: {
    teamId: number
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team_discussion[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionLegacy(p: {
    teamId: number
    requestBody: {
      body: string
      private?: boolean
      title: string
    }
  }): Promise<Res<201, t_team_discussion>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/discussions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionLegacy(p: {
    teamId: number
    discussionNumber: number
  }): Promise<Res<200, t_team_discussion>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionLegacy(p: {
    teamId: number
    discussionNumber: number
    requestBody?: {
      body?: string
      title?: string
    }
  }): Promise<Res<200, t_team_discussion>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionLegacy(p: {
    teamId: number
    discussionNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionCommentsLegacy(p: {
    teamId: number
    discussionNumber: number
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team_discussion_comment[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${
          p["discussionNumber"]
        }/comments?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionCommentLegacy(p: {
    teamId: number
    discussionNumber: number
    requestBody: {
      body: string
    }
  }): Promise<Res<201, t_team_discussion_comment>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionCommentLegacy(p: {
    teamId: number
    discussionNumber: number
    commentNumber: number
  }): Promise<Res<200, t_team_discussion_comment>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionCommentLegacy(p: {
    teamId: number
    discussionNumber: number
    commentNumber: number
    requestBody: {
      body: string
    }
  }): Promise<Res<200, t_team_discussion_comment>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionCommentLegacy(p: {
    teamId: number
    discussionNumber: number
    commentNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionCommentLegacy(p: {
    teamId: number
    discussionNumber: number
    commentNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${
          p["commentNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionCommentLegacy(p: {
    teamId: number
    discussionNumber: number
    commentNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<Res<201, t_reaction>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionLegacy(p: {
    teamId: number
    discussionNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_reaction[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${
          p["discussionNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionLegacy(p: {
    teamId: number
    discussionNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<Res<201, t_reaction>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListPendingInvitationsLegacy(p: {
    teamId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_organization_invitation[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListMembersLegacy(p: {
    teamId: number
    role?: "member" | "maintainer" | "all"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/members?${this._query({
          role: p["role"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetMemberLegacy(p: {
    teamId: number
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddMemberLegacy(p: {
    teamId: number
    username: string
  }): Promise<
    Res<204, void> | Res<403, t_basic_error> | Res<404, void> | Res<422, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveMemberLegacy(p: {
    teamId: number
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetMembershipForUserLegacy(p: {
    teamId: number
    username: string
  }): Promise<Res<200, t_team_membership> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/memberships/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateMembershipForUserLegacy(p: {
    teamId: number
    username: string
    requestBody?: {
      role?: "member" | "maintainer"
    }
  }): Promise<
    | Res<200, t_team_membership>
    | Res<403, void>
    | Res<404, t_basic_error>
    | Res<422, void>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/memberships/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveMembershipForUserLegacy(p: {
    teamId: number
    username: string
  }): Promise<Res<204, void> | Res<403, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/memberships/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListProjectsLegacy(p: {
    teamId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_team_project[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/projects?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForProjectLegacy(p: {
    teamId: number
    projectId: number
  }): Promise<Res<200, t_team_project> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateProjectPermissionsLegacy(p: {
    teamId: number
    projectId: number
    requestBody?: {
      permission?: "read" | "write" | "admin"
    }
  }): Promise<
    | Res<204, void>
    | Res<
        403,
        {
          documentation_url?: string
          message?: string
        }
      >
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveProjectLegacy(p: {
    teamId: number
    projectId: number
  }): Promise<
    Res<204, void> | Res<404, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListReposLegacy(p: {
    teamId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForRepoLegacy(p: {
    teamId: number
    owner: string
    repo: string
  }): Promise<Res<200, t_team_repository> | Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateRepoPermissionsLegacy(p: {
    teamId: number
    owner: string
    repo: string
    requestBody?: {
      permission?: "pull" | "push" | "admin"
    }
  }): Promise<
    Res<204, void> | Res<403, t_basic_error> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveRepoLegacy(p: {
    teamId: number
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListChildLegacy(p: {
    teamId: number
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_team[]>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetAuthenticated(): Promise<
    | Res<
        200,
        {
          [key: string]: unknown
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/user`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersUpdateAuthenticated(p: {
    requestBody?: {
      bio?: string
      blog?: string
      company?: string
      email?: string
      hireable?: boolean
      location?: string
      name?: string
      twitter_username?: string | null
    }
  }): Promise<
    | Res<200, t_private_user>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListBlockedByAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_simple_user[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/blocks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCheckBlocked(p: {
    username: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/blocks/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersBlock(p: {
    username: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/blocks/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersUnblock(p: {
    username: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/blocks/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListForAuthenticatedUser(p: {
    perPage?: number
    page?: number
    repositoryId?: number
  }): Promise<
    | Res<
        200,
        {
          codespaces: t_codespace[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/codespaces?${this._query({
          per_page: p["perPage"],
          page: p["page"],
          repository_id: p["repositoryId"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesCreateForAuthenticatedUser(p: {
    requestBody: {
      [key: string]: unknown
    }
  }): Promise<
    | Res<201, t_codespace>
    | Res<202, t_codespace>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<
        503,
        {
          code?: string
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/codespaces`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListSecretsForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets: t_codespaces_secret[]
        total_count: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/codespaces/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetPublicKeyForAuthenticatedUser(): Promise<
    Res<200, t_codespaces_user_public_key>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetSecretForAuthenticatedUser(p: {
    secretName: string
  }): Promise<Res<200, t_codespaces_secret>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesCreateOrUpdateSecretForAuthenticatedUser(p: {
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id: string
      selected_repository_ids?: string[]
    }
  }): Promise<
    | Res<201, t_empty_object>
    | Res<204, void>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/user/codespaces/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesDeleteSecretForAuthenticatedUser(p: {
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesListRepositoriesForSecretForAuthenticatedUser(p: {
    secretName: string
  }): Promise<
    | Res<
        200,
        {
          repositories: t_minimal_repository[]
          total_count: number
        }
      >
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/codespaces/secrets/${p["secretName"]}/repositories`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesSetRepositoriesForSecretForAuthenticatedUser(p: {
    secretName: string
    requestBody: {
      selected_repository_ids: number[]
    }
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath +
        `/user/codespaces/secrets/${p["secretName"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesAddRepositoryForSecretForAuthenticatedUser(p: {
    secretName: string
    repositoryId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesRemoveRepositoryForSecretForAuthenticatedUser(p: {
    secretName: string
    repositoryId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetForAuthenticatedUser(p: {
    codespaceName: string
  }): Promise<
    | Res<200, t_codespace>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesUpdateForAuthenticatedUser(p: {
    codespaceName: string
    requestBody?: {
      display_name?: string
      machine?: string
      recent_folders?: string[]
    }
  }): Promise<
    | Res<200, t_codespace>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesDeleteForAuthenticatedUser(p: {
    codespaceName: string
  }): Promise<
    | Res<
        202,
        {
          [key: string]: unknown
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesExportForAuthenticatedUser(p: {
    codespaceName: string
  }): Promise<
    | Res<202, t_codespace_export_details>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}/exports`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesGetExportDetailsForAuthenticatedUser(p: {
    codespaceName: string
    exportId: string
  }): Promise<Res<200, t_codespace_export_details> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/codespaces/${p["codespaceName"]}/exports/${p["exportId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesCodespaceMachinesForAuthenticatedUser(p: {
    codespaceName: string
  }): Promise<
    | Res<
        200,
        {
          machines: t_codespace_machine[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}/machines`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesPublishForAuthenticatedUser(p: {
    codespaceName: string
    requestBody: {
      name?: string
      private?: boolean
    }
  }): Promise<
    | Res<201, t_codespace_with_full_repository>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}/publish`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesStartForAuthenticatedUser(p: {
    codespaceName: string
  }): Promise<
    | Res<200, t_codespace>
    | Res<304, void>
    | Res<400, t_scim_error>
    | Res<401, t_basic_error>
    | Res<402, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}/start`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codespacesStopForAuthenticatedUser(p: {
    codespaceName: string
  }): Promise<
    | Res<200, t_codespace>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<500, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/codespaces/${p["codespaceName"]}/stop`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersSetPrimaryEmailVisibilityForAuthenticatedUser(p: {
    requestBody: {
      visibility: "public" | "private"
    }
  }): Promise<
    | Res<200, t_email[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/email/visibility`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListEmailsForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_email[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/emails?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersAddEmailForAuthenticatedUser(p: {
    requestBody?: {
      [key: string]: unknown
    }
  }): Promise<
    | Res<201, t_email[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/emails`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersDeleteEmailForAuthenticatedUser(p: {
    requestBody: {
      [key: string]: unknown
    }
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/emails`, {
      method: "DELETE",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowersForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_simple_user[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/followers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowedByAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_simple_user[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/following?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCheckPersonIsFollowedByAuthenticated(p: {
    username: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/following/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersFollow(p: {
    username: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/following/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersUnfollow(p: {
    username: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/following/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListGpgKeysForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_gpg_key[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/gpg_keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCreateGpgKeyForAuthenticatedUser(p: {
    requestBody: {
      armored_public_key: string
      name?: string
    }
  }): Promise<
    | Res<201, t_gpg_key>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/gpg_keys`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetGpgKeyForAuthenticatedUser(p: {
    gpgKeyId: number
  }): Promise<
    | Res<200, t_gpg_key>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/gpg_keys/${p["gpgKeyId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersDeleteGpgKeyForAuthenticatedUser(p: {
    gpgKeyId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/gpg_keys/${p["gpgKeyId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListInstallationsForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          installations: t_installation[]
          total_count: number
        }
      >
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/installations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListInstallationReposForAuthenticatedUser(p: {
    installationId: number
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          repositories: t_repository[]
          repository_selection?: string
          total_count: number
        }
      >
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/installations/${p["installationId"]}/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsAddRepoToInstallationForAuthenticatedUser(p: {
    installationId: number
    repositoryId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsRemoveRepoFromInstallationForAuthenticatedUser(p: {
    installationId: number
    repositoryId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsGetRestrictionsForAuthenticatedUser(): Promise<
    | Res<
        200,
        {
          [key: string]: unknown
        }
      >
    | Res<204, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/user/interaction-limits`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsSetRestrictionsForAuthenticatedUser(p: {
    requestBody: t_interaction_limit
  }): Promise<
    Res<200, t_interaction_limit_response> | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/interaction-limits`, {
      method: "PUT",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsRemoveRestrictionsForAuthenticatedUser(): Promise<
    Res<204, void>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/user/interaction-limits`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListForAuthenticatedUser(p: {
    filter?:
      | "assigned"
      | "created"
      | "mentioned"
      | "subscribed"
      | "repos"
      | "all"
    state?: "open" | "closed" | "all"
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_issue[]> | Res<304, void> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/issues?${this._query({
          filter: p["filter"],
          state: p["state"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListPublicSshKeysForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_key[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCreatePublicSshKeyForAuthenticatedUser(p: {
    requestBody: {
      key: string
      title?: string
    }
  }): Promise<
    | Res<201, t_key>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/keys`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetPublicSshKeyForAuthenticatedUser(p: {
    keyId: number
  }): Promise<
    | Res<200, t_key>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/user/keys/${p["keyId"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersDeletePublicSshKeyForAuthenticatedUser(p: {
    keyId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/user/keys/${p["keyId"]}`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListSubscriptionsForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_user_marketplace_purchase[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/marketplace_purchases?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListSubscriptionsForAuthenticatedUserStubbed(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_user_marketplace_purchase[]>
    | Res<304, void>
    | Res<401, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/marketplace_purchases/stubbed?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListMembershipsForAuthenticatedUser(p: {
    state?: "active" | "pending"
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_org_membership[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/memberships/orgs?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetMembershipForAuthenticatedUser(p: {
    org: string
  }): Promise<
    | Res<200, t_org_membership>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/memberships/orgs/${p["org"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUpdateMembershipForAuthenticatedUser(p: {
    org: string
    requestBody: {
      state: "active"
    }
  }): Promise<
    | Res<200, t_org_membership>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(
      this.config.basePath + `/user/memberships/orgs/${p["org"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_migration[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/migrations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsStartForAuthenticatedUser(p: {
    requestBody: {
      exclude?: "repositories"[]
      exclude_attachments?: boolean
      exclude_git_data?: boolean
      exclude_metadata?: boolean
      exclude_owner_projects?: boolean
      exclude_releases?: boolean
      lock_repositories?: boolean
      org_metadata_only?: boolean
      repositories: string[]
    }
  }): Promise<
    | Res<201, t_migration>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/migrations`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetStatusForAuthenticatedUser(p: {
    migrationId: number
    exclude?: string[]
  }): Promise<
    | Res<200, t_migration>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/migrations/${p["migrationId"]}?${this._query({
          exclude: p["exclude"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetArchiveForAuthenticatedUser(p: {
    migrationId: number
  }): Promise<
    | Res<302, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/migrations/${p["migrationId"]}/archive`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsDeleteArchiveForAuthenticatedUser(p: {
    migrationId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/migrations/${p["migrationId"]}/archive`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsUnlockRepoForAuthenticatedUser(p: {
    migrationId: number
    repoName: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListReposForAuthenticatedUser(p: {
    migrationId: number
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]> | Res<404, t_basic_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/migrations/${p["migrationId"]}/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_organization_simple[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/orgs?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesListPackagesForAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    visibility?: "public" | "private" | "internal"
  }): Promise<Res<200, t_package[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages?${this._query({
          package_type: p["packageType"],
          visibility: p["visibility"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetPackageForAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
  }): Promise<Res<200, t_package>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages/${p["packageType"]}/${p["packageName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesDeletePackageForAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages/${p["packageType"]}/${p["packageName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesRestorePackageForAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    token?: string
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages/${p["packageType"]}/${
          p["packageName"]
        }/restore?${this._query({ token: p["token"] })}`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    page?: number
    perPage?: number
    state?: "active" | "deleted"
  }): Promise<
    | Res<200, t_package_version[]>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages/${p["packageType"]}/${
          p["packageName"]
        }/versions?${this._query({
          page: p["page"],
          per_page: p["perPage"],
          state: p["state"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetPackageVersionForAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    packageVersionId: number
  }): Promise<Res<200, t_package_version>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesDeletePackageVersionForAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    packageVersionId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesRestorePackageVersionForAuthenticatedUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    packageVersionId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateForAuthenticatedUser(p: {
    requestBody: {
      body?: string | null
      name: string
    }
  }): Promise<
    | Res<201, t_project>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error_simple>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/projects`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListPublicEmailsForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_email[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/public_emails?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForAuthenticatedUser(p: {
    visibility?: "all" | "public" | "private"
    affiliation?: string
    type?: "all" | "owner" | "public" | "private" | "member"
    sort?: "created" | "updated" | "pushed" | "full_name"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
    since?: string
    before?: string
  }): Promise<
    | Res<200, t_repository[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/repos?${this._query({
          visibility: p["visibility"],
          affiliation: p["affiliation"],
          type: p["type"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
          since: p["since"],
          before: p["before"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateForAuthenticatedUser(p: {
    requestBody: {
      allow_auto_merge?: boolean
      allow_merge_commit?: boolean
      allow_rebase_merge?: boolean
      allow_squash_merge?: boolean
      auto_init?: boolean
      delete_branch_on_merge?: boolean
      description?: string
      gitignore_template?: string
      has_discussions?: boolean
      has_downloads?: boolean
      has_issues?: boolean
      has_projects?: boolean
      has_wiki?: boolean
      homepage?: string
      is_template?: boolean
      license_template?: string
      merge_commit_message?: "PR_BODY" | "PR_TITLE" | "BLANK"
      merge_commit_title?: "PR_TITLE" | "MERGE_MESSAGE"
      name: string
      private?: boolean
      squash_merge_commit_message?: "PR_BODY" | "COMMIT_MESSAGES" | "BLANK"
      squash_merge_commit_title?: "PR_TITLE" | "COMMIT_OR_PR_TITLE"
      team_id?: number
    }
  }): Promise<
    | Res<201, t_repository>
    | Res<304, void>
    | Res<400, t_scim_error>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/repos`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListInvitationsForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_repository_invitation[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/repository_invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAcceptInvitationForAuthenticatedUser(p: {
    invitationId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/repository_invitations/${p["invitationId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeclineInvitationForAuthenticatedUser(p: {
    invitationId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<409, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/repository_invitations/${p["invitationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListSshSigningKeysForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_ssh_signing_key[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/ssh_signing_keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCreateSshSigningKeyForAuthenticatedUser(p: {
    requestBody: {
      key: string
      title?: string
    }
  }): Promise<
    | Res<201, t_ssh_signing_key>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
    }

    const res = await fetch(this.config.basePath + `/user/ssh_signing_keys`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetSshSigningKeyForAuthenticatedUser(p: {
    sshSigningKeyId: number
  }): Promise<
    | Res<200, t_ssh_signing_key>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/ssh_signing_keys/${p["sshSigningKeyId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersDeleteSshSigningKeyForAuthenticatedUser(p: {
    sshSigningKeyId: number
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/ssh_signing_keys/${p["sshSigningKeyId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReposStarredByAuthenticatedUser(p: {
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_starred_repository[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/starred?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityCheckRepoIsStarredByAuthenticatedUser(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityStarRepoForAuthenticatedUser(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityUnstarRepoForAuthenticatedUser(p: {
    owner: string
    repo: string
  }): Promise<
    | Res<204, void>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListWatchedReposForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_minimal_repository[]>
    | Res<304, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/subscriptions?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListForAuthenticatedUser(p: {
    perPage?: number
    page?: number
  }): Promise<
    | Res<200, t_team_full[]>
    | Res<304, void>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/user/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersList(p: {
    since?: number
    perPage?: number
  }): Promise<Res<200, t_simple_user[]> | Res<304, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users?${this._query({ since: p["since"], per_page: p["perPage"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetByUsername(p: { username: string }): Promise<
    | Res<
        200,
        {
          [key: string]: unknown
        }
      >
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/users/${p["username"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListEventsForAuthenticatedUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_event[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListOrgEventsForAuthenticatedUser(p: {
    username: string
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_event[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/events/orgs/${p["org"]}?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicEventsForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_event[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/events/public?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowersForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/followers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowingForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_simple_user[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/following?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCheckFollowingForUser(p: {
    username: string
    targetUser: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/following/${p["targetUser"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListForUser(p: {
    username: string
    since?: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_base_gist[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/gists?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListGpgKeysForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_gpg_key[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/gpg_keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetContextForUser(p: {
    username: string
    subjectType?: "organization" | "repository" | "issue" | "pull_request"
    subjectId?: string
  }): Promise<
    | Res<200, t_hovercard>
    | Res<404, t_basic_error>
    | Res<422, t_validation_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/hovercard?${this._query({
          subject_type: p["subjectType"],
          subject_id: p["subjectId"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetUserInstallation(p: {
    username: string
  }): Promise<Res<200, t_installation>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/users/${p["username"]}/installation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListPublicKeysForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_key_simple[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_organization_simple[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/orgs?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesListPackagesForUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    visibility?: "public" | "private" | "internal"
    username: string
  }): Promise<
    Res<200, t_package[]> | Res<401, t_basic_error> | Res<403, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages?${this._query({
          package_type: p["packageType"],
          visibility: p["visibility"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetPackageForUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    username: string
  }): Promise<Res<200, t_package>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesDeletePackageForUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    username: string
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesRestorePackageForUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    username: string
    token?: string
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages/${p["packageType"]}/${
          p["packageName"]
        }/restore?${this._query({ token: p["token"] })}`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetAllPackageVersionsForPackageOwnedByUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    username: string
  }): Promise<
    | Res<200, t_package_version[]>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesGetPackageVersionForUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    packageVersionId: number
    username: string
  }): Promise<Res<200, t_package_version>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesDeletePackageVersionForUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    username: string
    packageVersionId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async packagesRestorePackageVersionForUser(p: {
    packageType: "npm" | "maven" | "rubygems" | "docker" | "nuget" | "container"
    packageName: string
    username: string
    packageVersionId: number
  }): Promise<
    | Res<204, void>
    | Res<401, t_basic_error>
    | Res<403, t_basic_error>
    | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListForUser(p: {
    username: string
    state?: "open" | "closed" | "all"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_project[]> | Res<422, t_validation_error>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/projects?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReceivedEventsForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_event[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/received_events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReceivedPublicEventsForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_event[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/received_events/public?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForUser(p: {
    username: string
    type?: "all" | "owner" | "member"
    sort?: "created" | "updated" | "pushed" | "full_name"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/repos?${this._query({
          type: p["type"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async billingGetGithubActionsBillingUser(p: {
    username: string
  }): Promise<Res<200, t_actions_billing_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath + `/users/${p["username"]}/settings/billing/actions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async billingGetGithubPackagesBillingUser(p: {
    username: string
  }): Promise<Res<200, t_packages_billing_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/settings/billing/packages`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async billingGetSharedStorageBillingUser(p: {
    username: string
  }): Promise<Res<200, t_combined_billing_usage>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/settings/billing/shared-storage`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListSshSigningKeysForUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_ssh_signing_key[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/ssh_signing_keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReposStarredByUser(p: {
    username: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        [key: string]: unknown
      }
    >
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/starred?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReposWatchedByUser(p: {
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<200, t_minimal_repository[]>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/subscriptions?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async metaGetAllVersions(): Promise<
    Res<200, string[]> | Res<404, t_basic_error>
  > {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/versions`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async metaGetZen(): Promise<Res<200, string>> {
    const headers: Record<string, string | undefined> = {}

    const res = await fetch(this.config.basePath + `/zen`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }
}
