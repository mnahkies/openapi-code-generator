/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint:disable */

import qs from "querystring"

export interface ApiClientConfig {
  basePath: string
  defaultHeaders: Record<string, string>
}

export interface Res<StatusCode, Body> {
  status: StatusCode
  body: Body
}

export class ApiClient {
  constructor(private readonly config: ApiClientConfig) {}

  private _query(
    params: Record<string, string | number | boolean | undefined | null>
  ): string {
    const filtered = Object.fromEntries(
      Object.entries(params).filter(([k, v]) => v !== undefined)
    )

    return qs.stringify(filtered)
  }

  private _headers(
    headers: Record<string, string | undefined>
  ): Record<string, string> {
    return Object.fromEntries(
      Object.entries({ ...this.config.defaultHeaders, ...headers }).filter(
        (it): it is [string, string] => it[1] !== undefined
      )
    )
  }

  async appsGetAuthenticated(p: { accept: string }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        events?: string[]
        external_url?: string
        html_url?: string
        id?: number
        installations_count?: number
        name?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        permissions?: {
          contents?: string
          issues?: string
          metadata?: string
          single_file?: string
        }
        slug?: string
        updated_at?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/app`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCreateFromManifest(p: { accept?: string; code: string }): Promise<
    Res<
      200,
      {
        client_id?: string
        client_secret?: string
        created_at?: string
        description?: string
        external_url?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        pem?: string
        updated_at?: string
        webhook_secret?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/app-manifests/${p["code"]}/conversions`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListInstallations(p: {
    accept: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        access_tokens_url?: string
        account?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        app_id?: number
        events?: string[]
        html_url?: string
        id?: number
        permissions?: {
          checks?: string
          contents?: string
          metadata?: string
        }
        repositories_url?: string
        repository_selection?: "all" | "selected"
        single_file_name?: string
        target_id?: number
        target_type?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/app/installations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetInstallation(p: {
    accept: string
    installationId: number
  }): Promise<
    Res<
      200,
      {
        access_tokens_url?: string
        account?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        app_id?: number
        events?: string[]
        html_url?: string
        id?: number
        permissions?: {
          checks?: string
          contents?: string
          metadata?: string
        }
        repositories_url?: string
        repository_selection?: "all" | "selected"
        single_file_name?: string
        target_id?: number
        target_type?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/app/installations/${p["installationId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsDeleteInstallation(p: {
    accept: string
    installationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/app/installations/${p["installationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCreateInstallationAccessToken(p: {
    accept: string
    installationId: number
    requestBody: {
      permissions?: {
        [key: string]: unknown
      }
      repository_ids?: number[]
    }
  }): Promise<
    Res<
      201,
      {
        expires_at?: string
        permissions?: {
          contents?: string
          issues?: string
        }
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        repository_selection?: "all" | "selected"
        token?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/app/installations/${p["installationId"]}/access_tokens`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsSuspendInstallation(p: {
    accept?: string
    installationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/app/installations/${p["installationId"]}/suspended`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsUnsuspendInstallation(p: {
    accept?: string
    installationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/app/installations/${p["installationId"]}/suspended`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsListGrants(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        id?: number
        scopes?: string[]
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/applications/grants?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsGetGrant(p: {
    accept?: string
    grantId: number
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        id?: number
        scopes?: string[]
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/applications/grants/${p["grantId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsDeleteGrant(p: {
    accept?: string
    grantId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/applications/grants/${p["grantId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsDeleteAuthorization(p: {
    accept?: string
    clientId: string
    requestBody: {
      access_token?: string
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/grant`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsRevokeGrantForApplication(p: {
    accept?: string
    clientId: string
    accessToken: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/applications/${p["clientId"]}/grants/${p["accessToken"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCheckToken(p: {
    accept?: string
    clientId: string
    requestBody: {
      access_token?: string
    }
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/token`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsResetToken(p: {
    accept?: string
    clientId: string
    requestBody: {
      access_token?: string
    }
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/token`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsDeleteToken(p: {
    accept?: string
    clientId: string
    requestBody: {
      access_token?: string
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/applications/${p["clientId"]}/token`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCheckAuthorization(p: {
    accept?: string
    clientId: string
    accessToken: string
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/applications/${p["clientId"]}/tokens/${p["accessToken"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsResetAuthorization(p: {
    accept?: string
    clientId: string
    accessToken: string
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/applications/${p["clientId"]}/tokens/${p["accessToken"]}`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsRevokeAuthorizationForApplication(p: {
    accept?: string
    clientId: string
    accessToken: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/applications/${p["clientId"]}/tokens/${p["accessToken"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetBySlug(p: { accept: string; appSlug: string }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        events?: string[]
        external_url?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        permissions?: {
          contents?: string
          issues?: string
          metadata?: string
          single_file?: string
        }
        slug?: string
        updated_at?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/apps/${p["appSlug"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsListAuthorizations(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/authorizations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsCreateAuthorization(p: {
    accept?: string
    requestBody: {
      client_id?: string
      client_secret?: string
      fingerprint?: string
      note: string
      note_url?: string
      scopes?: string[]
    }
  }): Promise<
    Res<
      201,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/authorizations`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsGetOrCreateAuthorizationForApp(p: {
    accept?: string
    clientId: string
    requestBody: {
      client_secret: string
      fingerprint?: string
      note?: string
      note_url?: string
      scopes?: string[]
    }
  }): Promise<
    | Res<
        200,
        {
          app?: {
            client_id?: string
            name?: string
            url?: string
          }
          created_at?: string
          fingerprint?: string
          hashed_token?: string
          id?: number
          note?: string
          note_url?: string
          scopes?: string[]
          token?: string
          token_last_eight?: string
          updated_at?: string
          url?: string
        }
      >
    | Res<
        201,
        {
          app?: {
            client_id?: string
            name?: string
            url?: string
          }
          created_at?: string
          fingerprint?: string
          hashed_token?: string
          id?: number
          note?: string
          note_url?: string
          scopes?: string[]
          token?: string
          token_last_eight?: string
          updated_at?: string
          url?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/authorizations/clients/${p["clientId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(p: {
    accept?: string
    clientId: string
    fingerprint: string
    requestBody: {
      client_secret: string
      note?: string
      note_url?: string
      scopes?: string[]
    }
  }): Promise<
    | Res<
        200,
        {
          app?: {
            client_id?: string
            name?: string
            url?: string
          }
          created_at?: string
          fingerprint?: string
          hashed_token?: string
          id?: number
          note?: string
          note_url?: string
          scopes?: string[]
          token?: string
          token_last_eight?: string
          updated_at?: string
          url?: string
        }
      >
    | Res<
        201,
        {
          app?: {
            client_id?: string
            name?: string
            url?: string
          }
          created_at?: string
          fingerprint?: string
          hashed_token?: string
          id?: number
          note?: string
          note_url?: string
          scopes?: string[]
          token?: string
          token_last_eight?: string
          updated_at?: string
          url?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/authorizations/clients/${p["clientId"]}/${p["fingerprint"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsGetAuthorization(p: {
    accept?: string
    authorizationId: number
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/authorizations/${p["authorizationId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsUpdateAuthorization(p: {
    accept?: string
    authorizationId: number
    requestBody: {
      add_scopes?: string[]
      fingerprint?: string
      note?: string
      note_url?: string
      remove_scopes?: string[]
      scopes?: string[]
    }
  }): Promise<
    Res<
      200,
      {
        app?: {
          client_id?: string
          name?: string
          url?: string
        }
        created_at?: string
        fingerprint?: string
        hashed_token?: string
        id?: number
        note?: string
        note_url?: string
        scopes?: string[]
        token?: string
        token_last_eight?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/authorizations/${p["authorizationId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async oauthAuthorizationsDeleteAuthorization(p: {
    accept?: string
    authorizationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/authorizations/${p["authorizationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codesOfConductGetAllCodesOfConduct(p: { accept: string }): Promise<
    Res<
      200,
      {
        key?: string
        name?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/codes_of_conduct`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codesOfConductGetConductCode(p: {
    accept: string
    key: string
  }): Promise<
    Res<
      200,
      {
        body?: string
        key?: string
        name?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/codes_of_conduct/${p["key"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsCreateContentAttachment(p: {
    accept: string
    contentReferenceId: number
    requestBody: {
      body: string
      title: string
    }
  }): Promise<
    Res<
      200,
      {
        body?: string
        id?: number
        title?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/content_references/${p["contentReferenceId"]}/attachments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async emojisGet(p: { accept?: string }): Promise<Res<200, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/emojis`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicEvents(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/events?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetFeeds(p: { accept?: string }): Promise<
    Res<
      200,
      {
        _links?: {
          current_user?: {
            href?: string
            type?: string
          }
          current_user_actor?: {
            href?: string
            type?: string
          }
          current_user_organization?: {
            href?: string
            type?: string
          }
          current_user_organizations?: {
            href?: string
            type?: string
          }[]
          current_user_public?: {
            href?: string
            type?: string
          }
          security_advisories?: {
            href?: string
            type?: string
          }
          timeline?: {
            href?: string
            type?: string
          }
          user?: {
            href?: string
            type?: string
          }
        }
        current_user_actor_url?: string
        current_user_organization_url?: string
        current_user_organization_urls?: string[]
        current_user_public_url?: string
        current_user_url?: string
        security_advisories_url?: string
        timeline_url?: string
        user_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/feeds`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsList(p: {
    accept?: string
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/gists?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsCreate(p: {
    accept?: string
    requestBody: {
      description?: string
      files: {
        [key: string]: unknown
      }
      public?: boolean
    }
  }): Promise<
    Res<
      201,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks?: {
          created_at?: string
          id?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }[]
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        history?: {
          change_status?: {
            additions?: number
            deletions?: number
            total?: number
          }
          committed_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          version?: string
        }[]
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/gists`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListPublic(p: {
    accept?: string
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/gists/public?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListStarred(p: {
    accept?: string
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/gists/starred?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsGet(p: { accept?: string; gistId: string }): Promise<
    Res<
      200,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks?: {
          created_at?: string
          id?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }[]
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        history?: {
          change_status?: {
            additions?: number
            deletions?: number
            total?: number
          }
          committed_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          version?: string
        }[]
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/gists/${p["gistId"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsUpdate(p: {
    accept?: string
    gistId: string
    requestBody: {
      description?: string
      files?: {
        [key: string]: unknown
      }
    }
  }): Promise<
    Res<
      200,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks?: {
          created_at?: string
          id?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }[]
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        history?: {
          change_status?: {
            additions?: number
            deletions?: number
            total?: number
          }
          committed_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          version?: string
        }[]
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/gists/${p["gistId"]}`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsDelete(p: {
    accept?: string
    gistId: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/gists/${p["gistId"]}`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListComments(p: {
    accept?: string
    gistId: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        created_at?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/gists/${p["gistId"]}/comments?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsCreateComment(p: {
    accept?: string
    gistId: string
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      201,
      {
        body?: string
        created_at?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsGetComment(p: {
    accept?: string
    gistId: string
    commentId: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        created_at?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsUpdateComment(p: {
    accept?: string
    gistId: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      200,
      {
        body?: string
        created_at?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsDeleteComment(p: {
    accept?: string
    gistId: string
    commentId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListCommits(p: {
    accept?: string
    gistId: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        change_status?: {
          additions?: number
          deletions?: number
          total?: number
        }
        committed_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        version?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/gists/${p["gistId"]}/commits?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsFork(p: { accept?: string; gistId: string }): Promise<
    Res<
      201,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/forks`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListForks(p: {
    accept?: string
    gistId: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/gists/${p["gistId"]}/forks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsStar(p: {
    accept?: string
    gistId: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/star`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsUnstar(p: {
    accept?: string
    gistId: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/star`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsCheckIsStarred(p: {
    accept?: string
    gistId: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/star`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsGetRevision(p: {
    accept?: string
    gistId: string
    sha: string
  }): Promise<
    Res<
      200,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks?: {
          created_at?: string
          id?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }[]
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        history?: {
          change_status?: {
            additions?: number
            deletions?: number
            total?: number
          }
          committed_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          version?: string
        }[]
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gists/${p["gistId"]}/${p["sha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitignoreGetAllTemplates(p: {
    accept?: string
  }): Promise<Res<200, string[]>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/gitignore/templates`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitignoreGetTemplate(p: { accept?: string; name: string }): Promise<
    Res<
      200,
      {
        name?: string
        source?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/gitignore/templates/${p["name"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListReposAccessibleToInstallation(p: {
    accept: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/installation/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsRevokeInstallationAccessToken(p: {
    accept?: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/installation/token`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesList(p: {
    accept?: string
    filter?: "assigned" | "created" | "mentioned" | "subscribed" | "all"
    state?: "open" | "closed" | "all"
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/issues?${this._query({
          filter: p["filter"],
          state: p["state"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async licensesGetAllCommonlyUsed(p: { accept?: string }): Promise<
    Res<
      200,
      {
        key?: string
        name?: string
        node_id?: string
        spdx_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/licenses`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async licensesGet(p: { accept?: string; license: string }): Promise<
    Res<
      200,
      {
        body?: string
        conditions?: string[]
        description?: string
        featured?: boolean
        html_url?: string
        implementation?: string
        key?: string
        limitations?: string[]
        name?: string
        node_id?: string
        permissions?: string[]
        spdx_id?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/licenses/${p["license"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async markdownRender(p: {
    accept?: string
    requestBody: {
      context?: string
      mode?: "markdown" | "gfm"
      text: string
    }
  }): Promise<Res<200, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/markdown`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async markdownRenderRaw(p: {
    accept?: string
    contentType?: "text/plain; charset=utf-8"
    requestBody: string
  }): Promise<Res<200, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
      "content-type": p["contentType"],
    }

    const res = await fetch(this.config.basePath + `/markdown/raw`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetSubscriptionPlanForAccount(p: {
    accept?: string
    accountId: number
  }): Promise<
    | Res<
        200,
        {
          email?: string
          id?: number
          login?: string
          marketplace_pending_change?: {
            effective_date?: string
            id?: number
            plan?: {
              accounts_url?: string
              bullets?: string[]
              description?: string
              has_free_trial?: boolean
              id?: number
              monthly_price_in_cents?: number
              name?: string
              number?: number
              price_model?: string
              state?: string
              unit_name?: string
              url?: string
              yearly_price_in_cents?: number
            }
            unit_count?: string
          }
          marketplace_purchase?: {
            billing_cycle?: string
            free_trial_ends_on?: string
            next_billing_date?: string
            on_free_trial?: boolean
            plan?: {
              accounts_url?: string
              bullets?: string[]
              description?: string
              has_free_trial?: boolean
              id?: number
              monthly_price_in_cents?: number
              name?: string
              number?: number
              price_model?: string
              state?: string
              unit_name?: string
              url?: string
              yearly_price_in_cents?: number
            }
            unit_count?: string
            updated_at?: string
          }
          organization_billing_email?: string
          type?: string
          url?: string
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/marketplace_listing/accounts/${p["accountId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListPlans(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        accounts_url?: string
        bullets?: string[]
        description?: string
        has_free_trial?: boolean
        id?: number
        monthly_price_in_cents?: number
        name?: string
        number?: number
        price_model?: string
        state?: string
        unit_name?: string
        url?: string
        yearly_price_in_cents?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/plans?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListAccountsForPlan(p: {
    accept?: string
    planId: number
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        email?: string
        id?: number
        login?: string
        marketplace_pending_change?: {
          effective_date?: string
          id?: number
          plan?: {
            accounts_url?: string
            bullets?: string[]
            description?: string
            has_free_trial?: boolean
            id?: number
            monthly_price_in_cents?: number
            name?: string
            number?: number
            price_model?: string
            state?: string
            unit_name?: string
            url?: string
            yearly_price_in_cents?: number
          }
          unit_count?: string
        }
        marketplace_purchase?: {
          billing_cycle?: string
          free_trial_ends_on?: string
          next_billing_date?: string
          on_free_trial?: boolean
          plan?: {
            accounts_url?: string
            bullets?: string[]
            description?: string
            has_free_trial?: boolean
            id?: number
            monthly_price_in_cents?: number
            name?: string
            number?: number
            price_model?: string
            state?: string
            unit_name?: string
            url?: string
            yearly_price_in_cents?: number
          }
          unit_count?: string
          updated_at?: string
        }
        organization_billing_email?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/plans/${p["planId"]}/accounts?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetSubscriptionPlanForAccountStubbed(p: {
    accept?: string
    accountId: number
  }): Promise<
    | Res<
        200,
        {
          email?: string
          id?: number
          login?: string
          marketplace_pending_change?: {
            effective_date?: string
            id?: number
            plan?: {
              accounts_url?: string
              bullets?: string[]
              description?: string
              has_free_trial?: boolean
              id?: number
              monthly_price_in_cents?: number
              name?: string
              number?: number
              price_model?: string
              state?: string
              unit_name?: string
              url?: string
              yearly_price_in_cents?: number
            }
            unit_count?: string
          }
          marketplace_purchase?: {
            billing_cycle?: string
            free_trial_ends_on?: string
            next_billing_date?: string
            on_free_trial?: boolean
            plan?: {
              accounts_url?: string
              bullets?: string[]
              description?: string
              has_free_trial?: boolean
              id?: number
              monthly_price_in_cents?: number
              name?: string
              number?: number
              price_model?: string
              state?: string
              unit_name?: string
              url?: string
              yearly_price_in_cents?: number
            }
            unit_count?: string
            updated_at?: string
          }
          organization_billing_email?: string
          type?: string
          url?: string
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/stubbed/accounts/${p["accountId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListPlansStubbed(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        accounts_url?: string
        bullets?: string[]
        description?: string
        has_free_trial?: boolean
        id?: number
        monthly_price_in_cents?: number
        name?: string
        number?: number
        price_model?: string
        state?: string
        unit_name?: string
        url?: string
        yearly_price_in_cents?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/stubbed/plans?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListAccountsForPlanStubbed(p: {
    accept?: string
    planId: number
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        email?: string
        id?: number
        login?: string
        marketplace_pending_change?: {
          effective_date?: string
          id?: number
          plan?: {
            accounts_url?: string
            bullets?: string[]
            description?: string
            has_free_trial?: boolean
            id?: number
            monthly_price_in_cents?: number
            name?: string
            number?: number
            price_model?: string
            state?: string
            unit_name?: string
            url?: string
            yearly_price_in_cents?: number
          }
          unit_count?: string
        }
        marketplace_purchase?: {
          billing_cycle?: string
          free_trial_ends_on?: string
          next_billing_date?: string
          on_free_trial?: boolean
          plan?: {
            accounts_url?: string
            bullets?: string[]
            description?: string
            has_free_trial?: boolean
            id?: number
            monthly_price_in_cents?: number
            name?: string
            number?: number
            price_model?: string
            state?: string
            unit_name?: string
            url?: string
            yearly_price_in_cents?: number
          }
          unit_count?: string
          updated_at?: string
        }
        organization_billing_email?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/marketplace_listing/stubbed/plans/${
          p["planId"]
        }/accounts?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async metaGet(p: { accept?: string }): Promise<
    Res<
      200,
      {
        api?: string[]
        git?: string[]
        hooks?: string[]
        importer?: string[]
        pages?: string[]
        ssh_key_fingerprints?: {
          MD5_DSA?: string
          MD5_RSA?: string
          SHA256_DSA?: string
          SHA256_RSA?: string
        }
        verifiable_password_authentication?: boolean
        web?: string[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/meta`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicEventsForRepoNetwork(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/networks/${p["owner"]}/${p["repo"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListNotificationsForAuthenticatedUser(p: {
    accept?: string
    all?: boolean
    participating?: boolean
    since?: string
    before?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        id?: string
        last_read_at?: string
        reason?: string
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        subject?: {
          latest_comment_url?: string
          title?: string
          type?: string
          url?: string
        }
        unread?: boolean
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/notifications?${this._query({
          all: p["all"],
          participating: p["participating"],
          since: p["since"],
          before: p["before"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityMarkNotificationsAsRead(p: {
    accept?: string
    requestBody: {
      last_read_at?: string
    }
  }): Promise<Res<205, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/notifications`, {
      method: "PUT",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetThread(p: { accept?: string; threadId: number }): Promise<
    Res<
      200,
      {
        id?: string
        last_read_at?: string
        reason?: string
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        subject?: {
          latest_comment_url?: string
          title?: string
          type?: string
          url?: string
        }
        unread?: boolean
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/notifications/threads/${p["threadId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityMarkThreadAsRead(p: {
    accept?: string
    threadId: number
  }): Promise<Res<205, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/notifications/threads/${p["threadId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetThreadSubscriptionForAuthenticatedUser(p: {
    accept?: string
    threadId: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        ignored?: boolean
        reason?: string
        subscribed?: boolean
        thread_url?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/notifications/threads/${p["threadId"]}/subscription`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activitySetThreadSubscription(p: {
    accept?: string
    threadId: number
    requestBody: {
      ignored?: boolean
    }
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        ignored?: boolean
        reason?: string
        subscribed?: boolean
        thread_url?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/notifications/threads/${p["threadId"]}/subscription`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityDeleteThreadSubscription(p: {
    accept?: string
    threadId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/notifications/threads/${p["threadId"]}/subscription`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsList(p: { accept?: string; since?: number }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        description?: string
        events_url?: string
        hooks_url?: string
        id?: number
        issues_url?: string
        login?: string
        members_url?: string
        node_id?: string
        public_members_url?: string
        repos_url?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/organizations?${this._query({ since: p["since"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGet(p: { accept?: string; org: string }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        billing_email?: string
        blog?: string
        collaborators?: number
        company?: string
        created_at?: string
        default_repository_permission?: string
        description?: string
        disk_usage?: number
        email?: string
        events_url?: string
        followers?: number
        following?: number
        has_organization_projects?: boolean
        has_repository_projects?: boolean
        hooks_url?: string
        html_url?: string
        id?: number
        is_verified?: boolean
        issues_url?: string
        location?: string
        login?: string
        members_allowed_repository_creation_type?: string
        members_can_create_internal_repositories?: boolean
        members_can_create_private_repositories?: boolean
        members_can_create_public_repositories?: boolean
        members_can_create_repositories?: boolean
        members_url?: string
        name?: string
        node_id?: string
        owned_private_repos?: number
        plan?: {
          name?: string
          private_repos?: number
          space?: number
        }
        private_gists?: number
        public_gists?: number
        public_members_url?: string
        public_repos?: number
        repos_url?: string
        total_private_repos?: number
        twitter_username?: string
        two_factor_requirement_enabled?: boolean
        type?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUpdate(p: {
    accept?: string
    org: string
    requestBody: {
      billing_email?: string
      company?: string
      default_repository_permission?: "read" | "write" | "admin" | "none"
      description?: string
      email?: string
      has_organization_projects?: boolean
      has_repository_projects?: boolean
      location?: string
      members_allowed_repository_creation_type?: "all" | "private" | "none"
      members_can_create_internal_repositories?: boolean
      members_can_create_private_repositories?: boolean
      members_can_create_public_repositories?: boolean
      members_can_create_repositories?: boolean
      name?: string
      twitter_username?: string
    }
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        billing_email?: string
        blog?: string
        collaborators?: number
        company?: string
        created_at?: string
        default_repository_permission?: string
        description?: string
        disk_usage?: number
        email?: string
        events_url?: string
        followers?: number
        following?: number
        has_organization_projects?: boolean
        has_repository_projects?: boolean
        hooks_url?: string
        html_url?: string
        id?: number
        is_verified?: boolean
        issues_url?: string
        location?: string
        login?: string
        members_allowed_repository_creation_type?: string
        members_can_create_internal_repositories?: boolean
        members_can_create_private_repositories?: boolean
        members_can_create_public_repositories?: boolean
        members_can_create_repositories?: boolean
        members_url?: string
        name?: string
        node_id?: string
        owned_private_repos?: number
        plan?: {
          name?: string
          private_repos?: number
          space?: number
        }
        private_gists?: number
        public_gists?: number
        public_members_url?: string
        public_repos?: number
        repos_url?: string
        total_private_repos?: number
        twitter_username?: string
        two_factor_requirement_enabled?: boolean
        type?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelfHostedRunnersForOrg(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        runners?: {
          id: number
          name: string
          os: string
          status: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRunnerApplicationsForOrg(p: {
    accept?: string
    org: string
  }): Promise<
    Res<
      200,
      {
        architecture?: string
        download_url?: string
        filename?: string
        os?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/runners/downloads`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRegistrationTokenForOrg(p: {
    accept?: string
    org: string
  }): Promise<
    Res<
      201,
      {
        expires_at?: string
        token?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/registration-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRemoveTokenForOrg(p: {
    accept?: string
    org: string
  }): Promise<
    Res<
      201,
      {
        expires_at?: string
        token?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/runners/remove-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetSelfHostedRunnerForOrg(p: {
    accept?: string
    org: string
    runnerId: number
  }): Promise<
    Res<
      200,
      {
        id?: number
        name?: string
        os?: string
        status?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteSelfHostedRunnerFromOrg(p: {
    accept?: string
    org: string
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListOrgSecrets(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets?: {
          created_at: string
          name: string
          selected_repositories_url?: string
          updated_at: string
          visibility: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetOrgPublicKey(p: { accept?: string; org: string }): Promise<
    Res<
      200,
      {
        key?: string
        key_id?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/actions/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetOrgSecret(p: {
    accept?: string
    org: string
    secretName: string
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        name?: string
        selected_repositories_url?: string
        updated_at?: string
        visibility?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateOrUpdateOrgSecret(p: {
    accept?: string
    org: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
      selected_repository_ids?: string[]
      visibility?: "all" | "private" | "selected"
    }
  }): Promise<Res<201, void> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteOrgSecret(p: {
    accept?: string
    org: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelectedReposForOrgSecret(p: {
    accept?: string
    org: string
    secretName: string
  }): Promise<
    Res<
      200,
      {
        repositories?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsSetSelectedReposForOrgSecret(p: {
    accept?: string
    org: string
    secretName: string
    requestBody: {
      selected_repository_ids?: number[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsAddSelectedRepoToOrgSecret(p: {
    accept?: string
    org: string
    secretName: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsRemoveSelectedRepoFromOrgSecret(p: {
    accept?: string
    org: string
    secretName: string
    repositoryId: number
  }): Promise<Res<204, void> | Res<409, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListBlockedUsers(p: { accept?: string; org: string }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}/blocks`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCheckBlockedUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsBlockUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUnblockUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListSamlSsoAuthorizations(p: {
    accept?: string
    org: string
  }): Promise<
    Res<
      200,
      {
        credential_authorized_at?: string
        credential_id?: string
        credential_type?: string
        login?: string
        scopes?: string[]
        token_last_eight?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/credential-authorizations`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveSamlSsoAuthorization(p: {
    accept?: string
    org: string
    credentialId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/credential-authorizations/${p["credentialId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicOrgEvents(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListWebhooks(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        config?: {
          content_type?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        name?: string
        ping_url?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/hooks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCreateWebhook(p: {
    accept?: string
    org: string
    requestBody: {
      active?: boolean
      config: {
        content_type?: string
        insecure_ssl?: string
        secret?: string
        url: string
      }
      events?: string[]
      name: string
    }
  }): Promise<
    Res<
      201,
      {
        active?: boolean
        config?: {
          content_type?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        name?: string
        ping_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}/hooks`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetWebhook(p: {
    accept?: string
    org: string
    hookId: number
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        config?: {
          content_type?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        name?: string
        ping_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUpdateWebhook(p: {
    accept?: string
    org: string
    hookId: number
    requestBody: {
      active?: boolean
      config?: {
        content_type?: string
        insecure_ssl?: string
        secret?: string
        url: string
      }
      events?: string[]
    }
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        config?: {
          content_type?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        name?: string
        ping_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsDeleteWebhook(p: {
    accept?: string
    org: string
    hookId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsPingWebhook(p: {
    accept?: string
    org: string
    hookId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/pings`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetOrgInstallation(p: { accept: string; org: string }): Promise<
    Res<
      200,
      {
        access_tokens_url?: string
        account?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        app_id?: number
        created_at?: string
        events?: string[]
        html_url?: string
        id?: number
        permissions?: {
          checks?: string
          contents?: string
          metadata?: string
        }
        repositories_url?: string
        repository_selection?: "all" | "selected"
        single_file_name?: string
        target_id?: number
        target_type?: string
        updated_at?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/installation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListAppInstallations(p: {
    accept: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        installations?: {
          access_tokens_url?: string
          account?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          app_id?: number
          created_at?: string
          events?: string[]
          html_url?: string
          id?: number
          permissions?: {
            deployments?: string
            metadata?: string
            pull_requests?: string
            statuses?: string
          }
          repositories_url?: string
          repository_selection?: "all" | "selected"
          single_file_name?: string
          target_id?: number
          target_type?: string
          updated_at?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/installations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsGetRestrictionsForOrg(p: {
    accept: string
    org: string
  }): Promise<
    Res<
      200,
      {
        expires_at?: string
        limit?: string
        origin?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/interaction-limits`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsSetRestrictionsForOrg(p: {
    accept: string
    org: string
    requestBody: {
      limit: "existing_users" | "contributors_only" | "collaborators_only"
    }
  }): Promise<
    Res<
      200,
      {
        expires_at?: string
        limit?: string
        origin?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/interaction-limits`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsRemoveRestrictionsForOrg(p: {
    accept: string
    org: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/interaction-limits`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListPendingInvitations(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        email?: string
        id?: number
        invitation_team_url?: string
        inviter?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        login?: string
        role?: string
        team_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCreateInvitation(p: {
    accept?: string
    org: string
    requestBody: {
      email?: string
      invitee_id?: number
      role?: "admin" | "direct_member" | "billing_manager"
      team_ids?: number[]
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        email?: string
        id?: number
        invitation_team_url?: string
        inviter?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        login?: string
        role?: string
        team_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/invitations`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListInvitationTeams(p: {
    accept?: string
    org: string
    invitationId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        description?: string
        html_url?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: string
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/invitations/${p["invitationId"]}/teams?${this._query(
          { per_page: p["perPage"], page: p["page"] }
        )}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListForOrg(p: {
    accept?: string
    org: string
    filter?: "assigned" | "created" | "mentioned" | "subscribed" | "all"
    state?: "open" | "closed" | "all"
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/issues?${this._query({
          filter: p["filter"],
          state: p["state"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListMembers(p: {
    accept?: string
    org: string
    filter?: "2fa_disabled" | "all"
    role?: "all" | "admin" | "member"
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
      >
    | Res<302, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/members?${this._query({
          filter: p["filter"],
          role: p["role"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCheckMembershipForUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void> | Res<302, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/members/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveMember(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/members/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetMembershipForUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<
    Res<
      200,
      {
        organization?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        organization_url?: string
        role?: string
        state?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsSetMembershipForUser(p: {
    accept?: string
    org: string
    username: string
    requestBody: {
      role?: "admin" | "member"
    }
  }): Promise<
    Res<
      200,
      {
        organization?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        organization_url?: string
        role?: string
        state?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveMembershipForUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsStartForOrg(p: {
    accept?: string
    org: string
    requestBody: {
      exclude_attachments?: boolean
      lock_repositories?: boolean
      repositories: string[]
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        exclude_attachments?: boolean
        guid?: string
        id?: number
        lock_repositories?: boolean
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/migrations`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListForOrg(p: {
    accept: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        exclude_attachments?: boolean
        guid?: string
        id?: number
        lock_repositories?: boolean
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        state?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetStatusForOrg(p: {
    accept: string
    org: string
    migrationId: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        exclude_attachments?: boolean
        guid?: string
        id?: number
        lock_repositories?: boolean
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/migrations/${p["migrationId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsDownloadArchiveForOrg(p: {
    accept: string
    org: string
    migrationId: number
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsDeleteArchiveForOrg(p: {
    accept: string
    org: string
    migrationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsUnlockRepoForOrg(p: {
    accept: string
    org: string
    migrationId: number
    repoName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListReposForOrg(p: {
    accept: string
    org: string
    migrationId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/migrations/${
          p["migrationId"]
        }/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListOutsideCollaborators(p: {
    accept?: string
    org: string
    filter?: "2fa_disabled" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/outside_collaborators?${this._query({
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemoveOutsideCollaborator(p: {
    accept?: string
    org: string
    username: string
  }): Promise<
    | Res<204, void>
    | Res<
        422,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsConvertMemberToOutsideCollaborator(p: {
    accept?: string
    org: string
    username: string
  }): Promise<
    | Res<204, void>
    | Res<
        403,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListForOrg(p: {
    accept: string
    org: string
    state?: "open" | "closed" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        owner_url?: string
        state?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/projects?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateForOrg(p: {
    accept: string
    org: string
    requestBody: {
      body?: string
      name: string
    }
  }): Promise<
    Res<
      201,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        owner_url?: string
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/projects`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListPublicMembers(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsCheckPublicMembershipForUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsSetPublicMembershipForAuthenticatedUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsRemovePublicMembershipForAuthenticatedUser(p: {
    accept?: string
    org: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/public_members/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForOrg(p: {
    accept?: string
    org: string
    type?:
      | "all"
      | "public"
      | "private"
      | "forks"
      | "sources"
      | "member"
      | "internal"
    sort?: "created" | "updated" | "pushed" | "full_name"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/repos?${this._query({
          type: p["type"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateInOrg(p: {
    accept?: string
    org: string
    requestBody: {
      allow_merge_commit?: boolean
      allow_rebase_merge?: boolean
      allow_squash_merge?: boolean
      auto_init?: boolean
      delete_branch_on_merge?: boolean
      description?: string
      gitignore_template?: string
      has_issues?: boolean
      has_projects?: boolean
      has_wiki?: boolean
      homepage?: string
      is_template?: boolean
      license_template?: string
      name: string
      private?: boolean
      team_id?: number
      visibility?: "public" | "private" | "visibility" | "internal"
    }
  }): Promise<
    Res<
      201,
      {
        allow_merge_commit?: boolean
        allow_rebase_merge?: boolean
        allow_squash_merge?: boolean
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}/repos`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListIdPGroupsForOrg(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        groups?: {
          group_description: string
          group_id: string
          group_name: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/team-sync/groups?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsList(p: {
    accept?: string
    org: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        description?: string
        html_url?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: string
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreate(p: {
    accept?: string
    org: string
    requestBody: {
      description?: string
      maintainers?: string[]
      name: string
      parent_team_id?: number
      permission?: "pull" | "push" | "admin"
      privacy?: "secret" | "closed"
      repo_names?: string[]
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        description?: string
        html_url?: string
        id?: number
        members_count?: number
        members_url?: string
        name?: string
        node_id?: string
        organization?: {
          avatar_url?: string
          blog?: string
          company?: string
          created_at?: string
          description?: string
          email?: string
          events_url?: string
          followers?: number
          following?: number
          has_organization_projects?: boolean
          has_repository_projects?: boolean
          hooks_url?: string
          html_url?: string
          id?: number
          is_verified?: boolean
          issues_url?: string
          location?: string
          login?: string
          members_url?: string
          name?: string
          node_id?: string
          public_gists?: number
          public_members_url?: string
          public_repos?: number
          repos_url?: string
          twitter_username?: string
          type?: string
          url?: string
        }
        parent?: string
        permission?: string
        privacy?: string
        repos_count?: number
        repositories_url?: string
        slug?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/orgs/${p["org"]}/teams`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetByName(p: {
    accept?: string
    org: string
    teamSlug: string
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        html_url?: string
        id?: number
        members_count?: number
        members_url?: string
        name?: string
        node_id?: string
        organization?: {
          avatar_url?: string
          blog?: string
          company?: string
          created_at?: string
          description?: string
          email?: string
          events_url?: string
          followers?: number
          following?: number
          has_organization_projects?: boolean
          has_repository_projects?: boolean
          hooks_url?: string
          html_url?: string
          id?: number
          is_verified?: boolean
          issues_url?: string
          location?: string
          login?: string
          members_url?: string
          name?: string
          node_id?: string
          public_gists?: number
          public_members_url?: string
          public_repos?: number
          repos_url?: string
          twitter_username?: string
          type?: string
          url?: string
        }
        parent?: string
        permission?: string
        privacy?: string
        repos_count?: number
        repositories_url?: string
        slug?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    requestBody: {
      description?: string
      name: string
      parent_team_id?: number
      permission?: "pull" | "push" | "admin"
      privacy?: "secret" | "closed"
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        description?: string
        html_url?: string
        id?: number
        members_count?: number
        members_url?: string
        name?: string
        node_id?: string
        organization?: {
          avatar_url?: string
          blog?: string
          company?: string
          created_at?: string
          description?: string
          email?: string
          events_url?: string
          followers?: number
          following?: number
          has_organization_projects?: boolean
          has_repository_projects?: boolean
          hooks_url?: string
          html_url?: string
          id?: number
          is_verified?: boolean
          issues_url?: string
          location?: string
          login?: string
          members_url?: string
          name?: string
          node_id?: string
          public_gists?: number
          public_members_url?: string
          public_repos?: number
          repos_url?: string
          twitter_username?: string
          type?: string
          url?: string
        }
        parent?: string
        permission?: string
        privacy?: string
        repos_count?: number
        repositories_url?: string
        slug?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionsInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    requestBody: {
      body: string
      private?: boolean
      title: string
    }
  }): Promise<
    Res<
      201,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
    requestBody: {
      body?: string
      title?: string
    }
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionCommentsInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${
          p["discussionNumber"]
        }/comments?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionCommentInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      201,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionCommentInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionCommentInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionCommentInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionCommentInOrg(p: {
    accept: string
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${
          p["discussionNumber"]
        }/comments/${p["commentNumber"]}/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionCommentInOrg(p: {
    accept: string
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForTeamDiscussionComment(p: {
    accept: string
    org: string
    teamSlug: string
    discussionNumber: number
    commentNumber: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionInOrg(p: {
    accept: string
    org: string
    teamSlug: string
    discussionNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${
          p["discussionNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionInOrg(p: {
    accept: string
    org: string
    teamSlug: string
    discussionNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForTeamDiscussion(p: {
    accept: string
    org: string
    teamSlug: string
    discussionNumber: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListPendingInvitationsInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        email?: string
        id?: number
        invitation_team_url?: string
        inviter?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        login?: string
        role?: string
        team_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListMembersInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    role?: "member" | "maintainer" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/members?${this._query({
          role: p["role"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetMembershipForUserInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    username: string
  }): Promise<
    | Res<
        200,
        {
          role?: string
          state?: string
          url?: string
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateMembershipForUserInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    username: string
    requestBody: {
      role?: "member" | "maintainer"
    }
  }): Promise<
    | Res<
        200,
        {
          role?: string
          state?: string
          url?: string
        }
      >
    | Res<403, void>
    | Res<
        422,
        {
          errors?: {
            code?: string
            field?: string
            resource?: string
          }[]
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveMembershipForUserInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    username: string
  }): Promise<Res<204, void> | Res<403, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListProjectsInOrg(p: {
    accept: string
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        organization_permission?: string
        owner_url?: string
        permissions?: {
          admin?: boolean
          read?: boolean
          write?: boolean
        }
        private?: boolean
        state?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForProjectInOrg(p: {
    accept: string
    org: string
    teamSlug: string
    projectId: number
  }): Promise<
    | Res<
        200,
        {
          body?: string
          columns_url?: string
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          number?: number
          organization_permission?: string
          owner_url?: string
          permissions?: {
            admin?: boolean
            read?: boolean
            write?: boolean
          }
          private?: boolean
          state?: string
          updated_at?: string
          url?: string
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateProjectPermissionsInOrg(p: {
    accept: string
    org: string
    teamSlug: string
    projectId: number
    requestBody: {
      permission?: "read" | "write" | "admin"
    }
  }): Promise<
    | Res<204, void>
    | Res<
        403,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveProjectInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    projectId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListReposInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForRepoInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    owner: string
    repo: string
  }): Promise<
    | Res<
        200,
        {
          organization?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          parent?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          permissions?: {
            admin?: boolean
            maintain?: boolean
            pull?: boolean
            push?: boolean
            triage?: boolean
          }
          source?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
        }
      >
    | Res<204, void>
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateRepoPermissionsInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    owner: string
    repo: string
    requestBody: {
      permission?: "pull" | "push" | "admin" | "maintain" | "triage"
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveRepoInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListIdPGroupsInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
  }): Promise<
    Res<
      200,
      {
        groups?: {
          group_description: string
          group_id: string
          group_name: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/team-sync/group-mappings`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateOrUpdateIdPGroupConnectionsInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    requestBody: {
      groups: {
        group_description: string
        group_id: string
        group_name: string
      }[]
    }
  }): Promise<
    Res<
      200,
      {
        groups?: {
          group_description?: string
          group_id?: string
          group_name?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/team-sync/group-mappings`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListChildInOrg(p: {
    accept?: string
    org: string
    teamSlug: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        description?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/orgs/${p["org"]}/teams/${p["teamSlug"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGetCard(p: { accept: string; cardId: number }): Promise<
    Res<
      200,
      {
        archived?: boolean
        column_url?: string
        content_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        id?: number
        node_id?: string
        note?: string
        project_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsUpdateCard(p: {
    accept: string
    cardId: number
    requestBody: {
      archived?: boolean
      note?: string
    }
  }): Promise<
    Res<
      200,
      {
        archived?: boolean
        column_url?: string
        content_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        id?: number
        node_id?: string
        note?: string
        project_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsDeleteCard(p: {
    accept: string
    cardId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsMoveCard(p: {
    accept: string
    cardId: number
    requestBody: {
      column_id?: number
      position: string
    }
  }): Promise<Res<201, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/cards/${p["cardId"]}/moves`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGetColumn(p: { accept: string; columnId: number }): Promise<
    Res<
      200,
      {
        cards_url?: string
        created_at?: string
        id?: number
        name?: string
        node_id?: string
        project_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsUpdateColumn(p: {
    accept: string
    columnId: number
    requestBody: {
      name: string
    }
  }): Promise<
    Res<
      200,
      {
        cards_url?: string
        created_at?: string
        id?: number
        name?: string
        node_id?: string
        project_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsDeleteColumn(p: {
    accept: string
    columnId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListCards(p: {
    accept: string
    columnId: number
    archivedState?: "all" | "archived" | "not_archived"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archived?: boolean
        column_url?: string
        content_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        id?: number
        node_id?: string
        note?: string
        project_url?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/projects/columns/${p["columnId"]}/cards?${this._query({
          archived_state: p["archivedState"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateCard(p: {
    accept: string
    columnId: number
    requestBody: {
      content_id?: number
      content_type?: string
      note?: string
    }
  }): Promise<
    Res<
      201,
      {
        archived?: boolean
        column_url?: string
        content_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        id?: number
        node_id?: string
        note?: string
        project_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}/cards`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsMoveColumn(p: {
    accept: string
    columnId: number
    requestBody: {
      position: string
    }
  }): Promise<Res<201, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/projects/columns/${p["columnId"]}/moves`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGet(p: { accept: string; projectId: number }): Promise<
    Res<
      200,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        owner_url?: string
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsUpdate(p: {
    accept: string
    projectId: number
    requestBody: {
      body?: string
      name?: string
      organization_permission?: string
      private?: boolean
      state?: "open" | "closed"
    }
  }): Promise<
    | Res<
        200,
        {
          body?: string
          columns_url?: string
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          number?: number
          owner_url?: string
          state?: string
          updated_at?: string
          url?: string
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsDelete(p: {
    accept: string
    projectId: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListCollaborators(p: {
    accept: string
    projectId: number
    affiliation?: "outside" | "direct" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators?${this._query({
          affiliation: p["affiliation"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsAddCollaborator(p: {
    accept: string
    projectId: number
    username: string
    requestBody: {
      permission?: "read" | "write" | "admin"
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsRemoveCollaborator(p: {
    accept: string
    projectId: number
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsGetPermissionForUser(p: {
    accept: string
    projectId: number
    username: string
  }): Promise<
    Res<
      200,
      {
        permission?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/collaborators/${p["username"]}/permission`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListColumns(p: {
    accept: string
    projectId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        cards_url?: string
        created_at?: string
        id?: number
        name?: string
        node_id?: string
        project_url?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/projects/${p["projectId"]}/columns?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateColumn(p: {
    accept: string
    projectId: number
    requestBody: {
      name: string
    }
  }): Promise<
    Res<
      200,
      {
        cards_url?: string
        created_at?: string
        id?: number
        name?: string
        node_id?: string
        project_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/projects/${p["projectId"]}/columns`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async rateLimitGet(p: { accept?: string }): Promise<
    Res<
      200,
      {
        rate?: {
          limit?: number
          remaining?: number
          reset?: number
        }
        resources?: {
          core?: {
            limit?: number
            remaining?: number
            reset?: number
          }
          graphql?: {
            limit?: number
            remaining?: number
            reset?: number
          }
          integration_manifest?: {
            limit?: number
            remaining?: number
            reset?: number
          }
          search?: {
            limit?: number
            remaining?: number
            reset?: number
          }
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/rate_limit`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteLegacy(p: {
    accept: string
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGet(p: { accept?: string; owner: string; repo: string }): Promise<
    Res<
      200,
      {
        allow_merge_commit?: boolean
        allow_rebase_merge?: boolean
        allow_squash_merge?: boolean
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        organization?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        parent?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        permissions?: {
          admin?: boolean
          maintain?: boolean
          pull?: boolean
          push?: boolean
          triage?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        source?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdate(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      allow_merge_commit?: boolean
      allow_rebase_merge?: boolean
      allow_squash_merge?: boolean
      archived?: boolean
      default_branch?: string
      delete_branch_on_merge?: boolean
      description?: string
      has_issues?: boolean
      has_projects?: boolean
      has_wiki?: boolean
      homepage?: string
      is_template?: boolean
      name?: string
      private?: boolean
      visibility?: "public" | "private" | "visibility" | "internal"
    }
  }): Promise<
    Res<
      200,
      {
        allow_merge_commit?: boolean
        allow_rebase_merge?: boolean
        allow_squash_merge?: boolean
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        organization?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        parent?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        permissions?: {
          admin?: boolean
          maintain?: boolean
          pull?: boolean
          push?: boolean
          triage?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        source?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDelete(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    | Res<204, void>
    | Res<
        403,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListArtifactsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        artifacts?: {
          archive_download_url: string
          created_at: string
          expired: boolean
          expires_at: string
          id: number
          name: string
          node_id: string
          size_in_bytes: number
          url: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetArtifact(p: {
    accept?: string
    owner: string
    repo: string
    artifactId: number
  }): Promise<
    Res<
      200,
      {
        archive_download_url?: string
        created_at?: string
        expired?: boolean
        expires_at?: string
        id?: number
        name?: string
        node_id?: string
        size_in_bytes?: number
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteArtifact(p: {
    accept?: string
    owner: string
    repo: string
    artifactId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDownloadArtifact(p: {
    accept?: string
    owner: string
    repo: string
    artifactId: number
    archiveFormat: string
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}/${p["archiveFormat"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetJobForWorkflowRun(p: {
    accept?: string
    owner: string
    repo: string
    jobId: number
  }): Promise<
    Res<
      202,
      {
        check_run_url?: string
        completed_at?: string
        conclusion?: string
        head_sha?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        run_id?: number
        run_url?: string
        started_at?: string
        status?: string
        steps?: {
          completed_at: string
          conclusion: string
          name: string
          number: number
          started_at: string
          status: string
        }[]
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDownloadJobLogsForWorkflowRun(p: {
    accept?: string
    owner: string
    repo: string
    jobId: number
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}/logs`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListSelfHostedRunnersForRepo(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        runners?: {
          id: number
          name: string
          os: string
          status: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRunnerApplicationsForRepo(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        architecture?: string
        download_url?: string
        filename?: string
        os?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/downloads`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRegistrationTokenForRepo(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      201,
      {
        expires_at?: string
        token?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/registration-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateRemoveTokenForRepo(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      201,
      {
        expires_at?: string
        token?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/remove-token`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetSelfHostedRunnerForRepo(p: {
    accept?: string
    owner: string
    repo: string
    runnerId: number
  }): Promise<
    Res<
      200,
      {
        id?: number
        name?: string
        os?: string
        status?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteSelfHostedRunnerFromRepo(p: {
    accept?: string
    owner: string
    repo: string
    runnerId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListWorkflowRunsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    actor?: string
    branch?: string
    event?: string
    status?: "completed" | "status" | "conclusion"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        total_count?: number
        workflow_runs?: {
          artifacts_url?: string
          cancel_url?: string
          check_suite_url?: string
          conclusion?: string
          created_at?: string
          event?: string
          head_branch?: string
          head_commit?: {
            author?: {
              email?: string
              name?: string
            }
            committer?: {
              email?: string
              name?: string
            }
            id?: string
            message?: string
            timestamp?: string
            tree_id?: string
          }
          head_repository?: {
            archive_url?: string
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            deployments_url?: string
            description?: string
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            hooks_url?: string
            html_url?: string
            id?: number
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            name?: string
            node_id?: string
            notifications_url?: string
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            private?: boolean
            pulls_url?: string
            releases_url?: string
            stargazers_url?: string
            statuses_url?: string
            subscribers_url?: string
            subscription_url?: string
            tags_url?: string
            teams_url?: string
            trees_url?: string
            url?: string
          }
          head_sha?: string
          html_url?: string
          id?: number
          jobs_url?: string
          logs_url?: string
          node_id?: string
          pull_requests?: {
            [key: string]: unknown
          }[]
          repository?: {
            archive_url?: string
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            deployments_url?: string
            description?: string
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            html_url?: string
            id?: number
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            name?: string
            node_id?: string
            notifications_url?: string
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            private?: boolean
            pulls_url?: string
            releases_url?: string
            ssh_url?: string
            stargazers_url?: string
            statuses_url?: string
            subscribers_url?: string
            subscription_url?: string
            tags_url?: string
            teams_url?: string
            trees_url?: string
            url?: string
          }
          rerun_url?: string
          run_number?: number
          status?: string
          updated_at?: string
          url?: string
          workflow_id?: number
          workflow_url?: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs?${this._query({
          actor: p["actor"],
          branch: p["branch"],
          event: p["event"],
          status: p["status"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowRun(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
  }): Promise<
    Res<
      200,
      {
        artifacts_url?: string
        cancel_url?: string
        check_suite_url?: string
        conclusion?: string
        created_at?: string
        event?: string
        head_branch?: string
        head_commit?: {
          author?: {
            email?: string
            name?: string
          }
          committer?: {
            email?: string
            name?: string
          }
          id?: string
          message?: string
          timestamp?: string
          tree_id?: string
        }
        head_repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          hooks_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        head_sha?: string
        html_url?: string
        id?: number
        jobs_url?: string
        logs_url?: string
        node_id?: string
        pull_requests?: {
          [key: string]: unknown
        }[]
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        rerun_url?: string
        run_number?: number
        status?: string
        updated_at?: string
        url?: string
        workflow_id?: number
        workflow_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListWorkflowRunArtifacts(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        artifacts?: {
          archive_download_url: string
          created_at: string
          expired: boolean
          expires_at: string
          id: number
          name: string
          node_id: string
          size_in_bytes: number
          url: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${
          p["runId"]
        }/artifacts?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCancelWorkflowRun(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
  }): Promise<Res<202, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/cancel`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListJobsForWorkflowRun(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
    filter?: "latest" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        jobs?: {
          check_run_url?: string
          completed_at?: string
          conclusion?: string
          head_sha?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          run_id?: number
          run_url?: string
          started_at?: string
          status?: string
          steps?: {
            completed_at: string
            conclusion: string
            name: string
            number: number
            started_at: string
            status: string
          }[]
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${
          p["runId"]
        }/jobs?${this._query({
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDownloadWorkflowRunLogs(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteWorkflowRunLogs(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsReRunWorkflow(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
  }): Promise<Res<201, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/rerun`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowRunUsage(p: {
    accept?: string
    owner: string
    repo: string
    runId: number
  }): Promise<
    Res<
      200,
      {
        billable?: {
          MACOS?: {
            jobs?: number
            total_ms?: number
          }
          UBUNTU?: {
            jobs?: number
            total_ms?: number
          }
          WINDOWS?: {
            jobs?: number
            total_ms?: number
          }
        }
        run_duration_ms?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/timing`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRepoSecrets(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        secrets?: {
          created_at: string
          name: string
          updated_at: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRepoPublicKey(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        key?: string
        key_id?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/public-key`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetRepoSecret(p: {
    accept?: string
    owner: string
    repo: string
    secretName: string
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        name?: string
        updated_at?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsCreateOrUpdateRepoSecret(p: {
    accept?: string
    owner: string
    repo: string
    secretName: string
    requestBody: {
      encrypted_value?: string
      key_id?: string
    }
  }): Promise<Res<201, void> | Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsDeleteRepoSecret(p: {
    accept?: string
    owner: string
    repo: string
    secretName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListRepoWorkflows(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        total_count?: number
        workflows?: {
          badge_url: string
          created_at: string
          html_url: string
          id: number
          name: string
          node_id: string
          path: string
          state: string
          updated_at: string
          url: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflow(p: {
    accept?: string
    owner: string
    repo: string
    workflowId: number
  }): Promise<
    Res<
      200,
      {
        badge_url?: string
        created_at?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        path?: string
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsListWorkflowRuns(p: {
    accept?: string
    owner: string
    repo: string
    workflowId: number
    actor?: string
    branch?: string
    event?: string
    status?: "completed" | "status" | "conclusion"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        total_count?: number
        workflow_runs?: {
          artifacts_url?: string
          cancel_url?: string
          check_suite_url?: string
          conclusion?: string
          created_at?: string
          event?: string
          head_branch?: string
          head_commit?: {
            author?: {
              email?: string
              name?: string
            }
            committer?: {
              email?: string
              name?: string
            }
            id?: string
            message?: string
            timestamp?: string
            tree_id?: string
          }
          head_repository?: {
            archive_url?: string
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            deployments_url?: string
            description?: string
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            hooks_url?: string
            html_url?: string
            id?: number
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            name?: string
            node_id?: string
            notifications_url?: string
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            private?: boolean
            pulls_url?: string
            releases_url?: string
            stargazers_url?: string
            statuses_url?: string
            subscribers_url?: string
            subscription_url?: string
            tags_url?: string
            teams_url?: string
            trees_url?: string
            url?: string
          }
          head_sha?: string
          html_url?: string
          id?: number
          jobs_url?: string
          logs_url?: string
          node_id?: string
          pull_requests?: {
            [key: string]: unknown
          }[]
          repository?: {
            archive_url?: string
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            deployments_url?: string
            description?: string
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            html_url?: string
            id?: number
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            name?: string
            node_id?: string
            notifications_url?: string
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            private?: boolean
            pulls_url?: string
            releases_url?: string
            ssh_url?: string
            stargazers_url?: string
            statuses_url?: string
            subscribers_url?: string
            subscription_url?: string
            tags_url?: string
            teams_url?: string
            trees_url?: string
            url?: string
          }
          rerun_url?: string
          run_number?: number
          status?: string
          updated_at?: string
          url?: string
          workflow_id?: number
          workflow_url?: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${
          p["workflowId"]
        }/runs?${this._query({
          actor: p["actor"],
          branch: p["branch"],
          event: p["event"],
          status: p["status"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async actionsGetWorkflowUsage(p: {
    accept?: string
    owner: string
    repo: string
    workflowId: number
  }): Promise<
    Res<
      200,
      {
        billable?: {
          MACOS?: {
            total_ms?: number
          }
          UBUNTU?: {
            total_ms?: number
          }
          WINDOWS?: {
            total_ms?: number
          }
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/timing`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListAssignees(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/assignees?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCheckUserCanBeAssigned(p: {
    accept?: string
    owner: string
    repo: string
    assignee: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/assignees/${p["assignee"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposEnableAutomatedSecurityFixes(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDisableAutomatedSecurityFixes(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListBranches(p: {
    accept?: string
    owner: string
    repo: string
    protected?: boolean
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        commit?: {
          sha?: string
          url?: string
        }
        name?: string
        protected?: boolean
        protection?: {
          enabled?: boolean
          required_status_checks?: {
            contexts?: string[]
            enforcement_level?: string
          }
        }
        protection_url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches?${this._query({
          protected: p["protected"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetBranch(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: string
          self?: string
        }
        commit?: {
          author?: {
            avatar_url?: string
            gravatar_id?: string
            id?: number
            login?: string
            url?: string
          }
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            message?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
            verification?: {
              payload?: string
              reason?: string
              signature?: string
              verified?: boolean
            }
          }
          committer?: {
            avatar_url?: string
            gravatar_id?: string
            id?: number
            login?: string
            url?: string
          }
          node_id?: string
          parents?: {
            sha: string
            url: string
          }[]
          sha?: string
          url?: string
        }
        name?: string
        protected?: boolean
        protection?: {
          enabled?: boolean
          required_status_checks?: {
            contexts?: string[]
            enforcement_level?: string
          }
        }
        protection_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetBranchProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        allow_deletions?: {
          enabled?: boolean
        }
        allow_force_pushes?: {
          enabled?: boolean
        }
        enforce_admins?: {
          enabled?: boolean
          url?: string
        }
        required_linear_history?: {
          enabled?: boolean
        }
        required_pull_request_reviews?: {
          dismiss_stale_reviews?: boolean
          dismissal_restrictions?: {
            teams?: {
              description?: string
              html_url?: string
              id?: number
              members_url?: string
              name?: string
              node_id?: string
              parent?: string
              permission?: string
              privacy?: string
              repositories_url?: string
              slug?: string
              url?: string
            }[]
            teams_url?: string
            url?: string
            users?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }[]
            users_url?: string
          }
          require_code_owner_reviews?: boolean
          required_approving_review_count?: number
          url?: string
        }
        required_status_checks?: {
          contexts?: string[]
          contexts_url?: string
          strict?: boolean
          url?: string
        }
        restrictions?: {
          apps?: {
            created_at?: string
            description?: string
            events?: string[]
            external_url?: string
            html_url?: string
            id?: number
            name?: string
            node_id?: string
            owner?: {
              avatar_url?: string
              description?: string
              events_url?: string
              hooks_url?: string
              id?: number
              issues_url?: string
              login?: string
              members_url?: string
              node_id?: string
              public_members_url?: string
              repos_url?: string
              url?: string
            }
            permissions?: {
              contents?: string
              issues?: string
              metadata?: string
              single_file?: string
            }
            slug?: string
            updated_at?: string
          }[]
          apps_url?: string
          teams?: {
            description?: string
            html_url?: string
            id?: number
            members_url?: string
            name?: string
            node_id?: string
            parent?: string
            permission?: string
            privacy?: string
            repositories_url?: string
            slug?: string
            url?: string
          }[]
          teams_url?: string
          url?: string
          users?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }[]
          users_url?: string
        }
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateBranchProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: {
      allow_deletions?: boolean
      allow_force_pushes?: boolean | null
      enforce_admins: boolean | null
      required_linear_history?: boolean
      required_pull_request_reviews: {
        dismiss_stale_reviews?: boolean
        dismissal_restrictions?: {
          teams?: string[]
          users?: string[]
        }
        require_code_owner_reviews?: boolean
        required_approving_review_count?: number
      } | null
      required_status_checks: {
        contexts: string[]
        strict: boolean
      } | null
      restrictions: {
        apps?: string[]
        teams: string[]
        users: string[]
      } | null
    }
  }): Promise<
    Res<
      200,
      {
        allow_deletions?: {
          enabled?: boolean
        }
        allow_force_pushes?: {
          enabled?: boolean
        }
        enforce_admins?: {
          enabled?: boolean
          url?: string
        }
        required_linear_history?: {
          enabled?: boolean
        }
        required_pull_request_reviews?: {
          dismiss_stale_reviews?: boolean
          dismissal_restrictions?: {
            teams?: {
              description?: string
              html_url?: string
              id?: number
              members_url?: string
              name?: string
              node_id?: string
              parent?: string
              permission?: string
              privacy?: string
              repositories_url?: string
              slug?: string
              url?: string
            }[]
            teams_url?: string
            url?: string
            users?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }[]
            users_url?: string
          }
          require_code_owner_reviews?: boolean
          required_approving_review_count?: number
          url?: string
        }
        required_status_checks?: {
          contexts?: string[]
          contexts_url?: string
          strict?: boolean
          url?: string
        }
        restrictions?: {
          apps?: {
            created_at?: string
            description?: string
            events?: string[]
            external_url?: string
            html_url?: string
            id?: number
            name?: string
            node_id?: string
            owner?: {
              avatar_url?: string
              description?: string
              events_url?: string
              hooks_url?: string
              id?: number
              issues_url?: string
              login?: string
              members_url?: string
              node_id?: string
              public_members_url?: string
              repos_url?: string
              url?: string
            }
            permissions?: {
              contents?: string
              issues?: string
              metadata?: string
              single_file?: string
            }
            slug?: string
            updated_at?: string
          }[]
          apps_url?: string
          teams?: {
            description?: string
            html_url?: string
            id?: number
            members_url?: string
            name?: string
            node_id?: string
            parent?: string
            permission?: string
            privacy?: string
            repositories_url?: string
            slug?: string
            url?: string
          }[]
          teams_url?: string
          url?: string
          users?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }[]
          users_url?: string
        }
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteBranchProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAdminBranchProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        enabled?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetAdminBranchProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        enabled?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteAdminBranchProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPullRequestReviewProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        dismiss_stale_reviews?: boolean
        dismissal_restrictions?: {
          teams?: {
            description?: string
            html_url?: string
            id?: number
            members_url?: string
            name?: string
            node_id?: string
            parent?: string
            permission?: string
            privacy?: string
            repositories_url?: string
            slug?: string
            url?: string
          }[]
          teams_url?: string
          url?: string
          users?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }[]
          users_url?: string
        }
        require_code_owner_reviews?: boolean
        required_approving_review_count?: number
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdatePullRequestReviewProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: {
      dismiss_stale_reviews?: boolean
      dismissal_restrictions?: {
        teams?: string[]
        users?: string[]
      }
      require_code_owner_reviews?: boolean
      required_approving_review_count?: number
    }
  }): Promise<
    Res<
      200,
      {
        dismiss_stale_reviews?: boolean
        dismissal_restrictions?: {
          teams?: {
            description?: string
            html_url?: string
            id?: number
            members_url?: string
            name?: string
            node_id?: string
            parent?: string
            permission?: string
            privacy?: string
            repositories_url?: string
            slug?: string
            url?: string
          }[]
          teams_url?: string
          url?: string
          users?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }[]
          users_url?: string
        }
        require_code_owner_reviews?: boolean
        required_approving_review_count?: number
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeletePullRequestReviewProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommitSignatureProtection(p: {
    accept: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        enabled?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateCommitSignatureProtection(p: {
    accept: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        enabled?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteCommitSignatureProtection(p: {
    accept: string
    owner: string
    repo: string
    branch: string
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetStatusChecksProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        contexts?: string[]
        contexts_url?: string
        strict?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateStatusCheckPotection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: {
      contexts?: string[]
      strict?: boolean
    }
  }): Promise<
    Res<
      200,
      {
        contexts?: string[]
        contexts_url?: string
        strict?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveStatusCheckProtection(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAllStatusCheckContexts(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<Res<200, string[]>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetStatusCheckContexts(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<Res<200, string[]>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddStatusCheckContexts(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<Res<200, string[]>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveStatusCheckContexts(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<Res<200, string[]>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        apps?: {
          created_at?: string
          description?: string
          events?: string[]
          external_url?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          owner?: {
            avatar_url?: string
            description?: string
            events_url?: string
            hooks_url?: string
            id?: number
            issues_url?: string
            login?: string
            members_url?: string
            node_id?: string
            public_members_url?: string
            repos_url?: string
            url?: string
          }
          permissions?: {
            contents?: string
            issues?: string
            metadata?: string
            single_file?: string
          }
          slug?: string
          updated_at?: string
        }[]
        apps_url?: string
        teams?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          parent?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }[]
        teams_url?: string
        url?: string
        users?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        users_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAppsWithAccessToProtectedBranch(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        events?: string[]
        external_url?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        permissions?: {
          contents?: string
          issues?: string
          metadata?: string
          single_file?: string
        }
        slug?: string
        updated_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetAppAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        events?: string[]
        external_url?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        permissions?: {
          contents?: string
          issues?: string
          metadata?: string
          single_file?: string
        }
        slug?: string
        updated_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddAppAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        events?: string[]
        external_url?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        permissions?: {
          contents?: string
          issues?: string
          metadata?: string
          single_file?: string
        }
        slug?: string
        updated_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveAppAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        events?: string[]
        external_url?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        permissions?: {
          contents?: string
          issues?: string
          metadata?: string
          single_file?: string
        }
        slug?: string
        updated_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetTeamsWithAccessToProtectedBranch(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        description?: string
        html_url?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: string
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetTeamAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        description?: string
        html_url?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: string
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddTeamAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        description?: string
        html_url?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: string
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveTeamAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        description?: string
        html_url?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: string
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetUsersWithAccessToProtectedBranch(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposSetUserAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddUserAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveUserAccessRestrictions(p: {
    accept?: string
    owner: string
    repo: string
    branch: string
    requestBody: string[]
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksCreate(p: {
    accept: string
    owner: string
    repo: string
    requestBody: {
      actions?: {
        description: string
        identifier: string
        label: string
      }[]
      completed_at?: string
      conclusion?:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "skipped"
        | "timed_out"
        | "action_required"
      details_url?: string
      external_id?: string
      head_sha: string
      name: string
      output?: {
        annotations?: {
          annotation_level: "notice" | "warning" | "failure"
          end_column?: number
          end_line: number
          message: string
          path: string
          raw_details?: string
          start_column?: number
          start_line: number
          title?: string
        }[]
        images?: {
          alt: string
          caption?: string
          image_url: string
        }[]
        summary: string
        text?: string
        title: string
      }
      started_at?: string
      status?: "queued" | "in_progress" | "completed"
    }
  }): Promise<
    Res<
      201,
      {
        app?: {
          created_at?: string
          description?: string
          events?: string[]
          external_url?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          owner?: {
            avatar_url?: string
            description?: string
            events_url?: string
            hooks_url?: string
            id?: number
            issues_url?: string
            login?: string
            members_url?: string
            node_id?: string
            public_members_url?: string
            repos_url?: string
            url?: string
          }
          permissions?: {
            contents?: string
            issues?: string
            metadata?: string
            single_file?: string
          }
          slug?: string
          updated_at?: string
        }
        check_suite?: {
          id?: number
        }
        completed_at?: string
        conclusion?: string
        details_url?: string
        external_id?: string
        head_sha?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        output?: {
          summary?: string
          text?: string
          title?: string
        }
        pull_requests?: {
          base?: {
            ref?: string
            repo?: {
              id?: number
              name?: string
              url?: string
            }
            sha?: string
          }
          head?: {
            ref?: string
            repo?: {
              id?: number
              name?: string
              url?: string
            }
            sha?: string
          }
          id?: number
          number?: number
          url?: string
        }[]
        started_at?: string
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/check-runs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksUpdate(p: {
    accept: string
    owner: string
    repo: string
    checkRunId: number
    requestBody: {
      actions?: {
        description: string
        identifier: string
        label: string
      }[]
      completed_at?: string
      conclusion?:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "skipped"
        | "timed_out"
        | "action_required"
      details_url?: string
      external_id?: string
      name?: string
      output?: {
        annotations?: {
          annotation_level: "notice" | "warning" | "failure"
          end_column?: number
          end_line: number
          message: string
          path: string
          raw_details?: string
          start_column?: number
          start_line: number
          title?: string
        }[]
        images?: {
          alt: string
          caption?: string
          image_url: string
        }[]
        summary: string
        text?: string
        title?: string
      }
      started_at?: string
      status?: "queued" | "in_progress" | "completed"
    }
  }): Promise<
    Res<
      200,
      {
        app?: {
          created_at?: string
          description?: string
          events?: string[]
          external_url?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          owner?: {
            avatar_url?: string
            description?: string
            events_url?: string
            hooks_url?: string
            id?: number
            issues_url?: string
            login?: string
            members_url?: string
            node_id?: string
            public_members_url?: string
            repos_url?: string
            url?: string
          }
          permissions?: {
            contents?: string
            issues?: string
            metadata?: string
            single_file?: string
          }
          slug?: string
          updated_at?: string
        }
        check_suite?: {
          id?: number
        }
        completed_at?: string
        conclusion?: string
        details_url?: string
        external_id?: string
        head_sha?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        output?: {
          annotations_count?: number
          annotations_url?: string
          summary?: string
          text?: string
          title?: string
        }
        pull_requests?: {
          base?: {
            ref?: string
            repo?: {
              id?: number
              name?: string
              url?: string
            }
            sha?: string
          }
          head?: {
            ref?: string
            repo?: {
              id?: number
              name?: string
              url?: string
            }
            sha?: string
          }
          id?: number
          number?: number
          url?: string
        }[]
        started_at?: string
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksGet(p: {
    accept: string
    owner: string
    repo: string
    checkRunId: number
  }): Promise<
    Res<
      200,
      {
        app?: {
          created_at?: string
          description?: string
          events?: string[]
          external_url?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          owner?: {
            avatar_url?: string
            description?: string
            events_url?: string
            hooks_url?: string
            id?: number
            issues_url?: string
            login?: string
            members_url?: string
            node_id?: string
            public_members_url?: string
            repos_url?: string
            url?: string
          }
          permissions?: {
            contents?: string
            issues?: string
            metadata?: string
            single_file?: string
          }
          slug?: string
          updated_at?: string
        }
        check_suite?: {
          id?: number
        }
        completed_at?: string
        conclusion?: string
        details_url?: string
        external_id?: string
        head_sha?: string
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        output?: {
          annotations_count?: number
          annotations_url?: string
          summary?: string
          text?: string
          title?: string
        }
        pull_requests?: {
          base?: {
            ref?: string
            repo?: {
              id?: number
              name?: string
              url?: string
            }
            sha?: string
          }
          head?: {
            ref?: string
            repo?: {
              id?: number
              name?: string
              url?: string
            }
            sha?: string
          }
          id?: number
          number?: number
          url?: string
        }[]
        started_at?: string
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListAnnotations(p: {
    accept: string
    owner: string
    repo: string
    checkRunId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        annotation_level?: string
        end_column?: number
        end_line?: number
        message?: string
        path?: string
        raw_details?: string
        start_column?: number
        start_line?: number
        title?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-runs/${
          p["checkRunId"]
        }/annotations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksCreateSuite(p: {
    accept: string
    owner: string
    repo: string
    requestBody: {
      head_sha: string
    }
  }): Promise<
    Res<
      201,
      {
        after?: string
        app?: {
          created_at?: string
          description?: string
          events?: string[]
          external_url?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          owner?: {
            avatar_url?: string
            description?: string
            events_url?: string
            hooks_url?: string
            id?: number
            issues_url?: string
            login?: string
            members_url?: string
            node_id?: string
            public_members_url?: string
            repos_url?: string
            url?: string
          }
          permissions?: {
            contents?: string
            issues?: string
            metadata?: string
            single_file?: string
          }
          slug?: string
          updated_at?: string
        }
        before?: string
        conclusion?: string
        head_branch?: string
        head_sha?: string
        id?: number
        node_id?: string
        pull_requests?: {
          [key: string]: unknown
        }[]
        repository?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/check-suites`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksSetSuitesPreferences(p: {
    accept: string
    owner: string
    repo: string
    requestBody: {
      auto_trigger_checks?: {
        app_id: number
        setting: boolean
      }[]
    }
  }): Promise<
    Res<
      200,
      {
        preferences?: {
          auto_trigger_checks?: {
            app_id: number
            setting: boolean
          }[]
        }
        repository?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/preferences`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksGetSuite(p: {
    accept: string
    owner: string
    repo: string
    checkSuiteId: number
  }): Promise<
    Res<
      200,
      {
        after?: string
        app?: {
          created_at?: string
          description?: string
          events?: string[]
          external_url?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          owner?: {
            avatar_url?: string
            description?: string
            events_url?: string
            hooks_url?: string
            id?: number
            issues_url?: string
            login?: string
            members_url?: string
            node_id?: string
            public_members_url?: string
            repos_url?: string
            url?: string
          }
          permissions?: {
            contents?: string
            issues?: string
            metadata?: string
            single_file?: string
          }
          slug?: string
          updated_at?: string
        }
        before?: string
        conclusion?: string
        head_branch?: string
        head_sha?: string
        id?: number
        node_id?: string
        pull_requests?: {
          [key: string]: unknown
        }[]
        repository?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListForSuite(p: {
    accept: string
    owner: string
    repo: string
    checkSuiteId: number
    checkName?: string
    status?: "queued" | "in_progress" | "completed"
    filter?: "latest" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        check_runs?: {
          app?: {
            created_at?: string
            description?: string
            events?: string[]
            external_url?: string
            html_url?: string
            id?: number
            name?: string
            node_id?: string
            owner?: {
              avatar_url?: string
              description?: string
              events_url?: string
              hooks_url?: string
              id?: number
              issues_url?: string
              login?: string
              members_url?: string
              node_id?: string
              public_members_url?: string
              repos_url?: string
              url?: string
            }
            permissions?: {
              contents?: string
              issues?: string
              metadata?: string
              single_file?: string
            }
            slug?: string
            updated_at?: string
          }
          check_suite?: {
            id?: number
          }
          completed_at?: string
          conclusion?: string
          details_url?: string
          external_id?: string
          head_sha?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          output?: {
            annotations_count?: number
            annotations_url?: string
            summary?: string
            text?: string
            title?: string
          }
          pull_requests?: {
            base?: {
              ref?: string
              repo?: {
                id?: number
                name?: string
                url?: string
              }
              sha?: string
            }
            head?: {
              ref?: string
              repo?: {
                id?: number
                name?: string
                url?: string
              }
              sha?: string
            }
            id?: number
            number?: number
            url?: string
          }[]
          started_at?: string
          status?: string
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/${
          p["checkSuiteId"]
        }/check-runs?${this._query({
          check_name: p["checkName"],
          status: p["status"],
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksRerequestSuite(p: {
    accept: string
    owner: string
    repo: string
    checkSuiteId: number
  }): Promise<Res<201, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}/rerequest`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningListAlertsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    state?: string
    ref?: string
  }): Promise<
    | Res<
        200,
        {
          closed_at?: string
          closed_by?: string
          created_at?: string
          html_url?: string
          open?: boolean
          rule_description?: string
          rule_id?: string
          rule_severity?: string
          tool?: string
          url?: string
        }[]
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts?${this._query({
          state: p["state"],
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codeScanningGetAlert(p: {
    accept?: string
    owner: string
    repo: string
    alertId: number
  }): Promise<
    Res<
      200,
      {
        closed_at?: string
        closed_by?: string
        created_at?: string
        html_url?: string
        open?: boolean
        rule_description?: string
        rule_id?: string
        rule_severity?: string
        tool?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCollaborators(p: {
    accept?: string
    owner: string
    repo: string
    affiliation?: "outside" | "direct" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators?${this._query({
          affiliation: p["affiliation"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCheckCollaborator(p: {
    accept?: string
    owner: string
    repo: string
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAddCollaborator(p: {
    accept?: string
    owner: string
    repo: string
    username: string
    requestBody: {
      permission?: "pull" | "push" | "admin" | "maintain" | "triage"
    }
  }): Promise<
    | Res<
        201,
        {
          created_at?: string
          html_url?: string
          id?: number
          invitee?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          inviter?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: string
          repository?: {
            archive_url?: string
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            deployments_url?: string
            description?: string
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            html_url?: string
            id?: number
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            name?: string
            node_id?: string
            notifications_url?: string
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            private?: boolean
            pulls_url?: string
            releases_url?: string
            ssh_url?: string
            stargazers_url?: string
            statuses_url?: string
            subscribers_url?: string
            subscription_url?: string
            tags_url?: string
            teams_url?: string
            trees_url?: string
            url?: string
          }
          url?: string
        }
      >
    | Res<204, void>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRemoveCollaborator(p: {
    accept?: string
    owner: string
    repo: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCollaboratorPermissionLevel(p: {
    accept?: string
    owner: string
    repo: string
    username: string
  }): Promise<
    Res<
      200,
      {
        permission?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}/permission`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommitCommentsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        commit_id?: string
        created_at?: string
        html_url?: string
        id?: number
        line?: number
        node_id?: string
        path?: string
        position?: number
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommitComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        commit_id?: string
        created_at?: string
        html_url?: string
        id?: number
        line?: number
        node_id?: string
        path?: string
        position?: number
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateCommitComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      200,
      {
        body?: string
        commit_id?: string
        created_at?: string
        html_url?: string
        id?: number
        line?: number
        node_id?: string
        path?: string
        position?: number
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteCommitComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForCommitComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${
          p["commentId"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForCommitComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForCommitComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommits(p: {
    accept?: string
    owner: string
    repo: string
    sha?: string
    path?: string
    author?: string
    since?: string
    until?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        comments_url?: string
        commit?: {
          author?: {
            date?: string
            email?: string
            name?: string
          }
          comment_count?: number
          committer?: {
            date?: string
            email?: string
            name?: string
          }
          message?: string
          tree?: {
            sha?: string
            url?: string
          }
          url?: string
          verification?: {
            payload?: string
            reason?: string
            signature?: string
            verified?: boolean
          }
        }
        committer?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        node_id?: string
        parents?: {
          sha?: string
          url?: string
        }[]
        sha?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits?${this._query({
          sha: p["sha"],
          path: p["path"],
          author: p["author"],
          since: p["since"],
          until: p["until"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListBranchesForHeadCommit(p: {
    accept: string
    owner: string
    repo: string
    commitSha: string
  }): Promise<
    Res<
      200,
      {
        commit?: {
          sha?: string
          url?: string
        }
        name?: string
        protected?: boolean
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/branches-where-head`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommentsForCommit(p: {
    accept?: string
    owner: string
    repo: string
    commitSha: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        commit_id?: string
        created_at?: string
        html_url?: string
        id?: number
        line?: number
        node_id?: string
        path?: string
        position?: number
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["commitSha"]
        }/comments?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateCommitComment(p: {
    accept?: string
    owner: string
    repo: string
    commitSha: string
    requestBody: {
      body: string
      line?: number
      path?: string
      position?: number
    }
  }): Promise<
    Res<
      201,
      {
        body?: string
        commit_id?: string
        created_at?: string
        html_url?: string
        id?: number
        line?: number
        node_id?: string
        path?: string
        position?: number
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListPullRequestsAssociatedWithCommit(p: {
    accept: string
    owner: string
    repo: string
    commitSha: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          comments?: {
            href?: string
          }
          commits?: {
            href?: string
          }
          html?: {
            href?: string
          }
          issue?: {
            href?: string
          }
          review_comment?: {
            href?: string
          }
          review_comments?: {
            href?: string
          }
          self?: {
            href?: string
          }
          statuses?: {
            href?: string
          }
        }
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url: string
          events_url: string
          followers_url: string
          following_url: string
          gists_url: string
          gravatar_id: string
          html_url: string
          id: number
          login: string
          node_id: string
          organizations_url: string
          received_events_url: string
          repos_url: string
          site_admin: boolean
          starred_url: string
          subscriptions_url: string
          type: string
          url: string
        }[]
        author_association?: string
        base?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        body?: string
        closed_at?: string
        comments_url?: string
        commits_url?: string
        created_at?: string
        diff_url?: string
        draft?: boolean
        head?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        html_url?: string
        id?: number
        issue_url?: string
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        locked?: boolean
        merge_commit_sha?: string
        merged_at?: string
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        patch_url?: string
        requested_reviewers?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        requested_teams?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          parent?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }[]
        review_comment_url?: string
        review_comments_url?: string
        state?: string
        statuses_url?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["commitSha"]
        }/pulls?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommit(p: {
    accept?: string
    owner: string
    repo: string
    ref: string
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        comments_url?: string
        commit?: {
          author?: {
            date?: string
            email?: string
            name?: string
          }
          comment_count?: number
          committer?: {
            date?: string
            email?: string
            name?: string
          }
          message?: string
          tree?: {
            sha?: string
            url?: string
          }
          url?: string
          verification?: {
            payload?: string
            reason?: string
            signature?: string
            verified?: boolean
          }
        }
        committer?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        files?: {
          additions?: number
          blob_url?: string
          changes?: number
          deletions?: number
          filename?: string
          patch?: string
          raw_url?: string
          status?: string
        }[]
        html_url?: string
        node_id?: string
        parents?: {
          sha?: string
          url?: string
        }[]
        sha?: string
        stats?: {
          additions?: number
          deletions?: number
          total?: number
        }
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListForRef(p: {
    accept: string
    owner: string
    repo: string
    ref: string
    checkName?: string
    status?: "queued" | "in_progress" | "completed"
    filter?: "latest" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        check_runs?: {
          app?: {
            created_at?: string
            description?: string
            events?: string[]
            external_url?: string
            html_url?: string
            id?: number
            name?: string
            node_id?: string
            owner?: {
              avatar_url?: string
              description?: string
              events_url?: string
              hooks_url?: string
              id?: number
              issues_url?: string
              login?: string
              members_url?: string
              node_id?: string
              public_members_url?: string
              repos_url?: string
              url?: string
            }
            permissions?: {
              contents?: string
              issues?: string
              metadata?: string
              single_file?: string
            }
            slug?: string
            updated_at?: string
          }
          check_suite?: {
            id?: number
          }
          completed_at?: string
          conclusion?: string
          details_url?: string
          external_id?: string
          head_sha?: string
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          output?: {
            annotations_count?: number
            annotations_url?: string
            summary?: string
            text?: string
            title?: string
          }
          pull_requests?: {
            base?: {
              ref?: string
              repo?: {
                id?: number
                name?: string
                url?: string
              }
              sha?: string
            }
            head?: {
              ref?: string
              repo?: {
                id?: number
                name?: string
                url?: string
              }
              sha?: string
            }
            id?: number
            number?: number
            url?: string
          }[]
          started_at?: string
          status?: string
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["ref"]
        }/check-runs?${this._query({
          check_name: p["checkName"],
          status: p["status"],
          filter: p["filter"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async checksListSuitesForRef(p: {
    accept: string
    owner: string
    repo: string
    ref: string
    appId?: number
    checkName?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        check_suites?: {
          after?: string
          app?: {
            created_at?: string
            description?: string
            events?: string[]
            external_url?: string
            html_url?: string
            id?: number
            name?: string
            node_id?: string
            owner?: {
              avatar_url?: string
              description?: string
              events_url?: string
              hooks_url?: string
              id?: number
              issues_url?: string
              login?: string
              members_url?: string
              node_id?: string
              public_members_url?: string
              repos_url?: string
              url?: string
            }
            permissions?: {
              contents?: string
              issues?: string
              metadata?: string
              single_file?: string
            }
            slug?: string
            updated_at?: string
          }
          before?: string
          conclusion?: string
          head_branch?: string
          head_sha?: string
          id?: number
          node_id?: string
          pull_requests?: {
            [key: string]: unknown
          }[]
          repository?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          status?: string
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["ref"]
        }/check-suites?${this._query({
          app_id: p["appId"],
          check_name: p["checkName"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCombinedStatusForRef(p: {
    accept?: string
    owner: string
    repo: string
    ref: string
  }): Promise<
    Res<
      200,
      {
        commit_url?: string
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        sha?: string
        state?: string
        statuses?: {
          avatar_url: string
          context: string
          created_at: string
          description: string
          id: number
          node_id: string
          state: string
          target_url: string
          updated_at: string
          url: string
        }[]
        total_count?: number
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/status`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListCommitStatusesForRef(p: {
    accept?: string
    owner: string
    repo: string
    ref: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        context?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        id?: number
        node_id?: string
        state?: string
        target_url?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/commits/${
          p["ref"]
        }/statuses?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async codesOfConductGetForRepo(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        body?: string
        key?: string
        name?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/community/code_of_conduct`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommunityProfileMetrics(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        description?: string
        documentation?: boolean
        files?: {
          code_of_conduct?: {
            html_url?: string
            key?: string
            name?: string
            url?: string
          }
          contributing?: {
            html_url?: string
            url?: string
          }
          issue_template?: {
            html_url?: string
            url?: string
          }
          license?: {
            html_url?: string
            key?: string
            name?: string
            spdx_id?: string
            url?: string
          }
          pull_request_template?: {
            html_url?: string
            url?: string
          }
          readme?: {
            html_url?: string
            url?: string
          }
        }
        health_percentage?: number
        updated_at?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/community/profile`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCompareCommits(p: {
    accept?: string
    owner: string
    repo: string
    base: string
    head: string
  }): Promise<
    Res<
      200,
      {
        ahead_by?: number
        base_commit?: {
          author?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          comments_url?: string
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            comment_count?: number
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            message?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
            verification?: {
              payload?: string
              reason?: string
              signature?: string
              verified?: boolean
            }
          }
          committer?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          node_id?: string
          parents?: {
            sha?: string
            url?: string
          }[]
          sha?: string
          url?: string
        }
        behind_by?: number
        commits?: {
          author?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          comments_url?: string
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            comment_count?: number
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            message?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
            verification?: {
              payload?: string
              reason?: string
              signature?: string
              verified?: boolean
            }
          }
          committer?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          node_id?: string
          parents?: {
            sha?: string
            url?: string
          }[]
          sha?: string
          url?: string
        }[]
        diff_url?: string
        files?: {
          additions?: number
          blob_url?: string
          changes?: number
          contents_url?: string
          deletions?: number
          filename?: string
          patch?: string
          raw_url?: string
          sha?: string
          status?: string
        }[]
        html_url?: string
        merge_base_commit?: {
          author?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          comments_url?: string
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            comment_count?: number
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            message?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
            verification?: {
              payload?: string
              reason?: string
              signature?: string
              verified?: boolean
            }
          }
          committer?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          node_id?: string
          parents?: {
            sha?: string
            url?: string
          }[]
          sha?: string
          url?: string
        }
        patch_url?: string
        permalink_url?: string
        status?: string
        total_commits?: number
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/compare/${p["base"]}...${p["head"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetContent(p: {
    accept?: string
    owner: string
    repo: string
    path: string
    ref?: string
  }): Promise<
    Res<
      200,
      {
        _links?: {
          git?: string
          html?: string
          self?: string
        }
        content?: string
        download_url?: string
        encoding?: string
        git_url?: string
        html_url?: string
        name?: string
        path?: string
        sha?: string
        size?: number
        type?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}?${this._query({
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateOrUpdateFileContents(p: {
    accept?: string
    owner: string
    repo: string
    path: string
    requestBody: {
      author?: {
        email: string
        name: string
      }
      branch?: string
      committer?: {
        email: string
        name: string
      }
      content: string
      message: string
      sha?: string
    }
  }): Promise<
    | Res<
        200,
        {
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            html_url?: string
            message?: string
            node_id?: string
            parents?: {
              html_url?: string
              sha?: string
              url?: string
            }[]
            sha?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
            verification?: {
              payload?: string
              reason?: string
              signature?: string
              verified?: boolean
            }
          }
          content?: {
            _links?: {
              git?: string
              html?: string
              self?: string
            }
            download_url?: string
            git_url?: string
            html_url?: string
            name?: string
            path?: string
            sha?: string
            size?: number
            type?: string
            url?: string
          }
        }
      >
    | Res<
        201,
        {
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            html_url?: string
            message?: string
            node_id?: string
            parents?: {
              html_url?: string
              sha?: string
              url?: string
            }[]
            sha?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
            verification?: {
              payload?: string
              reason?: string
              signature?: string
              verified?: boolean
            }
          }
          content?: {
            _links?: {
              git?: string
              html?: string
              self?: string
            }
            download_url?: string
            git_url?: string
            html_url?: string
            name?: string
            path?: string
            sha?: string
            size?: number
            type?: string
            url?: string
          }
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteFile(p: {
    accept?: string
    owner: string
    repo: string
    path: string
    requestBody: {
      author?: {
        email?: string
        name?: string
      }
      branch?: string
      committer?: {
        email?: string
        name?: string
      }
      message: string
      sha: string
    }
  }): Promise<
    Res<
      200,
      {
        commit?: {
          author?: {
            date?: string
            email?: string
            name?: string
          }
          committer?: {
            date?: string
            email?: string
            name?: string
          }
          html_url?: string
          message?: string
          node_id?: string
          parents?: {
            html_url?: string
            sha?: string
            url?: string
          }[]
          sha?: string
          tree?: {
            sha?: string
            url?: string
          }
          url?: string
          verification?: {
            payload?: string
            reason?: string
            signature?: string
            verified?: boolean
          }
        }
        content?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListContributors(p: {
    accept?: string
    owner: string
    repo: string
    anon?: string
    perPage?: number
    page?: number
  }): Promise<
    | Res<
        200,
        {
          avatar_url?: string
          contributions?: number
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
      >
    | Res<204, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/contributors?${this._query({
          anon: p["anon"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListDeployments(p: {
    accept?: string
    owner: string
    repo: string
    sha?: string
    ref?: string
    task?: string
    environment?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        environment?: string
        id?: number
        node_id?: string
        original_environment?: string
        payload?: {
          deploy?: string
        }
        production_environment?: boolean
        ref?: string
        repository_url?: string
        sha?: string
        statuses_url?: string
        task?: string
        transient_environment?: boolean
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments?${this._query({
          sha: p["sha"],
          ref: p["ref"],
          task: p["task"],
          environment: p["environment"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDeployment(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      auto_merge?: boolean
      description?: string
      environment?: string
      payload?: string
      production_environment?: boolean
      ref: string
      required_contexts?: string[]
      task?: string
      transient_environment?: boolean
    }
  }): Promise<
    | Res<
        201,
        {
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          environment?: string
          id?: number
          node_id?: string
          original_environment?: string
          payload?: {
            deploy?: string
          }
          production_environment?: boolean
          ref?: string
          repository_url?: string
          sha?: string
          statuses_url?: string
          task?: string
          transient_environment?: boolean
          updated_at?: string
          url?: string
        }
      >
    | Res<
        202,
        {
          message?: string
        }
      >
    | Res<
        409,
        {
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/deployments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetDeployment(p: {
    accept?: string
    owner: string
    repo: string
    deploymentId: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        environment?: string
        id?: number
        node_id?: string
        original_environment?: string
        payload?: {
          deploy?: string
        }
        production_environment?: boolean
        ref?: string
        repository_url?: string
        sha?: string
        statuses_url?: string
        task?: string
        transient_environment?: boolean
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteDeployment(p: {
    accept?: string
    owner: string
    repo: string
    deploymentId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListDeploymentStatuses(p: {
    accept?: string
    owner: string
    repo: string
    deploymentId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        deployment_url?: string
        description?: string
        environment?: string
        environment_url?: string
        id?: number
        log_url?: string
        node_id?: string
        repository_url?: string
        state?: string
        target_url?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${
          p["deploymentId"]
        }/statuses?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDeploymentStatus(p: {
    accept?: string
    owner: string
    repo: string
    deploymentId: number
    requestBody: {
      auto_inactive?: boolean
      description?: string
      environment?: "production" | "staging" | "qa"
      environment_url?: string
      log_url?: string
      state:
        | "error"
        | "failure"
        | "inactive"
        | "in_progress"
        | "queued"
        | "pending"
        | "success"
      target_url?: string
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        deployment_url?: string
        description?: string
        environment?: string
        environment_url?: string
        id?: number
        log_url?: string
        node_id?: string
        repository_url?: string
        state?: string
        target_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetDeploymentStatus(p: {
    accept?: string
    owner: string
    repo: string
    deploymentId: number
    statusId: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        deployment_url?: string
        description?: string
        environment?: string
        environment_url?: string
        id?: number
        log_url?: string
        node_id?: string
        repository_url?: string
        state?: string
        target_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses/${p["statusId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDispatchEvent(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      client_payload?: {
        [key: string]: unknown
      }
      event_type?: string
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/dispatches`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListRepoEvents(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForks(p: {
    accept?: string
    owner: string
    repo: string
    sort?: "newest" | "oldest" | "stargazers"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/forks?${this._query({
          sort: p["sort"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateFork(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      organization?: string
    }
  }): Promise<
    Res<
      202,
      {
        allow_merge_commit?: boolean
        allow_rebase_merge?: boolean
        allow_squash_merge?: boolean
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/forks`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateBlob(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      content: string
      encoding?: string
    }
  }): Promise<
    Res<
      201,
      {
        sha?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/blobs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetBlob(p: {
    accept?: string
    owner: string
    repo: string
    fileSha: string
  }): Promise<
    Res<
      200,
      {
        content?: string
        encoding?: string
        sha?: string
        size?: number
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/blobs/${p["fileSha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateCommit(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      author?: {
        date?: string
        email?: string
        name?: string
      }
      committer?: {
        date?: string
        email?: string
        name?: string
      }
      message: string
      parents: string[]
      signature?: string
      tree: string
    }
  }): Promise<
    Res<
      201,
      {
        author?: {
          date?: string
          email?: string
          name?: string
        }
        committer?: {
          date?: string
          email?: string
          name?: string
        }
        message?: string
        node_id?: string
        parents?: {
          sha?: string
          url?: string
        }[]
        sha?: string
        tree?: {
          sha?: string
          url?: string
        }
        url?: string
        verification?: {
          payload?: string
          reason?: string
          signature?: string
          verified?: boolean
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/commits`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetCommit(p: {
    accept?: string
    owner: string
    repo: string
    commitSha: string
  }): Promise<
    Res<
      200,
      {
        author?: {
          date?: string
          email?: string
          name?: string
        }
        committer?: {
          date?: string
          email?: string
          name?: string
        }
        message?: string
        node_id?: string
        parents?: {
          sha?: string
          url?: string
        }[]
        sha?: string
        tree?: {
          sha?: string
          url?: string
        }
        url?: string
        verification?: {
          payload?: string
          reason?: string
          signature?: string
          verified?: boolean
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/commits/${p["commitSha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitListMatchingRefs(p: {
    accept?: string
    owner: string
    repo: string
    ref: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        node_id?: string
        object?: {
          sha?: string
          type?: string
          url?: string
        }
        ref?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/matching-refs/${
          p["ref"]
        }?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetRef(p: {
    accept?: string
    owner: string
    repo: string
    ref: string
  }): Promise<
    Res<
      200,
      {
        node_id?: string
        object?: {
          sha?: string
          type?: string
          url?: string
        }
        ref?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/ref/${p["ref"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateRef(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      ref: string
      sha: string
    }
  }): Promise<
    Res<
      201,
      {
        node_id?: string
        object?: {
          sha?: string
          type?: string
          url?: string
        }
        ref?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/refs`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitUpdateRef(p: {
    accept?: string
    owner: string
    repo: string
    ref: string
    requestBody: {
      force?: boolean
      sha: string
    }
  }): Promise<
    Res<
      200,
      {
        node_id?: string
        object?: {
          sha?: string
          type?: string
          url?: string
        }
        ref?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitDeleteRef(p: {
    accept?: string
    owner: string
    repo: string
    ref: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateTag(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      message: string
      object: string
      tag: string
      tagger?: {
        date?: string
        email?: string
        name?: string
      }
      type: "commit" | "tree" | "blob"
    }
  }): Promise<
    Res<
      201,
      {
        message?: string
        node_id?: string
        object?: {
          sha?: string
          type?: string
          url?: string
        }
        sha?: string
        tag?: string
        tagger?: {
          date?: string
          email?: string
          name?: string
        }
        url?: string
        verification?: {
          payload?: string
          reason?: string
          signature?: string
          verified?: boolean
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/tags`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetTag(p: {
    accept?: string
    owner: string
    repo: string
    tagSha: string
  }): Promise<
    Res<
      200,
      {
        message?: string
        node_id?: string
        object?: {
          sha?: string
          type?: string
          url?: string
        }
        sha?: string
        tag?: string
        tagger?: {
          date?: string
          email?: string
          name?: string
        }
        url?: string
        verification?: {
          payload?: string
          reason?: string
          signature?: string
          verified?: boolean
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/tags/${p["tagSha"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitCreateTree(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      base_tree?: string
      tree: {
        content?: string
        mode?: "100644" | "100755" | "040000" | "160000" | "120000"
        path?: string
        sha?: string | null
        type?: "blob" | "tree" | "commit"
      }[]
    }
  }): Promise<
    Res<
      201,
      {
        sha?: string
        tree?: {
          mode?: string
          path?: string
          sha?: string
          size?: number
          type?: string
          url?: string
        }[]
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/trees`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gitGetTree(p: {
    accept?: string
    owner: string
    repo: string
    treeSha: string
    recursive?: string
  }): Promise<
    Res<
      200,
      {
        sha?: string
        tree?: {
          mode: string
          path: string
          sha: string
          size: number
          type: string
          url: string
        }[]
        truncated?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/git/trees/${
          p["treeSha"]
        }?${this._query({ recursive: p["recursive"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListWebhooks(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        config?: {
          content_type?: string
          insecure_ssl?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        last_response?: {
          code?: string
          message?: string
          status?: string
        }
        name?: string
        ping_url?: string
        test_url?: string
        type?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateWebhook(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      active?: boolean
      config: {
        content_type?: string
        insecure_ssl?: string
        secret?: string
        url: string
      }
      events?: string[]
      name?: string
    }
  }): Promise<
    Res<
      201,
      {
        active?: boolean
        config?: {
          content_type?: string
          insecure_ssl?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        last_response?: {
          code?: string
          message?: string
          status?: string
        }
        name?: string
        ping_url?: string
        test_url?: string
        type?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/hooks`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetWebhook(p: {
    accept?: string
    owner: string
    repo: string
    hookId: number
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        config?: {
          content_type?: string
          insecure_ssl?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        last_response?: {
          code?: string
          message?: string
          status?: string
        }
        name?: string
        ping_url?: string
        test_url?: string
        type?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateWebhook(p: {
    accept?: string
    owner: string
    repo: string
    hookId: number
    requestBody: {
      active?: boolean
      add_events?: string[]
      config?: {
        content_type?: string
        insecure_ssl?: string
        secret?: string
        url: string
      }
      events?: string[]
      remove_events?: string[]
    }
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        config?: {
          content_type?: string
          insecure_ssl?: string
          url?: string
        }
        created_at?: string
        events?: string[]
        id?: number
        last_response?: {
          code?: string
          message?: string
          status?: string
        }
        name?: string
        ping_url?: string
        test_url?: string
        type?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteWebhook(p: {
    accept?: string
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposPingWebhook(p: {
    accept?: string
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/pings`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposTestPushWebhook(p: {
    accept?: string
    owner: string
    repo: string
    hookId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/tests`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsStartImport(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      tfvc_project?: string
      vcs?: "subversion" | "git" | "mercurial" | "tfvc"
      vcs_password?: string
      vcs_url: string
      vcs_username?: string
    }
  }): Promise<
    Res<
      201,
      {
        authors_count?: number
        authors_url?: string
        commit_count?: number
        has_large_files?: boolean
        html_url?: string
        large_files_count?: number
        large_files_size?: number
        percent?: number
        repository_url?: string
        status?: string
        status_text?: string
        url?: string
        use_lfs?: string
        vcs?: string
        vcs_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetImportStatus(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        authors_count?: number
        authors_url?: string
        has_large_files?: boolean
        html_url?: string
        large_files_count?: number
        large_files_size?: number
        repository_url?: string
        status?: string
        status_text?: string
        url?: string
        use_lfs?: string
        vcs?: string
        vcs_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsUpdateImport(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      vcs_password?: string
      vcs_username?: string
    }
  }): Promise<
    Res<
      200,
      {
        authors_url?: string
        html_url?: string
        repository_url?: string
        status?: string
        url?: string
        use_lfs?: string
        vcs?: string
        vcs_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsCancelImport(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetCommitAuthors(p: {
    accept?: string
    owner: string
    repo: string
    since?: string
  }): Promise<
    Res<
      200,
      {
        email?: string
        id?: number
        import_url?: string
        name?: string
        remote_id?: string
        remote_name?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/import/authors?${this._query({
          since: p["since"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsMapCommitAuthor(p: {
    accept?: string
    owner: string
    repo: string
    authorId: number
    requestBody: {
      email?: string
      name?: string
    }
  }): Promise<
    Res<
      200,
      {
        email?: string
        id?: number
        import_url?: string
        name?: string
        remote_id?: string
        remote_name?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/import/authors/${p["authorId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetLargeFiles(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        oid?: string
        path?: string
        ref_name?: string
        size?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/import/large_files`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsSetLfsPreference(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      use_lfs: "opt_in" | "opt_out"
    }
  }): Promise<
    Res<
      200,
      {
        authors_count?: number
        authors_url?: string
        has_large_files?: boolean
        html_url?: string
        large_files_count?: number
        large_files_size?: number
        repository_url?: string
        status?: string
        status_text?: string
        url?: string
        use_lfs?: string
        vcs?: string
        vcs_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/import/lfs`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetRepoInstallation(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        access_tokens_url?: string
        account?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        app_id?: number
        created_at?: string
        events?: string[]
        html_url?: string
        id?: number
        permissions?: {
          checks?: string
          contents?: string
          metadata?: string
        }
        repositories_url?: string
        repository_selection?: "all" | "selected"
        single_file_name?: string
        target_id?: number
        target_type?: string
        updated_at?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/installation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsGetRestrictionsForRepo(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        expires_at?: string
        limit?: string
        origin?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsSetRestrictionsForRepo(p: {
    accept: string
    owner: string
    repo: string
    requestBody: {
      limit: "existing_users" | "contributors_only" | "collaborators_only"
    }
  }): Promise<
    Res<
      200,
      {
        expires_at?: string
        limit?: string
        origin?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async interactionsRemoveRestrictionsForRepo(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListInvitations(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        html_url?: string
        id?: number
        invitee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        inviter?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: string
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteInvitation(p: {
    accept?: string
    owner: string
    repo: string
    invitationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateInvitation(p: {
    accept?: string
    owner: string
    repo: string
    invitationId: number
    requestBody: {
      permissions?: "read" | "write" | "maintain" | "triage" | "admin"
    }
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        html_url?: string
        id?: number
        invitee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        inviter?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: string
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListForRepo(p: {
    accept?: string
    owner: string
    repo: string
    milestone?: string
    state?: "open" | "closed" | "all"
    assignee?: string
    creator?: string
    mentioned?: string
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues?${this._query({
          milestone: p["milestone"],
          state: p["state"],
          assignee: p["assignee"],
          creator: p["creator"],
          mentioned: p["mentioned"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreate(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      assignee?: string
      assignees?: string[]
      body?: string
      labels?: string[]
      milestone?: number
      title: string
    }
  }): Promise<
    Res<
      201,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        closed_by?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/issues`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListCommentsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        created_at?: string
        html_url?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        created_at?: string
        html_url?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdateComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      200,
      {
        body?: string
        created_at?: string
        html_url?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesDeleteComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForIssueComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${
          p["commentId"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForIssueComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForIssueComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListEventsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        actor?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        commit_id?: string
        commit_url?: string
        created_at?: string
        event?: string
        id?: number
        issue?: {
          active_lock_reason?: string
          assignee?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          assignees?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }[]
          body?: string
          closed_at?: string
          comments?: number
          comments_url?: string
          created_at?: string
          events_url?: string
          html_url?: string
          id?: number
          labels?: {
            color?: string
            default?: boolean
            description?: string
            id?: number
            name?: string
            node_id?: string
            url?: string
          }[]
          labels_url?: string
          locked?: boolean
          milestone?: {
            closed_at?: string
            closed_issues?: number
            created_at?: string
            creator?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            description?: string
            due_on?: string
            html_url?: string
            id?: number
            labels_url?: string
            node_id?: string
            number?: number
            open_issues?: number
            state?: string
            title?: string
            updated_at?: string
            url?: string
          }
          node_id?: string
          number?: number
          pull_request?: {
            diff_url?: string
            html_url?: string
            patch_url?: string
            url?: string
          }
          repository_url?: string
          state?: string
          title?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetEvent(p: {
    accept?: string
    owner: string
    repo: string
    eventId: number
  }): Promise<
    Res<
      200,
      {
        actor?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        commit_id?: string
        commit_url?: string
        created_at?: string
        event?: string
        id?: number
        issue?: {
          active_lock_reason?: string
          assignee?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          assignees?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }[]
          body?: string
          closed_at?: string
          comments?: number
          comments_url?: string
          created_at?: string
          events_url?: string
          html_url?: string
          id?: number
          labels?: {
            color?: string
            default?: boolean
            description?: string
            id?: number
            name?: string
            node_id?: string
            url?: string
          }[]
          labels_url?: string
          locked?: boolean
          milestone?: {
            closed_at?: string
            closed_issues?: number
            created_at?: string
            creator?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            description?: string
            due_on?: string
            html_url?: string
            id?: number
            labels_url?: string
            node_id?: string
            number?: number
            open_issues?: number
            state?: string
            title?: string
            updated_at?: string
            url?: string
          }
          node_id?: string
          number?: number
          pull_request?: {
            diff_url?: string
            html_url?: string
            patch_url?: string
            url?: string
          }
          repository_url?: string
          state?: string
          title?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        node_id?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/events/${p["eventId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGet(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
  }): Promise<
    Res<
      200,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        closed_by?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdate(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      assignee?: string
      assignees?: string[]
      body?: string
      labels?: string[]
      milestone?: number | null
      state?: "open" | "closed"
      title?: string
    }
  }): Promise<
    Res<
      200,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        closed_by?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesAddAssignees(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      assignees?: string[]
    }
  }): Promise<
    Res<
      201,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url: string
          events_url: string
          followers_url: string
          following_url: string
          gists_url: string
          gravatar_id: string
          html_url: string
          id: number
          login: string
          node_id: string
          organizations_url: string
          received_events_url: string
          repos_url: string
          site_admin: boolean
          starred_url: string
          subscriptions_url: string
          type: string
          url: string
        }[]
        body?: string
        closed_at?: string
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesRemoveAssignees(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      assignees?: string[]
    }
  }): Promise<
    Res<
      200,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListComments(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        created_at?: string
        html_url?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/comments?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreateComment(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      201,
      {
        body?: string
        created_at?: string
        html_url?: string
        id?: number
        node_id?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListEvents(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        actor?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        commit_id?: string
        commit_url?: string
        created_at?: string
        event?: string
        id?: number
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/events?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListLabelsOnIssue(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/labels?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesAddLabels(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      labels: string[]
    }
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesSetLabels(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      labels?: string[]
    }
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesRemoveAllLabels(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesRemoveLabel(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    name: string
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesLock(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      lock_reason?: "off-topic" | "too heated" | "resolved" | "spam"
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUnlock(p: {
    accept?: string
    owner: string
    repo: string
    issueNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForIssue(p: {
    accept: string
    owner: string
    repo: string
    issueNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForIssue(p: {
    accept: string
    owner: string
    repo: string
    issueNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForIssue(p: {
    accept: string
    owner: string
    repo: string
    issueNumber: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListEventsForTimeline(p: {
    accept: string
    owner: string
    repo: string
    issueNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        actor?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        commit_id?: string
        commit_url?: string
        created_at?: string
        event?: string
        id?: number
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/issues/${
          p["issueNumber"]
        }/timeline?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListDeployKeys(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        id?: number
        key?: string
        read_only?: boolean
        title?: string
        url?: string
        verified?: boolean
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateDeployKey(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      key: string
      read_only?: boolean
      title?: string
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        id?: number
        key?: string
        read_only?: boolean
        title?: string
        url?: string
        verified?: boolean
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/keys`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetDeployKey(p: {
    accept?: string
    owner: string
    repo: string
    keyId: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        id?: number
        key?: string
        read_only?: boolean
        title?: string
        url?: string
        verified?: boolean
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteDeployKey(p: {
    accept?: string
    owner: string
    repo: string
    keyId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListLabelsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreateLabel(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      color: string
      description?: string
      name: string
    }
  }): Promise<
    Res<
      201,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/labels`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetLabel(p: {
    accept?: string
    owner: string
    repo: string
    name: string
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdateLabel(p: {
    accept?: string
    owner: string
    repo: string
    name: string
    requestBody: {
      color?: string
      description?: string
      new_name?: string
    }
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesDeleteLabel(p: {
    accept?: string
    owner: string
    repo: string
    name: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListLanguages(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        C?: number
        Python?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/languages`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async licensesGetForRepo(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        _links?: {
          git?: string
          html?: string
          self?: string
        }
        content?: string
        download_url?: string
        encoding?: string
        git_url?: string
        html_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        name?: string
        path?: string
        sha?: string
        size?: number
        type?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/license`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposMerge(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      base: string
      commit_message?: string
      head: string
    }
  }): Promise<
    | Res<
        201,
        {
          author?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          comments_url?: string
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            comment_count?: number
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            message?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
            verification?: {
              payload?: string
              reason?: string
              signature?: string
              verified?: boolean
            }
          }
          committer?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          node_id?: string
          parents?: {
            sha: string
            url: string
          }[]
          sha?: string
          url?: string
        }
      >
    | Res<
        404,
        {
          message?: string
        }
      >
    | Res<
        409,
        {
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/merges`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListMilestones(p: {
    accept?: string
    owner: string
    repo: string
    state?: "open" | "closed" | "all"
    sort?: "due_on" | "completeness"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        closed_at?: string
        closed_issues?: number
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        due_on?: string
        html_url?: string
        id?: number
        labels_url?: string
        node_id?: string
        number?: number
        open_issues?: number
        state?: string
        title?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones?${this._query({
          state: p["state"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesCreateMilestone(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      description?: string
      due_on?: string
      state?: "open" | "closed"
      title: string
    }
  }): Promise<
    Res<
      201,
      {
        closed_at?: string
        closed_issues?: number
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        due_on?: string
        html_url?: string
        id?: number
        labels_url?: string
        node_id?: string
        number?: number
        open_issues?: number
        state?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/milestones`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesGetMilestone(p: {
    accept?: string
    owner: string
    repo: string
    milestoneNumber: number
  }): Promise<
    Res<
      200,
      {
        closed_at?: string
        closed_issues?: number
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        due_on?: string
        html_url?: string
        id?: number
        labels_url?: string
        node_id?: string
        number?: number
        open_issues?: number
        state?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesUpdateMilestone(p: {
    accept?: string
    owner: string
    repo: string
    milestoneNumber: number
    requestBody: {
      description?: string
      due_on?: string
      state?: "open" | "closed"
      title?: string
    }
  }): Promise<
    Res<
      200,
      {
        closed_at?: string
        closed_issues?: number
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        due_on?: string
        html_url?: string
        id?: number
        labels_url?: string
        node_id?: string
        number?: number
        open_issues?: number
        state?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesDeleteMilestone(p: {
    accept?: string
    owner: string
    repo: string
    milestoneNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListLabelsForMilestone(p: {
    accept?: string
    owner: string
    repo: string
    milestoneNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        color?: string
        default?: boolean
        description?: string
        id?: number
        name?: string
        node_id?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/milestones/${
          p["milestoneNumber"]
        }/labels?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListRepoNotificationsForAuthenticatedUser(p: {
    accept?: string
    owner: string
    repo: string
    all?: boolean
    participating?: boolean
    since?: string
    before?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        id?: string
        last_read_at?: string
        reason?: string
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        subject?: {
          latest_comment_url?: string
          title?: string
          type?: string
          url?: string
        }
        unread?: boolean
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/notifications?${this._query({
          all: p["all"],
          participating: p["participating"],
          since: p["since"],
          before: p["before"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityMarkRepoNotificationsAsRead(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      last_read_at?: string
    }
  }): Promise<Res<205, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/notifications`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPages(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        cname?: string
        custom_404?: boolean
        html_url?: string
        source?: {
          branch?: string
          directory?: string
        }
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreatePagesSite(p: {
    accept: string
    owner: string
    repo: string
    requestBody: {
      source?: {
        branch?: "master" | "gh-pages"
        path?: string
      }
    }
  }): Promise<
    Res<
      201,
      {
        cname?: string
        custom_404?: boolean
        html_url?: string
        source?: {
          branch?: string
          directory?: string
        }
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeletePagesSite(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateInformationAboutPagesSite(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      cname?: string
      source?: "gh-pages" | "master" | "master /docs"
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposRequestPagesBuild(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        status?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/builds`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListPagesBuilds(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        commit?: string
        created_at?: string
        duration?: number
        error?: {
          message?: string
        }
        pusher?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        status?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pages/builds?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetLatestPagesBuild(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        commit?: string
        created_at?: string
        duration?: number
        error?: {
          message?: string
        }
        pusher?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        status?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pages/builds/latest`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPagesBuild(p: {
    accept?: string
    owner: string
    repo: string
    buildId: number
  }): Promise<
    Res<
      200,
      {
        commit?: string
        created_at?: string
        duration?: number
        error?: {
          message?: string
        }
        pusher?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        status?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pages/builds/${p["buildId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListForRepo(p: {
    accept: string
    owner: string
    repo: string
    state?: "open" | "closed" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        owner_url?: string
        state?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/projects?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateForRepo(p: {
    accept: string
    owner: string
    repo: string
    requestBody: {
      body?: string
      name: string
    }
  }): Promise<
    Res<
      201,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        owner_url?: string
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/projects`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsList(p: {
    accept?: string
    owner: string
    repo: string
    state?: "open" | "closed" | "all"
    head?: string
    base?: string
    sort?: "created" | "updated" | "popularity" | "long-running"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          comments?: {
            href?: string
          }
          commits?: {
            href?: string
          }
          html?: {
            href?: string
          }
          issue?: {
            href?: string
          }
          review_comment?: {
            href?: string
          }
          review_comments?: {
            href?: string
          }
          self?: {
            href?: string
          }
          statuses?: {
            href?: string
          }
        }
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url: string
          events_url: string
          followers_url: string
          following_url: string
          gists_url: string
          gravatar_id: string
          html_url: string
          id: number
          login: string
          node_id: string
          organizations_url: string
          received_events_url: string
          repos_url: string
          site_admin: boolean
          starred_url: string
          subscriptions_url: string
          type: string
          url: string
        }[]
        author_association?: string
        base?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        body?: string
        closed_at?: string
        comments_url?: string
        commits_url?: string
        created_at?: string
        diff_url?: string
        draft?: boolean
        head?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        html_url?: string
        id?: number
        issue_url?: string
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        locked?: boolean
        merge_commit_sha?: string
        merged_at?: string
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        patch_url?: string
        requested_reviewers?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        requested_teams?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          parent?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }[]
        review_comment_url?: string
        review_comments_url?: string
        state?: string
        statuses_url?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls?${this._query({
          state: p["state"],
          head: p["head"],
          base: p["base"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreate(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      base: string
      body?: string
      draft?: boolean
      head: string
      maintainer_can_modify?: boolean
      title: string
    }
  }): Promise<
    Res<
      201,
      {
        _links?: {
          comments?: {
            href?: string
          }
          commits?: {
            href?: string
          }
          html?: {
            href?: string
          }
          issue?: {
            href?: string
          }
          review_comment?: {
            href?: string
          }
          review_comments?: {
            href?: string
          }
          self?: {
            href?: string
          }
          statuses?: {
            href?: string
          }
        }
        active_lock_reason?: string
        additions?: number
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url: string
          events_url: string
          followers_url: string
          following_url: string
          gists_url: string
          gravatar_id: string
          html_url: string
          id: number
          login: string
          node_id: string
          organizations_url: string
          received_events_url: string
          repos_url: string
          site_admin: boolean
          starred_url: string
          subscriptions_url: string
          type: string
          url: string
        }[]
        author_association?: string
        base?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        body?: string
        changed_files?: number
        closed_at?: string
        comments?: number
        comments_url?: string
        commits?: number
        commits_url?: string
        created_at?: string
        deletions?: number
        diff_url?: string
        draft?: boolean
        head?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        html_url?: string
        id?: number
        issue_url?: string
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        locked?: boolean
        maintainer_can_modify?: boolean
        merge_commit_sha?: string
        mergeable?: boolean
        mergeable_state?: string
        merged?: boolean
        merged_at?: string
        merged_by?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        patch_url?: string
        rebaseable?: boolean
        requested_reviewers?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        requested_teams?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          parent?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }[]
        review_comment_url?: string
        review_comments?: number
        review_comments_url?: string
        state?: string
        statuses_url?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/pulls`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListReviewCommentsForRepo(p: {
    accept?: string
    owner: string
    repo: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
          self?: {
            href?: string
          }
        }
        author_association?: string
        body?: string
        commit_id?: string
        created_at?: string
        diff_hunk?: string
        html_url?: string
        id?: number
        in_reply_to_id?: number
        line?: number
        node_id?: string
        original_commit_id?: string
        original_line?: number
        original_position?: number
        original_start_line?: number
        path?: string
        position?: number
        pull_request_review_id?: number
        pull_request_url?: string
        side?: string
        start_line?: number
        start_side?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsGetReviewComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
          self?: {
            href?: string
          }
        }
        author_association?: string
        body?: string
        commit_id?: string
        created_at?: string
        diff_hunk?: string
        html_url?: string
        id?: number
        in_reply_to_id?: number
        line?: number
        node_id?: string
        original_commit_id?: string
        original_line?: number
        original_position?: number
        original_start_line?: number
        path?: string
        position?: number
        pull_request_review_id?: number
        pull_request_url?: string
        side?: string
        start_line?: number
        start_side?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdateReviewComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
          self?: {
            href?: string
          }
        }
        author_association?: string
        body?: string
        commit_id?: string
        created_at?: string
        diff_hunk?: string
        html_url?: string
        id?: number
        in_reply_to_id?: number
        line?: number
        node_id?: string
        original_commit_id?: string
        original_line?: number
        original_position?: number
        original_start_line?: number
        path?: string
        position?: number
        pull_request_review_id?: number
        pull_request_url?: string
        side?: string
        start_line?: number
        start_side?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsDeleteReviewComment(p: {
    accept?: string
    owner: string
    repo: string
    commentId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForPullRequestReviewComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${
          p["commentId"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForPullRequestReviewComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsDeleteForPullRequestComment(p: {
    accept: string
    owner: string
    repo: string
    commentId: number
    reactionId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions/${p["reactionId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsGet(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          comments?: {
            href?: string
          }
          commits?: {
            href?: string
          }
          html?: {
            href?: string
          }
          issue?: {
            href?: string
          }
          review_comment?: {
            href?: string
          }
          review_comments?: {
            href?: string
          }
          self?: {
            href?: string
          }
          statuses?: {
            href?: string
          }
        }
        active_lock_reason?: string
        additions?: number
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url: string
          events_url: string
          followers_url: string
          following_url: string
          gists_url: string
          gravatar_id: string
          html_url: string
          id: number
          login: string
          node_id: string
          organizations_url: string
          received_events_url: string
          repos_url: string
          site_admin: boolean
          starred_url: string
          subscriptions_url: string
          type: string
          url: string
        }[]
        author_association?: string
        base?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        body?: string
        changed_files?: number
        closed_at?: string
        comments?: number
        comments_url?: string
        commits?: number
        commits_url?: string
        created_at?: string
        deletions?: number
        diff_url?: string
        draft?: boolean
        head?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        html_url?: string
        id?: number
        issue_url?: string
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        locked?: boolean
        maintainer_can_modify?: boolean
        merge_commit_sha?: string
        mergeable?: boolean
        mergeable_state?: string
        merged?: boolean
        merged_at?: string
        merged_by?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        patch_url?: string
        rebaseable?: boolean
        requested_reviewers?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        requested_teams?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          parent?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }[]
        review_comment_url?: string
        review_comments?: number
        review_comments_url?: string
        state?: string
        statuses_url?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdate(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      base?: string
      body?: string
      maintainer_can_modify?: boolean
      state?: "open" | "closed"
      title?: string
    }
  }): Promise<
    Res<
      200,
      {
        _links?: {
          comments?: {
            href?: string
          }
          commits?: {
            href?: string
          }
          html?: {
            href?: string
          }
          issue?: {
            href?: string
          }
          review_comment?: {
            href?: string
          }
          review_comments?: {
            href?: string
          }
          self?: {
            href?: string
          }
          statuses?: {
            href?: string
          }
        }
        active_lock_reason?: string
        additions?: number
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url: string
          events_url: string
          followers_url: string
          following_url: string
          gists_url: string
          gravatar_id: string
          html_url: string
          id: number
          login: string
          node_id: string
          organizations_url: string
          received_events_url: string
          repos_url: string
          site_admin: boolean
          starred_url: string
          subscriptions_url: string
          type: string
          url: string
        }[]
        author_association?: string
        base?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        body?: string
        changed_files?: number
        closed_at?: string
        comments?: number
        comments_url?: string
        commits?: number
        commits_url?: string
        created_at?: string
        deletions?: number
        diff_url?: string
        draft?: boolean
        head?: {
          label?: string
          ref?: string
          repo?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          sha?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
        html_url?: string
        id?: number
        issue_url?: string
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        locked?: boolean
        maintainer_can_modify?: boolean
        merge_commit_sha?: string
        mergeable?: boolean
        mergeable_state?: string
        merged?: boolean
        merged_at?: string
        merged_by?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        patch_url?: string
        rebaseable?: boolean
        requested_reviewers?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        requested_teams?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          parent?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }[]
        review_comment_url?: string
        review_comments?: number
        review_comments_url?: string
        state?: string
        statuses_url?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListReviewComments(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
          self?: {
            href?: string
          }
        }
        author_association?: string
        body?: string
        commit_id?: string
        created_at?: string
        diff_hunk?: string
        html_url?: string
        id?: number
        in_reply_to_id?: number
        line?: number
        node_id?: string
        original_commit_id?: string
        original_line?: number
        original_position?: number
        original_start_line?: number
        path?: string
        position?: number
        pull_request_review_id?: number
        pull_request_url?: string
        side?: string
        start_line?: number
        start_side?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/comments?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreateReviewComment(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      body: string
      commit_id: string
      line?: number
      path: string
      position?: number
      side?: "LEFT" | "RIGHT"
      start_line?: number
      start_side?: "LEFT" | "RIGHT" | "side"
    }
  }): Promise<
    Res<
      201,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
          self?: {
            href?: string
          }
        }
        author_association?: string
        body?: string
        commit_id?: string
        created_at?: string
        diff_hunk?: string
        html_url?: string
        id?: number
        in_reply_to_id?: number
        line?: number
        node_id?: string
        original_commit_id?: string
        original_line?: number
        original_position?: number
        original_start_line?: number
        path?: string
        position?: number
        pull_request_review_id?: number
        pull_request_url?: string
        side?: string
        start_line?: number
        start_side?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreateReplyForReviewComment(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    commentId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      201,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
          self?: {
            href?: string
          }
        }
        author_association?: string
        body?: string
        commit_id?: string
        created_at?: string
        diff_hunk?: string
        html_url?: string
        id?: number
        in_reply_to_id?: number
        line?: number
        node_id?: string
        original_commit_id?: string
        original_line?: number
        original_position?: number
        original_start_line?: number
        path?: string
        position?: number
        pull_request_review_id?: number
        pull_request_url?: string
        side?: string
        start_line?: number
        start_side?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments/${p["commentId"]}/replies`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListCommits(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        comments_url?: string
        commit?: {
          author?: {
            date?: string
            email?: string
            name?: string
          }
          comment_count?: number
          committer?: {
            date?: string
            email?: string
            name?: string
          }
          message?: string
          tree?: {
            sha?: string
            url?: string
          }
          url?: string
          verification?: {
            payload?: string
            reason?: string
            signature?: string
            verified?: boolean
          }
        }
        committer?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        node_id?: string
        parents?: {
          sha?: string
          url?: string
        }[]
        sha?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/commits?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListFiles(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        additions?: number
        blob_url?: string
        changes?: number
        contents_url?: string
        deletions?: number
        filename?: string
        patch?: string
        raw_url?: string
        sha?: string
        status?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/files?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCheckIfMerged(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsMerge(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      commit_message?: string
      commit_title?: string
      merge_method?: "merge" | "squash" | "rebase"
      sha?: string
    }
  }): Promise<
    | Res<
        200,
        {
          merged?: boolean
          message?: string
          sha?: string
        }
      >
    | Res<
        405,
        {
          documentation_url?: string
          message?: string
        }
      >
    | Res<
        409,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListRequestedReviewers(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        teams?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          parent?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }[]
        users?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/requested_reviewers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsRequestReviewers(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      reviewers?: string[]
      team_reviewers?: string[]
    }
  }): Promise<
    | Res<
        201,
        {
          _links?: {
            comments?: {
              href?: string
            }
            commits?: {
              href?: string
            }
            html?: {
              href?: string
            }
            issue?: {
              href?: string
            }
            review_comment?: {
              href?: string
            }
            review_comments?: {
              href?: string
            }
            self?: {
              href?: string
            }
            statuses?: {
              href?: string
            }
          }
          active_lock_reason?: string
          assignee?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          assignees?: {
            avatar_url: string
            events_url: string
            followers_url: string
            following_url: string
            gists_url: string
            gravatar_id: string
            html_url: string
            id: number
            login: string
            node_id: string
            organizations_url: string
            received_events_url: string
            repos_url: string
            site_admin: boolean
            starred_url: string
            subscriptions_url: string
            type: string
            url: string
          }[]
          author_association?: string
          base?: {
            label?: string
            ref?: string
            repo?: {
              allow_merge_commit?: boolean
              allow_rebase_merge?: boolean
              allow_squash_merge?: boolean
              archive_url?: string
              archived?: boolean
              assignees_url?: string
              blobs_url?: string
              branches_url?: string
              clone_url?: string
              collaborators_url?: string
              comments_url?: string
              commits_url?: string
              compare_url?: string
              contents_url?: string
              contributors_url?: string
              created_at?: string
              default_branch?: string
              delete_branch_on_merge?: boolean
              deployments_url?: string
              description?: string
              disabled?: boolean
              downloads_url?: string
              events_url?: string
              fork?: boolean
              forks_count?: number
              forks_url?: string
              full_name?: string
              git_commits_url?: string
              git_refs_url?: string
              git_tags_url?: string
              git_url?: string
              has_downloads?: boolean
              has_issues?: boolean
              has_pages?: boolean
              has_projects?: boolean
              has_wiki?: boolean
              homepage?: string
              hooks_url?: string
              html_url?: string
              id?: number
              is_template?: boolean
              issue_comment_url?: string
              issue_events_url?: string
              issues_url?: string
              keys_url?: string
              labels_url?: string
              language?: string
              languages_url?: string
              merges_url?: string
              milestones_url?: string
              mirror_url?: string
              name?: string
              network_count?: number
              node_id?: string
              notifications_url?: string
              open_issues_count?: number
              owner?: {
                avatar_url?: string
                events_url?: string
                followers_url?: string
                following_url?: string
                gists_url?: string
                gravatar_id?: string
                html_url?: string
                id?: number
                login?: string
                node_id?: string
                organizations_url?: string
                received_events_url?: string
                repos_url?: string
                site_admin?: boolean
                starred_url?: string
                subscriptions_url?: string
                type?: string
                url?: string
              }
              permissions?: {
                admin?: boolean
                pull?: boolean
                push?: boolean
              }
              private?: boolean
              pulls_url?: string
              pushed_at?: string
              releases_url?: string
              size?: number
              ssh_url?: string
              stargazers_count?: number
              stargazers_url?: string
              statuses_url?: string
              subscribers_count?: number
              subscribers_url?: string
              subscription_url?: string
              svn_url?: string
              tags_url?: string
              teams_url?: string
              temp_clone_token?: string
              template_repository?: string
              topics?: string[]
              trees_url?: string
              updated_at?: string
              url?: string
              visibility?: string
              watchers_count?: number
            }
            sha?: string
            user?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
          }
          body?: string
          closed_at?: string
          comments_url?: string
          commits_url?: string
          created_at?: string
          diff_url?: string
          draft?: boolean
          head?: {
            label?: string
            ref?: string
            repo?: {
              allow_merge_commit?: boolean
              allow_rebase_merge?: boolean
              allow_squash_merge?: boolean
              archive_url?: string
              archived?: boolean
              assignees_url?: string
              blobs_url?: string
              branches_url?: string
              clone_url?: string
              collaborators_url?: string
              comments_url?: string
              commits_url?: string
              compare_url?: string
              contents_url?: string
              contributors_url?: string
              created_at?: string
              default_branch?: string
              delete_branch_on_merge?: boolean
              deployments_url?: string
              description?: string
              disabled?: boolean
              downloads_url?: string
              events_url?: string
              fork?: boolean
              forks_count?: number
              forks_url?: string
              full_name?: string
              git_commits_url?: string
              git_refs_url?: string
              git_tags_url?: string
              git_url?: string
              has_downloads?: boolean
              has_issues?: boolean
              has_pages?: boolean
              has_projects?: boolean
              has_wiki?: boolean
              homepage?: string
              hooks_url?: string
              html_url?: string
              id?: number
              is_template?: boolean
              issue_comment_url?: string
              issue_events_url?: string
              issues_url?: string
              keys_url?: string
              labels_url?: string
              language?: string
              languages_url?: string
              merges_url?: string
              milestones_url?: string
              mirror_url?: string
              name?: string
              network_count?: number
              node_id?: string
              notifications_url?: string
              open_issues_count?: number
              owner?: {
                avatar_url?: string
                events_url?: string
                followers_url?: string
                following_url?: string
                gists_url?: string
                gravatar_id?: string
                html_url?: string
                id?: number
                login?: string
                node_id?: string
                organizations_url?: string
                received_events_url?: string
                repos_url?: string
                site_admin?: boolean
                starred_url?: string
                subscriptions_url?: string
                type?: string
                url?: string
              }
              permissions?: {
                admin?: boolean
                pull?: boolean
                push?: boolean
              }
              private?: boolean
              pulls_url?: string
              pushed_at?: string
              releases_url?: string
              size?: number
              ssh_url?: string
              stargazers_count?: number
              stargazers_url?: string
              statuses_url?: string
              subscribers_count?: number
              subscribers_url?: string
              subscription_url?: string
              svn_url?: string
              tags_url?: string
              teams_url?: string
              temp_clone_token?: string
              template_repository?: string
              topics?: string[]
              trees_url?: string
              updated_at?: string
              url?: string
              visibility?: string
              watchers_count?: number
            }
            sha?: string
            user?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
          }
          html_url?: string
          id?: number
          issue_url?: string
          labels?: {
            color?: string
            default?: boolean
            description?: string
            id?: number
            name?: string
            node_id?: string
            url?: string
          }[]
          locked?: boolean
          merge_commit_sha?: string
          merged_at?: string
          milestone?: {
            closed_at?: string
            closed_issues?: number
            created_at?: string
            creator?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            description?: string
            due_on?: string
            html_url?: string
            id?: number
            labels_url?: string
            node_id?: string
            number?: number
            open_issues?: number
            state?: string
            title?: string
            updated_at?: string
            url?: string
          }
          node_id?: string
          number?: number
          patch_url?: string
          requested_reviewers?: {
            avatar_url: string
            events_url: string
            followers_url: string
            following_url: string
            gists_url: string
            gravatar_id: string
            html_url: string
            id: number
            login: string
            node_id: string
            organizations_url: string
            received_events_url: string
            repos_url: string
            site_admin: boolean
            starred_url: string
            subscriptions_url: string
            type: string
            url: string
          }[]
          requested_teams?: {
            description?: string
            html_url?: string
            id?: number
            members_url?: string
            name?: string
            node_id?: string
            parent?: string
            permission?: string
            privacy?: string
            repositories_url?: string
            slug?: string
            url?: string
          }[]
          review_comment_url?: string
          review_comments_url?: string
          state?: string
          statuses_url?: string
          title?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }
      >
    | Res<422, void>
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsRemoveRequestedReviewers(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      reviewers?: string[]
      team_reviewers?: string[]
    }
  }): Promise<Res<200, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`,
      {
        method: "DELETE",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListReviews(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
        }
        body?: string
        commit_id?: string
        html_url?: string
        id?: number
        node_id?: string
        pull_request_url?: string
        state?: string
        submitted_at?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${
          p["pullNumber"]
        }/reviews?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsCreateReview(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      body?: string
      comments?: {
        body: string
        path: string
        position: number
      }[]
      commit_id?: string
      event?: "APPROVE" | "REQUEST_CHANGES" | "COMMENT"
    }
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
        }
        body?: string
        commit_id?: string
        html_url?: string
        id?: number
        node_id?: string
        pull_request_url?: string
        state?: string
        submitted_at?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsGetReview(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
        }
        body?: string
        commit_id?: string
        html_url?: string
        id?: number
        node_id?: string
        pull_request_url?: string
        state?: string
        submitted_at?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsDeletePendingReview(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
        }
        body?: string
        commit_id?: string
        html_url?: string
        id?: number
        node_id?: string
        pull_request_url?: string
        state?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdateReview(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
        }
        body?: string
        commit_id?: string
        html_url?: string
        id?: number
        node_id?: string
        pull_request_url?: string
        state?: string
        submitted_at?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsListCommentsForReview(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
          self?: {
            href?: string
          }
        }
        author_association?: string
        body?: string
        commit_id?: string
        created_at?: string
        diff_hunk?: string
        html_url?: string
        id?: number
        in_reply_to_id?: number
        node_id?: string
        original_commit_id?: string
        original_position?: number
        path?: string
        position?: number
        pull_request_review_id?: number
        pull_request_url?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${
          p["reviewId"]
        }/comments?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsDismissReview(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    requestBody: {
      message: string
    }
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
        }
        body?: string
        commit_id?: string
        html_url?: string
        id?: number
        node_id?: string
        pull_request_url?: string
        state?: string
        submitted_at?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/dismissals`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsSubmitReview(p: {
    accept?: string
    owner: string
    repo: string
    pullNumber: number
    reviewId: number
    requestBody: {
      body?: string
      event: "APPROVE" | "REQUEST_CHANGES" | "COMMENT"
    }
  }): Promise<
    Res<
      200,
      {
        _links?: {
          html?: {
            href?: string
          }
          pull_request?: {
            href?: string
          }
        }
        body?: string
        commit_id?: string
        html_url?: string
        id?: number
        node_id?: string
        pull_request_url?: string
        state?: string
        submitted_at?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/events`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async pullsUpdateBranch(p: {
    accept: string
    owner: string
    repo: string
    pullNumber: number
    requestBody: {
      expected_head_sha?: string
    }
  }): Promise<
    Res<
      202,
      {
        message?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/update-branch`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetReadme(p: {
    accept?: string
    owner: string
    repo: string
    ref?: string
  }): Promise<
    Res<
      200,
      {
        _links?: {
          git?: string
          html?: string
          self?: string
        }
        content?: string
        download_url?: string
        encoding?: string
        git_url?: string
        html_url?: string
        name?: string
        path?: string
        sha?: string
        size?: number
        type?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/readme?${this._query({
          ref: p["ref"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListReleases(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        assets?: {
          browser_download_url?: string
          content_type?: string
          created_at?: string
          download_count?: number
          id?: number
          label?: string
          name?: string
          node_id?: string
          size?: number
          state?: string
          updated_at?: string
          uploader?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          url?: string
        }[]
        assets_url?: string
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        created_at?: string
        draft?: boolean
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        prerelease?: boolean
        published_at?: string
        tag_name?: string
        tarball_url?: string
        target_commitish?: string
        upload_url?: string
        url?: string
        zipball_url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateRelease(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      body?: string
      draft?: boolean
      name?: string
      prerelease?: boolean
      tag_name: string
      target_commitish?: string
    }
  }): Promise<
    Res<
      201,
      {
        assets?: {
          [key: string]: unknown
        }[]
        assets_url?: string
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        created_at?: string
        draft?: boolean
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        prerelease?: boolean
        published_at?: string
        tag_name?: string
        tarball_url?: string
        target_commitish?: string
        upload_url?: string
        url?: string
        zipball_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/releases`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetReleaseAsset(p: {
    accept?: string
    owner: string
    repo: string
    assetId: number
  }): Promise<
    Res<
      200,
      {
        browser_download_url?: string
        content_type?: string
        created_at?: string
        download_count?: number
        id?: number
        label?: string
        name?: string
        node_id?: string
        size?: number
        state?: string
        updated_at?: string
        uploader?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateReleaseAsset(p: {
    accept?: string
    owner: string
    repo: string
    assetId: number
    requestBody: {
      label?: string
      name?: string
    }
  }): Promise<
    Res<
      200,
      {
        browser_download_url?: string
        content_type?: string
        created_at?: string
        download_count?: number
        id?: number
        label?: string
        name?: string
        node_id?: string
        size?: number
        state?: string
        updated_at?: string
        uploader?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteReleaseAsset(p: {
    accept?: string
    owner: string
    repo: string
    assetId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetLatestRelease(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        assets?: {
          browser_download_url?: string
          content_type?: string
          created_at?: string
          download_count?: number
          id?: number
          label?: string
          name?: string
          node_id?: string
          size?: number
          state?: string
          updated_at?: string
          uploader?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          url?: string
        }[]
        assets_url?: string
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        created_at?: string
        draft?: boolean
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        prerelease?: boolean
        published_at?: string
        tag_name?: string
        tarball_url?: string
        target_commitish?: string
        upload_url?: string
        url?: string
        zipball_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/latest`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetReleaseByTag(p: {
    accept?: string
    owner: string
    repo: string
    tag: string
  }): Promise<
    Res<
      200,
      {
        assets?: {
          browser_download_url?: string
          content_type?: string
          created_at?: string
          download_count?: number
          id?: number
          label?: string
          name?: string
          node_id?: string
          size?: number
          state?: string
          updated_at?: string
          uploader?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          url?: string
        }[]
        assets_url?: string
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        created_at?: string
        draft?: boolean
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        prerelease?: boolean
        published_at?: string
        tag_name?: string
        tarball_url?: string
        target_commitish?: string
        upload_url?: string
        url?: string
        zipball_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/tags/${p["tag"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetRelease(p: {
    accept?: string
    owner: string
    repo: string
    releaseId: number
  }): Promise<
    Res<
      200,
      {
        assets?: {
          browser_download_url?: string
          content_type?: string
          created_at?: string
          download_count?: number
          id?: number
          label?: string
          name?: string
          node_id?: string
          size?: number
          state?: string
          updated_at?: string
          uploader?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          url?: string
        }[]
        assets_url?: string
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        created_at?: string
        draft?: boolean
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        prerelease?: boolean
        published_at?: string
        tag_name?: string
        tarball_url?: string
        target_commitish?: string
        upload_url?: string
        url?: string
        zipball_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUpdateRelease(p: {
    accept?: string
    owner: string
    repo: string
    releaseId: number
    requestBody: {
      body?: string
      draft?: boolean
      name?: string
      prerelease?: boolean
      tag_name?: string
      target_commitish?: string
    }
  }): Promise<
    Res<
      200,
      {
        assets?: {
          browser_download_url?: string
          content_type?: string
          created_at?: string
          download_count?: number
          id?: number
          label?: string
          name?: string
          node_id?: string
          size?: number
          state?: string
          updated_at?: string
          uploader?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          url?: string
        }[]
        assets_url?: string
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        created_at?: string
        draft?: boolean
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        prerelease?: boolean
        published_at?: string
        tag_name?: string
        tarball_url?: string
        target_commitish?: string
        upload_url?: string
        url?: string
        zipball_url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeleteRelease(p: {
    accept?: string
    owner: string
    repo: string
    releaseId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListReleaseAssets(p: {
    accept?: string
    owner: string
    repo: string
    releaseId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        browser_download_url?: string
        content_type?: string
        created_at?: string
        download_count?: number
        id?: number
        label?: string
        name?: string
        node_id?: string
        size?: number
        state?: string
        updated_at?: string
        uploader?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${
          p["releaseId"]
        }/assets?${this._query({ per_page: p["perPage"], page: p["page"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposUploadReleaseAsset(p: {
    accept?: string
    contentLength: string
    contentType: string
    owner: string
    repo: string
    releaseId: number
    name?: string
    label?: string
    requestBody: string
  }): Promise<
    Res<
      201,
      {
        browser_download_url?: string
        content_type?: string
        created_at?: string
        download_count?: number
        id?: number
        label?: string
        name?: string
        node_id?: string
        size?: number
        state?: string
        updated_at?: string
        uploader?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "*/*",
      accept: p["accept"],
      "content-length": p["contentLength"],
      "content-type": p["contentType"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/releases/${
          p["releaseId"]
        }/assets?${this._query({ name: p["name"], label: p["label"] })}`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListStargazersForRepo(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        starred_at?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stargazers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCodeFrequencyStats(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<Res<200, number[][]>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/code_frequency`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetCommitActivityStats(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        days?: number[]
        total?: number
        week?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/commit_activity`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetContributorsStats(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        total?: number
        weeks?: {
          a?: number
          c?: number
          d?: number
          w?: string
        }[]
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/contributors`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetParticipationStats(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        all?: number[]
        owner?: number[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/participation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetPunchCardStats(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<Res<200, number[][]>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/stats/punch_card`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateCommitStatus(p: {
    accept?: string
    owner: string
    repo: string
    sha: string
    requestBody: {
      context?: string
      description?: string
      state: "error" | "failure" | "pending" | "success"
      target_url?: string
    }
  }): Promise<
    Res<
      201,
      {
        avatar_url?: string
        context?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        description?: string
        id?: number
        node_id?: string
        state?: string
        target_url?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/statuses/${p["sha"]}`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListWatchersForRepo(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/subscribers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityGetRepoSubscription(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    | Res<
        200,
        {
          created_at?: string
          ignored?: boolean
          reason?: string
          repository_url?: string
          subscribed?: boolean
          url?: string
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activitySetRepoSubscription(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      ignored?: boolean
      subscribed?: boolean
    }
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        ignored?: boolean
        reason?: string
        repository_url?: string
        subscribed?: boolean
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityDeleteRepoSubscription(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListTags(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        commit?: {
          sha?: string
          url?: string
        }
        name?: string
        tarball_url?: string
        zipball_url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/tags?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListTeams(p: {
    accept?: string
    owner: string
    repo: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        description?: string
        html_url?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: string
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetAllTopics(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        names?: string[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/topics`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposReplaceAllTopics(p: {
    accept: string
    owner: string
    repo: string
    requestBody: {
      names: string[]
    }
  }): Promise<
    Res<
      200,
      {
        names?: string[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/topics`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetClones(p: {
    accept?: string
    owner: string
    repo: string
    per?: "day" | "week"
  }): Promise<
    Res<
      200,
      {
        clones?: {
          count: number
          timestamp: string
          uniques: number
        }[]
        count?: number
        uniques?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/clones?${this._query({
          per: p["per"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetTopPaths(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        count?: number
        path?: string
        title?: string
        uniques?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/paths`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetTopReferrers(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<
    Res<
      200,
      {
        count?: number
        referrer?: string
        uniques?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/referrers`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposGetViews(p: {
    accept?: string
    owner: string
    repo: string
    per?: "day" | "week"
  }): Promise<
    Res<
      200,
      {
        count?: number
        uniques?: number
        views?: {
          count: number
          timestamp: string
          uniques: number
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/traffic/views?${this._query({
          per: p["per"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposTransfer(p: {
    accept?: string
    owner: string
    repo: string
    requestBody: {
      new_owner?: string
      team_ids?: number[]
    }
  }): Promise<
    Res<
      202,
      {
        allow_merge_commit?: boolean
        allow_rebase_merge?: boolean
        allow_squash_merge?: boolean
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/repos/${p["owner"]}/${p["repo"]}/transfer`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCheckVulnerabilityAlerts(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposEnableVulnerabilityAlerts(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDisableVulnerabilityAlerts(p: {
    accept: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDownloadArchive(p: {
    accept?: string
    owner: string
    repo: string
    archiveFormat: string
    ref: string
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["owner"]}/${p["repo"]}/${p["archiveFormat"]}/${p["ref"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateUsingTemplate(p: {
    accept: string
    templateOwner: string
    templateRepo: string
    requestBody: {
      description?: string
      name: string
      owner?: string
      private?: boolean
    }
  }): Promise<
    Res<
      201,
      {
        allow_merge_commit?: boolean
        allow_rebase_merge?: boolean
        allow_squash_merge?: boolean
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/repos/${p["templateOwner"]}/${p["templateRepo"]}/generate`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListPublic(p: { accept?: string; since?: number }): Promise<
    Res<
      200,
      {
        archive_url?: string
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        deployments_url?: string
        description?: string
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        html_url?: string
        id?: number
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        languages_url?: string
        merges_url?: string
        milestones_url?: string
        name?: string
        node_id?: string
        notifications_url?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        private?: boolean
        pulls_url?: string
        releases_url?: string
        ssh_url?: string
        stargazers_url?: string
        statuses_url?: string
        subscribers_url?: string
        subscription_url?: string
        tags_url?: string
        teams_url?: string
        trees_url?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/repositories?${this._query({ since: p["since"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async scimListProvisionedIdentities(p: {
    accept?: string
    org: string
    startIndex?: number
    count?: number
    filter?: string
  }): Promise<
    Res<
      200,
      {
        Resources?: {
          active?: boolean
          emails?: {
            primary?: boolean
            type?: string
            value?: string
          }[]
          externalId?: string
          id?: string
          meta?: {
            created?: string
            lastModified?: string
            location?: string
            resourceType?: string
          }
          name?: {
            familyName?: string
            givenName?: string
          }
          schemas?: string[]
          userName?: string
        }[]
        itemsPerPage?: number
        schemas?: string[]
        startIndex?: number
        totalResults?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/scim/v2/organizations/${p["org"]}/Users?${this._query({
          startIndex: p["startIndex"],
          count: p["count"],
          filter: p["filter"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async scimProvisionAndInviteUser(p: {
    accept?: string
    org: string
  }): Promise<
    Res<
      201,
      {
        active?: boolean
        emails?: {
          primary?: boolean
          type?: string
          value?: string
        }[]
        externalId?: string
        id?: string
        meta?: {
          created?: string
          lastModified?: string
          location?: string
          resourceType?: string
        }
        name?: {
          familyName?: string
          givenName?: string
        }
        schemas?: string[]
        userName?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/scim/v2/organizations/${p["org"]}/Users`,
      {
        method: "POST",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async scimGetProvisioningInformationForUser(p: {
    accept?: string
    org: string
    scimUserId: number
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        emails?: {
          primary?: boolean
          type?: string
          value?: string
        }[]
        externalId?: string
        id?: string
        meta?: {
          created?: string
          lastModified?: string
          location?: string
          resourceType?: string
        }
        name?: {
          familyName?: string
          givenName?: string
        }
        schemas?: string[]
        userName?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/scim/v2/organizations/${p["org"]}/Users/${p["scimUserId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async scimSetInformationForProvisionedUser(p: {
    accept?: string
    org: string
    scimUserId: number
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        emails?: {
          primary?: boolean
          type?: string
          value?: string
        }[]
        externalId?: string
        id?: string
        meta?: {
          created?: string
          lastModified?: string
          location?: string
          resourceType?: string
        }
        name?: {
          familyName?: string
          givenName?: string
        }
        schemas?: string[]
        userName?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/scim/v2/organizations/${p["org"]}/Users/${p["scimUserId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async scimUpdateAttributeForUser(p: {
    accept?: string
    org: string
    scimUserId: number
  }): Promise<
    Res<
      200,
      {
        active?: boolean
        emails?: {
          primary?: boolean
          type: string
          value: string
        }[]
        externalId?: string
        id?: string
        meta?: {
          created?: string
          lastModified?: string
          location?: string
          resourceType?: string
        }
        name?: {
          familyName?: string
          givenName?: string
        }
        schemas?: string[]
        userName?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/scim/v2/organizations/${p["org"]}/Users/${p["scimUserId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async scimDeleteUserFromOrg(p: {
    accept?: string
    org: string
    scimUserId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/scim/v2/organizations/${p["org"]}/Users/${p["scimUserId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchCode(p: {
    accept?: string
    q: string
    sort?: "indexed"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        incomplete_results?: boolean
        items?: {
          git_url?: string
          html_url?: string
          name?: string
          path?: string
          repository?: {
            archive_url?: string
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            description?: string
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            hooks_url?: string
            html_url?: string
            id?: number
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            name?: string
            node_id?: string
            notifications_url?: string
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            private?: boolean
            pulls_url?: string
            stargazers_url?: string
            statuses_url?: string
            subscribers_url?: string
            subscription_url?: string
            tags_url?: string
            teams_url?: string
            trees_url?: string
            url?: string
          }
          score?: number
          sha?: string
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/search/code?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchCommits(p: {
    accept: string
    q: string
    sort?: "author-date" | "committer-date"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        incomplete_results?: boolean
        items?: {
          author?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          comments_url?: string
          commit?: {
            author?: {
              date?: string
              email?: string
              name?: string
            }
            comment_count?: number
            committer?: {
              date?: string
              email?: string
              name?: string
            }
            message?: string
            tree?: {
              sha?: string
              url?: string
            }
            url?: string
          }
          committer?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          parents?: {
            html_url?: string
            sha?: string
            url?: string
          }[]
          repository?: {
            archive_url?: string
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            deployments_url?: string
            description?: string
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            hooks_url?: string
            html_url?: string
            id?: number
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            name?: string
            node_id?: string
            notifications_url?: string
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            private?: boolean
            pulls_url?: string
            releases_url?: string
            stargazers_url?: string
            statuses_url?: string
            subscribers_url?: string
            subscription_url?: string
            tags_url?: string
            teams_url?: string
            trees_url?: string
            url?: string
          }
          score?: number
          sha?: string
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/search/commits?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchIssuesAndPullRequests(p: {
    accept?: string
    q: string
    sort?:
      | "comments"
      | "reactions"
      | "reactions-+1"
      | "reactions--1"
      | "reactions-smile"
      | "reactions-thinking_face"
      | "reactions-heart"
      | "reactions-tada"
      | "interactions"
      | "created"
      | "updated"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        incomplete_results?: boolean
        items?: {
          assignee?: string
          body?: string
          closed_at?: string
          comments?: number
          comments_url?: string
          created_at?: string
          events_url?: string
          html_url?: string
          id?: number
          labels?: {
            color?: string
            id?: number
            name?: string
            node_id?: string
            url?: string
          }[]
          labels_url?: string
          milestone?: string
          node_id?: string
          number?: number
          pull_request?: {
            diff_url?: string
            html_url?: string
            patch_url?: string
          }
          repository_url?: string
          score?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
          user?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/search/issues?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchLabels(p: {
    accept?: string
    repositoryId: number
    q: string
    sort?: "created" | "updated"
    order?: "desc" | "asc"
  }): Promise<
    Res<
      200,
      {
        incomplete_results?: boolean
        items?: {
          color: string
          default: boolean
          description: string
          id: number
          name: string
          node_id: string
          score: number
          url: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/search/labels?${this._query({
          repository_id: p["repositoryId"],
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchRepos(p: {
    accept?: string
    q: string
    sort?: "stars" | "forks" | "help-wanted-issues" | "updated"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        incomplete_results?: boolean
        items?: {
          created_at?: string
          default_branch?: string
          description?: string
          fork?: boolean
          forks_count?: number
          full_name?: string
          homepage?: string
          html_url?: string
          id?: number
          language?: string
          master_branch?: string
          name?: string
          node_id?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            gravatar_id?: string
            id?: number
            login?: string
            node_id?: string
            received_events_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pushed_at?: string
          score?: number
          size?: number
          stargazers_count?: number
          updated_at?: string
          url?: string
          watchers_count?: number
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/search/repositories?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchTopics(p: { accept?: string; q: string }): Promise<
    Res<
      200,
      {
        incomplete_results?: boolean
        items?: {
          created_at: string
          created_by: string
          curated: boolean
          description: string
          display_name: string
          featured: boolean
          name: string
          released: string
          score: number
          short_description: string
          updated_at: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/search/topics?${this._query({ q: p["q"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async searchUsers(p: {
    accept?: string
    q: string
    sort?: "followers" | "repositories" | "joined"
    order?: "desc" | "asc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        incomplete_results?: boolean
        items?: {
          avatar_url?: string
          followers_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          score?: number
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/search/users?${this._query({
          q: p["q"],
          sort: p["sort"],
          order: p["order"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetLegacy(p: { accept?: string; teamId: number }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        html_url?: string
        id?: number
        members_count?: number
        members_url?: string
        name?: string
        node_id?: string
        organization?: {
          avatar_url?: string
          blog?: string
          company?: string
          created_at?: string
          description?: string
          email?: string
          events_url?: string
          followers?: number
          following?: number
          has_organization_projects?: boolean
          has_repository_projects?: boolean
          hooks_url?: string
          html_url?: string
          id?: number
          is_verified?: boolean
          issues_url?: string
          location?: string
          login?: string
          members_url?: string
          name?: string
          node_id?: string
          public_gists?: number
          public_members_url?: string
          public_repos?: number
          repos_url?: string
          twitter_username?: string
          type?: string
          url?: string
        }
        parent?: string
        permission?: string
        privacy?: string
        repos_count?: number
        repositories_url?: string
        slug?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/teams/${p["teamId"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateLegacy(p: {
    accept?: string
    teamId: number
    requestBody: {
      description?: string
      name: string
      parent_team_id?: number
      permission?: "pull" | "push" | "admin"
      privacy?: "secret" | "closed"
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        description?: string
        html_url?: string
        id?: number
        members_count?: number
        members_url?: string
        name?: string
        node_id?: string
        organization?: {
          avatar_url?: string
          blog?: string
          company?: string
          created_at?: string
          description?: string
          email?: string
          events_url?: string
          followers?: number
          following?: number
          has_organization_projects?: boolean
          has_repository_projects?: boolean
          hooks_url?: string
          html_url?: string
          id?: number
          is_verified?: boolean
          issues_url?: string
          location?: string
          login?: string
          members_url?: string
          name?: string
          node_id?: string
          public_gists?: number
          public_members_url?: string
          public_repos?: number
          repos_url?: string
          twitter_username?: string
          type?: string
          url?: string
        }
        parent?: string
        permission?: string
        privacy?: string
        repos_count?: number
        repositories_url?: string
        slug?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/teams/${p["teamId"]}`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteLegacy(p: {
    accept?: string
    teamId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/teams/${p["teamId"]}`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionsLegacy(p: {
    accept?: string
    teamId: number
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionLegacy(p: {
    accept?: string
    teamId: number
    requestBody: {
      body: string
      private?: boolean
      title: string
    }
  }): Promise<
    Res<
      201,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/discussions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
    requestBody: {
      body?: string
      title?: string
    }
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        comments_count?: number
        comments_url?: string
        created_at?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        pinned?: boolean
        private?: boolean
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        team_url?: string
        title?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListDiscussionCommentsLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${
          p["discussionNumber"]
        }/comments?${this._query({
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateDiscussionCommentLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      201,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetDiscussionCommentLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
    commentNumber: number
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsUpdateDiscussionCommentLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
    commentNumber: number
    requestBody: {
      body: string
    }
  }): Promise<
    Res<
      200,
      {
        author?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        body?: string
        body_html?: string
        body_version?: string
        created_at?: string
        discussion_url?: string
        html_url?: string
        last_edited_at?: string
        node_id?: string
        number?: number
        reactions?: {
          "+1"?: number
          "-1"?: number
          confused?: number
          heart?: number
          hooray?: number
          laugh?: number
          total_count?: number
          url?: string
        }
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsDeleteDiscussionCommentLegacy(p: {
    accept?: string
    teamId: number
    discussionNumber: number
    commentNumber: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionCommentLegacy(p: {
    accept: string
    teamId: number
    discussionNumber: number
    commentNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${
          p["commentNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionCommentLegacy(p: {
    accept: string
    teamId: number
    discussionNumber: number
    commentNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsListForTeamDiscussionLegacy(p: {
    accept: string
    teamId: number
    discussionNumber: number
    content?:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${
          p["discussionNumber"]
        }/reactions?${this._query({
          content: p["content"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reactionsCreateForTeamDiscussionLegacy(p: {
    accept: string
    teamId: number
    discussionNumber: number
    requestBody: {
      content:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
    }
  }): Promise<
    Res<
      201,
      {
        content?: string
        created_at?: string
        id?: number
        node_id?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/reactions`,
      {
        method: "POST",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListPendingInvitationsLegacy(p: {
    accept?: string
    teamId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        email?: string
        id?: number
        invitation_team_url?: string
        inviter?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        login?: string
        role?: string
        team_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListMembersLegacy(p: {
    accept?: string
    teamId: number
    role?: "member" | "maintainer" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/members?${this._query({
          role: p["role"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetMemberLegacy(p: {
    accept?: string
    teamId: number
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddMemberLegacy(p: {
    accept?: string
    teamId: number
    username: string
  }): Promise<
    | Res<204, void>
    | Res<404, void>
    | Res<
        422,
        {
          errors?: {
            code?: string
            field?: string
            resource?: string
          }[]
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveMemberLegacy(p: {
    accept?: string
    teamId: number
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsGetMembershipForUserLegacy(p: {
    accept?: string
    teamId: number
    username: string
  }): Promise<
    Res<
      200,
      {
        role?: string
        state?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/memberships/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateMembershipForUserLegacy(p: {
    accept?: string
    teamId: number
    username: string
    requestBody: {
      role?: "member" | "maintainer"
    }
  }): Promise<
    | Res<
        200,
        {
          role?: string
          state?: string
          url?: string
        }
      >
    | Res<403, void>
    | Res<
        422,
        {
          errors?: {
            code?: string
            field?: string
            resource?: string
          }[]
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/memberships/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveMembershipForUserLegacy(p: {
    accept?: string
    teamId: number
    username: string
  }): Promise<Res<204, void> | Res<403, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/memberships/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListProjectsLegacy(p: {
    accept: string
    teamId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        organization_permission?: string
        owner_url?: string
        permissions?: {
          admin?: boolean
          read?: boolean
          write?: boolean
        }
        private?: boolean
        state?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/projects?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForProjectLegacy(p: {
    accept: string
    teamId: number
    projectId: number
  }): Promise<
    | Res<
        200,
        {
          body?: string
          columns_url?: string
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          html_url?: string
          id?: number
          name?: string
          node_id?: string
          number?: number
          organization_permission?: string
          owner_url?: string
          permissions?: {
            admin?: boolean
            read?: boolean
            write?: boolean
          }
          private?: boolean
          state?: string
          updated_at?: string
          url?: string
        }
      >
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateProjectPermissionsLegacy(p: {
    accept: string
    teamId: number
    projectId: number
    requestBody: {
      permission?: "read" | "write" | "admin"
    }
  }): Promise<
    | Res<204, void>
    | Res<
        403,
        {
          documentation_url?: string
          message?: string
        }
      >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveProjectLegacy(p: {
    accept?: string
    teamId: number
    projectId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListReposLegacy(p: {
    accept?: string
    teamId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCheckPermissionsForRepoLegacy(p: {
    accept?: string
    teamId: number
    owner: string
    repo: string
  }): Promise<
    | Res<
        200,
        {
          organization?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          parent?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
          permissions?: {
            admin?: boolean
            maintain?: boolean
            pull?: boolean
            push?: boolean
            triage?: boolean
          }
          source?: {
            allow_merge_commit?: boolean
            allow_rebase_merge?: boolean
            allow_squash_merge?: boolean
            archive_url?: string
            archived?: boolean
            assignees_url?: string
            blobs_url?: string
            branches_url?: string
            clone_url?: string
            collaborators_url?: string
            comments_url?: string
            commits_url?: string
            compare_url?: string
            contents_url?: string
            contributors_url?: string
            created_at?: string
            default_branch?: string
            delete_branch_on_merge?: boolean
            deployments_url?: string
            description?: string
            disabled?: boolean
            downloads_url?: string
            events_url?: string
            fork?: boolean
            forks_count?: number
            forks_url?: string
            full_name?: string
            git_commits_url?: string
            git_refs_url?: string
            git_tags_url?: string
            git_url?: string
            has_downloads?: boolean
            has_issues?: boolean
            has_pages?: boolean
            has_projects?: boolean
            has_wiki?: boolean
            homepage?: string
            hooks_url?: string
            html_url?: string
            id?: number
            is_template?: boolean
            issue_comment_url?: string
            issue_events_url?: string
            issues_url?: string
            keys_url?: string
            labels_url?: string
            language?: string
            languages_url?: string
            merges_url?: string
            milestones_url?: string
            mirror_url?: string
            name?: string
            network_count?: number
            node_id?: string
            notifications_url?: string
            open_issues_count?: number
            owner?: {
              avatar_url?: string
              events_url?: string
              followers_url?: string
              following_url?: string
              gists_url?: string
              gravatar_id?: string
              html_url?: string
              id?: number
              login?: string
              node_id?: string
              organizations_url?: string
              received_events_url?: string
              repos_url?: string
              site_admin?: boolean
              starred_url?: string
              subscriptions_url?: string
              type?: string
              url?: string
            }
            permissions?: {
              admin?: boolean
              pull?: boolean
              push?: boolean
            }
            private?: boolean
            pulls_url?: string
            pushed_at?: string
            releases_url?: string
            size?: number
            ssh_url?: string
            stargazers_count?: number
            stargazers_url?: string
            statuses_url?: string
            subscribers_count?: number
            subscribers_url?: string
            subscription_url?: string
            svn_url?: string
            tags_url?: string
            teams_url?: string
            temp_clone_token?: string
            template_repository?: string
            topics?: string[]
            trees_url?: string
            updated_at?: string
            url?: string
            visibility?: string
            watchers_count?: number
          }
        }
      >
    | Res<204, void>
    | Res<404, void>
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsAddOrUpdateRepoPermissionsLegacy(p: {
    accept?: string
    teamId: number
    owner: string
    repo: string
    requestBody: {
      permission?: "pull" | "push" | "admin"
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsRemoveRepoLegacy(p: {
    accept?: string
    teamId: number
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListIdPGroupsForLegacy(p: {
    accept?: string
    teamId: number
  }): Promise<
    Res<
      200,
      {
        groups?: {
          group_description: string
          group_id: string
          group_name: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/team-sync/group-mappings`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsCreateOrUpdateIdPGroupConnectionsLegacy(p: {
    accept?: string
    teamId: number
    requestBody: {
      groups: {
        group_description: string
        group_id: string
        group_name: string
      }[]
    }
  }): Promise<
    Res<
      200,
      {
        groups?: {
          group_description?: string
          group_id?: string
          group_name?: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/teams/${p["teamId"]}/team-sync/group-mappings`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListChildLegacy(p: {
    accept?: string
    teamId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        description?: string
        id?: number
        members_url?: string
        name?: string
        node_id?: string
        parent?: {
          description?: string
          html_url?: string
          id?: number
          members_url?: string
          name?: string
          node_id?: string
          permission?: string
          privacy?: string
          repositories_url?: string
          slug?: string
          url?: string
        }
        permission?: string
        privacy?: string
        repositories_url?: string
        slug?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/teams/${p["teamId"]}/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetAuthenticated(p: { accept?: string }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        bio?: string
        blog?: string
        collaborators?: number
        company?: string
        created_at?: string
        disk_usage?: number
        email?: string
        events_url?: string
        followers?: number
        followers_url?: string
        following?: number
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        hireable?: boolean
        html_url?: string
        id?: number
        location?: string
        login?: string
        name?: string
        node_id?: string
        organizations_url?: string
        owned_private_repos?: number
        plan?: {
          collaborators?: number
          name?: string
          private_repos?: number
          space?: number
        }
        private_gists?: number
        public_gists?: number
        public_repos?: number
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        total_private_repos?: number
        twitter_username?: string
        two_factor_authentication?: boolean
        type?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/user`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersUpdateAuthenticated(p: {
    accept?: string
    requestBody: {
      bio?: string
      blog?: string
      company?: string
      email?: string
      hireable?: boolean
      location?: string
      name?: string
      twitter_username?: string
    }
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        bio?: string
        blog?: string
        collaborators?: number
        company?: string
        created_at?: string
        disk_usage?: number
        email?: string
        events_url?: string
        followers?: number
        followers_url?: string
        following?: number
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        hireable?: boolean
        html_url?: string
        id?: number
        location?: string
        login?: string
        name?: string
        node_id?: string
        organizations_url?: string
        owned_private_repos?: number
        plan?: {
          collaborators?: number
          name?: string
          private_repos?: number
          space?: number
        }
        private_gists?: number
        public_gists?: number
        public_repos?: number
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        total_private_repos?: number
        twitter_username?: string
        two_factor_authentication?: boolean
        type?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListBlockedByAuthenticated(p: { accept?: string }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/user/blocks`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCheckBlocked(p: {
    accept?: string
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/blocks/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersBlock(p: {
    accept?: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/blocks/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersUnblock(p: {
    accept?: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/blocks/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersSetPrimaryEmailVisibilityForAuthenticated(p: {
    accept?: string
    requestBody: {
      email: string
      visibility: string
    }
  }): Promise<
    Res<
      200,
      {
        email?: string
        primary?: boolean
        verified?: boolean
        visibility?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/email/visibility`, {
      method: "PATCH",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListEmailsForAuthenticated(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        email?: string
        primary?: boolean
        verified?: boolean
        visibility?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/emails?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersAddEmailForAuthenticated(p: {
    accept?: string
    requestBody: {
      emails: string[]
    }
  }): Promise<
    Res<
      201,
      {
        email?: string
        primary?: boolean
        verified?: boolean
        visibility?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/emails`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersDeleteEmailForAuthenticated(p: {
    accept?: string
    requestBody: {
      emails: string[]
    }
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/emails`, {
      method: "DELETE",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowersForAuthenticatedUser(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/followers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowedByAuthenticated(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/following?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCheckPersonIsFollowedByAuthenticated(p: {
    accept?: string
    username: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/following/${p["username"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersFollow(p: {
    accept?: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/following/${p["username"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersUnfollow(p: {
    accept?: string
    username: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/following/${p["username"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListGpgKeysForAuthenticated(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        can_certify?: boolean
        can_encrypt_comms?: boolean
        can_encrypt_storage?: boolean
        can_sign?: boolean
        created_at?: string
        emails?: {
          email?: string
          verified?: boolean
        }[]
        expires_at?: string
        id?: number
        key_id?: string
        primary_key_id?: string
        public_key?: string
        subkeys?: {
          can_certify?: boolean
          can_encrypt_comms?: boolean
          can_encrypt_storage?: boolean
          can_sign?: boolean
          created_at?: string
          emails?: {
            [key: string]: unknown
          }[]
          expires_at?: string
          id?: number
          key_id?: string
          primary_key_id?: number
          public_key?: string
          subkeys?: {
            [key: string]: unknown
          }[]
        }[]
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/gpg_keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCreateGpgKeyForAuthenticated(p: {
    accept?: string
    requestBody: {
      armored_public_key?: string
    }
  }): Promise<
    Res<
      201,
      {
        can_certify?: boolean
        can_encrypt_comms?: boolean
        can_encrypt_storage?: boolean
        can_sign?: boolean
        created_at?: string
        emails?: {
          email?: string
          verified?: boolean
        }[]
        expires_at?: string
        id?: number
        key_id?: string
        primary_key_id?: string
        public_key?: string
        subkeys?: {
          can_certify?: boolean
          can_encrypt_comms?: boolean
          can_encrypt_storage?: boolean
          can_sign?: boolean
          created_at?: string
          emails?: {
            [key: string]: unknown
          }[]
          expires_at?: string
          id?: number
          key_id?: string
          primary_key_id?: number
          public_key?: string
          subkeys?: {
            [key: string]: unknown
          }[]
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/gpg_keys`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetGpgKeyForAuthenticated(p: {
    accept?: string
    gpgKeyId: number
  }): Promise<
    Res<
      200,
      {
        can_certify?: boolean
        can_encrypt_comms?: boolean
        can_encrypt_storage?: boolean
        can_sign?: boolean
        created_at?: string
        emails?: {
          email?: string
          verified?: boolean
        }[]
        expires_at?: string
        id?: number
        key_id?: string
        primary_key_id?: string
        public_key?: string
        subkeys?: {
          can_certify?: boolean
          can_encrypt_comms?: boolean
          can_encrypt_storage?: boolean
          can_sign?: boolean
          created_at?: string
          emails?: {
            [key: string]: unknown
          }[]
          expires_at?: string
          id?: number
          key_id?: string
          primary_key_id?: number
          public_key?: string
          subkeys?: {
            [key: string]: unknown
          }[]
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/gpg_keys/${p["gpgKeyId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersDeleteGpgKeyForAuthenticated(p: {
    accept?: string
    gpgKeyId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/gpg_keys/${p["gpgKeyId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListInstallationsForAuthenticatedUser(p: {
    accept: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        installations?: {
          access_tokens_url: string
          account: {
            avatar_url?: string
            description?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            hooks_url?: string
            html_url?: string
            id?: number
            issues_url?: string
            login?: string
            members_url?: string
            node_id?: string
            organizations_url?: string
            public_members_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          app_id: number
          events: string[]
          html_url: string
          id: number
          permissions: {
            checks?: string
            contents?: string
            metadata?: string
          }
          repositories_url: string
          single_file_name: string
          target_id: number
          target_type: string
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/installations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListInstallationReposForAuthenticatedUser(p: {
    accept: string
    installationId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        total_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/installations/${p["installationId"]}/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsAddRepoToInstallation(p: {
    accept: string
    installationId: number
    repositoryId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsRemoveRepoFromInstallation(p: {
    accept: string
    installationId: number
    repositoryId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async issuesListForAuthenticatedUser(p: {
    accept?: string
    filter?: "assigned" | "created" | "mentioned" | "subscribed" | "all"
    state?: "open" | "closed" | "all"
    labels?: string
    sort?: "created" | "updated" | "comments"
    direction?: "asc" | "desc"
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        active_lock_reason?: string
        assignee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        assignees?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }[]
        body?: string
        closed_at?: string
        comments?: number
        comments_url?: string
        created_at?: string
        events_url?: string
        html_url?: string
        id?: number
        labels?: {
          color?: string
          default?: boolean
          description?: string
          id?: number
          name?: string
          node_id?: string
          url?: string
        }[]
        labels_url?: string
        locked?: boolean
        milestone?: {
          closed_at?: string
          closed_issues?: number
          created_at?: string
          creator?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          description?: string
          due_on?: string
          html_url?: string
          id?: number
          labels_url?: string
          node_id?: string
          number?: number
          open_issues?: number
          state?: string
          title?: string
          updated_at?: string
          url?: string
        }
        node_id?: string
        number?: number
        pull_request?: {
          diff_url?: string
          html_url?: string
          patch_url?: string
          url?: string
        }
        repository?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        repository_url?: string
        state?: string
        title?: string
        updated_at?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/issues?${this._query({
          filter: p["filter"],
          state: p["state"],
          labels: p["labels"],
          sort: p["sort"],
          direction: p["direction"],
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListPublicSshKeysForAuthenticated(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        key?: string
        key_id?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCreatePublicSshKeyForAuthenticated(p: {
    accept?: string
    requestBody: {
      key?: string
      title?: string
    }
  }): Promise<
    Res<
      201,
      {
        key?: string
        key_id?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/keys`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetPublicSshKeyForAuthenticated(p: {
    accept?: string
    keyId: number
  }): Promise<
    Res<
      200,
      {
        key?: string
        key_id?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/user/keys/${p["keyId"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersDeletePublicSshKeyForAuthenticated(p: {
    accept?: string
    keyId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/user/keys/${p["keyId"]}`, {
      method: "DELETE",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListSubscriptionsForAuthenticatedUser(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        account?: {
          email?: string
          id?: number
          login?: string
          organization_billing_email?: string
          type?: string
          url?: string
        }
        billing_cycle?: string
        free_trial_ends_on?: string
        next_billing_date?: string
        on_free_trial?: boolean
        plan?: {
          accounts_url?: string
          bullets?: string[]
          description?: string
          has_free_trial?: boolean
          id?: number
          monthly_price_in_cents?: number
          name?: string
          number?: number
          price_model?: string
          state?: string
          unit_name?: string
          url?: string
          yearly_price_in_cents?: number
        }
        unit_count?: string
        updated_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/marketplace_purchases?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsListSubscriptionsForAuthenticatedUserStubbed(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        account?: {
          email?: string
          id?: number
          login?: string
          organization_billing_email?: string
          type?: string
          url?: string
        }
        billing_cycle?: string
        free_trial_ends_on?: string
        next_billing_date?: string
        on_free_trial?: boolean
        plan?: {
          accounts_url?: string
          bullets?: string[]
          description?: string
          has_free_trial?: boolean
          id?: number
          monthly_price_in_cents?: number
          name?: string
          number?: number
          price_model?: string
          state?: string
          unit_name?: string
          url?: string
          yearly_price_in_cents?: number
        }
        unit_count?: string
        updated_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/marketplace_purchases/stubbed?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListMembershipsForAuthenticatedUser(p: {
    accept?: string
    state?: "active" | "pending"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        organization?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        organization_url?: string
        role?: string
        state?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/memberships/orgs?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsGetMembershipForAuthenticatedUser(p: {
    accept?: string
    org: string
  }): Promise<
    Res<
      200,
      {
        organization?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        organization_url?: string
        role?: string
        state?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/memberships/orgs/${p["org"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsUpdateMembershipForAuthenticatedUser(p: {
    accept?: string
    org: string
    requestBody: {
      state: "active"
    }
  }): Promise<
    Res<
      200,
      {
        organization?: {
          avatar_url?: string
          description?: string
          events_url?: string
          hooks_url?: string
          id?: number
          issues_url?: string
          login?: string
          members_url?: string
          node_id?: string
          public_members_url?: string
          repos_url?: string
          url?: string
        }
        organization_url?: string
        role?: string
        state?: string
        url?: string
        user?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(
      this.config.basePath + `/user/memberships/orgs/${p["org"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
        body: JSON.stringify(p.requestBody),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsStartForAuthenticatedUser(p: {
    accept?: string
    requestBody: {
      exclude_attachments?: boolean
      lock_repositories?: boolean
      repositories: string[]
    }
  }): Promise<
    Res<
      201,
      {
        created_at?: string
        exclude_attachments?: boolean
        guid?: string
        id?: number
        lock_repositories?: boolean
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/migrations`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListForAuthenticatedUser(p: {
    accept: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        exclude_attachments?: boolean
        guid?: string
        id?: number
        lock_repositories?: boolean
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        state?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/migrations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetStatusForAuthenticatedUser(p: {
    accept: string
    migrationId: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        exclude_attachments?: boolean
        guid?: string
        id?: number
        lock_repositories?: boolean
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        repositories?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }[]
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/migrations/${p["migrationId"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsGetArchiveForAuthenticatedUser(p: {
    accept: string
    migrationId: number
  }): Promise<Res<302, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/migrations/${p["migrationId"]}/archive`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsDeleteArchiveForAuthenticatedUser(p: {
    accept: string
    migrationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/migrations/${p["migrationId"]}/archive`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsUnlockRepoForAuthenticatedUser(p: {
    accept: string
    migrationId: number
    repoName: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListForAuthenticatedUser(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        description?: string
        events_url?: string
        hooks_url?: string
        id?: number
        issues_url?: string
        login?: string
        members_url?: string
        node_id?: string
        public_members_url?: string
        repos_url?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/orgs?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsCreateForAuthenticatedUser(p: {
    accept: string
    requestBody: {
      body?: string
      name: string
    }
  }): Promise<
    Res<
      201,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        owner_url?: string
        state?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/projects`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListPublicEmailsForAuthenticated(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        email?: string
        primary?: boolean
        verified?: boolean
        visibility?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/public_emails?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForAuthenticatedUser(p: {
    accept?: string
    visibility?: "all" | "public" | "private"
    affiliation?: string
    type?: "all" | "owner" | "public" | "private" | "member"
    sort?: "created" | "updated" | "pushed" | "full_name"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/repos?${this._query({
          visibility: p["visibility"],
          affiliation: p["affiliation"],
          type: p["type"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposCreateForAuthenticatedUser(p: {
    accept?: string
    requestBody: {
      allow_merge_commit?: boolean
      allow_rebase_merge?: boolean
      allow_squash_merge?: boolean
      auto_init?: boolean
      delete_branch_on_merge?: boolean
      description?: string
      gitignore_template?: string
      has_issues?: boolean
      has_projects?: boolean
      has_wiki?: boolean
      homepage?: string
      is_template?: boolean
      license_template?: string
      name: string
      private?: boolean
      team_id?: number
      visibility?: "public" | "private" | "visibility" | "internal"
    }
  }): Promise<
    Res<
      201,
      {
        allow_merge_commit?: boolean
        allow_rebase_merge?: boolean
        allow_squash_merge?: boolean
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }
    >
  > {
    const headers: Record<string, string | undefined> = {
      "Content-Type": "application/json",
      accept: p["accept"],
    }

    const res = await fetch(this.config.basePath + `/user/repos`, {
      method: "POST",
      headers: this._headers(headers),
      body: JSON.stringify(p.requestBody),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListInvitationsForAuthenticatedUser(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        html_url?: string
        id?: number
        invitee?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        inviter?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: string
        repository?: {
          archive_url?: string
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          deployments_url?: string
          description?: string
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          html_url?: string
          id?: number
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          name?: string
          node_id?: string
          notifications_url?: string
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          private?: boolean
          pulls_url?: string
          releases_url?: string
          ssh_url?: string
          stargazers_url?: string
          statuses_url?: string
          subscribers_url?: string
          subscription_url?: string
          tags_url?: string
          teams_url?: string
          trees_url?: string
          url?: string
        }
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/repository_invitations?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposAcceptInvitation(p: {
    accept?: string
    invitationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/repository_invitations/${p["invitationId"]}`,
      {
        method: "PATCH",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposDeclineInvitation(p: {
    accept?: string
    invitationId: number
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/repository_invitations/${p["invitationId"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReposStarredByAuthenticatedUser(p: {
    accept?: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        repo?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        starred_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/starred?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityCheckRepoIsStarredByAuthenticatedUser(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityStarRepoForAuthenticatedUser(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`,
      {
        method: "PUT",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityUnstarRepoForAuthenticatedUser(p: {
    accept?: string
    owner: string
    repo: string
  }): Promise<Res<204, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`,
      {
        method: "DELETE",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListWatchedReposForAuthenticatedUser(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/subscriptions?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async teamsListForAuthenticatedUser(p: {
    accept?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        created_at?: string
        description?: string
        html_url?: string
        id?: number
        members_count?: number
        members_url?: string
        name?: string
        node_id?: string
        organization?: {
          avatar_url?: string
          blog?: string
          company?: string
          created_at?: string
          description?: string
          email?: string
          events_url?: string
          followers?: number
          following?: number
          has_organization_projects?: boolean
          has_repository_projects?: boolean
          hooks_url?: string
          html_url?: string
          id?: number
          is_verified?: boolean
          issues_url?: string
          location?: string
          login?: string
          members_url?: string
          name?: string
          node_id?: string
          public_gists?: number
          public_members_url?: string
          public_repos?: number
          repos_url?: string
          twitter_username?: string
          type?: string
          url?: string
        }
        parent?: string
        permission?: string
        privacy?: string
        repos_count?: number
        repositories_url?: string
        slug?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/teams?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async migrationsListReposForUser(p: {
    accept: string
    migrationId: number
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/user/${p["migrationId"]}/repositories?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersList(p: { accept?: string; since?: string }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/users?${this._query({ since: p["since"] })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetByUsername(p: { accept?: string; username: string }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        bio?: string
        blog?: string
        company?: string
        created_at?: string
        email?: string
        events_url?: string
        followers?: number
        followers_url?: string
        following?: number
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        hireable?: boolean
        html_url?: string
        id?: number
        location?: string
        login?: string
        name?: string
        node_id?: string
        organizations_url?: string
        public_gists?: number
        public_repos?: number
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        twitter_username?: string
        type?: string
        updated_at?: string
        url?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(this.config.basePath + `/users/${p["username"]}`, {
      method: "GET",
      headers: this._headers(headers),
    })

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListEventsForAuthenticatedUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListOrgEventsForAuthenticatedUser(p: {
    accept?: string
    username: string
    org: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/events/orgs/${p["org"]}?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListPublicEventsForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/events/public?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowersForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/followers?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListFollowingForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        events_url?: string
        followers_url?: string
        following_url?: string
        gists_url?: string
        gravatar_id?: string
        html_url?: string
        id?: number
        login?: string
        node_id?: string
        organizations_url?: string
        received_events_url?: string
        repos_url?: string
        site_admin?: boolean
        starred_url?: string
        subscriptions_url?: string
        type?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/following?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersCheckFollowingForUser(p: {
    accept?: string
    username: string
    targetUser: string
  }): Promise<Res<204, void> | Res<404, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/following/${p["targetUser"]}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async gistsListForUser(p: {
    accept?: string
    username: string
    since?: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        comments?: number
        comments_url?: string
        commits_url?: string
        created_at?: string
        description?: string
        files?: {
          [key: string]: unknown
        }
        forks_url?: string
        git_pull_url?: string
        git_push_url?: string
        html_url?: string
        id?: string
        node_id?: string
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        public?: boolean
        truncated?: boolean
        updated_at?: string
        url?: string
        user?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/gists?${this._query({
          since: p["since"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListGpgKeysForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        can_certify?: boolean
        can_encrypt_comms?: boolean
        can_encrypt_storage?: boolean
        can_sign?: boolean
        created_at?: string
        emails?: {
          email?: string
          verified?: boolean
        }[]
        expires_at?: string
        id?: number
        key_id?: string
        primary_key_id?: string
        public_key?: string
        subkeys?: {
          can_certify?: boolean
          can_encrypt_comms?: boolean
          can_encrypt_storage?: boolean
          can_sign?: boolean
          created_at?: string
          emails?: {
            [key: string]: unknown
          }[]
          expires_at?: string
          id?: number
          key_id?: string
          primary_key_id?: number
          public_key?: string
          subkeys?: {
            [key: string]: unknown
          }[]
        }[]
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/gpg_keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersGetContextForUser(p: {
    accept?: string
    username: string
    subjectType?: "organization" | "repository" | "issue" | "pull_request"
    subjectId?: string
  }): Promise<
    Res<
      200,
      {
        contexts?: {
          message?: string
          octicon?: string
        }[]
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/hovercard?${this._query({
          subject_type: p["subjectType"],
          subject_id: p["subjectId"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async appsGetUserInstallation(p: {
    accept: string
    username: string
  }): Promise<
    Res<
      200,
      {
        access_tokens_url?: string
        account?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        app_id?: number
        created_at?: string
        events?: string[]
        html_url?: string
        id?: number
        permissions?: {
          checks?: string
          contents?: string
          metadata?: string
        }
        repositories_url?: string
        repository_selection?: "all" | "selected"
        single_file_name?: string
        target_id?: number
        target_type?: string
        updated_at?: string
      }
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath + `/users/${p["username"]}/installation`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async usersListPublicKeysForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        id?: number
        key?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/keys?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async orgsListForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        avatar_url?: string
        description?: string
        events_url?: string
        hooks_url?: string
        id?: number
        issues_url?: string
        login?: string
        members_url?: string
        node_id?: string
        public_members_url?: string
        repos_url?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/orgs?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async projectsListForUser(p: {
    accept: string
    username: string
    state?: "open" | "closed" | "all"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        body?: string
        columns_url?: string
        created_at?: string
        creator?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        html_url?: string
        id?: number
        name?: string
        node_id?: string
        number?: number
        owner_url?: string
        state?: string
        updated_at?: string
        url?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/projects?${this._query({
          state: p["state"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReceivedEventsForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/received_events?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReceivedPublicEventsForUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/received_events/public?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async reposListForUser(p: {
    accept?: string
    username: string
    type?: "all" | "owner" | "member"
    sort?: "created" | "updated" | "pushed" | "full_name"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<Res<418, void>> {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/repos?${this._query({
          type: p["type"],
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReposStarredByUser(p: {
    accept?: string
    username: string
    sort?: "created" | "updated"
    direction?: "asc" | "desc"
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        repo?: {
          allow_merge_commit?: boolean
          allow_rebase_merge?: boolean
          allow_squash_merge?: boolean
          archive_url?: string
          archived?: boolean
          assignees_url?: string
          blobs_url?: string
          branches_url?: string
          clone_url?: string
          collaborators_url?: string
          comments_url?: string
          commits_url?: string
          compare_url?: string
          contents_url?: string
          contributors_url?: string
          created_at?: string
          default_branch?: string
          delete_branch_on_merge?: boolean
          deployments_url?: string
          description?: string
          disabled?: boolean
          downloads_url?: string
          events_url?: string
          fork?: boolean
          forks_count?: number
          forks_url?: string
          full_name?: string
          git_commits_url?: string
          git_refs_url?: string
          git_tags_url?: string
          git_url?: string
          has_downloads?: boolean
          has_issues?: boolean
          has_pages?: boolean
          has_projects?: boolean
          has_wiki?: boolean
          homepage?: string
          hooks_url?: string
          html_url?: string
          id?: number
          is_template?: boolean
          issue_comment_url?: string
          issue_events_url?: string
          issues_url?: string
          keys_url?: string
          labels_url?: string
          language?: string
          languages_url?: string
          merges_url?: string
          milestones_url?: string
          mirror_url?: string
          name?: string
          network_count?: number
          node_id?: string
          notifications_url?: string
          open_issues_count?: number
          owner?: {
            avatar_url?: string
            events_url?: string
            followers_url?: string
            following_url?: string
            gists_url?: string
            gravatar_id?: string
            html_url?: string
            id?: number
            login?: string
            node_id?: string
            organizations_url?: string
            received_events_url?: string
            repos_url?: string
            site_admin?: boolean
            starred_url?: string
            subscriptions_url?: string
            type?: string
            url?: string
          }
          permissions?: {
            admin?: boolean
            pull?: boolean
            push?: boolean
          }
          private?: boolean
          pulls_url?: string
          pushed_at?: string
          releases_url?: string
          size?: number
          ssh_url?: string
          stargazers_count?: number
          stargazers_url?: string
          statuses_url?: string
          subscribers_count?: number
          subscribers_url?: string
          subscription_url?: string
          svn_url?: string
          tags_url?: string
          teams_url?: string
          temp_clone_token?: string
          template_repository?: string
          topics?: string[]
          trees_url?: string
          updated_at?: string
          url?: string
          visibility?: string
          watchers_count?: number
        }
        starred_at?: string
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/starred?${this._query({
          sort: p["sort"],
          direction: p["direction"],
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }

  async activityListReposWatchedByUser(p: {
    accept?: string
    username: string
    perPage?: number
    page?: number
  }): Promise<
    Res<
      200,
      {
        archive_url?: string
        archived?: boolean
        assignees_url?: string
        blobs_url?: string
        branches_url?: string
        clone_url?: string
        collaborators_url?: string
        comments_url?: string
        commits_url?: string
        compare_url?: string
        contents_url?: string
        contributors_url?: string
        created_at?: string
        default_branch?: string
        delete_branch_on_merge?: boolean
        deployments_url?: string
        description?: string
        disabled?: boolean
        downloads_url?: string
        events_url?: string
        fork?: boolean
        forks_count?: number
        forks_url?: string
        full_name?: string
        git_commits_url?: string
        git_refs_url?: string
        git_tags_url?: string
        git_url?: string
        has_downloads?: boolean
        has_issues?: boolean
        has_pages?: boolean
        has_projects?: boolean
        has_wiki?: boolean
        homepage?: string
        hooks_url?: string
        html_url?: string
        id?: number
        is_template?: boolean
        issue_comment_url?: string
        issue_events_url?: string
        issues_url?: string
        keys_url?: string
        labels_url?: string
        language?: string
        languages_url?: string
        license?: {
          key?: string
          name?: string
          node_id?: string
          spdx_id?: string
          url?: string
        }
        merges_url?: string
        milestones_url?: string
        mirror_url?: string
        name?: string
        network_count?: number
        node_id?: string
        notifications_url?: string
        open_issues_count?: number
        owner?: {
          avatar_url?: string
          events_url?: string
          followers_url?: string
          following_url?: string
          gists_url?: string
          gravatar_id?: string
          html_url?: string
          id?: number
          login?: string
          node_id?: string
          organizations_url?: string
          received_events_url?: string
          repos_url?: string
          site_admin?: boolean
          starred_url?: string
          subscriptions_url?: string
          type?: string
          url?: string
        }
        permissions?: {
          admin?: boolean
          pull?: boolean
          push?: boolean
        }
        private?: boolean
        pulls_url?: string
        pushed_at?: string
        releases_url?: string
        size?: number
        ssh_url?: string
        stargazers_count?: number
        stargazers_url?: string
        statuses_url?: string
        subscribers_count?: number
        subscribers_url?: string
        subscription_url?: string
        svn_url?: string
        tags_url?: string
        teams_url?: string
        temp_clone_token?: string
        template_repository?: string
        topics?: string[]
        trees_url?: string
        updated_at?: string
        url?: string
        visibility?: string
        watchers_count?: number
      }[]
    >
  > {
    const headers: Record<string, string | undefined> = { accept: p["accept"] }

    const res = await fetch(
      this.config.basePath +
        `/users/${p["username"]}/subscriptions?${this._query({
          per_page: p["perPage"],
          page: p["page"],
        })}`,
      {
        method: "GET",
        headers: this._headers(headers),
      }
    )

    // TODO: this is a poor assumption
    return { status: res.status as any, body: (await res.json()) as any }
  }
}
