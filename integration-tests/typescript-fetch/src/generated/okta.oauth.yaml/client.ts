/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AcrValue,
  t_AmrValue,
  t_BackchannelAuthorizeRequest,
  t_BackchannelAuthorizeResponse,
  t_Client,
  t_CodeChallengeMethod,
  t_DeviceAuthorizeRequest,
  t_DeviceAuthorizeResponse,
  t_Error,
  t_IntrospectionRequest,
  t_IntrospectionResponse,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OidcMetadata,
  t_ParRequest,
  t_ParResponse,
  t_Prompt,
  t_ResponseMode,
  t_ResponseTypesSupported,
  t_RevokeRequest,
  t_TokenRequest,
  t_TokenResponse,
  t_UserInfo,
} from "./models"
import {
  AbstractFetchClient,
  AbstractFetchClientConfig,
  Res,
  TypedFetchResponse,
} from "@nahkies/typescript-fetch-runtime/main"

export interface ApiClientConfig extends AbstractFetchClientConfig {}

export class ApiClient extends AbstractFetchClient {
  constructor(config: ApiClientConfig) {
    super(config)
  }

  async getWellKnownOpenIdConfiguration(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_OidcMetadata> | Res<400, t_Error>>> {
    const url = this.basePath + `/.well-known/openid-configuration`
    const query = this._query({ client_id: p["clientId"] })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async authorize(
    p: {
      acrValues?: t_AcrValue
      clientId?: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri?: string
      responseType?: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope?: string
      sessionToken?: string
      state?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<429, t_Error>>> {
    const url = this.basePath + `/oauth2/v1/authorize`
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async bcAuthorize(
    p: {
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_BackchannelAuthorizeResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/bc/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async listClients(
    p: {
      after?: string
      limit?: number
      q?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_Client[]> | Res<403, t_Error> | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/clients`
    const query = this._query({
      after: p["after"],
      limit: p["limit"],
      q: p["q"],
    })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async createClient(
    p: {
      requestBody: t_Client
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_Client>
      | Res<400, t_Error>
      | Res<403, t_Error>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/clients`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async getClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_Client>
      | Res<403, t_Error>
      | Res<404, t_Error>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/clients/${p["clientId"]}`

    return this._fetch(url, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async replaceClient(
    p: {
      clientId: string
      requestBody: t_Client
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_Client>
      | Res<400, t_Error>
      | Res<403, t_Error>
      | Res<404, t_Error>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "PUT", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deleteClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_Error> | Res<404, t_Error> | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/clients/${p["clientId"]}`

    return this._fetch(url, { method: "DELETE", ...(opts ?? {}) }, timeout)
  }

  async generateNewClientSecret(
    p: {
      clientId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_Client>
      | Res<403, t_Error>
      | Res<404, t_Error>
      | Res<429, t_Error>
    >
  > {
    const url =
      this.basePath + `/oauth2/v1/clients/${p["clientId"]}/lifecycle/newSecret`

    return this._fetch(url, { method: "POST", ...(opts ?? {}) }, timeout)
  }

  async deviceAuthorize(
    p: {
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_DeviceAuthorizeResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/device/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async introspect(
    p: {
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_IntrospectionResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/introspect`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async oauthKeys(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_OAuthKeys> | Res<429, t_Error>>> {
    const url = this.basePath + `/oauth2/v1/keys`
    const query = this._query({ client_id: p["clientId"] })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async logout(
    p: {
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<429, t_Error>>> {
    const url = this.basePath + `/oauth2/v1/logout`
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async par(
    p: {
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_ParResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<403, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/par`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async revoke(
    p: {
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, void>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/revoke`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async token(
    p: {
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_TokenResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/token`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async userinfo(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_UserInfo> | Res<401, void> | Res<403, void> | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/v1/userinfo`

    return this._fetch(url, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async getWellKnownOAuthConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_OAuthMetadata> | Res<400, t_Error> | Res<404, t_Error>
    >
  > {
    const url =
      this.basePath +
      `/oauth2/${p["authorizationServerId"]}/.well-known/oauth-authorization-server`
    const query = this._query({ client_id: p["clientId"] })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async getWellKnownOpenIdConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_OidcMetadata> | Res<400, t_Error> | Res<404, t_Error>
    >
  > {
    const url =
      this.basePath +
      `/oauth2/${p["authorizationServerId"]}/.well-known/openid-configuration`
    const query = this._query({ client_id: p["clientId"] })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async authorizeCustomAs(
    p: {
      authorizationServerId: string
      acrValues?: t_AcrValue
      clientId?: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri?: string
      responseType?: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope?: string
      sessionToken?: string
      state?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<429, t_Error>>> {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/authorize`
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async bcAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_BackchannelAuthorizeResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/bc/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async deviceAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_DeviceAuthorizeResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url =
      this.basePath +
      `/oauth2/${p["authorizationServerId"]}/v1/device/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async introspectCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_IntrospectionResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/introspect`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async oauthKeysCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_OAuthKeys> | Res<429, t_Error>>> {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/keys`

    return this._fetch(url, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async logoutCustomAs(
    p: {
      authorizationServerId: string
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<429, t_Error>>> {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/logout`
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    return this._fetch(url + query, { method: "GET", ...(opts ?? {}) }, timeout)
  }

  async parCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_ParResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<403, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/par`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async revokeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, void>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/revoke`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async tokenCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_TokenResponse>
      | Res<400, t_OAuthError>
      | Res<401, t_OAuthError>
      | Res<429, t_Error>
    >
  > {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/token`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      { method: "POST", headers, body, ...(opts ?? {}) },
      timeout,
    )
  }

  async userinfoCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_UserInfo> | Res<401, void> | Res<403, void> | Res<429, t_Error>
    >
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/userinfo`

    return this._fetch(url, { method: "GET", ...(opts ?? {}) }, timeout)
  }
}
