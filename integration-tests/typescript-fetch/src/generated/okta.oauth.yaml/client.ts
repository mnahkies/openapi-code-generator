/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AcrValue,
  t_AmrValue,
  t_AuthorizeWithPost,
  t_BackchannelAuthorizeRequest,
  t_BackchannelAuthorizeResponse,
  t_ChallengeRequest,
  t_ChallengeResponse,
  t_Client,
  t_CodeChallengeMethod,
  t_DeviceAuthorizeRequest,
  t_DeviceAuthorizeResponse,
  t_Error,
  t_GlobalTokenRevocationRequest,
  t_IntrospectionRequest,
  t_IntrospectionResponse,
  t_LogoutWithPost,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OidcMetadata,
  t_OobAuthenticateRequest,
  t_OobAuthenticateResponse,
  t_ParRequest,
  t_ParResponse,
  t_Prompt,
  t_ResponseMode,
  t_ResponseTypesSupported,
  t_RevokeRequest,
  t_TokenRequest,
  t_TokenResponse,
  t_UserInfo,
} from "./models"
import {
  AbstractFetchClient,
  AbstractFetchClientConfig,
  Res,
  Server,
} from "@nahkies/typescript-fetch-runtime/main"

export class OktaOpenIdConnectOAuth20Servers {
  static default(): Server<"OktaOpenIdConnectOAuth20"> {
    return OktaOpenIdConnectOAuth20Servers.server().build()
  }

  static server(url: "https://{yourOktaDomain}" = "https://{yourOktaDomain}"): {
    build: (yourOktaDomain?: string) => Server<"OktaOpenIdConnectOAuth20">
  } {
    switch (url) {
      case "https://{yourOktaDomain}":
        return {
          build(
            yourOktaDomain = "subdomain.okta.com",
          ): Server<"OktaOpenIdConnectOAuth20"> {
            return "https://{yourOktaDomain}".replace(
              "{yourOktaDomain}",
              yourOktaDomain,
            ) as Server<"OktaOpenIdConnectOAuth20">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export interface OktaOpenIdConnectOAuth20Config
  extends AbstractFetchClientConfig {
  basePath: Server<"OktaOpenIdConnectOAuth20"> | string
}

export class OktaOpenIdConnectOAuth20 extends AbstractFetchClient {
  constructor(config: OktaOpenIdConnectOAuth20Config) {
    super(config)
  }

  async getWellKnownOpenIdConfiguration(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_OidcMetadata> | Res<400, t_Error>> {
    const url = this.basePath + `/.well-known/openid-configuration`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({client_id: p["clientId"]})

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async authorize(
    p: {
      acrValues?: t_AcrValue
      clientId: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri: string
      responseType: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope: string
      sessionToken?: string
      state: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/authorize`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async authorizeWithPost(
    p: {
      requestBody: t_AuthorizeWithPost
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/authorize`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async bcAuthorize(
    p: {
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_BackchannelAuthorizeResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/bc/authorize`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async challenge(
    p: {
      requestBody: t_ChallengeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_ChallengeResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<403, t_OAuthError>
    | Res<429, t_OAuthError>
  > {
    const url = this.basePath + `/oauth2/v1/challenge`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async listClients(
    p: {
      after?: string
      limit?: number
      q?: string
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_Client[]> | Res<403, t_Error> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/clients`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({after: p["after"], limit: p["limit"], q: p["q"]})

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async createClient(
    p: {
      requestBody: t_Client
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<201, t_Client>
    | Res<400, t_Error>
    | Res<403, t_Error>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/clients`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async getClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_Client>
    | Res<403, t_Error>
    | Res<404, t_Error>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(url, {method: "GET", ...opts, headers}, timeout)
  }

  async replaceClient(
    p: {
      clientId: string
      requestBody: t_Client
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_Client>
    | Res<400, t_Error>
    | Res<403, t_Error>
    | Res<404, t_Error>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._fetch(url, {method: "PUT", body, ...opts, headers}, timeout)
  }

  async deleteClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<204, void> | Res<403, t_Error> | Res<404, t_Error> | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(url, {method: "DELETE", ...opts, headers}, timeout)
  }

  async generateNewClientSecret(
    p: {
      clientId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_Client>
    | Res<403, t_Error>
    | Res<404, t_Error>
    | Res<429, t_Error>
  > {
    const url =
      this.basePath + `/oauth2/v1/clients/${p["clientId"]}/lifecycle/newSecret`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(url, {method: "POST", ...opts, headers}, timeout)
  }

  async deviceAuthorize(
    p: {
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_DeviceAuthorizeResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/device/authorize`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async globalTokenRevocation(
    p: {
      requestBody: t_GlobalTokenRevocationRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<204, void> | Res<400, void> | Res<403, t_Error> | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/global-token-revocation`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async introspect(
    p: {
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_IntrospectionResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/introspect`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async oauthKeys(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_OAuthKeys> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({client_id: p["clientId"]})

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async logout(
    p: {
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, void> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/logout`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async logoutWithPost(
    p: {
      requestBody: t_LogoutWithPost
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, void> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/logout`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async oobAuthenticate(
    p: {
      requestBody: t_OobAuthenticateRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_OobAuthenticateResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<403, t_OAuthError>
    | Res<429, t_OAuthError>
  > {
    const url = this.basePath + `/oauth2/v1/oob-authenticate`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async parOptions(
    p: {
      origin?: string
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<204, void> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/par`
    const headers = this._headers(
      {Accept: "application/json", Origin: p["origin"]},
      opts.headers,
    )

    return this._fetch(url, {method: "OPTIONS", ...opts, headers}, timeout)
  }

  async par(
    p: {
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_ParResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<403, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/par`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async revoke(
    p: {
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, void>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/revoke`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async tokenOptions(
    p: {
      origin?: string
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<204, void> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/v1/token`
    const headers = this._headers(
      {Accept: "application/json", Origin: p["origin"]},
      opts.headers,
    )

    return this._fetch(url, {method: "OPTIONS", ...opts, headers}, timeout)
  }

  async token(
    p: {
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_TokenResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/token`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async userinfo(
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_UserInfo> | Res<401, void> | Res<403, void> | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/v1/userinfo`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(url, {method: "GET", ...opts, headers}, timeout)
  }

  async getWellKnownOAuthConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_OAuthMetadata> | Res<400, t_Error> | Res<404, t_Error>
  > {
    const url =
      this.basePath +
      `/oauth2/${p["authorizationServerId"]}/.well-known/oauth-authorization-server`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({client_id: p["clientId"]})

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async getWellKnownOpenIdConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_OidcMetadata> | Res<400, t_Error> | Res<404, t_Error>> {
    const url =
      this.basePath +
      `/oauth2/${p["authorizationServerId"]}/.well-known/openid-configuration`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({client_id: p["clientId"]})

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async authorizeCustomAs(
    p: {
      authorizationServerId: string
      acrValues?: t_AcrValue
      clientId: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri: string
      responseType: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope: string
      sessionToken?: string
      state: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<429, t_Error>> {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/authorize`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async authorizeCustomAsWithPost(
    p: {
      authorizationServerId: string
      requestBody: t_AuthorizeWithPost
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<429, t_Error>> {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/authorize`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async bcAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_BackchannelAuthorizeResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/bc/authorize`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async challengeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_ChallengeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_ChallengeResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<403, t_OAuthError>
    | Res<429, t_OAuthError>
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/challenge`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async deviceAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_DeviceAuthorizeResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url =
      this.basePath +
      `/oauth2/${p["authorizationServerId"]}/v1/device/authorize`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async introspectCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_IntrospectionResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/introspect`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async oauthKeysCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_OAuthKeys> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(url, {method: "GET", ...opts, headers}, timeout)
  }

  async logoutCustomAs(
    p: {
      authorizationServerId: string
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, void> | Res<429, t_Error>> {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/logout`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async logoutCustomAsWithPost(
    p: {
      authorizationServerId: string
      requestBody: t_LogoutWithPost
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, void> | Res<429, t_Error>> {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/logout`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async oobAuthenticateCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_OobAuthenticateRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_OobAuthenticateResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<403, t_OAuthError>
    | Res<429, t_OAuthError>
  > {
    const url =
      this.basePath +
      `/oauth2/${p["authorizationServerId"]}/v1/oob-authenticate`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async parOptionsCustomAs(
    p: {
      authorizationServerId: string
      origin?: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<204, void> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/par`
    const headers = this._headers(
      {Accept: "application/json", Origin: p["origin"]},
      opts.headers,
    )

    return this._fetch(url, {method: "OPTIONS", ...opts, headers}, timeout)
  }

  async parCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_ParResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<403, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/par`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async revokeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, void>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/revoke`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async tokenOptionsCustomAs(
    p: {
      authorizationServerId: string
      origin?: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<204, void> | Res<429, t_Error>> {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/token`
    const headers = this._headers(
      {Accept: "application/json", Origin: p["origin"]},
      opts.headers,
    )

    return this._fetch(url, {method: "OPTIONS", ...opts, headers}, timeout)
  }

  async tokenCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_TokenResponse>
    | Res<400, t_OAuthError>
    | Res<401, t_OAuthError>
    | Res<429, t_Error>
  > {
    const url = this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/token`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = p.requestBody
      ? this._requestBodyToUrlSearchParams(p.requestBody)
      : undefined

    return this._fetch(url, {method: "POST", body, ...opts, headers}, timeout)
  }

  async userinfoCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_UserInfo> | Res<401, void> | Res<403, void> | Res<429, t_Error>
  > {
    const url =
      this.basePath + `/oauth2/${p["authorizationServerId"]}/v1/userinfo`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(url, {method: "GET", ...opts, headers}, timeout)
  }
}

export {OktaOpenIdConnectOAuth20 as ApiClient}
export type {OktaOpenIdConnectOAuth20Config as ApiClientConfig}
