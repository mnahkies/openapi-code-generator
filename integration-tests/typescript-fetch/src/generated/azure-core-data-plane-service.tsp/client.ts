/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_Azure_Core_Foundations_Error,
  t_Azure_Core_Foundations_ErrorResponse,
  t_Azure_Core_uuid,
  t_Manufacturer,
  t_OperationState,
  t_PagedManufacturer,
  t_PagedWidget,
  t_PagedWidgetPart,
  t_Widget,
  t_WidgetAnalytics,
  t_WidgetAnalyticsCreateOrUpdate,
  t_WidgetCreateOrUpdate,
  t_WidgetPart,
  t_WidgetPartReorderRequest,
  t_WidgetRepairRequest,
  t_WidgetRepairState,
} from "./models"
import {
  AbstractFetchClient,
  AbstractFetchClientConfig,
  Res,
  StatusCode,
  TypedFetchResponse,
} from "@nahkies/typescript-fetch-runtime/main"

export interface ApiClientConfig extends AbstractFetchClientConfig {}

export class ApiClient extends AbstractFetchClient {
  constructor(config: ApiClientConfig) {
    super(config)
  }

  async serviceStatus(
    p: {
      apiVersion: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            statusString: string
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/service-status`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus(
    p: {
      apiVersion: string
      widgetName: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          | {
              error?: t_Azure_Core_Foundations_Error
              id: string
              result?: t_Widget
              status: t_OperationState
            }
          | {
              error?: t_Azure_Core_Foundations_Error
              id: string
              status: t_OperationState
            }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url =
      this.basePath +
      `/widgets/${p["widgetName"]}/operations/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetsCreateOrUpdateWidget(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetCreateOrUpdate
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_Widget>
      | Res<201, t_Widget>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        "Content-Type": "application/merge-patch+json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "PATCH", body, ...opts, headers },
      timeout,
    )
  }

  async widgetsGetWidget(
    p: {
      apiVersion: string
      widgetName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_Widget>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetsDeleteWidget(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          202,
          {
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_OperationState
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "DELETE", ...opts, headers },
      timeout,
    )
  }

  async widgetsListWidgets(
    p: {
      apiVersion: string
      top?: number
      skip?: number
      maxpagesize?: number
      select?: string[]
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_PagedWidget>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
      top: p["top"],
      skip: p["skip"],
      maxpagesize: p["maxpagesize"],
      select: p["select"],
    })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetsGetAnalytics(
    p: {
      apiVersion: string
      widgetName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_WidgetAnalytics>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/analytics/current`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetsUpdateAnalytics(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetAnalyticsCreateOrUpdate
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_WidgetAnalytics>
      | Res<201, t_WidgetAnalytics>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/analytics/current`
    const headers = this._headers(
      {
        "Content-Type": "application/merge-patch+json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "PATCH", body, ...opts, headers },
      timeout,
    )
  }

  async widgetsGetRepairStatus(
    p: {
      apiVersion: string
      widgetId: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_WidgetRepairRequest
            status: t_OperationState
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url =
      this.basePath + `/widgets/${p["widgetId"]}/repairs/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetsScheduleRepairs(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetRepairRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          202,
          {
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: {
              completedDateTime: string
              createdDateTime: string
              requestState: t_WidgetRepairState
              scheduledDateTime: string
              updatedDateTime: string
            }
            status: t_OperationState
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}:scheduleRepairs`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "POST", body, ...opts, headers },
      timeout,
    )
  }

  async widgetPartsGetWidgetPartOperationStatus(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_WidgetPart
            status: t_OperationState
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url =
      this.basePath +
      `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}/operations/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetPartsCreateWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetPart
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      Res<201, void> | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/parts`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "POST", body, ...opts, headers },
      timeout,
    )
  }

  async widgetPartsListWidgetParts(
    p: {
      apiVersion: string
      widgetName: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_PagedWidgetPart>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/parts`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetPartsGetWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_WidgetPart>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url =
      this.basePath + `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async widgetPartsDeleteWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url =
      this.basePath + `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}`
    const headers = this._headers(
      {
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "DELETE", ...opts, headers },
      timeout,
    )
  }

  async widgetPartsReorderParts(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetPartReorderRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          202,
          {
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_OperationState
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/parts:reorderParts`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "POST", body, ...opts, headers },
      timeout,
    )
  }

  async manufacturersGetManufacturerOperationStatus(
    p: {
      apiVersion: string
      manufacturerId: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          {
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_Manufacturer
            status: t_OperationState
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url =
      this.basePath +
      `/manufacturers/${p["manufacturerId"]}/operations/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async manufacturersCreateManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_Manufacturer
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_Manufacturer>
      | Res<201, t_Manufacturer>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      { method: "PUT", body, ...opts, headers },
      timeout,
    )
  }

  async manufacturersGetManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_Manufacturer>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }

  async manufacturersDeleteManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<
          202,
          {
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_OperationState
          }
        >
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "DELETE", ...opts, headers },
      timeout,
    )
  }

  async manufacturersListManufacturers(
    p: {
      apiVersion: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_PagedManufacturer>
      | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    >
  > {
    const url = this.basePath + `/manufacturers`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._fetch(
      url + query,
      { method: "GET", ...opts, headers },
      timeout,
    )
  }
}
