/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  AbstractFetchClient,
  type AbstractFetchClientConfig,
  type Res,
  type Server,
  type StatusCode,
} from "@nahkies/typescript-fetch-runtime/main"
import type {
  t_Azure_Core_Foundations_Error,
  t_Azure_Core_Foundations_ErrorResponse,
  t_Azure_Core_Foundations_OperationState,
  t_Azure_Core_uuid,
  t_Manufacturer,
  t_PagedManufacturer,
  t_PagedWidget,
  t_PagedWidgetPart,
  t_Widget,
  t_WidgetAnalytics,
  t_WidgetAnalyticsCreateOrUpdate,
  t_WidgetCreateOrUpdate,
  t_WidgetPart,
  t_WidgetPartReorderRequest,
  t_WidgetRepairRequest,
  t_WidgetRepairState,
} from "./models.ts"

export class ContosoWidgetManagerServers {
  static server(url: "{endpoint}/widget" = "{endpoint}/widget"): {
    build: (endpoint: string) => Server<"ContosoWidgetManager">
  } {
    switch (url) {
      case "{endpoint}/widget":
        return {
          build(endpoint): Server<"ContosoWidgetManager"> {
            return "{endpoint}/widget".replace(
              "{endpoint}",
              endpoint,
            ) as Server<"ContosoWidgetManager">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export interface ContosoWidgetManagerConfig extends AbstractFetchClientConfig {
  basePath: Server<"ContosoWidgetManager"> | string
}

export class ContosoWidgetManager extends AbstractFetchClient {
  constructor(config: ContosoWidgetManagerConfig) {
    super(config)
  }

  async getServiceStatus(
    p: {
      apiVersion: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          statusString: string
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/service-status`
    const headers = this._headers(
      {
        Accept: "application/json",
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus(
    p: {
      apiVersion: string
      widgetName: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        | {
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_Widget
            status: t_Azure_Core_Foundations_OperationState
          }
        | {
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_Azure_Core_Foundations_OperationState
          }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url =
      this.basePath +
      `/widgets/${p["widgetName"]}/operations/${p["operationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetsCreateOrUpdateWidget(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetCreateOrUpdate
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_Widget>
    | Res<201, t_Widget>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/merge-patch+json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      {method: "PATCH", body, ...opts, headers},
      timeout,
    )
  }

  async widgetsGetWidget(
    p: {
      apiVersion: string
      widgetName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_Widget> | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetsDeleteWidget(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        202,
        {
          error?: t_Azure_Core_Foundations_Error
          id: string
          status: t_Azure_Core_Foundations_OperationState
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(
      url + query,
      {method: "DELETE", ...opts, headers},
      timeout,
    )
  }

  async widgetsListWidgets(
    p: {
      apiVersion: string
      top?: number
      skip?: number
      maxpagesize?: number
      select?: string[]
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_PagedWidget>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets`
    const headers = this._headers(
      {
        Accept: "application/json",
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query(
      {
        "api-version": p["apiVersion"],
        top: p["top"],
        skip: p["skip"],
        maxpagesize: p["maxpagesize"],
        select: p["select"],
      },
      {
        select: {
          style: "form",
          explode: true,
        },
      },
    )

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetsGetAnalytics(
    p: {
      apiVersion: string
      widgetName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_WidgetAnalytics>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/analytics/current`
    const headers = this._headers(
      {
        Accept: "application/json",
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetsUpdateAnalytics(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetAnalyticsCreateOrUpdate
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_WidgetAnalytics>
    | Res<201, t_WidgetAnalytics>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/analytics/current`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/merge-patch+json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      {method: "PATCH", body, ...opts, headers},
      timeout,
    )
  }

  async widgetsGetRepairStatus(
    p: {
      apiVersion: string
      widgetId: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          error?: t_Azure_Core_Foundations_Error
          id: string
          result?: t_WidgetRepairRequest
          status: t_Azure_Core_Foundations_OperationState
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url =
      this.basePath + `/widgets/${p["widgetId"]}/repairs/${p["operationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetsScheduleRepairs(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetRepairRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        202,
        {
          error?: t_Azure_Core_Foundations_Error
          id: string
          result?: {
            completedDateTime: string
            createdDateTime: string
            requestState: t_WidgetRepairState
            scheduledDateTime: string
            updatedDateTime: string
          }
          status: t_Azure_Core_Foundations_OperationState
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}:scheduleRepairs`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      {method: "POST", body, ...opts, headers},
      timeout,
    )
  }

  async widgetPartsGetWidgetPartOperationStatus(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          error?: t_Azure_Core_Foundations_Error
          id: string
          result?: t_WidgetPart
          status: t_Azure_Core_Foundations_OperationState
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url =
      this.basePath +
      `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}/operations/${p["operationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetPartsCreateWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetPart
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<201, void> | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/parts`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      {method: "POST", body, ...opts, headers},
      timeout,
    )
  }

  async widgetPartsListWidgetParts(
    p: {
      apiVersion: string
      widgetName: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_PagedWidgetPart>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/parts`
    const headers = this._headers(
      {
        Accept: "application/json",
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetPartsGetWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_WidgetPart>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url =
      this.basePath + `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async widgetPartsDeleteWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<204, void> | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url =
      this.basePath + `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(
      url + query,
      {method: "DELETE", ...opts, headers},
      timeout,
    )
  }

  async widgetPartsReorderParts(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetPartReorderRequest
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        202,
        {
          error?: t_Azure_Core_Foundations_Error
          id: string
          status: t_Azure_Core_Foundations_OperationState
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/widgets/${p["widgetName"]}/parts:reorderParts`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      {method: "POST", body, ...opts, headers},
      timeout,
    )
  }

  async manufacturersGetManufacturerOperationStatus(
    p: {
      apiVersion: string
      manufacturerId: string
      operationId: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          error?: t_Azure_Core_Foundations_Error
          id: string
          result?: t_Manufacturer
          status: t_Azure_Core_Foundations_OperationState
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url =
      this.basePath +
      `/manufacturers/${p["manufacturerId"]}/operations/${p["operationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async manufacturersCreateOrReplaceManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_Manufacturer
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_Manufacturer>
    | Res<201, t_Manufacturer>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      {method: "PUT", body, ...opts, headers},
      timeout,
    )
  }

  async manufacturersGetManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_Manufacturer>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }

  async manufacturersDeleteManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        202,
        {
          error?: t_Azure_Core_Foundations_Error
          id: string
          status: t_Azure_Core_Foundations_OperationState
        }
      >
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(
      url + query,
      {method: "DELETE", ...opts, headers},
      timeout,
    )
  }

  async manufacturersListManufacturers(
    p: {
      apiVersion: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_PagedManufacturer>
    | Res<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  > {
    const url = this.basePath + `/manufacturers`
    const headers = this._headers(
      {
        Accept: "application/json",
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
    })

    return this._fetch(url + query, {method: "GET", ...opts, headers}, timeout)
  }
}

export {ContosoWidgetManager as ApiClient}
export type {ContosoWidgetManagerConfig as ApiClientConfig}
