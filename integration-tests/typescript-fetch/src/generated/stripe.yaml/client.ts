/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  UnknownEnumStringValue,
  t_account,
  t_account_link,
  t_account_session,
  t_apple_pay_domain,
  t_application_fee,
  t_apps_secret,
  t_balance,
  t_balance_transaction,
  t_bank_account,
  t_billing_alert,
  t_billing_credit_balance_summary,
  t_billing_credit_balance_transaction,
  t_billing_credit_grant,
  t_billing_meter,
  t_billing_meter_event,
  t_billing_meter_event_adjustment,
  t_billing_meter_event_summary,
  t_billing_portal_configuration,
  t_billing_portal_session,
  t_capability,
  t_card,
  t_cash_balance,
  t_charge,
  t_checkout_session,
  t_climate_order,
  t_climate_product,
  t_climate_supplier,
  t_confirmation_token,
  t_country_spec,
  t_coupon,
  t_credit_note,
  t_credit_note_line_item,
  t_customer,
  t_customer_balance_transaction,
  t_customer_cash_balance_transaction,
  t_customer_session,
  t_deleted_account,
  t_deleted_apple_pay_domain,
  t_deleted_coupon,
  t_deleted_customer,
  t_deleted_discount,
  t_deleted_external_account,
  t_deleted_invoice,
  t_deleted_invoiceitem,
  t_deleted_payment_source,
  t_deleted_person,
  t_deleted_plan,
  t_deleted_product,
  t_deleted_product_feature,
  t_deleted_radar_value_list,
  t_deleted_radar_value_list_item,
  t_deleted_subscription_item,
  t_deleted_tax_id,
  t_deleted_terminal_configuration,
  t_deleted_terminal_location,
  t_deleted_terminal_reader,
  t_deleted_test_helpers_test_clock,
  t_deleted_webhook_endpoint,
  t_discount,
  t_dispute,
  t_entitlements_active_entitlement,
  t_entitlements_feature,
  t_ephemeral_key,
  t_error,
  t_event,
  t_exchange_rate,
  t_external_account,
  t_fee_refund,
  t_file,
  t_file_link,
  t_financial_connections_account,
  t_financial_connections_account_owner,
  t_financial_connections_session,
  t_financial_connections_transaction,
  t_forwarding_request,
  t_funding_instructions,
  t_identity_verification_report,
  t_identity_verification_session,
  t_invoice,
  t_invoice_payment,
  t_invoice_rendering_template,
  t_invoiceitem,
  t_issuing_authorization,
  t_issuing_card,
  t_issuing_cardholder,
  t_issuing_dispute,
  t_issuing_personalization_design,
  t_issuing_physical_bundle,
  t_issuing_settlement,
  t_issuing_token,
  t_issuing_transaction,
  t_item,
  t_line_item,
  t_login_link,
  t_mandate,
  t_payment_intent,
  t_payment_link,
  t_payment_method,
  t_payment_method_configuration,
  t_payment_method_domain,
  t_payment_source,
  t_payout,
  t_person,
  t_plan,
  t_price,
  t_product,
  t_product_feature,
  t_promotion_code,
  t_quote,
  t_radar_early_fraud_warning,
  t_radar_value_list,
  t_radar_value_list_item,
  t_refund,
  t_reporting_report_run,
  t_reporting_report_type,
  t_review,
  t_scheduled_query_run,
  t_setup_attempt,
  t_setup_intent,
  t_shipping_rate,
  t_sigma_sigma_api_query,
  t_source,
  t_source_mandate_notification,
  t_source_transaction,
  t_subscription,
  t_subscription_item,
  t_subscription_schedule,
  t_tax_calculation,
  t_tax_calculation_line_item,
  t_tax_code,
  t_tax_id,
  t_tax_rate,
  t_tax_registration,
  t_tax_settings,
  t_tax_transaction,
  t_tax_transaction_line_item,
  t_terminal_configuration,
  t_terminal_connection_token,
  t_terminal_location,
  t_terminal_reader,
  t_test_helpers_test_clock,
  t_token,
  t_topup,
  t_transfer,
  t_transfer_reversal,
  t_treasury_credit_reversal,
  t_treasury_debit_reversal,
  t_treasury_financial_account,
  t_treasury_financial_account_features,
  t_treasury_inbound_transfer,
  t_treasury_outbound_payment,
  t_treasury_outbound_transfer,
  t_treasury_received_credit,
  t_treasury_received_debit,
  t_treasury_transaction,
  t_treasury_transaction_entry,
  t_webhook_endpoint,
} from "./models"
import {
  AbstractFetchClient,
  AbstractFetchClientConfig,
  Res,
  Server,
  StatusCode,
} from "@nahkies/typescript-fetch-runtime/main"

export class StripeApiServersOperations {
  static postFiles(
    url: "https://files.stripe.com/" = "https://files.stripe.com/",
  ): {build: () => Server<"postFiles_StripeApi">} {
    switch (url) {
      case "https://files.stripe.com/":
        return {
          build(): Server<"postFiles_StripeApi"> {
            return "https://files.stripe.com/" as Server<"postFiles_StripeApi">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }

  static getQuotesQuotePdf(
    url: "https://files.stripe.com/" = "https://files.stripe.com/",
  ): {build: () => Server<"getQuotesQuotePdf_StripeApi">} {
    switch (url) {
      case "https://files.stripe.com/":
        return {
          build(): Server<"getQuotesQuotePdf_StripeApi"> {
            return "https://files.stripe.com/" as Server<"getQuotesQuotePdf_StripeApi">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export class StripeApiServers {
  static default(): Server<"StripeApi"> {
    return StripeApiServers.server().build()
  }

  static server(url: "https://api.stripe.com/" = "https://api.stripe.com/"): {
    build: () => Server<"StripeApi">
  } {
    switch (url) {
      case "https://api.stripe.com/":
        return {
          build(): Server<"StripeApi"> {
            return "https://api.stripe.com/" as Server<"StripeApi">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }

  static readonly operations = StripeApiServersOperations
}

export interface StripeApiConfig extends AbstractFetchClientConfig {
  basePath: Server<"StripeApi"> | string
}

export class StripeApi extends AbstractFetchClient {
  constructor(config: StripeApiConfig) {
    super(config)
  }

  async getAccount(
    p: {
      expand?: string[]
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/account`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountLinks(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_account_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/account_links`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountSessions(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_account_session> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/account_sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccounts(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_account[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccounts(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteAccountsAccount(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccount(
    p: {
      account: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccount(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountBankAccounts(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_external_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}/bank_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteAccountsAccountBankAccountsId(
    p: {
      account: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_external_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountBankAccountsId(
    p: {
      account: string
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_external_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountBankAccountsId(
    p: {
      account: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_external_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountCapabilities(
    p: {
      account: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_capability[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/capabilities`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountCapabilitiesCapability(
    p: {
      account: string
      capability: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_capability> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/capabilities/${p["capability"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountCapabilitiesCapability(
    p: {
      account: string
      capability: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_capability> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/capabilities/${p["capability"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountExternalAccounts(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      object?: "bank_account" | "card" | UnknownEnumStringValue
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: (t_bank_account | t_card)[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/external_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      object: p["object"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountExternalAccounts(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_external_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}/external_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteAccountsAccountExternalAccountsId(
    p: {
      account: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_external_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/external_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountExternalAccountsId(
    p: {
      account: string
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_external_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/external_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountExternalAccountsId(
    p: {
      account: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_external_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/accounts/${p["account"]}/external_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountLoginLinks(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_login_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}/login_links`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountPeople(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      relationship?: {
        authorizer?: boolean
        director?: boolean
        executive?: boolean
        legal_guardian?: boolean
        owner?: boolean
        representative?: boolean
      }
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_person[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/people`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      relationship: p["relationship"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountPeople(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_person> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}/people`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteAccountsAccountPeoplePerson(
    p: {
      account: string
      person: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_person> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/people/${p["person"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountPeoplePerson(
    p: {
      account: string
      expand?: string[]
      person: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_person> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/people/${p["person"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountPeoplePerson(
    p: {
      account: string
      person: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_person> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/people/${p["person"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountPersons(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      relationship?: {
        authorizer?: boolean
        director?: boolean
        executive?: boolean
        legal_guardian?: boolean
        owner?: boolean
        representative?: boolean
      }
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_person[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/accounts/${p["account"]}/persons`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      relationship: p["relationship"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountPersons(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_person> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}/persons`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteAccountsAccountPersonsPerson(
    p: {
      account: string
      person: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_person> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/persons/${p["person"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAccountsAccountPersonsPerson(
    p: {
      account: string
      expand?: string[]
      person: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_person> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/persons/${p["person"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountPersonsPerson(
    p: {
      account: string
      person: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_person> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/accounts/${p["account"]}/persons/${p["person"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAccountsAccountReject(
    p: {
      account: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/accounts/${p["account"]}/reject`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getApplePayDomains(
    p: {
      domainName?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_apple_pay_domain[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/apple_pay/domains`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      domain_name: p["domainName"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postApplePayDomains(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_apple_pay_domain> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/apple_pay/domains`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteApplePayDomainsDomain(
    p: {
      domain: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_apple_pay_domain> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/apple_pay/domains/${p["domain"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getApplePayDomainsDomain(
    p: {
      domain: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_apple_pay_domain> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/apple_pay/domains/${p["domain"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getApplicationFees(
    p: {
      charge?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_application_fee[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/application_fees`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      charge: p["charge"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getApplicationFeesFeeRefundsId(
    p: {
      expand?: string[]
      fee: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_fee_refund> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/application_fees/${p["fee"]}/refunds/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postApplicationFeesFeeRefundsId(
    p: {
      fee: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_fee_refund> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/application_fees/${p["fee"]}/refunds/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getApplicationFeesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_application_fee> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/application_fees/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postApplicationFeesIdRefund(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_application_fee> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/application_fees/${p["id"]}/refund`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getApplicationFeesIdRefunds(
    p: {
      endingBefore?: string
      expand?: string[]
      id: string
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_fee_refund[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/application_fees/${p["id"]}/refunds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postApplicationFeesIdRefunds(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_fee_refund> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/application_fees/${p["id"]}/refunds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAppsSecrets(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      scope: {
        type: "account" | "user" | UnknownEnumStringValue
        user?: string
      }
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_apps_secret[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/apps/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      scope: p["scope"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAppsSecrets(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_apps_secret> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/apps/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postAppsSecretsDelete(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_apps_secret> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/apps/secrets/delete`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getAppsSecretsFind(
    p: {
      expand?: string[]
      name: string
      scope: {
        type: "account" | "user" | UnknownEnumStringValue
        user?: string
      }
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_apps_secret> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/apps/secrets/find`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      name: p["name"],
      scope: p["scope"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBalance(
    p: {
      expand?: string[]
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_balance> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/balance`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBalanceHistory(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      payout?: string
      source?: string
      startingAfter?: string
      type?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_balance_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/balance/history`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payout: p["payout"],
      source: p["source"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBalanceHistoryId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_balance_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/balance/history/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBalanceTransactions(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      payout?: string
      source?: string
      startingAfter?: string
      type?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_balance_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/balance_transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payout: p["payout"],
      source: p["source"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBalanceTransactionsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_balance_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/balance_transactions/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingAlerts(
    p: {
      alertType?: "usage_threshold" | UnknownEnumStringValue
      endingBefore?: string
      expand?: string[]
      limit?: number
      meter?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_billing_alert[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      alert_type: p["alertType"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      meter: p["meter"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingAlerts(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_alert> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingAlertsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_alert> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/alerts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingAlertsIdActivate(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_alert> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/alerts/${p["id"]}/activate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingAlertsIdArchive(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_alert> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/alerts/${p["id"]}/archive`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingAlertsIdDeactivate(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_alert> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/alerts/${p["id"]}/deactivate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingCreditBalanceSummary(
    p: {
      customer: string
      expand?: string[]
      filter: {
        applicability_scope?: {
          price_type?: "metered" | UnknownEnumStringValue
          prices?: {
            id: string
          }[]
        }
        credit_grant?: string
        type: "applicability_scope" | "credit_grant" | UnknownEnumStringValue
      }
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_billing_credit_balance_summary> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing/credit_balance_summary`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      customer: p["customer"],
      expand: p["expand"],
      filter: p["filter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingCreditBalanceTransactions(
    p: {
      creditGrant?: string
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_billing_credit_balance_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing/credit_balance_transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      credit_grant: p["creditGrant"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingCreditBalanceTransactionsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_billing_credit_balance_transaction> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/billing/credit_balance_transactions/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingCreditGrants(
    p: {
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_billing_credit_grant[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing/credit_grants`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingCreditGrants(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_credit_grant> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/credit_grants`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingCreditGrantsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_credit_grant> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/credit_grants/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingCreditGrantsId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_credit_grant> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/credit_grants/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingCreditGrantsIdExpire(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_credit_grant> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/credit_grants/${p["id"]}/expire`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingCreditGrantsIdVoid(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_credit_grant> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/credit_grants/${p["id"]}/void`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingMeterEventAdjustments(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_billing_meter_event_adjustment> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing/meter_event_adjustments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingMeterEvents(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_meter_event> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/meter_events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingMeters(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "active" | "inactive" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_billing_meter[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing/meters`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingMeters(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_meter> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/meters`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingMetersId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_meter> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/meters/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingMetersId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_meter> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/meters/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingMetersIdDeactivate(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_meter> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/meters/${p["id"]}/deactivate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingMetersIdEventSummaries(
    p: {
      customer: string
      endTime: number
      endingBefore?: string
      expand?: string[]
      id: string
      limit?: number
      startTime: number
      startingAfter?: string
      valueGroupingWindow?: "day" | "hour" | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_billing_meter_event_summary[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing/meters/${p["id"]}/event_summaries`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      customer: p["customer"],
      end_time: p["endTime"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      start_time: p["startTime"],
      starting_after: p["startingAfter"],
      value_grouping_window: p["valueGroupingWindow"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingMetersIdReactivate(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_meter> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing/meters/${p["id"]}/reactivate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingPortalConfigurations(
    p: {
      active?: boolean
      endingBefore?: string
      expand?: string[]
      isDefault?: boolean
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_billing_portal_configuration[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing_portal/configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      is_default: p["isDefault"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingPortalConfigurations(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_billing_portal_configuration> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/billing_portal/configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getBillingPortalConfigurationsConfiguration(
    p: {
      configuration: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_billing_portal_configuration> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/billing_portal/configurations/${p["configuration"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingPortalConfigurationsConfiguration(
    p: {
      configuration: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_billing_portal_configuration> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/billing_portal/configurations/${p["configuration"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postBillingPortalSessions(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_billing_portal_session> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/billing_portal/sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCharges(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      transferGroup?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_charge[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/charges`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
      transfer_group: p["transferGroup"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCharges(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_charge> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getChargesSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_charge[]
          has_more: boolean
          next_page?: string | null
          object: "search_result" | UnknownEnumStringValue
          total_count?: number
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/charges/search`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getChargesCharge(
    p: {
      charge: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_charge> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postChargesCharge(
    p: {
      charge: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_charge> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postChargesChargeCapture(
    p: {
      charge: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_charge> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}/capture`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getChargesChargeDispute(
    p: {
      charge: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}/dispute`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postChargesChargeDispute(
    p: {
      charge: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}/dispute`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postChargesChargeDisputeClose(
    p: {
      charge: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}/dispute/close`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postChargesChargeRefund(
    p: {
      charge: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_charge> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}/refund`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getChargesChargeRefunds(
    p: {
      charge: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_refund[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/charges/${p["charge"]}/refunds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postChargesChargeRefunds(
    p: {
      charge: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/charges/${p["charge"]}/refunds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getChargesChargeRefundsRefund(
    p: {
      charge: string
      expand?: string[]
      refund: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/charges/${p["charge"]}/refunds/${p["refund"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postChargesChargeRefundsRefund(
    p: {
      charge: string
      refund: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/charges/${p["charge"]}/refunds/${p["refund"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCheckoutSessions(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      customerDetails?: {
        email: string
      }
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      paymentLink?: string
      startingAfter?: string
      status?: "complete" | "expired" | "open" | UnknownEnumStringValue
      subscription?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_checkout_session[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/checkout/sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      customer_details: p["customerDetails"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      payment_link: p["paymentLink"],
      starting_after: p["startingAfter"],
      status: p["status"],
      subscription: p["subscription"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCheckoutSessions(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_checkout_session> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/checkout/sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCheckoutSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_checkout_session> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/checkout/sessions/${p["session"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCheckoutSessionsSession(
    p: {
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_checkout_session> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/checkout/sessions/${p["session"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCheckoutSessionsSessionExpire(
    p: {
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_checkout_session> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/checkout/sessions/${p["session"]}/expire`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCheckoutSessionsSessionLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      session: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/checkout/sessions/${p["session"]}/line_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getClimateOrders(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_climate_order[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/climate/orders`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postClimateOrders(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_climate_order> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/climate/orders`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getClimateOrdersOrder(
    p: {
      expand?: string[]
      order: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_climate_order> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/climate/orders/${p["order"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postClimateOrdersOrder(
    p: {
      order: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_climate_order> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/climate/orders/${p["order"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postClimateOrdersOrderCancel(
    p: {
      order: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_climate_order> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/climate/orders/${p["order"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getClimateProducts(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_climate_product[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/climate/products`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getClimateProductsProduct(
    p: {
      expand?: string[]
      product: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_climate_product> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/climate/products/${p["product"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getClimateSuppliers(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_climate_supplier[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/climate/suppliers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getClimateSuppliersSupplier(
    p: {
      expand?: string[]
      supplier: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_climate_supplier> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/climate/suppliers/${p["supplier"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getConfirmationTokensConfirmationToken(
    p: {
      confirmationToken: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_confirmation_token> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/confirmation_tokens/${p["confirmationToken"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCountrySpecs(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_country_spec[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/country_specs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCountrySpecsCountry(
    p: {
      country: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_country_spec> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/country_specs/${p["country"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCoupons(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_coupon[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/coupons`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCoupons(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_coupon> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/coupons`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCouponsCoupon(
    p: {
      coupon: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_coupon> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/coupons/${p["coupon"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCouponsCoupon(
    p: {
      coupon: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_coupon> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/coupons/${p["coupon"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCouponsCoupon(
    p: {
      coupon: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_coupon> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/coupons/${p["coupon"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCreditNotes(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      invoice?: string
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_credit_note[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/credit_notes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice: p["invoice"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCreditNotes(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_credit_note> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/credit_notes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCreditNotesPreview(
    p: {
      amount?: number
      creditAmount?: number
      effectiveAt?: number
      emailType?: "credit_note" | "none" | UnknownEnumStringValue
      expand?: string[]
      invoice: string
      lines?: {
        amount?: number
        description?: string
        invoice_line_item?: string
        quantity?: number
        tax_amounts?:
          | {
              amount: number
              tax_rate: string
              taxable_amount: number
            }[]
          | ""
          | UnknownEnumStringValue
        tax_rates?: string[] | "" | UnknownEnumStringValue
        type: "custom_line_item" | "invoice_line_item" | UnknownEnumStringValue
        unit_amount?: number
        unit_amount_decimal?: string
      }[]
      memo?: string
      metadata?: {
        [key: string]: string | undefined
      }
      outOfBandAmount?: number
      reason?:
        | "duplicate"
        | "fraudulent"
        | "order_change"
        | "product_unsatisfactory"
        | UnknownEnumStringValue
      refundAmount?: number
      refunds?: {
        amount_refunded?: number
        refund?: string
      }[]
      shippingCost?: {
        shipping_rate?: string
      }
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_credit_note> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/credit_notes/preview`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      amount: p["amount"],
      credit_amount: p["creditAmount"],
      effective_at: p["effectiveAt"],
      email_type: p["emailType"],
      expand: p["expand"],
      invoice: p["invoice"],
      lines: p["lines"],
      memo: p["memo"],
      metadata: p["metadata"],
      out_of_band_amount: p["outOfBandAmount"],
      reason: p["reason"],
      refund_amount: p["refundAmount"],
      refunds: p["refunds"],
      shipping_cost: p["shippingCost"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCreditNotesPreviewLines(
    p: {
      amount?: number
      creditAmount?: number
      effectiveAt?: number
      emailType?: "credit_note" | "none" | UnknownEnumStringValue
      endingBefore?: string
      expand?: string[]
      invoice: string
      limit?: number
      lines?: {
        amount?: number
        description?: string
        invoice_line_item?: string
        quantity?: number
        tax_amounts?:
          | {
              amount: number
              tax_rate: string
              taxable_amount: number
            }[]
          | ""
          | UnknownEnumStringValue
        tax_rates?: string[] | "" | UnknownEnumStringValue
        type: "custom_line_item" | "invoice_line_item" | UnknownEnumStringValue
        unit_amount?: number
        unit_amount_decimal?: string
      }[]
      memo?: string
      metadata?: {
        [key: string]: string | undefined
      }
      outOfBandAmount?: number
      reason?:
        | "duplicate"
        | "fraudulent"
        | "order_change"
        | "product_unsatisfactory"
        | UnknownEnumStringValue
      refundAmount?: number
      refunds?: {
        amount_refunded?: number
        refund?: string
      }[]
      shippingCost?: {
        shipping_rate?: string
      }
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_credit_note_line_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/credit_notes/preview/lines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      amount: p["amount"],
      credit_amount: p["creditAmount"],
      effective_at: p["effectiveAt"],
      email_type: p["emailType"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice: p["invoice"],
      limit: p["limit"],
      lines: p["lines"],
      memo: p["memo"],
      metadata: p["metadata"],
      out_of_band_amount: p["outOfBandAmount"],
      reason: p["reason"],
      refund_amount: p["refundAmount"],
      refunds: p["refunds"],
      shipping_cost: p["shippingCost"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCreditNotesCreditNoteLines(
    p: {
      creditNote: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_credit_note_line_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/credit_notes/${p["creditNote"]}/lines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCreditNotesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_credit_note> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/credit_notes/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCreditNotesId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_credit_note> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/credit_notes/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCreditNotesIdVoid(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_credit_note> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/credit_notes/${p["id"]}/void`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomerSessions(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_customer_session> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customer_sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomers(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      email?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      testClock?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_customer[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      email: p["email"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      test_clock: p["testClock"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomers(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_customer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_customer[]
          has_more: boolean
          next_page?: string | null
          object: "search_result" | UnknownEnumStringValue
          total_count?: number
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/search`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomer(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_customer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomer(
    p: {
      customer: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_customer | t_deleted_customer> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomer(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_customer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerBalanceTransactions(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_customer_balance_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/balance_transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerBalanceTransactions(
    p: {
      customer: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_customer_balance_transaction> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/balance_transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerBalanceTransactionsTransaction(
    p: {
      customer: string
      expand?: string[]
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_customer_balance_transaction> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/balance_transactions/${p["transaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerBalanceTransactionsTransaction(
    p: {
      customer: string
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_customer_balance_transaction> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/balance_transactions/${p["transaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerBankAccounts(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_bank_account[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/bank_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerBankAccounts(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_source> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/bank_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomerBankAccountsId(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_payment_source | t_deleted_payment_source>
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerBankAccountsId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_bank_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerBankAccountsId(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_card | t_bank_account | t_source> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerBankAccountsIdVerify(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_bank_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/bank_accounts/${p["id"]}/verify`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerCards(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_card[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cards`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerCards(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_source> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cards`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomerCardsId(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_payment_source | t_deleted_payment_source>
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cards/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerCardsId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_card> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cards/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerCardsId(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_card | t_bank_account | t_source> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cards/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerCashBalance(
    p: {
      customer: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_cash_balance> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cash_balance`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerCashBalance(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_cash_balance> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/cash_balance`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerCashBalanceTransactions(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_customer_cash_balance_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/cash_balance_transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerCashBalanceTransactionsTransaction(
    p: {
      customer: string
      expand?: string[]
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_customer_cash_balance_transaction> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/cash_balance_transactions/${p["transaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomerDiscount(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_discount> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/discount`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerDiscount(
    p: {
      customer: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_discount> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/discount`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerFundingInstructions(
    p: {
      customer: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_funding_instructions> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/funding_instructions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerPaymentMethods(
    p: {
      allowRedisplay?:
        | "always"
        | "limited"
        | "unspecified"
        | UnknownEnumStringValue
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?:
        | "acss_debit"
        | "affirm"
        | "afterpay_clearpay"
        | "alipay"
        | "alma"
        | "amazon_pay"
        | "au_becs_debit"
        | "bacs_debit"
        | "bancontact"
        | "billie"
        | "blik"
        | "boleto"
        | "card"
        | "cashapp"
        | "crypto"
        | "customer_balance"
        | "eps"
        | "fpx"
        | "giropay"
        | "grabpay"
        | "ideal"
        | "kakao_pay"
        | "klarna"
        | "konbini"
        | "kr_card"
        | "link"
        | "mobilepay"
        | "multibanco"
        | "naver_pay"
        | "nz_bank_account"
        | "oxxo"
        | "p24"
        | "pay_by_bank"
        | "payco"
        | "paynow"
        | "paypal"
        | "pix"
        | "promptpay"
        | "revolut_pay"
        | "samsung_pay"
        | "satispay"
        | "sepa_debit"
        | "sofort"
        | "swish"
        | "twint"
        | "us_bank_account"
        | "wechat_pay"
        | "zip"
        | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payment_method[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/payment_methods`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      allow_redisplay: p["allowRedisplay"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerPaymentMethodsPaymentMethod(
    p: {
      customer: string
      expand?: string[]
      paymentMethod: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/payment_methods/${p["paymentMethod"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerSources(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      object?: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: (t_bank_account | t_card | t_source)[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/sources`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      object: p["object"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerSources(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_source> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/sources`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomerSourcesId(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_payment_source | t_deleted_payment_source>
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerSourcesId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_source> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerSourcesId(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_card | t_bank_account | t_source> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerSourcesIdVerify(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_bank_account> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/sources/${p["id"]}/verify`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerSubscriptions(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_subscription[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/subscriptions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerSubscriptions(
    p: {
      customer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/subscriptions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomerSubscriptionsSubscriptionExposedId(
    p: {
      customer: string
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerSubscriptionsSubscriptionExposedId(
    p: {
      customer: string
      expand?: string[]
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerSubscriptionsSubscriptionExposedId(
    p: {
      customer: string
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
    p: {
      customer: string
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_discount> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}/discount`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
    p: {
      customer: string
      expand?: string[]
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_discount> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/customers/${p["customer"]}/subscriptions/${p["subscriptionExposedId"]}/discount`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerTaxIds(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_tax_id[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/customers/${p["customer"]}/tax_ids`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postCustomersCustomerTaxIds(
    p: {
      customer: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_id> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/customers/${p["customer"]}/tax_ids`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteCustomersCustomerTaxIdsId(
    p: {
      customer: string
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_tax_id> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/tax_ids/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getCustomersCustomerTaxIdsId(
    p: {
      customer: string
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_id> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/customers/${p["customer"]}/tax_ids/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getDisputes(
    p: {
      charge?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_dispute[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/disputes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      charge: p["charge"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getDisputesDispute(
    p: {
      dispute: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/disputes/${p["dispute"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postDisputesDispute(
    p: {
      dispute: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/disputes/${p["dispute"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postDisputesDisputeClose(
    p: {
      dispute: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/disputes/${p["dispute"]}/close`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getEntitlementsActiveEntitlements(
    p: {
      customer: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_entitlements_active_entitlement[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/entitlements/active_entitlements`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getEntitlementsActiveEntitlementsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_entitlements_active_entitlement> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/entitlements/active_entitlements/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getEntitlementsFeatures(
    p: {
      archived?: boolean
      endingBefore?: string
      expand?: string[]
      limit?: number
      lookupKey?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_entitlements_feature[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/entitlements/features`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      archived: p["archived"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      lookup_key: p["lookupKey"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postEntitlementsFeatures(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_entitlements_feature> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/entitlements/features`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getEntitlementsFeaturesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_entitlements_feature> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/entitlements/features/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postEntitlementsFeaturesId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_entitlements_feature> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/entitlements/features/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postEphemeralKeys(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_ephemeral_key> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/ephemeral_keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteEphemeralKeysKey(
    p: {
      key: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_ephemeral_key> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/ephemeral_keys/${p["key"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getEvents(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      deliverySuccess?: boolean
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?: string
      types?: string[]
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_event[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      delivery_success: p["deliverySuccess"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
      types: p["types"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getEventsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_event> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/events/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getExchangeRates(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_exchange_rate[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/exchange_rates`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getExchangeRatesRateId(
    p: {
      expand?: string[]
      rateId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_exchange_rate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/exchange_rates/${p["rateId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postExternalAccountsId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_external_account> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/external_accounts/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFileLinks(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      expired?: boolean
      file?: string
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_file_link[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/file_links`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      expired: p["expired"],
      file: p["file"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFileLinks(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_file_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/file_links`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFileLinksLink(
    p: {
      expand?: string[]
      link: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_file_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/file_links/${p["link"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFileLinksLink(
    p: {
      link: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_file_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/file_links/${p["link"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFiles(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      purpose?:
        | "account_requirement"
        | "additional_verification"
        | "business_icon"
        | "business_logo"
        | "customer_signature"
        | "dispute_evidence"
        | "document_provider_identity_document"
        | "finance_report_run"
        | "financial_account_statement"
        | "identity_document"
        | "identity_document_downloadable"
        | "issuing_regulatory_reporting"
        | "pci_document"
        | "selfie"
        | "sigma_scheduled_query"
        | "tax_document_user_upload"
        | "terminal_reader_splashscreen"
        | UnknownEnumStringValue
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_file[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/files`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      purpose: p["purpose"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFiles(
    p: {
      requestBody: never
    },
    basePath:
      | Server<"postFiles_StripeApi">
      | string = StripeApiServers.operations.postFiles().build(),
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_file> | Res<StatusCode, t_error>> {
    const url = basePath + `/v1/files`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'multipart/form-data' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFilesFile(
    p: {
      expand?: string[]
      file: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_file> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/files/${p["file"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFinancialConnectionsAccounts(
    p: {
      accountHolder?: {
        account?: string
        customer?: string
      }
      endingBefore?: string
      expand?: string[]
      limit?: number
      session?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_financial_connections_account[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/financial_connections/accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      account_holder: p["accountHolder"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      session: p["session"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFinancialConnectionsAccountsAccount(
    p: {
      account: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/financial_connections/accounts/${p["account"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFinancialConnectionsAccountsAccountDisconnect(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/disconnect`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFinancialConnectionsAccountsAccountOwners(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      ownership: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_financial_connections_account_owner[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/owners`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      ownership: p["ownership"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFinancialConnectionsAccountsAccountRefresh(
    p: {
      account: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/refresh`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFinancialConnectionsAccountsAccountSubscribe(
    p: {
      account: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/subscribe`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFinancialConnectionsAccountsAccountUnsubscribe(
    p: {
      account: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/accounts/${p["account"]}/unsubscribe`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postFinancialConnectionsSessions(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/financial_connections/sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFinancialConnectionsSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/financial_connections/sessions/${p["session"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFinancialConnectionsTransactions(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      transactedAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      transactionRefresh?: {
        after: string
      }
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_financial_connections_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/financial_connections/transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      account: p["account"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      transacted_at: p["transactedAt"],
      transaction_refresh: p["transactionRefresh"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getFinancialConnectionsTransactionsTransaction(
    p: {
      expand?: string[]
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_transaction> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/financial_connections/transactions/${p["transaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getForwardingRequests(
    p: {
      created?: {
        gt?: number
        gte?: number
        lt?: number
        lte?: number
      }
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_forwarding_request[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/forwarding/requests`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postForwardingRequests(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_forwarding_request> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/forwarding/requests`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getForwardingRequestsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_forwarding_request> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/forwarding/requests/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIdentityVerificationReports(
    p: {
      clientReferenceId?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?: "document" | "id_number" | UnknownEnumStringValue
      verificationSession?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_identity_verification_report[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/identity/verification_reports`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      client_reference_id: p["clientReferenceId"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
      verification_session: p["verificationSession"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIdentityVerificationReportsReport(
    p: {
      expand?: string[]
      report: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_identity_verification_report> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/identity/verification_reports/${p["report"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIdentityVerificationSessions(
    p: {
      clientReferenceId?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      relatedCustomer?: string
      startingAfter?: string
      status?:
        | "canceled"
        | "processing"
        | "requires_input"
        | "verified"
        | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_identity_verification_session[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/identity/verification_sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      client_reference_id: p["clientReferenceId"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      related_customer: p["relatedCustomer"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIdentityVerificationSessions(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/identity/verification_sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIdentityVerificationSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/identity/verification_sessions/${p["session"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIdentityVerificationSessionsSession(
    p: {
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/identity/verification_sessions/${p["session"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIdentityVerificationSessionsSessionCancel(
    p: {
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/identity/verification_sessions/${p["session"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIdentityVerificationSessionsSessionRedact(
    p: {
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_identity_verification_session> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/identity/verification_sessions/${p["session"]}/redact`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoicePayments(
    p: {
      endingBefore?: string
      expand?: string[]
      invoice?: string
      limit?: number
      payment?: {
        payment_intent?: string
        type: "payment_intent" | UnknownEnumStringValue
      }
      startingAfter?: string
      status?: "canceled" | "open" | "paid" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_invoice_payment[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/invoice_payments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice: p["invoice"],
      limit: p["limit"],
      payment: p["payment"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoicePaymentsInvoicePayment(
    p: {
      expand?: string[]
      invoicePayment: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice_payment> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoice_payments/${p["invoicePayment"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoiceRenderingTemplates(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "active" | "archived" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_invoice_rendering_template[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/invoice_rendering_templates`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoiceRenderingTemplatesTemplate(
    p: {
      expand?: string[]
      template: string
      version?: number
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_invoice_rendering_template> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/invoice_rendering_templates/${p["template"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"], version: p["version"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoiceRenderingTemplatesTemplateArchive(
    p: {
      template: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_invoice_rendering_template> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/invoice_rendering_templates/${p["template"]}/archive`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoiceRenderingTemplatesTemplateUnarchive(
    p: {
      template: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_invoice_rendering_template> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/invoice_rendering_templates/${p["template"]}/unarchive`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoiceitems(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      invoice?: string
      limit?: number
      pending?: boolean
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_invoiceitem[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/invoiceitems`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      invoice: p["invoice"],
      limit: p["limit"],
      pending: p["pending"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoiceitems(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoiceitem> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoiceitems`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteInvoiceitemsInvoiceitem(
    p: {
      invoiceitem: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_invoiceitem> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoiceitems/${p["invoiceitem"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoiceitemsInvoiceitem(
    p: {
      expand?: string[]
      invoiceitem: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoiceitem> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoiceitems/${p["invoiceitem"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoiceitemsInvoiceitem(
    p: {
      invoiceitem: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoiceitem> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoiceitems/${p["invoiceitem"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoices(
    p: {
      collectionMethod?:
        | "charge_automatically"
        | "send_invoice"
        | UnknownEnumStringValue
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      dueDate?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?:
        | "draft"
        | "open"
        | "paid"
        | "uncollectible"
        | "void"
        | UnknownEnumStringValue
      subscription?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_invoice[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/invoices`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      collection_method: p["collectionMethod"],
      created: p["created"],
      customer: p["customer"],
      due_date: p["dueDate"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      subscription: p["subscription"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoices(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesCreatePreview(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/create_preview`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoicesSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_invoice[]
          has_more: boolean
          next_page?: string | null
          object: "search_result" | UnknownEnumStringValue
          total_count?: number
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/invoices/search`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteInvoicesInvoice(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoicesInvoice(
    p: {
      expand?: string[]
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoice(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceAddLines(
    p: {
      invoice: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/add_lines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceAttachPayment(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/attach_payment`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceFinalize(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/finalize`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getInvoicesInvoiceLines(
    p: {
      endingBefore?: string
      expand?: string[]
      invoice: string
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_line_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/lines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceLinesLineItemId(
    p: {
      invoice: string
      lineItemId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_line_item> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/invoices/${p["invoice"]}/lines/${p["lineItemId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceMarkUncollectible(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/invoices/${p["invoice"]}/mark_uncollectible`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoicePay(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/pay`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceRemoveLines(
    p: {
      invoice: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/remove_lines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceSend(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/send`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceUpdateLines(
    p: {
      invoice: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/update_lines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postInvoicesInvoiceVoid(
    p: {
      invoice: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_invoice> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/invoices/${p["invoice"]}/void`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingAuthorizations(
    p: {
      card?: string
      cardholder?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?:
        | "closed"
        | "expired"
        | "pending"
        | "reversed"
        | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_authorization[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/authorizations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      card: p["card"],
      cardholder: p["cardholder"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingAuthorizationsAuthorization(
    p: {
      authorization: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingAuthorizationsAuthorization(
    p: {
      authorization: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingAuthorizationsAuthorizationApprove(
    p: {
      authorization: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}/approve`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingAuthorizationsAuthorizationDecline(
    p: {
      authorization: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/issuing/authorizations/${p["authorization"]}/decline`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingCardholders(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      email?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      phoneNumber?: string
      startingAfter?: string
      status?: "active" | "blocked" | "inactive" | UnknownEnumStringValue
      type?: "company" | "individual" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_cardholder[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/cardholders`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      email: p["email"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      phone_number: p["phoneNumber"],
      starting_after: p["startingAfter"],
      status: p["status"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingCardholders(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_cardholder> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/cardholders`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingCardholdersCardholder(
    p: {
      cardholder: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_cardholder> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/cardholders/${p["cardholder"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingCardholdersCardholder(
    p: {
      cardholder: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_cardholder> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/cardholders/${p["cardholder"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingCards(
    p: {
      cardholder?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expMonth?: number
      expYear?: number
      expand?: string[]
      last4?: string
      limit?: number
      personalizationDesign?: string
      startingAfter?: string
      status?: "active" | "canceled" | "inactive" | UnknownEnumStringValue
      type?: "physical" | "virtual" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_card[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/cards`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      cardholder: p["cardholder"],
      created: p["created"],
      ending_before: p["endingBefore"],
      exp_month: p["expMonth"],
      exp_year: p["expYear"],
      expand: p["expand"],
      last4: p["last4"],
      limit: p["limit"],
      personalization_design: p["personalizationDesign"],
      starting_after: p["startingAfter"],
      status: p["status"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingCards(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/cards`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingCardsCard(
    p: {
      card: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/cards/${p["card"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingCardsCard(
    p: {
      card: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/cards/${p["card"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingDisputes(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?:
        | "expired"
        | "lost"
        | "submitted"
        | "unsubmitted"
        | "won"
        | UnknownEnumStringValue
      transaction?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_dispute[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/disputes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      transaction: p["transaction"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingDisputes(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/disputes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingDisputesDispute(
    p: {
      dispute: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/disputes/${p["dispute"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingDisputesDispute(
    p: {
      dispute: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/disputes/${p["dispute"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingDisputesDisputeSubmit(
    p: {
      dispute: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_dispute> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/disputes/${p["dispute"]}/submit`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingPersonalizationDesigns(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      lookupKeys?: string[]
      preferences?: {
        is_default?: boolean
        is_platform_default?: boolean
      }
      startingAfter?: string
      status?:
        | "active"
        | "inactive"
        | "rejected"
        | "review"
        | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_personalization_design[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/personalization_designs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      lookup_keys: p["lookupKeys"],
      preferences: p["preferences"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingPersonalizationDesigns(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_issuing_personalization_design> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/personalization_designs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingPersonalizationDesignsPersonalizationDesign(
    p: {
      expand?: string[]
      personalizationDesign: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_issuing_personalization_design> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/issuing/personalization_designs/${p["personalizationDesign"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingPersonalizationDesignsPersonalizationDesign(
    p: {
      personalizationDesign: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_issuing_personalization_design> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/issuing/personalization_designs/${p["personalizationDesign"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingPhysicalBundles(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "active" | "inactive" | "review" | UnknownEnumStringValue
      type?: "custom" | "standard" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_physical_bundle[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/physical_bundles`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingPhysicalBundlesPhysicalBundle(
    p: {
      expand?: string[]
      physicalBundle: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_physical_bundle> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/issuing/physical_bundles/${p["physicalBundle"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingSettlementsSettlement(
    p: {
      expand?: string[]
      settlement: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_settlement> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/settlements/${p["settlement"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingSettlementsSettlement(
    p: {
      settlement: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_settlement> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/settlements/${p["settlement"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingTokens(
    p: {
      card: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?:
        | "active"
        | "deleted"
        | "requested"
        | "suspended"
        | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_token[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/tokens`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      card: p["card"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingTokensToken(
    p: {
      expand?: string[]
      token: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_token> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/tokens/${p["token"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingTokensToken(
    p: {
      token: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_token> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/tokens/${p["token"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingTransactions(
    p: {
      card?: string
      cardholder?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?: "capture" | "refund" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_issuing_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/issuing/transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      card: p["card"],
      cardholder: p["cardholder"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getIssuingTransactionsTransaction(
    p: {
      expand?: string[]
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/transactions/${p["transaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postIssuingTransactionsTransaction(
    p: {
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/issuing/transactions/${p["transaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postLinkAccountSessions(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/link_account_sessions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getLinkAccountSessionsSession(
    p: {
      expand?: string[]
      session: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_session> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/link_account_sessions/${p["session"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getLinkedAccounts(
    p: {
      accountHolder?: {
        account?: string
        customer?: string
      }
      endingBefore?: string
      expand?: string[]
      limit?: number
      session?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_financial_connections_account[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/linked_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      account_holder: p["accountHolder"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      session: p["session"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getLinkedAccountsAccount(
    p: {
      account: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postLinkedAccountsAccountDisconnect(
    p: {
      account: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}/disconnect`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getLinkedAccountsAccountOwners(
    p: {
      account: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      ownership: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_financial_connections_account_owner[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}/owners`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      ownership: p["ownership"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postLinkedAccountsAccountRefresh(
    p: {
      account: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_financial_connections_account> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/linked_accounts/${p["account"]}/refresh`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getMandatesMandate(
    p: {
      expand?: string[]
      mandate: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_mandate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/mandates/${p["mandate"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentIntents(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payment_intent[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payment_intents`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntents(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_intents`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentIntentsSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payment_intent[]
          has_more: boolean
          next_page?: string | null
          object: "search_result" | UnknownEnumStringValue
          total_count?: number
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payment_intents/search`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentIntentsIntent(
    p: {
      clientSecret?: string
      expand?: string[]
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      client_secret: p["clientSecret"],
      expand: p["expand"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntentsIntent(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntentsIntentApplyCustomerBalance(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/payment_intents/${p["intent"]}/apply_customer_balance`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntentsIntentCancel(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntentsIntentCapture(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}/capture`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntentsIntentConfirm(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_intents/${p["intent"]}/confirm`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntentsIntentIncrementAuthorization(
    p: {
      intent: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/payment_intents/${p["intent"]}/increment_authorization`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentIntentsIntentVerifyMicrodeposits(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_intent> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/payment_intents/${p["intent"]}/verify_microdeposits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentLinks(
    p: {
      active?: boolean
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payment_link[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payment_links`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentLinks(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_links`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentLinksPaymentLink(
    p: {
      expand?: string[]
      paymentLink: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_links/${p["paymentLink"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentLinksPaymentLink(
    p: {
      paymentLink: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_link> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_links/${p["paymentLink"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentLinksPaymentLinkLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentLink: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/payment_links/${p["paymentLink"]}/line_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentMethodConfigurations(
    p: {
      application?: string | "" | UnknownEnumStringValue
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payment_method_configuration[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payment_method_configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      application: p["application"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodConfigurations(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_payment_method_configuration> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payment_method_configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentMethodConfigurationsConfiguration(
    p: {
      configuration: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_payment_method_configuration> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/payment_method_configurations/${p["configuration"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodConfigurationsConfiguration(
    p: {
      configuration: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_payment_method_configuration> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/payment_method_configurations/${p["configuration"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentMethodDomains(
    p: {
      domainName?: string
      enabled?: boolean
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payment_method_domain[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payment_method_domains`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      domain_name: p["domainName"],
      enabled: p["enabled"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodDomains(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method_domain> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_method_domains`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentMethodDomainsPaymentMethodDomain(
    p: {
      expand?: string[]
      paymentMethodDomain: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method_domain> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/payment_method_domains/${p["paymentMethodDomain"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodDomainsPaymentMethodDomain(
    p: {
      paymentMethodDomain: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method_domain> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/payment_method_domains/${p["paymentMethodDomain"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodDomainsPaymentMethodDomainValidate(
    p: {
      paymentMethodDomain: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method_domain> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/payment_method_domains/${p["paymentMethodDomain"]}/validate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentMethods(
    p: {
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      type?:
        | "acss_debit"
        | "affirm"
        | "afterpay_clearpay"
        | "alipay"
        | "alma"
        | "amazon_pay"
        | "au_becs_debit"
        | "bacs_debit"
        | "bancontact"
        | "billie"
        | "blik"
        | "boleto"
        | "card"
        | "cashapp"
        | "crypto"
        | "customer_balance"
        | "eps"
        | "fpx"
        | "giropay"
        | "grabpay"
        | "ideal"
        | "kakao_pay"
        | "klarna"
        | "konbini"
        | "kr_card"
        | "link"
        | "mobilepay"
        | "multibanco"
        | "naver_pay"
        | "nz_bank_account"
        | "oxxo"
        | "p24"
        | "pay_by_bank"
        | "payco"
        | "paynow"
        | "paypal"
        | "pix"
        | "promptpay"
        | "revolut_pay"
        | "samsung_pay"
        | "satispay"
        | "sepa_debit"
        | "sofort"
        | "swish"
        | "twint"
        | "us_bank_account"
        | "wechat_pay"
        | "zip"
        | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payment_method[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payment_methods`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethods(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_methods`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPaymentMethodsPaymentMethod(
    p: {
      expand?: string[]
      paymentMethod: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_methods/${p["paymentMethod"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodsPaymentMethod(
    p: {
      paymentMethod: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payment_methods/${p["paymentMethod"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodsPaymentMethodAttach(
    p: {
      paymentMethod: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/payment_methods/${p["paymentMethod"]}/attach`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPaymentMethodsPaymentMethodDetach(
    p: {
      paymentMethod: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payment_method> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/payment_methods/${p["paymentMethod"]}/detach`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPayouts(
    p: {
      arrivalDate?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      destination?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_payout[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/payouts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      arrival_date: p["arrivalDate"],
      created: p["created"],
      destination: p["destination"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPayouts(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payout> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payouts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPayoutsPayout(
    p: {
      expand?: string[]
      payout: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payout> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payouts/${p["payout"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPayoutsPayout(
    p: {
      payout: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payout> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payouts/${p["payout"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPayoutsPayoutCancel(
    p: {
      payout: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payout> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payouts/${p["payout"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPayoutsPayoutReverse(
    p: {
      payout: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_payout> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/payouts/${p["payout"]}/reverse`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPlans(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      product?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_plan[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/plans`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      product: p["product"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPlans(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_plan> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/plans`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deletePlansPlan(
    p: {
      plan: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_plan> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/plans/${p["plan"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPlansPlan(
    p: {
      expand?: string[]
      plan: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_plan> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/plans/${p["plan"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPlansPlan(
    p: {
      plan: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_plan> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/plans/${p["plan"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPrices(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      lookupKeys?: string[]
      product?: string
      recurring?: {
        interval?: "day" | "month" | "week" | "year" | UnknownEnumStringValue
        meter?: string
        usage_type?: "licensed" | "metered" | UnknownEnumStringValue
      }
      startingAfter?: string
      type?: "one_time" | "recurring" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_price[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/prices`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      lookup_keys: p["lookupKeys"],
      product: p["product"],
      recurring: p["recurring"],
      starting_after: p["startingAfter"],
      type: p["type"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPrices(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_price> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/prices`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPricesSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_price[]
          has_more: boolean
          next_page?: string | null
          object: "search_result" | UnknownEnumStringValue
          total_count?: number
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/prices/search`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPricesPrice(
    p: {
      expand?: string[]
      price: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_price> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/prices/${p["price"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPricesPrice(
    p: {
      price: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_price> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/prices/${p["price"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getProducts(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      ids?: string[]
      limit?: number
      shippable?: boolean
      startingAfter?: string
      url?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_product[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/products`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      ids: p["ids"],
      limit: p["limit"],
      shippable: p["shippable"],
      starting_after: p["startingAfter"],
      url: p["url"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postProducts(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_product> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/products`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getProductsSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_product[]
          has_more: boolean
          next_page?: string | null
          object: "search_result" | UnknownEnumStringValue
          total_count?: number
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/products/search`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteProductsId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_product> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/products/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getProductsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_product> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/products/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postProductsId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_product> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/products/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getProductsProductFeatures(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      product: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_product_feature[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/products/${p["product"]}/features`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postProductsProductFeatures(
    p: {
      product: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_product_feature> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/products/${p["product"]}/features`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteProductsProductFeaturesId(
    p: {
      id: string
      product: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_product_feature> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/products/${p["product"]}/features/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getProductsProductFeaturesId(
    p: {
      expand?: string[]
      id: string
      product: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_product_feature> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/products/${p["product"]}/features/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPromotionCodes(
    p: {
      active?: boolean
      code?: string
      coupon?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_promotion_code[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/promotion_codes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      code: p["code"],
      coupon: p["coupon"],
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPromotionCodes(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_promotion_code> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/promotion_codes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getPromotionCodesPromotionCode(
    p: {
      expand?: string[]
      promotionCode: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_promotion_code> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/promotion_codes/${p["promotionCode"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postPromotionCodesPromotionCode(
    p: {
      promotionCode: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_promotion_code> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/promotion_codes/${p["promotionCode"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getQuotes(
    p: {
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?:
        | "accepted"
        | "canceled"
        | "draft"
        | "open"
        | UnknownEnumStringValue
      testClock?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_quote[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/quotes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
      test_clock: p["testClock"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postQuotes(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_quote> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/quotes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getQuotesQuote(
    p: {
      expand?: string[]
      quote: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_quote> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postQuotesQuote(
    p: {
      quote: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_quote> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postQuotesQuoteAccept(
    p: {
      quote: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_quote> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/accept`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postQuotesQuoteCancel(
    p: {
      quote: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_quote> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getQuotesQuoteComputedUpfrontLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      quote: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/quotes/${p["quote"]}/computed_upfront_line_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postQuotesQuoteFinalize(
    p: {
      quote: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_quote> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/finalize`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getQuotesQuoteLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      quote: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/quotes/${p["quote"]}/line_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getQuotesQuotePdf(
    p: {
      expand?: string[]
      quote: string
      requestBody?: never
    },
    basePath:
      | Server<"getQuotesQuotePdf_StripeApi">
      | string = StripeApiServers.operations.getQuotesQuotePdf().build(),
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, string> | Res<StatusCode, t_error>> {
    const url = basePath + `/v1/quotes/${p["quote"]}/pdf`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRadarEarlyFraudWarnings(
    p: {
      charge?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_radar_early_fraud_warning[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/radar/early_fraud_warnings`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      charge: p["charge"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRadarEarlyFraudWarningsEarlyFraudWarning(
    p: {
      earlyFraudWarning: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_radar_early_fraud_warning> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/radar/early_fraud_warnings/${p["earlyFraudWarning"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRadarValueListItems(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      value?: string
      valueList: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_radar_value_list_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/radar/value_list_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      value: p["value"],
      value_list: p["valueList"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postRadarValueListItems(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_radar_value_list_item> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/radar/value_list_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteRadarValueListItemsItem(
    p: {
      item: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_deleted_radar_value_list_item> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/radar/value_list_items/${p["item"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRadarValueListItemsItem(
    p: {
      expand?: string[]
      item: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_radar_value_list_item> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/radar/value_list_items/${p["item"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRadarValueLists(
    p: {
      alias?: string
      contains?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_radar_value_list[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/radar/value_lists`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      alias: p["alias"],
      contains: p["contains"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postRadarValueLists(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_radar_value_list> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/radar/value_lists`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteRadarValueListsValueList(
    p: {
      valueList: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_radar_value_list> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/radar/value_lists/${p["valueList"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRadarValueListsValueList(
    p: {
      expand?: string[]
      valueList: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_radar_value_list> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/radar/value_lists/${p["valueList"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postRadarValueListsValueList(
    p: {
      valueList: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_radar_value_list> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/radar/value_lists/${p["valueList"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRefunds(
    p: {
      charge?: string
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentIntent?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_refund[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/refunds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      charge: p["charge"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_intent: p["paymentIntent"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postRefunds(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/refunds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getRefundsRefund(
    p: {
      expand?: string[]
      refund: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/refunds/${p["refund"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postRefundsRefund(
    p: {
      refund: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/refunds/${p["refund"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postRefundsRefundCancel(
    p: {
      refund: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/refunds/${p["refund"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getReportingReportRuns(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_reporting_report_run[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/reporting/report_runs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postReportingReportRuns(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_reporting_report_run> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/reporting/report_runs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getReportingReportRunsReportRun(
    p: {
      expand?: string[]
      reportRun: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_reporting_report_run> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/reporting/report_runs/${p["reportRun"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getReportingReportTypes(
    p: {
      expand?: string[]
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_reporting_report_type[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/reporting/report_types`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getReportingReportTypesReportType(
    p: {
      expand?: string[]
      reportType: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_reporting_report_type> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/reporting/report_types/${p["reportType"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getReviews(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_review[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/reviews`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getReviewsReview(
    p: {
      expand?: string[]
      review: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_review> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/reviews/${p["review"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postReviewsReviewApprove(
    p: {
      review: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_review> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/reviews/${p["review"]}/approve`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSetupAttempts(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      setupIntent: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_setup_attempt[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/setup_attempts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      setup_intent: p["setupIntent"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSetupIntents(
    p: {
      attachToSelf?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      paymentMethod?: string
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_setup_intent[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/setup_intents`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      attach_to_self: p["attachToSelf"],
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      payment_method: p["paymentMethod"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSetupIntents(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_setup_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/setup_intents`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSetupIntentsIntent(
    p: {
      clientSecret?: string
      expand?: string[]
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_setup_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      client_secret: p["clientSecret"],
      expand: p["expand"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSetupIntentsIntent(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_setup_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSetupIntentsIntentCancel(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_setup_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSetupIntentsIntentConfirm(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_setup_intent> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/setup_intents/${p["intent"]}/confirm`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSetupIntentsIntentVerifyMicrodeposits(
    p: {
      intent: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_setup_intent> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/setup_intents/${p["intent"]}/verify_microdeposits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getShippingRates(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currency?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_shipping_rate[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/shipping_rates`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      created: p["created"],
      currency: p["currency"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postShippingRates(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_shipping_rate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/shipping_rates`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getShippingRatesShippingRateToken(
    p: {
      expand?: string[]
      shippingRateToken: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_shipping_rate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/shipping_rates/${p["shippingRateToken"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postShippingRatesShippingRateToken(
    p: {
      shippingRateToken: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_shipping_rate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/shipping_rates/${p["shippingRateToken"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSigmaSavedQueriesId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_sigma_sigma_api_query> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/sigma/saved_queries/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSigmaScheduledQueryRuns(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_scheduled_query_run[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/sigma/scheduled_query_runs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSigmaScheduledQueryRunsScheduledQueryRun(
    p: {
      expand?: string[]
      scheduledQueryRun: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_scheduled_query_run> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/sigma/scheduled_query_runs/${p["scheduledQueryRun"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSources(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_source> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/sources`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSourcesSource(
    p: {
      clientSecret?: string
      expand?: string[]
      source: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_source> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/sources/${p["source"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      client_secret: p["clientSecret"],
      expand: p["expand"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSourcesSource(
    p: {
      source: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_source> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/sources/${p["source"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSourcesSourceMandateNotificationsMandateNotification(
    p: {
      expand?: string[]
      mandateNotification: string
      source: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_source_mandate_notification> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/sources/${p["source"]}/mandate_notifications/${p["mandateNotification"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSourcesSourceSourceTransactions(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      source: string
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_source_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/sources/${p["source"]}/source_transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSourcesSourceSourceTransactionsSourceTransaction(
    p: {
      expand?: string[]
      source: string
      sourceTransaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_source_transaction> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/sources/${p["source"]}/source_transactions/${p["sourceTransaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSourcesSourceVerify(
    p: {
      source: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_source> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/sources/${p["source"]}/verify`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSubscriptionItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      subscription: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_subscription_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/subscription_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      subscription: p["subscription"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionItems(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_item> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscription_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteSubscriptionItemsItem(
    p: {
      item: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_subscription_item> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscription_items/${p["item"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSubscriptionItemsItem(
    p: {
      expand?: string[]
      item: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_item> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscription_items/${p["item"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionItemsItem(
    p: {
      item: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_item> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscription_items/${p["item"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSubscriptionSchedules(
    p: {
      canceledAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      completedAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      releasedAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      scheduled?: boolean
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_subscription_schedule[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/subscription_schedules`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      canceled_at: p["canceledAt"],
      completed_at: p["completedAt"],
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      released_at: p["releasedAt"],
      scheduled: p["scheduled"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionSchedules(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_schedule> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscription_schedules`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSubscriptionSchedulesSchedule(
    p: {
      expand?: string[]
      schedule: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_schedule> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscription_schedules/${p["schedule"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionSchedulesSchedule(
    p: {
      schedule: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_schedule> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscription_schedules/${p["schedule"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionSchedulesScheduleCancel(
    p: {
      schedule: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_schedule> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/subscription_schedules/${p["schedule"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionSchedulesScheduleRelease(
    p: {
      schedule: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription_schedule> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/subscription_schedules/${p["schedule"]}/release`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSubscriptions(
    p: {
      automaticTax?: {
        enabled: boolean
      }
      collectionMethod?:
        | "charge_automatically"
        | "send_invoice"
        | UnknownEnumStringValue
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currentPeriodEnd?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      currentPeriodStart?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      price?: string
      startingAfter?: string
      status?:
        | "active"
        | "all"
        | "canceled"
        | "ended"
        | "incomplete"
        | "incomplete_expired"
        | "past_due"
        | "paused"
        | "trialing"
        | "unpaid"
        | UnknownEnumStringValue
      testClock?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_subscription[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/subscriptions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      automatic_tax: p["automaticTax"],
      collection_method: p["collectionMethod"],
      created: p["created"],
      current_period_end: p["currentPeriodEnd"],
      current_period_start: p["currentPeriodStart"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      price: p["price"],
      starting_after: p["startingAfter"],
      status: p["status"],
      test_clock: p["testClock"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptions(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscriptions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSubscriptionsSearch(
    p: {
      expand?: string[]
      limit?: number
      page?: string
      query: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_subscription[]
          has_more: boolean
          next_page?: string | null
          object: "search_result" | UnknownEnumStringValue
          total_count?: number
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/subscriptions/search`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      expand: p["expand"],
      limit: p["limit"],
      page: p["page"],
      query: p["query"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteSubscriptionsSubscriptionExposedId(
    p: {
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getSubscriptionsSubscriptionExposedId(
    p: {
      expand?: string[]
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionsSubscriptionExposedId(
    p: {
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteSubscriptionsSubscriptionExposedIdDiscount(
    p: {
      subscriptionExposedId: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_discount> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/subscriptions/${p["subscriptionExposedId"]}/discount`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionsSubscriptionMigrate(
    p: {
      subscription: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscriptions/${p["subscription"]}/migrate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postSubscriptionsSubscriptionResume(
    p: {
      subscription: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_subscription> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/subscriptions/${p["subscription"]}/resume`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxCalculations(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_calculation> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/calculations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxCalculationsCalculation(
    p: {
      calculation: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_calculation> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/calculations/${p["calculation"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxCalculationsCalculationLineItems(
    p: {
      calculation: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_tax_calculation_line_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/tax/calculations/${p["calculation"]}/line_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxRegistrations(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?:
        | "active"
        | "all"
        | "expired"
        | "scheduled"
        | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_tax_registration[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/tax/registrations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxRegistrations(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_registration> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/registrations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxRegistrationsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_registration> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/registrations/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxRegistrationsId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_registration> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/registrations/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxSettings(
    p: {
      expand?: string[]
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_settings> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/settings`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxSettings(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_settings> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/settings`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxTransactionsCreateFromCalculation(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/transactions/create_from_calculation`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxTransactionsCreateReversal(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/transactions/create_reversal`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxTransactionsTransaction(
    p: {
      expand?: string[]
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax/transactions/${p["transaction"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxTransactionsTransactionLineItems(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_tax_transaction_line_item[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/tax/transactions/${p["transaction"]}/line_items`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxCodes(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_tax_code[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/tax_codes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxCodesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_code> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax_codes/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxIds(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      owner?: {
        account?: string
        customer?: string
        type:
          | "account"
          | "application"
          | "customer"
          | "self"
          | UnknownEnumStringValue
      }
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_tax_id[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/tax_ids`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      owner: p["owner"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxIds(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_id> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax_ids`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteTaxIdsId(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_tax_id> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax_ids/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxIdsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_id> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax_ids/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxRates(
    p: {
      active?: boolean
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      inclusive?: boolean
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_tax_rate[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/tax_rates`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      active: p["active"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      inclusive: p["inclusive"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxRates(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_rate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax_rates`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTaxRatesTaxRate(
    p: {
      expand?: string[]
      taxRate: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_rate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax_rates/${p["taxRate"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTaxRatesTaxRate(
    p: {
      taxRate: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_tax_rate> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tax_rates/${p["taxRate"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTerminalConfigurations(
    p: {
      endingBefore?: string
      expand?: string[]
      isAccountDefault?: boolean
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_terminal_configuration[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/terminal/configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      is_account_default: p["isAccountDefault"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalConfigurations(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_configuration> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/terminal/configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteTerminalConfigurationsConfiguration(
    p: {
      configuration: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_deleted_terminal_configuration> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/terminal/configurations/${p["configuration"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTerminalConfigurationsConfiguration(
    p: {
      configuration: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_terminal_configuration | t_deleted_terminal_configuration>
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/terminal/configurations/${p["configuration"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalConfigurationsConfiguration(
    p: {
      configuration: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_terminal_configuration | t_deleted_terminal_configuration>
    | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/terminal/configurations/${p["configuration"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalConnectionTokens(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_connection_token> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/terminal/connection_tokens`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTerminalLocations(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_terminal_location[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/terminal/locations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalLocations(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_location> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/terminal/locations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteTerminalLocationsLocation(
    p: {
      location: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_terminal_location> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/terminal/locations/${p["location"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTerminalLocationsLocation(
    p: {
      expand?: string[]
      location: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_terminal_location | t_deleted_terminal_location>
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/terminal/locations/${p["location"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalLocationsLocation(
    p: {
      location: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_terminal_location | t_deleted_terminal_location>
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/terminal/locations/${p["location"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTerminalReaders(
    p: {
      deviceType?:
        | "bbpos_chipper2x"
        | "bbpos_wisepad3"
        | "bbpos_wisepos_e"
        | "mobile_phone_reader"
        | "simulated_stripe_s700"
        | "simulated_wisepos_e"
        | "stripe_m2"
        | "stripe_s700"
        | "verifone_P400"
        | UnknownEnumStringValue
      endingBefore?: string
      expand?: string[]
      limit?: number
      location?: string
      serialNumber?: string
      startingAfter?: string
      status?: "offline" | "online" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_terminal_reader[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/terminal/readers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      device_type: p["deviceType"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      location: p["location"],
      serial_number: p["serialNumber"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReaders(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/terminal/readers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteTerminalReadersReader(
    p: {
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_terminal_reader> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/terminal/readers/${p["reader"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTerminalReadersReader(
    p: {
      expand?: string[]
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_terminal_reader | t_deleted_terminal_reader>
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/terminal/readers/${p["reader"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReader(
    p: {
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<200, t_terminal_reader | t_deleted_terminal_reader>
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/terminal/readers/${p["reader"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderCancelAction(
    p: {
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/cancel_action`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderCollectInputs(
    p: {
      reader: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/collect_inputs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderCollectPaymentMethod(
    p: {
      reader: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/terminal/readers/${p["reader"]}/collect_payment_method`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderConfirmPaymentIntent(
    p: {
      reader: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/terminal/readers/${p["reader"]}/confirm_payment_intent`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderProcessPaymentIntent(
    p: {
      reader: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/terminal/readers/${p["reader"]}/process_payment_intent`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderProcessSetupIntent(
    p: {
      reader: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/process_setup_intent`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderRefundPayment(
    p: {
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/refund_payment`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTerminalReadersReaderSetReaderDisplay(
    p: {
      reader: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/terminal/readers/${p["reader"]}/set_reader_display`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersConfirmationTokens(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_confirmation_token> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/confirmation_tokens`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersCustomersCustomerFundCashBalance(
    p: {
      customer: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_customer_cash_balance_transaction> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/customers/${p["customer"]}/fund_cash_balance`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingAuthorizations(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/issuing/authorizations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingAuthorizationsAuthorizationCapture(
    p: {
      authorization: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/authorizations/${p["authorization"]}/capture`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingAuthorizationsAuthorizationExpire(
    p: {
      authorization: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/authorizations/${p["authorization"]}/expire`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount(
    p: {
      authorization: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/authorizations/${p["authorization"]}/finalize_amount`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond(
    p: {
      authorization: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/authorizations/${p["authorization"]}/fraud_challenges/respond`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingAuthorizationsAuthorizationIncrement(
    p: {
      authorization: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/authorizations/${p["authorization"]}/increment`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingAuthorizationsAuthorizationReverse(
    p: {
      authorization: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_authorization> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/authorizations/${p["authorization"]}/reverse`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingDeliver(
    p: {
      card: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/deliver`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingFail(
    p: {
      card: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/fail`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingReturn(
    p: {
      card: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/return`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingShip(
    p: {
      card: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/ship`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingCardsCardShippingSubmit(
    p: {
      card: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_card> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/cards/${p["card"]}/shipping/submit`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate(
    p: {
      personalizationDesign: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_issuing_personalization_design> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/personalization_designs/${p["personalizationDesign"]}/activate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate(
    p: {
      personalizationDesign: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_issuing_personalization_design> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/personalization_designs/${p["personalizationDesign"]}/deactivate`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject(
    p: {
      personalizationDesign: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_issuing_personalization_design> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/personalization_designs/${p["personalizationDesign"]}/reject`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingSettlements(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_settlement> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/issuing/settlements`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingSettlementsSettlementComplete(
    p: {
      settlement: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_settlement> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/settlements/${p["settlement"]}/complete`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingTransactionsCreateForceCapture(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_transaction> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/transactions/create_force_capture`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingTransactionsCreateUnlinkedRefund(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_transaction> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/transactions/create_unlinked_refund`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersIssuingTransactionsTransactionRefund(
    p: {
      transaction: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_issuing_transaction> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/issuing/transactions/${p["transaction"]}/refund`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersRefundsRefundExpire(
    p: {
      refund: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_refund> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/refunds/${p["refund"]}/expire`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTerminalReadersReaderPresentPaymentMethod(
    p: {
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/terminal/readers/${p["reader"]}/present_payment_method`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTerminalReadersReaderSucceedInputCollection(
    p: {
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/terminal/readers/${p["reader"]}/succeed_input_collection`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTerminalReadersReaderTimeoutInputCollection(
    p: {
      reader: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_terminal_reader> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/terminal/readers/${p["reader"]}/timeout_input_collection`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTestHelpersTestClocks(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_test_helpers_test_clock[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/test_helpers/test_clocks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTestClocks(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_test_helpers_test_clock> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/test_clocks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteTestHelpersTestClocksTestClock(
    p: {
      testClock: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_deleted_test_helpers_test_clock> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/test_helpers/test_clocks/${p["testClock"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTestHelpersTestClocksTestClock(
    p: {
      expand?: string[]
      testClock: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_test_helpers_test_clock> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/test_clocks/${p["testClock"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTestClocksTestClockAdvance(
    p: {
      testClock: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_test_helpers_test_clock> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/test_helpers/test_clocks/${p["testClock"]}/advance`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryInboundTransfersIdFail(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/inbound_transfers/${p["id"]}/fail`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryInboundTransfersIdReturn(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/inbound_transfers/${p["id"]}/return`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryInboundTransfersIdSucceed(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/inbound_transfers/${p["id"]}/succeed`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundPaymentsId(
    p: {
      id: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/test_helpers/treasury/outbound_payments/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundPaymentsIdFail(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_payments/${p["id"]}/fail`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundPaymentsIdPost(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_payments/${p["id"]}/post`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundPaymentsIdReturn(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_payments/${p["id"]}/return`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundTransfersOutboundTransfer(
    p: {
      outboundTransfer: string
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_transfers/${p["outboundTransfer"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundTransfersOutboundTransferFail(
    p: {
      outboundTransfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_transfers/${p["outboundTransfer"]}/fail`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundTransfersOutboundTransferPost(
    p: {
      outboundTransfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_transfers/${p["outboundTransfer"]}/post`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn(
    p: {
      outboundTransfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/test_helpers/treasury/outbound_transfers/${p["outboundTransfer"]}/return`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryReceivedCredits(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_received_credit> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/treasury/received_credits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTestHelpersTreasuryReceivedDebits(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_received_debit> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/test_helpers/treasury/received_debits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTokens(
    p: {
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_token> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tokens`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTokensToken(
    p: {
      expand?: string[]
      token: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_token> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/tokens/${p["token"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTopups(
    p: {
      amount?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?:
        | "canceled"
        | "failed"
        | "pending"
        | "succeeded"
        | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_topup[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/topups`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      amount: p["amount"],
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTopups(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_topup> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/topups`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTopupsTopup(
    p: {
      expand?: string[]
      topup: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_topup> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/topups/${p["topup"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTopupsTopup(
    p: {
      topup: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_topup> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/topups/${p["topup"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTopupsTopupCancel(
    p: {
      topup: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_topup> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/topups/${p["topup"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTransfers(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      destination?: string
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      transferGroup?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_transfer[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/transfers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      destination: p["destination"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      transfer_group: p["transferGroup"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTransfers(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_transfer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/transfers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTransfersIdReversals(
    p: {
      endingBefore?: string
      expand?: string[]
      id: string
      limit?: number
      startingAfter?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_transfer_reversal[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/transfers/${p["id"]}/reversals`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTransfersIdReversals(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_transfer_reversal> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/transfers/${p["id"]}/reversals`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTransfersTransfer(
    p: {
      expand?: string[]
      transfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_transfer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/transfers/${p["transfer"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTransfersTransfer(
    p: {
      transfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_transfer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/transfers/${p["transfer"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTransfersTransferReversalsId(
    p: {
      expand?: string[]
      id: string
      transfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_transfer_reversal> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/transfers/${p["transfer"]}/reversals/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTransfersTransferReversalsId(
    p: {
      id: string
      transfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_transfer_reversal> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/transfers/${p["transfer"]}/reversals/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryCreditReversals(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      receivedCredit?: string
      startingAfter?: string
      status?: "canceled" | "posted" | "processing" | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_credit_reversal[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/credit_reversals`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      received_credit: p["receivedCredit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryCreditReversals(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_credit_reversal> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/credit_reversals`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryCreditReversalsCreditReversal(
    p: {
      creditReversal: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_credit_reversal> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/treasury/credit_reversals/${p["creditReversal"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryDebitReversals(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      receivedDebit?: string
      resolution?: "lost" | "won" | UnknownEnumStringValue
      startingAfter?: string
      status?: "canceled" | "completed" | "processing" | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_debit_reversal[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/debit_reversals`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      received_debit: p["receivedDebit"],
      resolution: p["resolution"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryDebitReversals(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_debit_reversal> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/debit_reversals`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryDebitReversalsDebitReversal(
    p: {
      debitReversal: string
      expand?: string[]
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_debit_reversal> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/treasury/debit_reversals/${p["debitReversal"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryFinancialAccounts(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      status?: "closed" | "open" | UnknownEnumStringValue
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_financial_account[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/financial_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryFinancialAccounts(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_financial_account> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/financial_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryFinancialAccountsFinancialAccount(
    p: {
      expand?: string[]
      financialAccount: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_financial_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/treasury/financial_accounts/${p["financialAccount"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryFinancialAccountsFinancialAccount(
    p: {
      financialAccount: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_financial_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/treasury/financial_accounts/${p["financialAccount"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryFinancialAccountsFinancialAccountClose(
    p: {
      financialAccount: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_financial_account> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/treasury/financial_accounts/${p["financialAccount"]}/close`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryFinancialAccountsFinancialAccountFeatures(
    p: {
      expand?: string[]
      financialAccount: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_financial_account_features> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/treasury/financial_accounts/${p["financialAccount"]}/features`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryFinancialAccountsFinancialAccountFeatures(
    p: {
      financialAccount: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_financial_account_features> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/treasury/financial_accounts/${p["financialAccount"]}/features`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryInboundTransfers(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?:
        | "canceled"
        | "failed"
        | "processing"
        | "succeeded"
        | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_inbound_transfer[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/inbound_transfers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryInboundTransfers(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/inbound_transfers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryInboundTransfersId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/inbound_transfers/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryInboundTransfersInboundTransferCancel(
    p: {
      inboundTransfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_inbound_transfer> | Res<StatusCode, t_error>> {
    const url =
      this.basePath +
      `/v1/treasury/inbound_transfers/${p["inboundTransfer"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryOutboundPayments(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      customer?: string
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?:
        | "canceled"
        | "failed"
        | "posted"
        | "processing"
        | "returned"
        | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_outbound_payment[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/outbound_payments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      customer: p["customer"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryOutboundPayments(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/outbound_payments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryOutboundPaymentsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/outbound_payments/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryOutboundPaymentsIdCancel(
    p: {
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_outbound_payment> | Res<StatusCode, t_error>> {
    const url =
      this.basePath + `/v1/treasury/outbound_payments/${p["id"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryOutboundTransfers(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?:
        | "canceled"
        | "failed"
        | "posted"
        | "processing"
        | "returned"
        | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_outbound_transfer[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/outbound_transfers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryOutboundTransfers(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/outbound_transfers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryOutboundTransfersOutboundTransfer(
    p: {
      expand?: string[]
      outboundTransfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath + `/v1/treasury/outbound_transfers/${p["outboundTransfer"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postTreasuryOutboundTransfersOutboundTransferCancel(
    p: {
      outboundTransfer: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_outbound_transfer> | Res<StatusCode, t_error>
  > {
    const url =
      this.basePath +
      `/v1/treasury/outbound_transfers/${p["outboundTransfer"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryReceivedCredits(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      linkedFlows?: {
        source_flow_type:
          | "credit_reversal"
          | "other"
          | "outbound_payment"
          | "outbound_transfer"
          | "payout"
          | UnknownEnumStringValue
      }
      startingAfter?: string
      status?: "failed" | "succeeded" | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_received_credit[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/received_credits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      linked_flows: p["linkedFlows"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryReceivedCreditsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_received_credit> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/received_credits/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryReceivedDebits(
    p: {
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      startingAfter?: string
      status?: "failed" | "succeeded" | UnknownEnumStringValue
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_received_debit[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/received_debits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
      status: p["status"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryReceivedDebitsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_received_debit> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/received_debits/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryTransactionEntries(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      effectiveAt?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      orderBy?: "created" | "effective_at" | UnknownEnumStringValue
      startingAfter?: string
      transaction?: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_transaction_entry[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/transaction_entries`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      effective_at: p["effectiveAt"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      order_by: p["orderBy"],
      starting_after: p["startingAfter"],
      transaction: p["transaction"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryTransactionEntriesId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_treasury_transaction_entry> | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/transaction_entries/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryTransactions(
    p: {
      created?:
        | {
            gt?: number
            gte?: number
            lt?: number
            lte?: number
          }
        | number
      endingBefore?: string
      expand?: string[]
      financialAccount: string
      limit?: number
      orderBy?: "created" | "posted_at" | UnknownEnumStringValue
      startingAfter?: string
      status?: "open" | "posted" | "void" | UnknownEnumStringValue
      statusTransitions?: {
        posted_at?:
          | {
              gt?: number
              gte?: number
              lt?: number
              lte?: number
            }
          | number
      }
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_treasury_transaction[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/treasury/transactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      created: p["created"],
      ending_before: p["endingBefore"],
      expand: p["expand"],
      financial_account: p["financialAccount"],
      limit: p["limit"],
      order_by: p["orderBy"],
      starting_after: p["startingAfter"],
      status: p["status"],
      status_transitions: p["statusTransitions"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getTreasuryTransactionsId(
    p: {
      expand?: string[]
      id: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_treasury_transaction> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/treasury/transactions/${p["id"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getWebhookEndpoints(
    p: {
      endingBefore?: string
      expand?: string[]
      limit?: number
      startingAfter?: string
      requestBody?: never
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    | Res<
        200,
        {
          data: t_webhook_endpoint[]
          has_more: boolean
          object: "list" | UnknownEnumStringValue
          url: string
        }
      >
    | Res<StatusCode, t_error>
  > {
    const url = this.basePath + `/v1/webhook_endpoints`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ending_before: p["endingBefore"],
      expand: p["expand"],
      limit: p["limit"],
      starting_after: p["startingAfter"],
    })

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postWebhookEndpoints(
    p: {
      requestBody: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_webhook_endpoint> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/webhook_endpoints`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async deleteWebhookEndpointsWebhookEndpoint(
    p: {
      webhookEndpoint: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_deleted_webhook_endpoint> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/webhook_endpoints/${p["webhookEndpoint"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "DELETE",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async getWebhookEndpointsWebhookEndpoint(
    p: {
      expand?: string[]
      webhookEndpoint: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_webhook_endpoint> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/webhook_endpoints/${p["webhookEndpoint"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({expand: p["expand"]})

    return this._fetch(
      url + query,
      {
        method: "GET",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }

  async postWebhookEndpointsWebhookEndpoint(
    p: {
      webhookEndpoint: string
      requestBody?: never
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_webhook_endpoint> | Res<StatusCode, t_error>> {
    const url = this.basePath + `/v1/webhook_endpoints/${p["webhookEndpoint"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._fetch(
      url,
      {
        method: "POST",
        // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported,
        ...opts,
        headers,
      },
      timeout,
    )
  }
}

export {StripeApi as ApiClient}
export type {StripeApiConfig as ApiClientConfig}
